"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/datatables.net";
exports.ids = ["vendor-chunks/datatables.net"];
exports.modules = {

/***/ "(ssr)/./node_modules/datatables.net/js/dataTables.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/datatables.net/js/dataTables.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\");\n/*! DataTables 2.3.0\n * © SpryMedia Ltd - datatables.net/license\n */ \n// DataTables code uses $ internally, but we want to be able to\n// reassign $ with the `use` method, so it is a regular var.\nvar $ = jquery__WEBPACK_IMPORTED_MODULE_0__;\nvar DataTable = function(selector, options) {\n    // Check if called with a window or jQuery object for DOM less applications\n    // This is for backwards compatibility\n    if (DataTable.factory(selector, options)) {\n        return DataTable;\n    }\n    // When creating with `new`, create a new DataTable, returning the API instance\n    if (this instanceof DataTable) {\n        return $(selector).DataTable(options);\n    } else {\n        // Argument switching\n        options = selector;\n    }\n    var _that = this;\n    var emptyInit = options === undefined;\n    var len = this.length;\n    if (emptyInit) {\n        options = {};\n    }\n    // Method to get DT API instance from jQuery object\n    this.api = function() {\n        return new _Api(this);\n    };\n    this.each(function() {\n        // For each initialisation we want to give it a clean initialisation\n        // object that can be bashed around\n        var o = {};\n        var oInit = len > 1 ? _fnExtend(o, options, true) : options;\n        var i = 0, iLen;\n        var sId = this.getAttribute(\"id\");\n        var defaults = DataTable.defaults;\n        var $this = $(this);\n        // Sanity check\n        if (this.nodeName.toLowerCase() != \"table\") {\n            _fnLog(null, 0, \"Non-table node initialisation (\" + this.nodeName + \")\", 2);\n            return;\n        }\n        // Special case for options\n        if (oInit.on && oInit.on.options) {\n            _fnListener($this, \"options\", oInit.on.options);\n        }\n        $this.trigger(\"options.dt\", oInit);\n        /* Backwards compatibility for the defaults */ _fnCompatOpts(defaults);\n        _fnCompatCols(defaults.column);\n        /* Convert the camel-case defaults to Hungarian */ _fnCamelToHungarian(defaults, defaults, true);\n        _fnCamelToHungarian(defaults.column, defaults.column, true);\n        /* Setting up the initialisation object */ _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()), true);\n        /* Check to see if we are re-initialising a table */ var allSettings = DataTable.settings;\n        for(i = 0, iLen = allSettings.length; i < iLen; i++){\n            var s = allSettings[i];\n            /* Base check on table node */ if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {\n                var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;\n                var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;\n                if (emptyInit || bRetrieve) {\n                    return s.oInstance;\n                } else if (bDestroy) {\n                    new DataTable.Api(s).destroy();\n                    break;\n                } else {\n                    _fnLog(s, 0, \"Cannot reinitialise DataTable\", 3);\n                    return;\n                }\n            }\n            /* If the element we are initialising has the same ID as a table which was previously\n\t\t\t * initialised, but the table nodes don't match (from before) then we destroy the old\n\t\t\t * instance by simply deleting it. This is under the assumption that the table has been\n\t\t\t * destroyed by other methods. Anyone using non-id selectors will need to do this manually\n\t\t\t */ if (s.sTableId == this.id) {\n                allSettings.splice(i, 1);\n                break;\n            }\n        }\n        /* Ensure the table has an ID - required for accessibility */ if (sId === null || sId === \"\") {\n            sId = \"DataTables_Table_\" + DataTable.ext._unique++;\n            this.id = sId;\n        }\n        /* Create the settings object for this table and set some of the default parameters */ var oSettings = $.extend(true, {}, DataTable.models.oSettings, {\n            \"sDestroyWidth\": $this[0].style.width,\n            \"sInstance\": sId,\n            \"sTableId\": sId,\n            colgroup: $(\"<colgroup>\").prependTo(this),\n            fastData: function(row, column, type) {\n                return _fnGetCellData(oSettings, row, column, type);\n            }\n        });\n        oSettings.nTable = this;\n        oSettings.oInit = oInit;\n        allSettings.push(oSettings);\n        // Make a single API instance available for internal handling\n        oSettings.api = new _Api(oSettings);\n        // Need to add the instance after the instance after the settings object has been added\n        // to the settings array, so we can self reference the table instance if more than one\n        oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();\n        // Backwards compatibility, before we apply all the defaults\n        _fnCompatOpts(oInit);\n        // If the length menu is given, but the init display length is not, use the length menu\n        if (oInit.aLengthMenu && !oInit.iDisplayLength) {\n            oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : $.isPlainObject(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0].value : oInit.aLengthMenu[0];\n        }\n        // Apply the defaults and init options to make a single init object will all\n        // options defined from defaults and instance options.\n        oInit = _fnExtend($.extend(true, {}, defaults), oInit);\n        // Map the initialisation options onto the settings object\n        _fnMap(oSettings.oFeatures, oInit, [\n            \"bPaginate\",\n            \"bLengthChange\",\n            \"bFilter\",\n            \"bSort\",\n            \"bSortMulti\",\n            \"bInfo\",\n            \"bProcessing\",\n            \"bAutoWidth\",\n            \"bSortClasses\",\n            \"bServerSide\",\n            \"bDeferRender\"\n        ]);\n        _fnMap(oSettings, oInit, [\n            \"ajax\",\n            \"fnFormatNumber\",\n            \"sServerMethod\",\n            \"aaSorting\",\n            \"aaSortingFixed\",\n            \"aLengthMenu\",\n            \"sPaginationType\",\n            \"iStateDuration\",\n            \"bSortCellsTop\",\n            \"iTabIndex\",\n            \"sDom\",\n            \"fnStateLoadCallback\",\n            \"fnStateSaveCallback\",\n            \"renderer\",\n            \"searchDelay\",\n            \"rowId\",\n            \"caption\",\n            \"layout\",\n            \"orderDescReverse\",\n            \"orderIndicators\",\n            \"orderHandler\",\n            \"titleRow\",\n            \"typeDetect\",\n            [\n                \"iCookieDuration\",\n                \"iStateDuration\"\n            ],\n            [\n                \"oSearch\",\n                \"oPreviousSearch\"\n            ],\n            [\n                \"aoSearchCols\",\n                \"aoPreSearchCols\"\n            ],\n            [\n                \"iDisplayLength\",\n                \"_iDisplayLength\"\n            ]\n        ]);\n        _fnMap(oSettings.oScroll, oInit, [\n            [\n                \"sScrollX\",\n                \"sX\"\n            ],\n            [\n                \"sScrollXInner\",\n                \"sXInner\"\n            ],\n            [\n                \"sScrollY\",\n                \"sY\"\n            ],\n            [\n                \"bScrollCollapse\",\n                \"bCollapse\"\n            ]\n        ]);\n        _fnMap(oSettings.oLanguage, oInit, \"fnInfoCallback\");\n        /* Callback functions which are array driven */ _fnCallbackReg(oSettings, \"aoDrawCallback\", oInit.fnDrawCallback);\n        _fnCallbackReg(oSettings, \"aoStateSaveParams\", oInit.fnStateSaveParams);\n        _fnCallbackReg(oSettings, \"aoStateLoadParams\", oInit.fnStateLoadParams);\n        _fnCallbackReg(oSettings, \"aoStateLoaded\", oInit.fnStateLoaded);\n        _fnCallbackReg(oSettings, \"aoRowCallback\", oInit.fnRowCallback);\n        _fnCallbackReg(oSettings, \"aoRowCreatedCallback\", oInit.fnCreatedRow);\n        _fnCallbackReg(oSettings, \"aoHeaderCallback\", oInit.fnHeaderCallback);\n        _fnCallbackReg(oSettings, \"aoFooterCallback\", oInit.fnFooterCallback);\n        _fnCallbackReg(oSettings, \"aoInitComplete\", oInit.fnInitComplete);\n        _fnCallbackReg(oSettings, \"aoPreDrawCallback\", oInit.fnPreDrawCallback);\n        oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);\n        // Add event listeners\n        if (oInit.on) {\n            Object.keys(oInit.on).forEach(function(key) {\n                _fnListener($this, key, oInit.on[key]);\n            });\n        }\n        /* Browser support detection */ _fnBrowserDetect(oSettings);\n        var oClasses = oSettings.oClasses;\n        $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);\n        $this.addClass(oClasses.table);\n        if (!oSettings.oFeatures.bPaginate) {\n            oInit.iDisplayStart = 0;\n        }\n        if (oSettings.iInitDisplayStart === undefined) {\n            /* Display start point, taking into account the save saving */ oSettings.iInitDisplayStart = oInit.iDisplayStart;\n            oSettings._iDisplayStart = oInit.iDisplayStart;\n        }\n        var defer = oInit.iDeferLoading;\n        if (defer !== null) {\n            oSettings.deferLoading = true;\n            var tmp = Array.isArray(defer);\n            oSettings._iRecordsDisplay = tmp ? defer[0] : defer;\n            oSettings._iRecordsTotal = tmp ? defer[1] : defer;\n        }\n        /*\n\t\t * Columns\n\t\t * See if we should load columns automatically or use defined ones\n\t\t */ var columnsInit = [];\n        var thead = this.getElementsByTagName(\"thead\");\n        var initHeaderLayout = _fnDetectHeader(oSettings, thead[0]);\n        // If we don't have a columns array, then generate one with nulls\n        if (oInit.aoColumns) {\n            columnsInit = oInit.aoColumns;\n        } else if (initHeaderLayout.length) {\n            for(i = 0, iLen = initHeaderLayout[0].length; i < iLen; i++){\n                columnsInit.push(null);\n            }\n        }\n        // Add the columns\n        for(i = 0, iLen = columnsInit.length; i < iLen; i++){\n            _fnAddColumn(oSettings);\n        }\n        // Apply the column definitions\n        _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function(iCol, oDef) {\n            _fnColumnOptions(oSettings, iCol, oDef);\n        });\n        /* HTML5 attribute detection - build an mData object automatically if the\n\t\t * attributes are found\n\t\t */ var rowOne = $this.children(\"tbody\").find(\"tr:first-child\").eq(0);\n        if (rowOne.length) {\n            var a = function(cell, name) {\n                return cell.getAttribute(\"data-\" + name) !== null ? name : null;\n            };\n            $(rowOne[0]).children(\"th, td\").each(function(i, cell) {\n                var col = oSettings.aoColumns[i];\n                if (!col) {\n                    _fnLog(oSettings, 0, \"Incorrect column count\", 18);\n                }\n                if (col.mData === i) {\n                    var sort = a(cell, \"sort\") || a(cell, \"order\");\n                    var filter = a(cell, \"filter\") || a(cell, \"search\");\n                    if (sort !== null || filter !== null) {\n                        col.mData = {\n                            _: i + \".display\",\n                            sort: sort !== null ? i + \".@data-\" + sort : undefined,\n                            type: sort !== null ? i + \".@data-\" + sort : undefined,\n                            filter: filter !== null ? i + \".@data-\" + filter : undefined\n                        };\n                        col._isArrayHost = true;\n                        _fnColumnOptions(oSettings, i);\n                    }\n                }\n            });\n        }\n        // Must be done after everything which can be overridden by the state saving!\n        _fnCallbackReg(oSettings, \"aoDrawCallback\", _fnSaveState);\n        var features = oSettings.oFeatures;\n        if (oInit.bStateSave) {\n            features.bStateSave = true;\n        }\n        // If aaSorting is not defined, then we use the first indicator in asSorting\n        // in case that has been altered, so the default sort reflects that option\n        if (oInit.aaSorting === undefined) {\n            var sorting = oSettings.aaSorting;\n            for(i = 0, iLen = sorting.length; i < iLen; i++){\n                sorting[i][1] = oSettings.aoColumns[i].asSorting[0];\n            }\n        }\n        // Do a first pass on the sorting classes (allows any size changes to be taken into\n        // account, and also will apply sorting disabled classes if disabled\n        _fnSortingClasses(oSettings);\n        _fnCallbackReg(oSettings, \"aoDrawCallback\", function() {\n            if (oSettings.bSorted || _fnDataSource(oSettings) === \"ssp\" || features.bDeferRender) {\n                _fnSortingClasses(oSettings);\n            }\n        });\n        /*\n\t\t * Table HTML init\n\t\t * Cache the header, body and footer as required, creating them if needed\n\t\t */ var caption = $this.children(\"caption\");\n        if (oSettings.caption) {\n            if (caption.length === 0) {\n                caption = $(\"<caption/>\").appendTo($this);\n            }\n            caption.html(oSettings.caption);\n        }\n        // Store the caption side, so we can remove the element from the document\n        // when creating the element\n        if (caption.length) {\n            caption[0]._captionSide = caption.css(\"caption-side\");\n            oSettings.captionNode = caption[0];\n        }\n        if (thead.length === 0) {\n            thead = $(\"<thead/>\").appendTo($this);\n        }\n        oSettings.nTHead = thead[0];\n        var tbody = $this.children(\"tbody\");\n        if (tbody.length === 0) {\n            tbody = $(\"<tbody/>\").insertAfter(thead);\n        }\n        oSettings.nTBody = tbody[0];\n        var tfoot = $this.children(\"tfoot\");\n        if (tfoot.length === 0) {\n            // If we are a scrolling table, and no footer has been given, then we need to create\n            // a tfoot element for the caption element to be appended to\n            tfoot = $(\"<tfoot/>\").appendTo($this);\n        }\n        oSettings.nTFoot = tfoot[0];\n        // Copy the data index array\n        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();\n        // Initialisation complete - table can be drawn\n        oSettings.bInitialised = true;\n        // Language definitions\n        var oLanguage = oSettings.oLanguage;\n        $.extend(true, oLanguage, oInit.oLanguage);\n        if (oLanguage.sUrl) {\n            // Get the language definitions from a file\n            $.ajax({\n                dataType: \"json\",\n                url: oLanguage.sUrl,\n                success: function(json) {\n                    _fnCamelToHungarian(defaults.oLanguage, json);\n                    $.extend(true, oLanguage, json, oSettings.oInit.oLanguage);\n                    _fnCallbackFire(oSettings, null, \"i18n\", [\n                        oSettings\n                    ], true);\n                    _fnInitialise(oSettings);\n                },\n                error: function() {\n                    // Error occurred loading language file\n                    _fnLog(oSettings, 0, \"i18n file loading error\", 21);\n                    // Continue on as best we can\n                    _fnInitialise(oSettings);\n                }\n            });\n        } else {\n            _fnCallbackFire(oSettings, null, \"i18n\", [\n                oSettings\n            ], true);\n            _fnInitialise(oSettings);\n        }\n    });\n    _that = null;\n    return this;\n};\n/**\n * DataTables extensions\n * \n * This namespace acts as a collection area for plug-ins that can be used to\n * extend DataTables capabilities. Indeed many of the build in methods\n * use this method to provide their own capabilities (sorting methods for\n * example).\n *\n * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy\n * reasons\n *\n *  @namespace\n */ DataTable.ext = _ext = {\n    /**\n\t * DataTables build type (expanded by the download builder)\n\t *\n\t *  @type string\n\t */ builder: \"-source-\",\n    /**\n\t * Buttons. For use with the Buttons extension for DataTables. This is\n\t * defined here so other extensions can define buttons regardless of load\n\t * order. It is _not_ used by DataTables core.\n\t *\n\t *  @type object\n\t *  @default {}\n\t */ buttons: {},\n    /**\n\t * ColumnControl buttons and content\n\t *\n\t *  @type object\n\t */ ccContent: {},\n    /**\n\t * Element class names\n\t *\n\t *  @type object\n\t *  @default {}\n\t */ classes: {},\n    /**\n\t * Error reporting.\n\t * \n\t * How should DataTables report an error. Can take the value 'alert',\n\t * 'throw', 'none' or a function.\n\t *\n\t *  @type string|function\n\t *  @default alert\n\t */ errMode: \"alert\",\n    /**\n\t * Legacy so v1 plug-ins don't throw js errors on load\n\t */ feature: [],\n    /**\n\t * Feature plug-ins.\n\t * \n\t * This is an object of callbacks which provide the features for DataTables\n\t * to be initialised via the `layout` option.\n\t */ features: {},\n    /**\n\t * Row searching.\n\t * \n\t * This method of searching is complimentary to the default type based\n\t * searching, and a lot more comprehensive as it allows you complete control\n\t * over the searching logic. Each element in this array is a function\n\t * (parameters described below) that is called for every row in the table,\n\t * and your logic decides if it should be included in the searching data set\n\t * or not.\n\t *\n\t * Searching functions have the following input parameters:\n\t *\n\t * 1. `{object}` DataTables settings object: see\n\t *    {@link DataTable.models.oSettings}\n\t * 2. `{array|object}` Data for the row to be processed (same as the\n\t *    original format that was passed in as the data source, or an array\n\t *    from a DOM data source\n\t * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which\n\t *    can be useful to retrieve the `TR` element if you need DOM interaction.\n\t *\n\t * And the following return is expected:\n\t *\n\t * * {boolean} Include the row in the searched result set (true) or not\n\t *   (false)\n\t *\n\t * Note that as with the main search ability in DataTables, technically this\n\t * is \"filtering\", since it is subtractive. However, for consistency in\n\t * naming we call it searching here.\n\t *\n\t *  @type array\n\t *  @default []\n\t *\n\t *  @example\n\t *    // The following example shows custom search being applied to the\n\t *    // fourth column (i.e. the data[3] index) based on two input values\n\t *    // from the end-user, matching the data in a certain range.\n\t *    $.fn.dataTable.ext.search.push(\n\t *      function( settings, data, dataIndex ) {\n\t *        var min = document.getElementById('min').value * 1;\n\t *        var max = document.getElementById('max').value * 1;\n\t *        var version = data[3] == \"-\" ? 0 : data[3]*1;\n\t *\n\t *        if ( min == \"\" && max == \"\" ) {\n\t *          return true;\n\t *        }\n\t *        else if ( min == \"\" && version < max ) {\n\t *          return true;\n\t *        }\n\t *        else if ( min < version && \"\" == max ) {\n\t *          return true;\n\t *        }\n\t *        else if ( min < version && version < max ) {\n\t *          return true;\n\t *        }\n\t *        return false;\n\t *      }\n\t *    );\n\t */ search: [],\n    /**\n\t * Selector extensions\n\t *\n\t * The `selector` option can be used to extend the options available for the\n\t * selector modifier options (`selector-modifier` object data type) that\n\t * each of the three built in selector types offer (row, column and cell +\n\t * their plural counterparts). For example the Select extension uses this\n\t * mechanism to provide an option to select only rows, columns and cells\n\t * that have been marked as selected by the end user (`{selected: true}`),\n\t * which can be used in conjunction with the existing built in selector\n\t * options.\n\t *\n\t * Each property is an array to which functions can be pushed. The functions\n\t * take three attributes:\n\t *\n\t * * Settings object for the host table\n\t * * Options object (`selector-modifier` object type)\n\t * * Array of selected item indexes\n\t *\n\t * The return is an array of the resulting item indexes after the custom\n\t * selector has been applied.\n\t *\n\t *  @type object\n\t */ selector: {\n        cell: [],\n        column: [],\n        row: []\n    },\n    /**\n\t * Legacy configuration options. Enable and disable legacy options that\n\t * are available in DataTables.\n\t *\n\t *  @type object\n\t */ legacy: {\n        /**\n\t\t * Enable / disable DataTables 1.9 compatible server-side processing\n\t\t * requests\n\t\t *\n\t\t *  @type boolean\n\t\t *  @default null\n\t\t */ ajax: null\n    },\n    /**\n\t * Pagination plug-in methods.\n\t * \n\t * Each entry in this object is a function and defines which buttons should\n\t * be shown by the pagination rendering method that is used for the table:\n\t * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the\n\t * buttons are displayed in the document, while the functions here tell it\n\t * what buttons to display. This is done by returning an array of button\n\t * descriptions (what each button will do).\n\t *\n\t * Pagination types (the four built in options and any additional plug-in\n\t * options defined here) can be used through the `paginationType`\n\t * initialisation parameter.\n\t *\n\t * The functions defined take two parameters:\n\t *\n\t * 1. `{int} page` The current page index\n\t * 2. `{int} pages` The number of pages in the table\n\t *\n\t * Each function is expected to return an array where each element of the\n\t * array can be one of:\n\t *\n\t * * `first` - Jump to first page when activated\n\t * * `last` - Jump to last page when activated\n\t * * `previous` - Show previous page when activated\n\t * * `next` - Show next page when activated\n\t * * `{int}` - Show page of the index given\n\t * * `{array}` - A nested array containing the above elements to add a\n\t *   containing 'DIV' element (might be useful for styling).\n\t *\n\t * Note that DataTables v1.9- used this object slightly differently whereby\n\t * an object with two functions would be defined for each plug-in. That\n\t * ability is still supported by DataTables 1.10+ to provide backwards\n\t * compatibility, but this option of use is now decremented and no longer\n\t * documented in DataTables 1.10+.\n\t *\n\t *  @type object\n\t *  @default {}\n\t *\n\t *  @example\n\t *    // Show previous, next and current page buttons only\n\t *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {\n\t *      return [ 'previous', page, 'next' ];\n\t *    };\n\t */ pager: {},\n    renderer: {\n        pageButton: {},\n        header: {}\n    },\n    /**\n\t * Ordering plug-ins - custom data source\n\t * \n\t * The extension options for ordering of data available here is complimentary\n\t * to the default type based ordering that DataTables typically uses. It\n\t * allows much greater control over the the data that is being used to\n\t * order a column, but is necessarily therefore more complex.\n\t * \n\t * This type of ordering is useful if you want to do ordering based on data\n\t * live from the DOM (for example the contents of an 'input' element) rather\n\t * than just the static string that DataTables knows of.\n\t * \n\t * The way these plug-ins work is that you create an array of the values you\n\t * wish to be ordering for the column in question and then return that\n\t * array. The data in the array much be in the index order of the rows in\n\t * the table (not the currently ordering order!). Which order data gathering\n\t * function is run here depends on the `dt-init columns.orderDataType`\n\t * parameter that is used for the column (if any).\n\t *\n\t * The functions defined take two parameters:\n\t *\n\t * 1. `{object}` DataTables settings object: see\n\t *    {@link DataTable.models.oSettings}\n\t * 2. `{int}` Target column index\n\t *\n\t * Each function is expected to return an array:\n\t *\n\t * * `{array}` Data for the column to be ordering upon\n\t *\n\t *  @type array\n\t *\n\t *  @example\n\t *    // Ordering using `input` node values\n\t *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )\n\t *    {\n\t *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {\n\t *        return $('input', td).val();\n\t *      } );\n\t *    }\n\t */ order: {},\n    /**\n\t * Type based plug-ins.\n\t *\n\t * Each column in DataTables has a type assigned to it, either by automatic\n\t * detection or by direct assignment using the `type` option for the column.\n\t * The type of a column will effect how it is ordering and search (plug-ins\n\t * can also make use of the column type if required).\n\t *\n\t * @namespace\n\t */ type: {\n        /**\n\t\t * Automatic column class assignment\n\t\t */ className: {},\n        /**\n\t\t * Type detection functions.\n\t\t *\n\t\t * The functions defined in this object are used to automatically detect\n\t\t * a column's type, making initialisation of DataTables super easy, even\n\t\t * when complex data is in the table.\n\t\t *\n\t\t * The functions defined take two parameters:\n\t\t *\n\t     *  1. `{*}` Data from the column cell to be analysed\n\t     *  2. `{settings}` DataTables settings object. This can be used to\n\t     *     perform context specific type detection - for example detection\n\t     *     based on language settings such as using a comma for a decimal\n\t     *     place. Generally speaking the options from the settings will not\n\t     *     be required\n\t\t *\n\t\t * Each function is expected to return:\n\t\t *\n\t\t * * `{string|null}` Data type detected, or null if unknown (and thus\n\t\t *   pass it on to the other type detection functions.\n\t\t *\n\t\t *  @type array\n\t\t *\n\t\t *  @example\n\t\t *    // Currency type detection plug-in:\n\t\t *    $.fn.dataTable.ext.type.detect.push(\n\t\t *      function ( data, settings ) {\n\t\t *        // Check the numeric part\n\t\t *        if ( ! data.substring(1).match(/[0-9]/) ) {\n\t\t *          return null;\n\t\t *        }\n\t\t *\n\t\t *        // Check prefixed by currency\n\t\t *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {\n\t\t *          return 'currency';\n\t\t *        }\n\t\t *        return null;\n\t\t *      }\n\t\t *    );\n\t\t */ detect: [],\n        /**\n\t\t * Automatic renderer assignment\n\t\t */ render: {},\n        /**\n\t\t * Type based search formatting.\n\t\t *\n\t\t * The type based searching functions can be used to pre-format the\n\t\t * data to be search on. For example, it can be used to strip HTML\n\t\t * tags or to de-format telephone numbers for numeric only searching.\n\t\t *\n\t\t * Note that is a search is not defined for a column of a given type,\n\t\t * no search formatting will be performed.\n\t\t * \n\t\t * Pre-processing of searching data plug-ins - When you assign the sType\n\t\t * for a column (or have it automatically detected for you by DataTables\n\t\t * or a type detection plug-in), you will typically be using this for\n\t\t * custom sorting, but it can also be used to provide custom searching\n\t\t * by allowing you to pre-processing the data and returning the data in\n\t\t * the format that should be searched upon. This is done by adding\n\t\t * functions this object with a parameter name which matches the sType\n\t\t * for that target column. This is the corollary of <i>afnSortData</i>\n\t\t * for searching data.\n\t\t *\n\t\t * The functions defined take a single parameter:\n\t\t *\n\t     *  1. `{*}` Data from the column cell to be prepared for searching\n\t\t *\n\t\t * Each function is expected to return:\n\t\t *\n\t\t * * `{string|null}` Formatted string that will be used for the searching.\n\t\t *\n\t\t *  @type object\n\t\t *  @default {}\n\t\t *\n\t\t *  @example\n\t\t *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {\n\t\t *      return d.replace(/\\n/g,\" \").replace( /<.*?>/g, \"\" );\n\t\t *    }\n\t\t */ search: {},\n        /**\n\t\t * Type based ordering.\n\t\t *\n\t\t * The column type tells DataTables what ordering to apply to the table\n\t\t * when a column is sorted upon. The order for each type that is defined,\n\t\t * is defined by the functions available in this object.\n\t\t *\n\t\t * Each ordering option can be described by three properties added to\n\t\t * this object:\n\t\t *\n\t\t * * `{type}-pre` - Pre-formatting function\n\t\t * * `{type}-asc` - Ascending order function\n\t\t * * `{type}-desc` - Descending order function\n\t\t *\n\t\t * All three can be used together, only `{type}-pre` or only\n\t\t * `{type}-asc` and `{type}-desc` together. It is generally recommended\n\t\t * that only `{type}-pre` is used, as this provides the optimal\n\t\t * implementation in terms of speed, although the others are provided\n\t\t * for compatibility with existing Javascript sort functions.\n\t\t *\n\t\t * `{type}-pre`: Functions defined take a single parameter:\n\t\t *\n\t     *  1. `{*}` Data from the column cell to be prepared for ordering\n\t\t *\n\t\t * And return:\n\t\t *\n\t\t * * `{*}` Data to be sorted upon\n\t\t *\n\t\t * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort\n\t\t * functions, taking two parameters:\n\t\t *\n\t     *  1. `{*}` Data to compare to the second parameter\n\t     *  2. `{*}` Data to compare to the first parameter\n\t\t *\n\t\t * And returning:\n\t\t *\n\t\t * * `{*}` Ordering match: <0 if first parameter should be sorted lower\n\t\t *   than the second parameter, ===0 if the two parameters are equal and\n\t\t *   >0 if the first parameter should be sorted height than the second\n\t\t *   parameter.\n\t\t * \n\t\t *  @type object\n\t\t *  @default {}\n\t\t *\n\t\t *  @example\n\t\t *    // Numeric ordering of formatted numbers with a pre-formatter\n\t\t *    $.extend( $.fn.dataTable.ext.type.order, {\n\t\t *      \"string-pre\": function(x) {\n\t\t *        a = (a === \"-\" || a === \"\") ? 0 : a.replace( /[^\\d\\-\\.]/g, \"\" );\n\t\t *        return parseFloat( a );\n\t\t *      }\n\t\t *    } );\n\t\t *\n\t\t *  @example\n\t\t *    // Case-sensitive string ordering, with no pre-formatting method\n\t\t *    $.extend( $.fn.dataTable.ext.order, {\n\t\t *      \"string-case-asc\": function(x,y) {\n\t\t *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n\t\t *      },\n\t\t *      \"string-case-desc\": function(x,y) {\n\t\t *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));\n\t\t *      }\n\t\t *    } );\n\t\t */ order: {}\n    },\n    /**\n\t * Unique DataTables instance counter\n\t *\n\t * @type int\n\t * @private\n\t */ _unique: 0,\n    //\n    // Depreciated\n    // The following properties are retained for backwards compatibility only.\n    // The should not be used in new projects and will be removed in a future\n    // version\n    //\n    /**\n\t * Version check function.\n\t *  @type function\n\t *  @depreciated Since 1.10\n\t */ fnVersionCheck: DataTable.fnVersionCheck,\n    /**\n\t * Index for what 'this' index API functions should use\n\t *  @type int\n\t *  @deprecated Since v1.10\n\t */ iApiIndex: 0,\n    /**\n\t * Software version\n\t *  @type string\n\t *  @deprecated Since v1.10\n\t */ sVersion: DataTable.version\n};\n//\n// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts\n//\n$.extend(_ext, {\n    afnFiltering: _ext.search,\n    aTypes: _ext.type.detect,\n    ofnSearch: _ext.type.search,\n    oSort: _ext.type.order,\n    afnSortData: _ext.order,\n    aoFeatures: _ext.feature,\n    oStdClasses: _ext.classes,\n    oPagination: _ext.pager\n});\n$.extend(DataTable.ext.classes, {\n    container: \"dt-container\",\n    empty: {\n        row: \"dt-empty\"\n    },\n    info: {\n        container: \"dt-info\"\n    },\n    layout: {\n        row: \"dt-layout-row\",\n        cell: \"dt-layout-cell\",\n        tableRow: \"dt-layout-table\",\n        tableCell: \"\",\n        start: \"dt-layout-start\",\n        end: \"dt-layout-end\",\n        full: \"dt-layout-full\"\n    },\n    length: {\n        container: \"dt-length\",\n        select: \"dt-input\"\n    },\n    order: {\n        canAsc: \"dt-orderable-asc\",\n        canDesc: \"dt-orderable-desc\",\n        isAsc: \"dt-ordering-asc\",\n        isDesc: \"dt-ordering-desc\",\n        none: \"dt-orderable-none\",\n        position: \"sorting_\"\n    },\n    processing: {\n        container: \"dt-processing\"\n    },\n    scrolling: {\n        body: \"dt-scroll-body\",\n        container: \"dt-scroll\",\n        footer: {\n            self: \"dt-scroll-foot\",\n            inner: \"dt-scroll-footInner\"\n        },\n        header: {\n            self: \"dt-scroll-head\",\n            inner: \"dt-scroll-headInner\"\n        }\n    },\n    search: {\n        container: \"dt-search\",\n        input: \"dt-input\"\n    },\n    table: \"dataTable\",\n    tbody: {\n        cell: \"\",\n        row: \"\"\n    },\n    thead: {\n        cell: \"\",\n        row: \"\"\n    },\n    tfoot: {\n        cell: \"\",\n        row: \"\"\n    },\n    paging: {\n        active: \"current\",\n        button: \"dt-paging-button\",\n        container: \"dt-paging\",\n        disabled: \"disabled\",\n        nav: \"\"\n    }\n});\n/*\n * It is useful to have variables which are scoped locally so only the\n * DataTables functions can access them and they don't leak into global space.\n * At the same time these functions are often useful over multiple files in the\n * core and API, so we list, or at least document, all variables which are used\n * by DataTables as private variables here. This also ensures that there is no\n * clashing of variable names and that they can easily referenced for reuse.\n */ // Defined else where\n//  _selector_run\n//  _selector_opts\n//  _selector_row_indexes\nvar _ext; // DataTable.ext\nvar _Api; // DataTable.Api\nvar _api_register; // DataTable.Api.register\nvar _api_registerPlural; // DataTable.Api.registerPlural\nvar _re_dic = {};\nvar _re_new_lines = /[\\r\\n\\u2028]/g;\nvar _re_html = /<([^>]*>)/g;\nvar _max_str_len = Math.pow(2, 28);\n// This is not strict ISO8601 - Date.parse() is quite lax, although\n// implementations differ between browsers.\nvar _re_date = /^\\d{2,4}[./-]\\d{1,2}[./-]\\d{1,2}([T ]{1}\\d{1,2}[:.]\\d{2}([.:]\\d{2})?)?$/;\n// Escape regular expression special characters\nvar _re_escape_regex = new RegExp(\"(\\\\\" + [\n    \"/\",\n    \".\",\n    \"*\",\n    \"+\",\n    \"?\",\n    \"|\",\n    \"(\",\n    \")\",\n    \"[\",\n    \"]\",\n    \"{\",\n    \"}\",\n    \"\\\\\",\n    \"$\",\n    \"^\",\n    \"-\"\n].join(\"|\\\\\") + \")\", \"g\");\n// https://en.wikipedia.org/wiki/Foreign_exchange_market\n// - \\u20BD - Russian ruble.\n// - \\u20a9 - South Korean Won\n// - \\u20BA - Turkish Lira\n// - \\u20B9 - Indian Rupee\n// - R - Brazil (R$) and South Africa\n// - fr - Swiss Franc\n// - kr - Swedish krona, Norwegian krone and Danish krone\n// - \\u2009 is thin space and \\u202F is narrow no-break space, both used in many\n// - Ƀ - Bitcoin\n// - Ξ - Ethereum\n//   standards as thousands separators.\nvar _re_formatted_numeric = /['\\u00A0,$£€¥%\\u2009\\u202F\\u20BD\\u20a9\\u20BArfkɃΞ]/gi;\nvar _empty = function(d) {\n    return !d || d === true || d === \"-\" ? true : false;\n};\nvar _intVal = function(s) {\n    var integer = parseInt(s, 10);\n    return !isNaN(integer) && isFinite(s) ? integer : null;\n};\n// Convert from a formatted number with characters other than `.` as the\n// decimal place, to a Javascript number\nvar _numToDecimal = function(num, decimalPoint) {\n    // Cache created regular expressions for speed as this function is called often\n    if (!_re_dic[decimalPoint]) {\n        _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), \"g\");\n    }\n    return typeof num === \"string\" && decimalPoint !== \".\" ? num.replace(/\\./g, \"\").replace(_re_dic[decimalPoint], \".\") : num;\n};\nvar _isNumber = function(d, decimalPoint, formatted, allowEmpty) {\n    var type = typeof d;\n    var strType = type === \"string\";\n    if (type === \"number\" || type === \"bigint\") {\n        return true;\n    }\n    // If empty return immediately so there must be a number if it is a\n    // formatted string (this stops the string \"k\", or \"kr\", etc being detected\n    // as a formatted number for currency\n    if (allowEmpty && _empty(d)) {\n        return true;\n    }\n    if (decimalPoint && strType) {\n        d = _numToDecimal(d, decimalPoint);\n    }\n    if (formatted && strType) {\n        d = d.replace(_re_formatted_numeric, \"\");\n    }\n    return !isNaN(parseFloat(d)) && isFinite(d);\n};\n// A string without HTML in it can be considered to be HTML still\nvar _isHtml = function(d) {\n    return _empty(d) || typeof d === \"string\";\n};\n// Is a string a number surrounded by HTML?\nvar _htmlNumeric = function(d, decimalPoint, formatted, allowEmpty) {\n    if (allowEmpty && _empty(d)) {\n        return true;\n    }\n    // input and select strings mean that this isn't just a number\n    if (typeof d === \"string\" && d.match(/<(input|select)/i)) {\n        return null;\n    }\n    var html = _isHtml(d);\n    return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted, allowEmpty) ? true : null;\n};\nvar _pluck = function(a, prop, prop2) {\n    var out = [];\n    var i = 0, ien = a.length;\n    // Could have the test in the loop for slightly smaller code, but speed\n    // is essential here\n    if (prop2 !== undefined) {\n        for(; i < ien; i++){\n            if (a[i] && a[i][prop]) {\n                out.push(a[i][prop][prop2]);\n            }\n        }\n    } else {\n        for(; i < ien; i++){\n            if (a[i]) {\n                out.push(a[i][prop]);\n            }\n        }\n    }\n    return out;\n};\n// Basically the same as _pluck, but rather than looping over `a` we use `order`\n// as the indexes to pick from `a`\nvar _pluck_order = function(a, order, prop, prop2) {\n    var out = [];\n    var i = 0, ien = order.length;\n    // Could have the test in the loop for slightly smaller code, but speed\n    // is essential here\n    if (prop2 !== undefined) {\n        for(; i < ien; i++){\n            if (a[order[i]] && a[order[i]][prop]) {\n                out.push(a[order[i]][prop][prop2]);\n            }\n        }\n    } else {\n        for(; i < ien; i++){\n            if (a[order[i]]) {\n                out.push(a[order[i]][prop]);\n            }\n        }\n    }\n    return out;\n};\nvar _range = function(len, start) {\n    var out = [];\n    var end;\n    if (start === undefined) {\n        start = 0;\n        end = len;\n    } else {\n        end = start;\n        start = len;\n    }\n    for(var i = start; i < end; i++){\n        out.push(i);\n    }\n    return out;\n};\nvar _removeEmpty = function(a) {\n    var out = [];\n    for(var i = 0, ien = a.length; i < ien; i++){\n        if (a[i]) {\n            out.push(a[i]);\n        }\n    }\n    return out;\n};\n// Replaceable function in api.util\nvar _stripHtml = function(input) {\n    if (!input || typeof input !== \"string\") {\n        return input;\n    }\n    // Irrelevant check to workaround CodeQL's false positive on the regex\n    if (input.length > _max_str_len) {\n        throw new Error(\"Exceeded max str len\");\n    }\n    var previous;\n    input = input.replace(_re_html, \"\"); // Complete tags\n    // Safety for incomplete script tag - use do / while to ensure that\n    // we get all instances\n    do {\n        previous = input;\n        input = input.replace(/<script/i, \"\");\n    }while (input !== previous);\n    return previous;\n};\n// Replaceable function in api.util\nvar _escapeHtml = function(d) {\n    if (Array.isArray(d)) {\n        d = d.join(\",\");\n    }\n    return typeof d === \"string\" ? d.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\") : d;\n};\n// Remove diacritics from a string by decomposing it and then removing\n// non-ascii characters\nvar _normalize = function(str, both) {\n    if (typeof str !== \"string\") {\n        return str;\n    }\n    // It is faster to just run `normalize` than it is to check if\n    // we need to with a regex! (Check as it isn't available in old\n    // Safari)\n    var res = str.normalize ? str.normalize(\"NFD\") : str;\n    // Equally, here we check if a regex is needed or not\n    return res.length !== str.length ? (both === true ? str + \" \" : \"\") + res.replace(/[\\u0300-\\u036f]/g, \"\") : res;\n};\n/**\n * Determine if all values in the array are unique. This means we can short\n * cut the _unique method at the cost of a single loop. A sorted array is used\n * to easily check the values.\n *\n * @param  {array} src Source array\n * @return {boolean} true if all unique, false otherwise\n * @ignore\n */ var _areAllUnique = function(src) {\n    if (src.length < 2) {\n        return true;\n    }\n    var sorted = src.slice().sort();\n    var last = sorted[0];\n    for(var i = 1, ien = sorted.length; i < ien; i++){\n        if (sorted[i] === last) {\n            return false;\n        }\n        last = sorted[i];\n    }\n    return true;\n};\n/**\n * Find the unique elements in a source array.\n *\n * @param  {array} src Source array\n * @return {array} Array of unique items\n * @ignore\n */ var _unique = function(src) {\n    if (Array.from && Set) {\n        return Array.from(new Set(src));\n    }\n    if (_areAllUnique(src)) {\n        return src.slice();\n    }\n    // A faster unique method is to use object keys to identify used values,\n    // but this doesn't work with arrays or objects, which we must also\n    // consider. See jsperf.app/compare-array-unique-versions/4 for more\n    // information.\n    var out = [], val, i, ien = src.length, j, k = 0;\n    again: for(i = 0; i < ien; i++){\n        val = src[i];\n        for(j = 0; j < k; j++){\n            if (out[j] === val) {\n                continue again;\n            }\n        }\n        out.push(val);\n        k++;\n    }\n    return out;\n};\n// Surprisingly this is faster than [].concat.apply\n// https://jsperf.com/flatten-an-array-loop-vs-reduce/2\nvar _flatten = function(out, val) {\n    if (Array.isArray(val)) {\n        for(var i = 0; i < val.length; i++){\n            _flatten(out, val[i]);\n        }\n    } else {\n        out.push(val);\n    }\n    return out;\n};\n// Similar to jQuery's addClass, but use classList.add\nfunction _addClass(el, name) {\n    if (name) {\n        name.split(\" \").forEach(function(n) {\n            if (n) {\n                // `add` does deduplication, so no need to check `contains`\n                el.classList.add(n);\n            }\n        });\n    }\n}\n/**\n * DataTables utility methods\n * \n * This namespace provides helper methods that DataTables uses internally to\n * create a DataTable, but which are not exclusively used only for DataTables.\n * These methods can be used by extension authors to save the duplication of\n * code.\n *\n *  @namespace\n */ DataTable.util = {\n    /**\n\t * Return a string with diacritic characters decomposed\n\t * @param {*} mixed Function or string to normalize\n\t * @param {*} both Return original string and the normalized string\n\t * @returns String or undefined\n\t */ diacritics: function(mixed, both) {\n        var type = typeof mixed;\n        if (type !== \"function\") {\n            return _normalize(mixed, both);\n        }\n        _normalize = mixed;\n    },\n    /**\n\t * Debounce a function\n\t *\n\t * @param {function} fn Function to be called\n\t * @param {integer} freq Call frequency in mS\n\t * @return {function} Wrapped function\n\t */ debounce: function(fn, timeout) {\n        var timer;\n        return function() {\n            var that = this;\n            var args = arguments;\n            clearTimeout(timer);\n            timer = setTimeout(function() {\n                fn.apply(that, args);\n            }, timeout || 250);\n        };\n    },\n    /**\n\t * Throttle the calls to a function. Arguments and context are maintained\n\t * for the throttled function.\n\t *\n\t * @param {function} fn Function to be called\n\t * @param {integer} freq Call frequency in mS\n\t * @return {function} Wrapped function\n\t */ throttle: function(fn, freq) {\n        var frequency = freq !== undefined ? freq : 200, last, timer;\n        return function() {\n            var that = this, now = +new Date(), args = arguments;\n            if (last && now < last + frequency) {\n                clearTimeout(timer);\n                timer = setTimeout(function() {\n                    last = undefined;\n                    fn.apply(that, args);\n                }, frequency);\n            } else {\n                last = now;\n                fn.apply(that, args);\n            }\n        };\n    },\n    /**\n\t * Escape a string such that it can be used in a regular expression\n\t *\n\t *  @param {string} val string to escape\n\t *  @returns {string} escaped string\n\t */ escapeRegex: function(val) {\n        return val.replace(_re_escape_regex, \"\\\\$1\");\n    },\n    /**\n\t * Create a function that will write to a nested object or array\n\t * @param {*} source JSON notation string\n\t * @returns Write function\n\t */ set: function(source) {\n        if ($.isPlainObject(source)) {\n            /* Unlike get, only the underscore (global) option is used for for\n\t\t\t * setting data since we don't know the type here. This is why an object\n\t\t\t * option is not documented for `mData` (which is read/write), but it is\n\t\t\t * for `mRender` which is read only.\n\t\t\t */ return DataTable.util.set(source._);\n        } else if (source === null) {\n            // Nothing to do when the data source is null\n            return function() {};\n        } else if (typeof source === \"function\") {\n            return function(data, val, meta) {\n                source(data, \"set\", val, meta);\n            };\n        } else if (typeof source === \"string\" && (source.indexOf(\".\") !== -1 || source.indexOf(\"[\") !== -1 || source.indexOf(\"(\") !== -1)) {\n            // Like the get, we need to get data from a nested object\n            var setData = function(data, val, src) {\n                var a = _fnSplitObjNotation(src), b;\n                var aLast = a[a.length - 1];\n                var arrayNotation, funcNotation, o, innerSrc;\n                for(var i = 0, iLen = a.length - 1; i < iLen; i++){\n                    // Protect against prototype pollution\n                    if (a[i] === \"__proto__\" || a[i] === \"constructor\") {\n                        throw new Error(\"Cannot set prototype values\");\n                    }\n                    // Check if we are dealing with an array notation request\n                    arrayNotation = a[i].match(__reArray);\n                    funcNotation = a[i].match(__reFn);\n                    if (arrayNotation) {\n                        a[i] = a[i].replace(__reArray, \"\");\n                        data[a[i]] = [];\n                        // Get the remainder of the nested object to set so we can recurse\n                        b = a.slice();\n                        b.splice(0, i + 1);\n                        innerSrc = b.join(\".\");\n                        // Traverse each entry in the array setting the properties requested\n                        if (Array.isArray(val)) {\n                            for(var j = 0, jLen = val.length; j < jLen; j++){\n                                o = {};\n                                setData(o, val[j], innerSrc);\n                                data[a[i]].push(o);\n                            }\n                        } else {\n                            // We've been asked to save data to an array, but it\n                            // isn't array data to be saved. Best that can be done\n                            // is to just save the value.\n                            data[a[i]] = val;\n                        }\n                        // The inner call to setData has already traversed through the remainder\n                        // of the source and has set the data, thus we can exit here\n                        return;\n                    } else if (funcNotation) {\n                        // Function call\n                        a[i] = a[i].replace(__reFn, \"\");\n                        data = data[a[i]](val);\n                    }\n                    // If the nested object doesn't currently exist - since we are\n                    // trying to set the value - create it\n                    if (data[a[i]] === null || data[a[i]] === undefined) {\n                        data[a[i]] = {};\n                    }\n                    data = data[a[i]];\n                }\n                // Last item in the input - i.e, the actual set\n                if (aLast.match(__reFn)) {\n                    // Function call\n                    data = data[aLast.replace(__reFn, \"\")](val);\n                } else {\n                    // If array notation is used, we just want to strip it and use the property name\n                    // and assign the value. If it isn't used, then we get the result we want anyway\n                    data[aLast.replace(__reArray, \"\")] = val;\n                }\n            };\n            return function(data, val) {\n                return setData(data, val, source);\n            };\n        } else {\n            // Array or flat object mapping\n            return function(data, val) {\n                data[source] = val;\n            };\n        }\n    },\n    /**\n\t * Create a function that will read nested objects from arrays, based on JSON notation\n\t * @param {*} source JSON notation string\n\t * @returns Value read\n\t */ get: function(source) {\n        if ($.isPlainObject(source)) {\n            // Build an object of get functions, and wrap them in a single call\n            var o = {};\n            $.each(source, function(key, val) {\n                if (val) {\n                    o[key] = DataTable.util.get(val);\n                }\n            });\n            return function(data, type, row, meta) {\n                var t = o[type] || o._;\n                return t !== undefined ? t(data, type, row, meta) : data;\n            };\n        } else if (source === null) {\n            // Give an empty string for rendering / sorting etc\n            return function(data) {\n                return data;\n            };\n        } else if (typeof source === \"function\") {\n            return function(data, type, row, meta) {\n                return source(data, type, row, meta);\n            };\n        } else if (typeof source === \"string\" && (source.indexOf(\".\") !== -1 || source.indexOf(\"[\") !== -1 || source.indexOf(\"(\") !== -1)) {\n            /* If there is a . in the source string then the data source is in a\n\t\t\t * nested object so we loop over the data for each level to get the next\n\t\t\t * level down. On each loop we test for undefined, and if found immediately\n\t\t\t * return. This allows entire objects to be missing and sDefaultContent to\n\t\t\t * be used if defined, rather than throwing an error\n\t\t\t */ var fetchData = function(data, type, src) {\n                var arrayNotation, funcNotation, out, innerSrc;\n                if (src !== \"\") {\n                    var a = _fnSplitObjNotation(src);\n                    for(var i = 0, iLen = a.length; i < iLen; i++){\n                        // Check if we are dealing with special notation\n                        arrayNotation = a[i].match(__reArray);\n                        funcNotation = a[i].match(__reFn);\n                        if (arrayNotation) {\n                            // Array notation\n                            a[i] = a[i].replace(__reArray, \"\");\n                            // Condition allows simply [] to be passed in\n                            if (a[i] !== \"\") {\n                                data = data[a[i]];\n                            }\n                            out = [];\n                            // Get the remainder of the nested object to get\n                            a.splice(0, i + 1);\n                            innerSrc = a.join(\".\");\n                            // Traverse each entry in the array getting the properties requested\n                            if (Array.isArray(data)) {\n                                for(var j = 0, jLen = data.length; j < jLen; j++){\n                                    out.push(fetchData(data[j], type, innerSrc));\n                                }\n                            }\n                            // If a string is given in between the array notation indicators, that\n                            // is used to join the strings together, otherwise an array is returned\n                            var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);\n                            data = join === \"\" ? out : out.join(join);\n                            break;\n                        } else if (funcNotation) {\n                            // Function call\n                            a[i] = a[i].replace(__reFn, \"\");\n                            data = data[a[i]]();\n                            continue;\n                        }\n                        if (data === null || data[a[i]] === null) {\n                            return null;\n                        } else if (data === undefined || data[a[i]] === undefined) {\n                            return undefined;\n                        }\n                        data = data[a[i]];\n                    }\n                }\n                return data;\n            };\n            return function(data, type) {\n                return fetchData(data, type, source);\n            };\n        } else {\n            // Array or flat object mapping\n            return function(data) {\n                return data[source];\n            };\n        }\n    },\n    stripHtml: function(mixed) {\n        var type = typeof mixed;\n        if (type === \"function\") {\n            _stripHtml = mixed;\n            return;\n        } else if (type === \"string\") {\n            return _stripHtml(mixed);\n        }\n        return mixed;\n    },\n    escapeHtml: function(mixed) {\n        var type = typeof mixed;\n        if (type === \"function\") {\n            _escapeHtml = mixed;\n            return;\n        } else if (type === \"string\" || Array.isArray(mixed)) {\n            return _escapeHtml(mixed);\n        }\n        return mixed;\n    },\n    unique: _unique\n};\n/**\n * Create a mapping object that allows camel case parameters to be looked up\n * for their Hungarian counterparts. The mapping is stored in a private\n * parameter called `_hungarianMap` which can be accessed on the source object.\n *  @param {object} o\n *  @memberof DataTable#oApi\n */ function _fnHungarianMap(o) {\n    var hungarian = \"a aa ai ao as b fn i m o s \", match, newKey, map = {};\n    $.each(o, function(key) {\n        match = key.match(/^([^A-Z]+?)([A-Z])/);\n        if (match && hungarian.indexOf(match[1] + \" \") !== -1) {\n            newKey = key.replace(match[0], match[2].toLowerCase());\n            map[newKey] = key;\n            if (match[1] === \"o\") {\n                _fnHungarianMap(o[key]);\n            }\n        }\n    });\n    o._hungarianMap = map;\n}\n/**\n * Convert from camel case parameters to Hungarian, based on a Hungarian map\n * created by _fnHungarianMap.\n *  @param {object} src The model object which holds all parameters that can be\n *    mapped.\n *  @param {object} user The object to convert from camel case to Hungarian.\n *  @param {boolean} force When set to `true`, properties which already have a\n *    Hungarian value in the `user` object will be overwritten. Otherwise they\n *    won't be.\n *  @memberof DataTable#oApi\n */ function _fnCamelToHungarian(src, user, force) {\n    if (!src._hungarianMap) {\n        _fnHungarianMap(src);\n    }\n    var hungarianKey;\n    $.each(user, function(key) {\n        hungarianKey = src._hungarianMap[key];\n        if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {\n            // For objects, we need to buzz down into the object to copy parameters\n            if (hungarianKey.charAt(0) === \"o\") {\n                // Copy the camelCase options over to the hungarian\n                if (!user[hungarianKey]) {\n                    user[hungarianKey] = {};\n                }\n                $.extend(true, user[hungarianKey], user[key]);\n                _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);\n            } else {\n                user[hungarianKey] = user[key];\n            }\n        }\n    });\n}\n/**\n * Map one parameter onto another\n *  @param {object} o Object to map\n *  @param {*} knew The new parameter name\n *  @param {*} old The old parameter name\n */ var _fnCompatMap = function(o, knew, old) {\n    if (o[knew] !== undefined) {\n        o[old] = o[knew];\n    }\n};\n/**\n * Provide backwards compatibility for the main DT options. Note that the new\n * options are mapped onto the old parameters, so this is an external interface\n * change only.\n *  @param {object} init Object to map\n */ function _fnCompatOpts(init) {\n    _fnCompatMap(init, \"ordering\", \"bSort\");\n    _fnCompatMap(init, \"orderMulti\", \"bSortMulti\");\n    _fnCompatMap(init, \"orderClasses\", \"bSortClasses\");\n    _fnCompatMap(init, \"orderCellsTop\", \"bSortCellsTop\");\n    _fnCompatMap(init, \"order\", \"aaSorting\");\n    _fnCompatMap(init, \"orderFixed\", \"aaSortingFixed\");\n    _fnCompatMap(init, \"paging\", \"bPaginate\");\n    _fnCompatMap(init, \"pagingType\", \"sPaginationType\");\n    _fnCompatMap(init, \"pageLength\", \"iDisplayLength\");\n    _fnCompatMap(init, \"searching\", \"bFilter\");\n    // Boolean initialisation of x-scrolling\n    if (typeof init.sScrollX === \"boolean\") {\n        init.sScrollX = init.sScrollX ? \"100%\" : \"\";\n    }\n    if (typeof init.scrollX === \"boolean\") {\n        init.scrollX = init.scrollX ? \"100%\" : \"\";\n    }\n    // Objects for ordering\n    if (typeof init.bSort === \"object\") {\n        init.orderIndicators = init.bSort.indicators !== undefined ? init.bSort.indicators : true;\n        init.orderHandler = init.bSort.handler !== undefined ? init.bSort.handler : true;\n        init.bSort = true;\n    } else if (init.bSort === false) {\n        init.orderIndicators = false;\n        init.orderHandler = false;\n    }\n    // Which cells are the title cells?\n    if (typeof init.bSortCellsTop === \"boolean\") {\n        init.titleRow = init.bSortCellsTop;\n    }\n    // Column search objects are in an array, so it needs to be converted\n    // element by element\n    var searchCols = init.aoSearchCols;\n    if (searchCols) {\n        for(var i = 0, ien = searchCols.length; i < ien; i++){\n            if (searchCols[i]) {\n                _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);\n            }\n        }\n    }\n    // Enable search delay if server-side processing is enabled\n    if (init.serverSide && !init.searchDelay) {\n        init.searchDelay = 400;\n    }\n}\n/**\n * Provide backwards compatibility for column options. Note that the new options\n * are mapped onto the old parameters, so this is an external interface change\n * only.\n *  @param {object} init Object to map\n */ function _fnCompatCols(init) {\n    _fnCompatMap(init, \"orderable\", \"bSortable\");\n    _fnCompatMap(init, \"orderData\", \"aDataSort\");\n    _fnCompatMap(init, \"orderSequence\", \"asSorting\");\n    _fnCompatMap(init, \"orderDataType\", \"sortDataType\");\n    // orderData can be given as an integer\n    var dataSort = init.aDataSort;\n    if (typeof dataSort === \"number\" && !Array.isArray(dataSort)) {\n        init.aDataSort = [\n            dataSort\n        ];\n    }\n}\n/**\n * Browser feature detection for capabilities, quirks\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnBrowserDetect(settings) {\n    // We don't need to do this every time DataTables is constructed, the values\n    // calculated are specific to the browser and OS configuration which we\n    // don't expect to change between initialisations\n    if (!DataTable.__browser) {\n        var browser = {};\n        DataTable.__browser = browser;\n        // Scrolling feature / quirks detection\n        var n = $(\"<div/>\").css({\n            position: \"fixed\",\n            top: 0,\n            left: -1 * window.pageXOffset,\n            height: 1,\n            width: 1,\n            overflow: \"hidden\"\n        }).append($(\"<div/>\").css({\n            position: \"absolute\",\n            top: 1,\n            left: 1,\n            width: 100,\n            overflow: \"scroll\"\n        }).append($(\"<div/>\").css({\n            width: \"100%\",\n            height: 10\n        }))).appendTo(\"body\");\n        var outer = n.children();\n        var inner = outer.children();\n        // Get scrollbar width\n        browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;\n        // In rtl text layout, some browsers (most, but not all) will place the\n        // scrollbar on the left, rather than the right.\n        browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;\n        n.remove();\n    }\n    $.extend(settings.oBrowser, DataTable.__browser);\n    settings.oScroll.iBarWidth = DataTable.__browser.barWidth;\n}\n/**\n * Add a column to the list used for the table with default values\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnAddColumn(oSettings) {\n    // Add column to aoColumns array\n    var oDefaults = DataTable.defaults.column;\n    var iCol = oSettings.aoColumns.length;\n    var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {\n        \"aDataSort\": oDefaults.aDataSort ? oDefaults.aDataSort : [\n            iCol\n        ],\n        \"mData\": oDefaults.mData ? oDefaults.mData : iCol,\n        idx: iCol,\n        searchFixed: {},\n        colEl: $(\"<col>\").attr(\"data-dt-column\", iCol)\n    });\n    oSettings.aoColumns.push(oCol);\n    // Add search object for column specific search. Note that the `searchCols[ iCol ]`\n    // passed into extend can be undefined. This allows the user to give a default\n    // with only some of the parameters defined, and also not give a default\n    var searchCols = oSettings.aoPreSearchCols;\n    searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]);\n}\n/**\n * Apply options for a column\n *  @param {object} oSettings dataTables settings object\n *  @param {int} iCol column index to consider\n *  @param {object} oOptions object with sType, bVisible and bSearchable etc\n *  @memberof DataTable#oApi\n */ function _fnColumnOptions(oSettings, iCol, oOptions) {\n    var oCol = oSettings.aoColumns[iCol];\n    /* User specified column options */ if (oOptions !== undefined && oOptions !== null) {\n        // Backwards compatibility\n        _fnCompatCols(oOptions);\n        // Map camel case parameters to their Hungarian counterparts\n        _fnCamelToHungarian(DataTable.defaults.column, oOptions, true);\n        /* Backwards compatibility for mDataProp */ if (oOptions.mDataProp !== undefined && !oOptions.mData) {\n            oOptions.mData = oOptions.mDataProp;\n        }\n        if (oOptions.sType) {\n            oCol._sManualType = oOptions.sType;\n        }\n        // `class` is a reserved word in Javascript, so we need to provide\n        // the ability to use a valid name for the camel case input\n        if (oOptions.className && !oOptions.sClass) {\n            oOptions.sClass = oOptions.className;\n        }\n        var origClass = oCol.sClass;\n        $.extend(oCol, oOptions);\n        _fnMap(oCol, oOptions, \"sWidth\", \"sWidthOrig\");\n        // Merge class from previously defined classes with this one, rather than just\n        // overwriting it in the extend above\n        if (origClass !== oCol.sClass) {\n            oCol.sClass = origClass + \" \" + oCol.sClass;\n        }\n        /* iDataSort to be applied (backwards compatibility), but aDataSort will take\n\t\t * priority if defined\n\t\t */ if (oOptions.iDataSort !== undefined) {\n            oCol.aDataSort = [\n                oOptions.iDataSort\n            ];\n        }\n        _fnMap(oCol, oOptions, \"aDataSort\");\n    }\n    /* Cache the data get and set functions for speed */ var mDataSrc = oCol.mData;\n    var mData = _fnGetObjectDataFn(mDataSrc);\n    // The `render` option can be given as an array to access the helper rendering methods.\n    // The first element is the rendering method to use, the rest are the parameters to pass\n    if (oCol.mRender && Array.isArray(oCol.mRender)) {\n        var copy = oCol.mRender.slice();\n        var name = copy.shift();\n        oCol.mRender = DataTable.render[name].apply(window, copy);\n    }\n    oCol._render = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;\n    var attrTest = function(src) {\n        return typeof src === \"string\" && src.indexOf(\"@\") !== -1;\n    };\n    oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));\n    oCol._setter = null;\n    oCol.fnGetData = function(rowData, type, meta) {\n        var innerData = mData(rowData, type, undefined, meta);\n        return oCol._render && type ? oCol._render(innerData, type, rowData, meta) : innerData;\n    };\n    oCol.fnSetData = function(rowData, val, meta) {\n        return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);\n    };\n    // Indicate if DataTables should read DOM data as an object or array\n    // Used in _fnGetRowElements\n    if (typeof mDataSrc !== \"number\" && !oCol._isArrayHost) {\n        oSettings._rowReadObject = true;\n    }\n    /* Feature sorting overrides column specific when off */ if (!oSettings.oFeatures.bSort) {\n        oCol.bSortable = false;\n    }\n}\n/**\n * Adjust the table column widths for new data. Note: you would probably want to\n * do a redraw after calling this function!\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnAdjustColumnSizing(settings) {\n    _fnCalculateColumnWidths(settings);\n    _fnColumnSizes(settings);\n    var scroll = settings.oScroll;\n    if (scroll.sY !== \"\" || scroll.sX !== \"\") {\n        _fnScrollDraw(settings);\n    }\n    _fnCallbackFire(settings, null, \"column-sizing\", [\n        settings\n    ]);\n}\n/**\n * Apply column sizes\n *\n * @param {*} settings DataTables settings object\n */ function _fnColumnSizes(settings) {\n    var cols = settings.aoColumns;\n    for(var i = 0; i < cols.length; i++){\n        var width = _fnColumnsSumWidth(settings, [\n            i\n        ], false, false);\n        cols[i].colEl.css(\"width\", width);\n        if (settings.oScroll.sX) {\n            cols[i].colEl.css(\"min-width\", width);\n        }\n    }\n}\n/**\n * Convert the index of a visible column to the index in the data array (take account\n * of hidden columns)\n *  @param {object} oSettings dataTables settings object\n *  @param {int} iMatch Visible column index to lookup\n *  @returns {int} i the data index\n *  @memberof DataTable#oApi\n */ function _fnVisibleToColumnIndex(oSettings, iMatch) {\n    var aiVis = _fnGetColumns(oSettings, \"bVisible\");\n    return typeof aiVis[iMatch] === \"number\" ? aiVis[iMatch] : null;\n}\n/**\n * Convert the index of an index in the data array and convert it to the visible\n *   column index (take account of hidden columns)\n *  @param {int} iMatch Column index to lookup\n *  @param {object} oSettings dataTables settings object\n *  @returns {int} i the data index\n *  @memberof DataTable#oApi\n */ function _fnColumnIndexToVisible(oSettings, iMatch) {\n    var aiVis = _fnGetColumns(oSettings, \"bVisible\");\n    var iPos = aiVis.indexOf(iMatch);\n    return iPos !== -1 ? iPos : null;\n}\n/**\n * Get the number of visible columns\n *  @param {object} oSettings dataTables settings object\n *  @returns {int} i the number of visible columns\n *  @memberof DataTable#oApi\n */ function _fnVisbleColumns(settings) {\n    var layout = settings.aoHeader;\n    var columns = settings.aoColumns;\n    var vis = 0;\n    if (layout.length) {\n        for(var i = 0, ien = layout[0].length; i < ien; i++){\n            if (columns[i].bVisible && $(layout[0][i].cell).css(\"display\") !== \"none\") {\n                vis++;\n            }\n        }\n    }\n    return vis;\n}\n/**\n * Get an array of column indexes that match a given property\n *  @param {object} oSettings dataTables settings object\n *  @param {string} sParam Parameter in aoColumns to look for - typically\n *    bVisible or bSearchable\n *  @returns {array} Array of indexes with matched properties\n *  @memberof DataTable#oApi\n */ function _fnGetColumns(oSettings, sParam) {\n    var a = [];\n    oSettings.aoColumns.map(function(val, i) {\n        if (val[sParam]) {\n            a.push(i);\n        }\n    });\n    return a;\n}\n/**\n * Allow the result from a type detection function to be `true` while\n * translating that into a string. Old type detection functions will\n * return the type name if it passes. An obect store would be better,\n * but not backwards compatible.\n *\n * @param {*} typeDetect Object or function for type detection\n * @param {*} res Result from the type detection function\n * @returns Type name or false\n */ function _typeResult(typeDetect, res) {\n    return res === true ? typeDetect._name : res;\n}\n/**\n * Calculate the 'type' of a column\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnColumnTypes(settings) {\n    var columns = settings.aoColumns;\n    var data = settings.aoData;\n    var types = DataTable.ext.type.detect;\n    var i, ien, j, jen, k, ken;\n    var col, detectedType, cache;\n    // For each column, spin over the data type detection functions, seeing if one matches\n    for(i = 0, ien = columns.length; i < ien; i++){\n        col = columns[i];\n        cache = [];\n        if (!col.sType && col._sManualType) {\n            col.sType = col._sManualType;\n        } else if (!col.sType) {\n            // With SSP type detection can be unreliable and error prone, so we provide a way\n            // to turn it off.\n            if (!settings.typeDetect) {\n                return;\n            }\n            for(j = 0, jen = types.length; j < jen; j++){\n                var typeDetect = types[j];\n                // There can be either one, or three type detection functions\n                var oneOf = typeDetect.oneOf;\n                var allOf = typeDetect.allOf || typeDetect;\n                var init = typeDetect.init;\n                var one = false;\n                detectedType = null;\n                // Fast detect based on column assignment\n                if (init) {\n                    detectedType = _typeResult(typeDetect, init(settings, col, i));\n                    if (detectedType) {\n                        col.sType = detectedType;\n                        break;\n                    }\n                }\n                for(k = 0, ken = data.length; k < ken; k++){\n                    if (!data[k]) {\n                        continue;\n                    }\n                    // Use a cache array so we only need to get the type data\n                    // from the formatter once (when using multiple detectors)\n                    if (cache[k] === undefined) {\n                        cache[k] = _fnGetCellData(settings, k, i, \"type\");\n                    }\n                    // Only one data point in the column needs to match this function\n                    if (oneOf && !one) {\n                        one = _typeResult(typeDetect, oneOf(cache[k], settings));\n                    }\n                    // All data points need to match this function\n                    detectedType = _typeResult(typeDetect, allOf(cache[k], settings));\n                    // If null, then this type can't apply to this column, so\n                    // rather than testing all cells, break out. There is an\n                    // exception for the last type which is `html`. We need to\n                    // scan all rows since it is possible to mix string and HTML\n                    // types\n                    if (!detectedType && j !== types.length - 3) {\n                        break;\n                    }\n                    // Only a single match is needed for html type since it is\n                    // bottom of the pile and very similar to string - but it\n                    // must not be empty\n                    if (detectedType === \"html\" && !_empty(cache[k])) {\n                        break;\n                    }\n                }\n                // Type is valid for all data points in the column - use this\n                // type\n                if (oneOf && one && detectedType || !oneOf && detectedType) {\n                    col.sType = detectedType;\n                    break;\n                }\n            }\n            // Fall back - if no type was detected, always use string\n            if (!col.sType) {\n                col.sType = \"string\";\n            }\n        }\n        // Set class names for header / footer for auto type classes\n        var autoClass = _ext.type.className[col.sType];\n        if (autoClass) {\n            _columnAutoClass(settings.aoHeader, i, autoClass);\n            _columnAutoClass(settings.aoFooter, i, autoClass);\n        }\n        var renderer = _ext.type.render[col.sType];\n        // This can only happen once! There is no way to remove\n        // a renderer. After the first time the renderer has\n        // already been set so createTr will run the renderer itself.\n        if (renderer && !col._render) {\n            col._render = DataTable.util.get(renderer);\n            _columnAutoRender(settings, i);\n        }\n    }\n}\n/**\n * Apply an auto detected renderer to data which doesn't yet have\n * a renderer\n */ function _columnAutoRender(settings, colIdx) {\n    var data = settings.aoData;\n    for(var i = 0; i < data.length; i++){\n        if (data[i].nTr) {\n            // We have to update the display here since there is no\n            // invalidation check for the data\n            var display = _fnGetCellData(settings, i, colIdx, \"display\");\n            data[i].displayData[colIdx] = display;\n            _fnWriteCell(data[i].anCells[colIdx], display);\n        // No need to update sort / filter data since it has\n        // been invalidated and will be re-read with the\n        // renderer now applied\n        }\n    }\n}\n/**\n * Apply a class name to a column's header cells\n */ function _columnAutoClass(container, colIdx, className) {\n    container.forEach(function(row) {\n        if (row[colIdx] && row[colIdx].unique) {\n            _addClass(row[colIdx].cell, className);\n        }\n    });\n}\n/**\n * Take the column definitions and static columns arrays and calculate how\n * they relate to column indexes. The callback function will then apply the\n * definition found for a column to a suitable configuration object.\n *  @param {object} oSettings dataTables settings object\n *  @param {array} aoColDefs The aoColumnDefs array that is to be applied\n *  @param {array} aoCols The aoColumns array that defines columns individually\n *  @param {array} headerLayout Layout for header as it was loaded\n *  @param {function} fn Callback function - takes two parameters, the calculated\n *    column index and the definition for that column.\n *  @memberof DataTable#oApi\n */ function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, headerLayout, fn) {\n    var i, iLen, j, jLen, k, kLen, def;\n    var columns = oSettings.aoColumns;\n    if (aoCols) {\n        for(i = 0, iLen = aoCols.length; i < iLen; i++){\n            if (aoCols[i] && aoCols[i].name) {\n                columns[i].sName = aoCols[i].name;\n            }\n        }\n    }\n    // Column definitions with aTargets\n    if (aoColDefs) {\n        /* Loop over the definitions array - loop in reverse so first instance has priority */ for(i = aoColDefs.length - 1; i >= 0; i--){\n            def = aoColDefs[i];\n            /* Each definition can target multiple columns, as it is an array */ var aTargets = def.target !== undefined ? def.target : def.targets !== undefined ? def.targets : def.aTargets;\n            if (!Array.isArray(aTargets)) {\n                aTargets = [\n                    aTargets\n                ];\n            }\n            for(j = 0, jLen = aTargets.length; j < jLen; j++){\n                var target = aTargets[j];\n                if (typeof target === \"number\" && target >= 0) {\n                    /* Add columns that we don't yet know about */ while(columns.length <= target){\n                        _fnAddColumn(oSettings);\n                    }\n                    /* Integer, basic index */ fn(target, def);\n                } else if (typeof target === \"number\" && target < 0) {\n                    /* Negative integer, right to left column counting */ fn(columns.length + target, def);\n                } else if (typeof target === \"string\") {\n                    for(k = 0, kLen = columns.length; k < kLen; k++){\n                        if (target === \"_all\") {\n                            // Apply to all columns\n                            fn(k, def);\n                        } else if (target.indexOf(\":name\") !== -1) {\n                            // Column selector\n                            if (columns[k].sName === target.replace(\":name\", \"\")) {\n                                fn(k, def);\n                            }\n                        } else {\n                            // Cell selector\n                            headerLayout.forEach(function(row) {\n                                if (row[k]) {\n                                    var cell = $(row[k].cell);\n                                    // Legacy support. Note that it means that we don't support\n                                    // an element name selector only, since they are treated as\n                                    // class names for 1.x compat.\n                                    if (target.match(/^[a-z][\\w-]*$/i)) {\n                                        target = \".\" + target;\n                                    }\n                                    if (cell.is(target)) {\n                                        fn(k, def);\n                                    }\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // Statically defined columns array\n    if (aoCols) {\n        for(i = 0, iLen = aoCols.length; i < iLen; i++){\n            fn(i, aoCols[i]);\n        }\n    }\n}\n/**\n * Get the width for a given set of columns\n *\n * @param {*} settings DataTables settings object\n * @param {*} targets Columns - comma separated string or array of numbers\n * @param {*} original Use the original width (true) or calculated (false)\n * @param {*} incVisible Include visible columns (true) or not (false)\n * @returns Combined CSS value\n */ function _fnColumnsSumWidth(settings, targets, original, incVisible) {\n    if (!Array.isArray(targets)) {\n        targets = _fnColumnsFromHeader(targets);\n    }\n    var sum = 0;\n    var unit;\n    var columns = settings.aoColumns;\n    for(var i = 0, ien = targets.length; i < ien; i++){\n        var column = columns[targets[i]];\n        var definedWidth = original ? column.sWidthOrig : column.sWidth;\n        if (!incVisible && column.bVisible === false) {\n            continue;\n        }\n        if (definedWidth === null || definedWidth === undefined) {\n            return null; // can't determine a defined width - browser defined\n        } else if (typeof definedWidth === \"number\") {\n            unit = \"px\";\n            sum += definedWidth;\n        } else {\n            var matched = definedWidth.match(/([\\d\\.]+)([^\\d]*)/);\n            if (matched) {\n                sum += matched[1] * 1;\n                unit = matched.length === 3 ? matched[2] : \"px\";\n            }\n        }\n    }\n    return sum + unit;\n}\nfunction _fnColumnsFromHeader(cell) {\n    var attr = $(cell).closest(\"[data-dt-column]\").attr(\"data-dt-column\");\n    if (!attr) {\n        return [];\n    }\n    return attr.split(\",\").map(function(val) {\n        return val * 1;\n    });\n}\n/**\n * Add a data array to the table, creating DOM node etc. This is the parallel to\n * _fnGatherData, but for adding rows from a Javascript source, rather than a\n * DOM source.\n *  @param {object} settings dataTables settings object\n *  @param {array} data data array to be added\n *  @param {node} [tr] TR element to add to the table - optional. If not given,\n *    DataTables will create a row automatically\n *  @param {array} [tds] Array of TD|TH elements for the row - must be given\n *    if nTr is.\n *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed\n *  @memberof DataTable#oApi\n */ function _fnAddData(settings, dataIn, tr, tds) {\n    /* Create the object for storing information about this new row */ var rowIdx = settings.aoData.length;\n    var rowModel = $.extend(true, {}, DataTable.models.oRow, {\n        src: tr ? \"dom\" : \"data\",\n        idx: rowIdx\n    });\n    rowModel._aData = dataIn;\n    settings.aoData.push(rowModel);\n    var columns = settings.aoColumns;\n    for(var i = 0, iLen = columns.length; i < iLen; i++){\n        // Invalidate the column types as the new data needs to be revalidated\n        columns[i].sType = null;\n    }\n    /* Add to the display array */ settings.aiDisplayMaster.push(rowIdx);\n    var id = settings.rowIdFn(dataIn);\n    if (id !== undefined) {\n        settings.aIds[id] = rowModel;\n    }\n    /* Create the DOM information, or register it if already present */ if (tr || !settings.oFeatures.bDeferRender) {\n        _fnCreateTr(settings, rowIdx, tr, tds);\n    }\n    return rowIdx;\n}\n/**\n * Add one or more TR elements to the table. Generally we'd expect to\n * use this for reading data from a DOM sourced table, but it could be\n * used for an TR element. Note that if a TR is given, it is used (i.e.\n * it is not cloned).\n *  @param {object} settings dataTables settings object\n *  @param {array|node|jQuery} trs The TR element(s) to add to the table\n *  @returns {array} Array of indexes for the added rows\n *  @memberof DataTable#oApi\n */ function _fnAddTr(settings, trs) {\n    var row;\n    // Allow an individual node to be passed in\n    if (!(trs instanceof $)) {\n        trs = $(trs);\n    }\n    return trs.map(function(i, el) {\n        row = _fnGetRowElements(settings, el);\n        return _fnAddData(settings, row.data, el, row.cells);\n    });\n}\n/**\n * Get the data for a given cell from the internal cache, taking into account data mapping\n *  @param {object} settings dataTables settings object\n *  @param {int} rowIdx aoData row id\n *  @param {int} colIdx Column index\n *  @param {string} type data get type ('display', 'type' 'filter|search' 'sort|order')\n *  @returns {*} Cell data\n *  @memberof DataTable#oApi\n */ function _fnGetCellData(settings, rowIdx, colIdx, type) {\n    if (type === \"search\") {\n        type = \"filter\";\n    } else if (type === \"order\") {\n        type = \"sort\";\n    }\n    var row = settings.aoData[rowIdx];\n    if (!row) {\n        return undefined;\n    }\n    var draw = settings.iDraw;\n    var col = settings.aoColumns[colIdx];\n    var rowData = row._aData;\n    var defaultContent = col.sDefaultContent;\n    var cellData = col.fnGetData(rowData, type, {\n        settings: settings,\n        row: rowIdx,\n        col: colIdx\n    });\n    // Allow for a node being returned for non-display types\n    if (type !== \"display\" && cellData && typeof cellData === \"object\" && cellData.nodeName) {\n        cellData = cellData.innerHTML;\n    }\n    if (cellData === undefined) {\n        if (settings.iDrawError != draw && defaultContent === null) {\n            _fnLog(settings, 0, \"Requested unknown parameter \" + (typeof col.mData == \"function\" ? \"{function}\" : \"'\" + col.mData + \"'\") + \" for row \" + rowIdx + \", column \" + colIdx, 4);\n            settings.iDrawError = draw;\n        }\n        return defaultContent;\n    }\n    // When the data source is null and a specific data type is requested (i.e.\n    // not the original data), we can use default column data\n    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined) {\n        cellData = defaultContent;\n    } else if (typeof cellData === \"function\") {\n        // If the data source is a function, then we run it and use the return,\n        // executing in the scope of the data object (for instances)\n        return cellData.call(rowData);\n    }\n    if (cellData === null && type === \"display\") {\n        return \"\";\n    }\n    if (type === \"filter\") {\n        var fomatters = DataTable.ext.type.search;\n        if (fomatters[col.sType]) {\n            cellData = fomatters[col.sType](cellData);\n        }\n    }\n    return cellData;\n}\n/**\n * Set the value for a specific cell, into the internal data cache\n *  @param {object} settings dataTables settings object\n *  @param {int} rowIdx aoData row id\n *  @param {int} colIdx Column index\n *  @param {*} val Value to set\n *  @memberof DataTable#oApi\n */ function _fnSetCellData(settings, rowIdx, colIdx, val) {\n    var col = settings.aoColumns[colIdx];\n    var rowData = settings.aoData[rowIdx]._aData;\n    col.fnSetData(rowData, val, {\n        settings: settings,\n        row: rowIdx,\n        col: colIdx\n    });\n}\n/**\n * Write a value to a cell\n * @param {*} td Cell\n * @param {*} val Value\n */ function _fnWriteCell(td, val) {\n    if (val && typeof val === \"object\" && val.nodeName) {\n        $(td).empty().append(val);\n    } else {\n        td.innerHTML = val;\n    }\n}\n// Private variable that is used to match action syntax in the data property object\nvar __reArray = /\\[.*?\\]$/;\nvar __reFn = /\\(\\)$/;\n/**\n * Split string on periods, taking into account escaped periods\n * @param  {string} str String to split\n * @return {array} Split string\n */ function _fnSplitObjNotation(str) {\n    var parts = str.match(/(\\\\.|[^.])+/g) || [\n        \"\"\n    ];\n    return parts.map(function(s) {\n        return s.replace(/\\\\\\./g, \".\");\n    });\n}\n/**\n * Return a function that can be used to get data from a source object, taking\n * into account the ability to use nested objects as a source\n *  @param {string|int|function} mSource The data source for the object\n *  @returns {function} Data get function\n *  @memberof DataTable#oApi\n */ var _fnGetObjectDataFn = DataTable.util.get;\n/**\n * Return a function that can be used to set data from a source object, taking\n * into account the ability to use nested objects as a source\n *  @param {string|int|function} mSource The data source for the object\n *  @returns {function} Data set function\n *  @memberof DataTable#oApi\n */ var _fnSetObjectDataFn = DataTable.util.set;\n/**\n * Return an array with the full table data\n *  @param {object} oSettings dataTables settings object\n *  @returns array {array} aData Master data array\n *  @memberof DataTable#oApi\n */ function _fnGetDataMaster(settings) {\n    return _pluck(settings.aoData, \"_aData\");\n}\n/**\n * Nuke the table\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnClearTable(settings) {\n    settings.aoData.length = 0;\n    settings.aiDisplayMaster.length = 0;\n    settings.aiDisplay.length = 0;\n    settings.aIds = {};\n}\n/**\n * Mark cached data as invalid such that a re-read of the data will occur when\n * the cached data is next requested. Also update from the data source object.\n *\n * @param {object} settings DataTables settings object\n * @param {int}    rowIdx   Row index to invalidate\n * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'\n *     or 'data'\n * @param {int}    [colIdx] Column index to invalidate. If undefined the whole\n *     row will be invalidated\n * @memberof DataTable#oApi\n *\n * @todo For the modularisation of v1.11 this will need to become a callback, so\n *   the sort and filter methods can subscribe to it. That will required\n *   initialisation options for sorting, which is why it is not already baked in\n */ function _fnInvalidate(settings, rowIdx, src, colIdx) {\n    var row = settings.aoData[rowIdx];\n    var i, ien;\n    // Remove the cached data for the row\n    row._aSortData = null;\n    row._aFilterData = null;\n    row.displayData = null;\n    // Are we reading last data from DOM or the data object?\n    if (src === \"dom\" || (!src || src === \"auto\") && row.src === \"dom\") {\n        // Read the data from the DOM\n        row._aData = _fnGetRowElements(settings, row, colIdx, colIdx === undefined ? undefined : row._aData).data;\n    } else {\n        // Reading from data object, update the DOM\n        var cells = row.anCells;\n        var display = _fnGetRowDisplay(settings, rowIdx);\n        if (cells) {\n            if (colIdx !== undefined) {\n                _fnWriteCell(cells[colIdx], display[colIdx]);\n            } else {\n                for(i = 0, ien = cells.length; i < ien; i++){\n                    _fnWriteCell(cells[i], display[i]);\n                }\n            }\n        }\n    }\n    // Column specific invalidation\n    var cols = settings.aoColumns;\n    if (colIdx !== undefined) {\n        // Type - the data might have changed\n        cols[colIdx].sType = null;\n        // Max length string. Its a fairly cheep recalculation, so not worth\n        // something more complicated\n        cols[colIdx].maxLenString = null;\n    } else {\n        for(i = 0, ien = cols.length; i < ien; i++){\n            cols[i].sType = null;\n            cols[i].maxLenString = null;\n        }\n        // Update DataTables special `DT_*` attributes for the row\n        _fnRowAttributes(settings, row);\n    }\n}\n/**\n * Build a data source object from an HTML row, reading the contents of the\n * cells that are in the row.\n *\n * @param {object} settings DataTables settings object\n * @param {node|object} TR element from which to read data or existing row\n *   object from which to re-read the data from the cells\n * @param {int} [colIdx] Optional column index\n * @param {array|object} [d] Data source object. If `colIdx` is given then this\n *   parameter should also be given and will be used to write the data into.\n *   Only the column in question will be written\n * @returns {object} Object with two parameters: `data` the data read, in\n *   document order, and `cells` and array of nodes (they can be useful to the\n *   caller, so rather than needing a second traversal to get them, just return\n *   them from here).\n * @memberof DataTable#oApi\n */ function _fnGetRowElements(settings, row, colIdx, d) {\n    var tds = [], td = row.firstChild, name, col, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;\n    // Allow the data object to be passed in, or construct\n    d = d !== undefined ? d : objectRead ? {} : [];\n    var attr = function(str, td) {\n        if (typeof str === \"string\") {\n            var idx = str.indexOf(\"@\");\n            if (idx !== -1) {\n                var attr = str.substring(idx + 1);\n                var setter = _fnSetObjectDataFn(str);\n                setter(d, td.getAttribute(attr));\n            }\n        }\n    };\n    // Read data from a cell and store into the data object\n    var cellProcess = function(cell) {\n        if (colIdx === undefined || colIdx === i) {\n            col = columns[i];\n            contents = cell.innerHTML.trim();\n            if (col && col._bAttrSrc) {\n                var setter = _fnSetObjectDataFn(col.mData._);\n                setter(d, contents);\n                attr(col.mData.sort, cell);\n                attr(col.mData.type, cell);\n                attr(col.mData.filter, cell);\n            } else {\n                // Depending on the `data` option for the columns the data can\n                // be read to either an object or an array.\n                if (objectRead) {\n                    if (!col._setter) {\n                        // Cache the setter function\n                        col._setter = _fnSetObjectDataFn(col.mData);\n                    }\n                    col._setter(d, contents);\n                } else {\n                    d[i] = contents;\n                }\n            }\n        }\n        i++;\n    };\n    if (td) {\n        // `tr` element was passed in\n        while(td){\n            name = td.nodeName.toUpperCase();\n            if (name == \"TD\" || name == \"TH\") {\n                cellProcess(td);\n                tds.push(td);\n            }\n            td = td.nextSibling;\n        }\n    } else {\n        // Existing row object passed in\n        tds = row.anCells;\n        for(var j = 0, jen = tds.length; j < jen; j++){\n            cellProcess(tds[j]);\n        }\n    }\n    // Read the ID from the DOM if present\n    var rowNode = row.firstChild ? row : row.nTr;\n    if (rowNode) {\n        var id = rowNode.getAttribute(\"id\");\n        if (id) {\n            _fnSetObjectDataFn(settings.rowId)(d, id);\n        }\n    }\n    return {\n        data: d,\n        cells: tds\n    };\n}\n/**\n * Render and cache a row's display data for the columns, if required\n * @returns \n */ function _fnGetRowDisplay(settings, rowIdx) {\n    var rowModal = settings.aoData[rowIdx];\n    var columns = settings.aoColumns;\n    if (!rowModal.displayData) {\n        // Need to render and cache\n        rowModal.displayData = [];\n        for(var colIdx = 0, len = columns.length; colIdx < len; colIdx++){\n            rowModal.displayData.push(_fnGetCellData(settings, rowIdx, colIdx, \"display\"));\n        }\n    }\n    return rowModal.displayData;\n}\n/**\n * Create a new TR element (and it's TD children) for a row\n *  @param {object} oSettings dataTables settings object\n *  @param {int} iRow Row to consider\n *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,\n *    DataTables will create a row automatically\n *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n *    if nTr is.\n *  @memberof DataTable#oApi\n */ function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {\n    var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen, create, trClass = oSettings.oClasses.tbody.row;\n    if (row.nTr === null) {\n        nTr = nTrIn || document.createElement(\"tr\");\n        row.nTr = nTr;\n        row.anCells = cells;\n        _addClass(nTr, trClass);\n        /* Use a private property on the node to allow reserve mapping from the node\n\t\t * to the aoData array for fast look up\n\t\t */ nTr._DT_RowIndex = iRow;\n        /* Special parameters can be given by the data source to be used on the row */ _fnRowAttributes(oSettings, row);\n        /* Process each column */ for(i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++){\n            oCol = oSettings.aoColumns[i];\n            create = nTrIn && anTds[i] ? false : true;\n            nTd = create ? document.createElement(oCol.sCellType) : anTds[i];\n            if (!nTd) {\n                _fnLog(oSettings, 0, \"Incorrect column count\", 18);\n            }\n            nTd._DT_CellIndex = {\n                row: iRow,\n                column: i\n            };\n            cells.push(nTd);\n            var display = _fnGetRowDisplay(oSettings, iRow);\n            // Need to create the HTML if new, or if a rendering function is defined\n            if (create || (oCol.mRender || oCol.mData !== i) && (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i + \".display\")) {\n                _fnWriteCell(nTd, display[i]);\n            }\n            // column class\n            _addClass(nTd, oCol.sClass);\n            // Visibility - add or remove as required\n            if (oCol.bVisible && create) {\n                nTr.appendChild(nTd);\n            } else if (!oCol.bVisible && !create) {\n                nTd.parentNode.removeChild(nTd);\n            }\n            if (oCol.fnCreatedCell) {\n                oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i);\n            }\n        }\n        _fnCallbackFire(oSettings, \"aoRowCreatedCallback\", \"row-created\", [\n            nTr,\n            rowData,\n            iRow,\n            cells\n        ]);\n    } else {\n        _addClass(row.nTr, trClass);\n    }\n}\n/**\n * Add attributes to a row based on the special `DT_*` parameters in a data\n * source object.\n *  @param {object} settings DataTables settings object\n *  @param {object} DataTables row object for the row to be modified\n *  @memberof DataTable#oApi\n */ function _fnRowAttributes(settings, row) {\n    var tr = row.nTr;\n    var data = row._aData;\n    if (tr) {\n        var id = settings.rowIdFn(data);\n        if (id) {\n            tr.id = id;\n        }\n        if (data.DT_RowClass) {\n            // Remove any classes added by DT_RowClass before\n            var a = data.DT_RowClass.split(\" \");\n            row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a;\n            $(tr).removeClass(row.__rowc.join(\" \")).addClass(data.DT_RowClass);\n        }\n        if (data.DT_RowAttr) {\n            $(tr).attr(data.DT_RowAttr);\n        }\n        if (data.DT_RowData) {\n            $(tr).data(data.DT_RowData);\n        }\n    }\n}\n/**\n * Create the HTML header for the table\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnBuildHead(settings, side) {\n    var classes = settings.oClasses;\n    var columns = settings.aoColumns;\n    var i, ien, row;\n    var target = side === \"header\" ? settings.nTHead : settings.nTFoot;\n    var titleProp = side === \"header\" ? \"sTitle\" : side;\n    // Footer might be defined\n    if (!target) {\n        return;\n    }\n    // If no cells yet and we have content for them, then create\n    if (side === \"header\" || _pluck(settings.aoColumns, titleProp).join(\"\")) {\n        row = $(\"tr\", target);\n        // Add a row if needed\n        if (!row.length) {\n            row = $(\"<tr/>\").appendTo(target);\n        }\n        // Add the number of cells needed to make up to the number of columns\n        if (row.length === 1) {\n            var cellCount = 0;\n            $(\"td, th\", row).each(function() {\n                cellCount += this.colSpan;\n            });\n            for(i = cellCount, ien = columns.length; i < ien; i++){\n                $(\"<th/>\").html(columns[i][titleProp] || \"\").appendTo(row);\n            }\n        }\n    }\n    var detected = _fnDetectHeader(settings, target, true);\n    if (side === \"header\") {\n        settings.aoHeader = detected;\n        $(\"tr\", target).addClass(classes.thead.row);\n    } else {\n        settings.aoFooter = detected;\n        $(\"tr\", target).addClass(classes.tfoot.row);\n    }\n    // Every cell needs to be passed through the renderer\n    $(target).children(\"tr\").children(\"th, td\").each(function() {\n        _fnRenderer(settings, side)(settings, $(this), classes);\n    });\n}\n/**\n * Build a layout structure for a header or footer\n *\n * @param {*} settings DataTables settings\n * @param {*} source Source layout array\n * @param {*} incColumns What columns should be included\n * @returns Layout array in column index order\n */ function _fnHeaderLayout(settings, source, incColumns) {\n    var row, column, cell;\n    var local = [];\n    var structure = [];\n    var columns = settings.aoColumns;\n    var columnCount = columns.length;\n    var rowspan, colspan;\n    if (!source) {\n        return;\n    }\n    // Default is to work on only visible columns\n    if (!incColumns) {\n        incColumns = _range(columnCount).filter(function(idx) {\n            return columns[idx].bVisible;\n        });\n    }\n    // Make a copy of the master layout array, but with only the columns we want\n    for(row = 0; row < source.length; row++){\n        // Remove any columns we haven't selected\n        local[row] = source[row].slice().filter(function(cell, i) {\n            return incColumns.includes(i);\n        });\n        // Prep the structure array - it needs an element for each row\n        structure.push([]);\n    }\n    for(row = 0; row < local.length; row++){\n        for(column = 0; column < local[row].length; column++){\n            rowspan = 1;\n            colspan = 1;\n            // Check to see if there is already a cell (row/colspan) covering our target\n            // insert point. If there is, then there is nothing to do.\n            if (structure[row][column] === undefined) {\n                cell = local[row][column].cell;\n                // Expand for rowspan\n                while(local[row + rowspan] !== undefined && local[row][column].cell == local[row + rowspan][column].cell){\n                    structure[row + rowspan][column] = null;\n                    rowspan++;\n                }\n                // And for colspan\n                while(local[row][column + colspan] !== undefined && local[row][column].cell == local[row][column + colspan].cell){\n                    // Which also needs to go over rows\n                    for(var k = 0; k < rowspan; k++){\n                        structure[row + k][column + colspan] = null;\n                    }\n                    colspan++;\n                }\n                var titleSpan = $(\"span.dt-column-title\", cell);\n                structure[row][column] = {\n                    cell: cell,\n                    colspan: colspan,\n                    rowspan: rowspan,\n                    title: titleSpan.length ? titleSpan.html() : $(cell).html()\n                };\n            }\n        }\n    }\n    return structure;\n}\n/**\n * Draw the header (or footer) element based on the column visibility states.\n *\n *  @param object oSettings dataTables settings object\n *  @param array aoSource Layout array from _fnDetectHeader\n *  @memberof DataTable#oApi\n */ function _fnDrawHead(settings, source) {\n    var layout = _fnHeaderLayout(settings, source);\n    var tr, n;\n    for(var row = 0; row < source.length; row++){\n        tr = source[row].row;\n        // All cells are going to be replaced, so empty out the row\n        // Can't use $().empty() as that kills event handlers\n        if (tr) {\n            while(n = tr.firstChild){\n                tr.removeChild(n);\n            }\n        }\n        for(var column = 0; column < layout[row].length; column++){\n            var point = layout[row][column];\n            if (point) {\n                $(point.cell).appendTo(tr).attr(\"rowspan\", point.rowspan).attr(\"colspan\", point.colspan);\n            }\n        }\n    }\n}\n/**\n * Insert the required TR nodes into the table for display\n *  @param {object} oSettings dataTables settings object\n *  @param ajaxComplete true after ajax call to complete rendering\n *  @memberof DataTable#oApi\n */ function _fnDraw(oSettings, ajaxComplete) {\n    // Allow for state saving and a custom start position\n    _fnStart(oSettings);\n    /* Provide a pre-callback function which can be used to cancel the draw is false is returned */ var aPreDraw = _fnCallbackFire(oSettings, \"aoPreDrawCallback\", \"preDraw\", [\n        oSettings\n    ]);\n    if (aPreDraw.indexOf(false) !== -1) {\n        _fnProcessingDisplay(oSettings, false);\n        return;\n    }\n    var anRows = [];\n    var iRowCount = 0;\n    var bServerSide = _fnDataSource(oSettings) == \"ssp\";\n    var aiDisplay = oSettings.aiDisplay;\n    var iDisplayStart = oSettings._iDisplayStart;\n    var iDisplayEnd = oSettings.fnDisplayEnd();\n    var columns = oSettings.aoColumns;\n    var body = $(oSettings.nTBody);\n    oSettings.bDrawing = true;\n    /* Server-side processing draw intercept */ if (oSettings.deferLoading) {\n        oSettings.deferLoading = false;\n        oSettings.iDraw++;\n        _fnProcessingDisplay(oSettings, false);\n    } else if (!bServerSide) {\n        oSettings.iDraw++;\n    } else if (!oSettings.bDestroying && !ajaxComplete) {\n        // Show loading message for server-side processing\n        if (oSettings.iDraw === 0) {\n            body.empty().append(_emptyRow(oSettings));\n        }\n        _fnAjaxUpdate(oSettings);\n        return;\n    }\n    if (aiDisplay.length !== 0) {\n        var iStart = bServerSide ? 0 : iDisplayStart;\n        var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;\n        for(var j = iStart; j < iEnd; j++){\n            var iDataIndex = aiDisplay[j];\n            var aoData = oSettings.aoData[iDataIndex];\n            if (aoData.nTr === null) {\n                _fnCreateTr(oSettings, iDataIndex);\n            }\n            var nRow = aoData.nTr;\n            // Add various classes as needed\n            for(var i = 0; i < columns.length; i++){\n                var col = columns[i];\n                var td = aoData.anCells[i];\n                _addClass(td, _ext.type.className[col.sType]); // auto class\n                _addClass(td, oSettings.oClasses.tbody.cell); // all cells\n            }\n            // Row callback functions - might want to manipulate the row\n            // iRowCount and j are not currently documented. Are they at all\n            // useful?\n            _fnCallbackFire(oSettings, \"aoRowCallback\", null, [\n                nRow,\n                aoData._aData,\n                iRowCount,\n                j,\n                iDataIndex\n            ]);\n            anRows.push(nRow);\n            iRowCount++;\n        }\n    } else {\n        anRows[0] = _emptyRow(oSettings);\n    }\n    /* Header and footer callbacks */ _fnCallbackFire(oSettings, \"aoHeaderCallback\", \"header\", [\n        $(oSettings.nTHead).children(\"tr\")[0],\n        _fnGetDataMaster(oSettings),\n        iDisplayStart,\n        iDisplayEnd,\n        aiDisplay\n    ]);\n    _fnCallbackFire(oSettings, \"aoFooterCallback\", \"footer\", [\n        $(oSettings.nTFoot).children(\"tr\")[0],\n        _fnGetDataMaster(oSettings),\n        iDisplayStart,\n        iDisplayEnd,\n        aiDisplay\n    ]);\n    // replaceChildren is faster, but only became widespread in 2020,\n    // so a fall back in jQuery is provided for older browsers.\n    if (body[0].replaceChildren) {\n        body[0].replaceChildren.apply(body[0], anRows);\n    } else {\n        body.children().detach();\n        body.append($(anRows));\n    }\n    // Empty table needs a specific class\n    $(oSettings.nTableWrapper).toggleClass(\"dt-empty-footer\", $(\"tr\", oSettings.nTFoot).length === 0);\n    /* Call all required callback functions for the end of a draw */ _fnCallbackFire(oSettings, \"aoDrawCallback\", \"draw\", [\n        oSettings\n    ], true);\n    /* Draw is complete, sorting and filtering must be as well */ oSettings.bSorted = false;\n    oSettings.bFiltered = false;\n    oSettings.bDrawing = false;\n}\n/**\n * Redraw the table - taking account of the various features which are enabled\n *  @param {object} oSettings dataTables settings object\n *  @param {boolean} [holdPosition] Keep the current paging position. By default\n *    the paging is reset to the first page\n *  @memberof DataTable#oApi\n */ function _fnReDraw(settings, holdPosition, recompute) {\n    var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;\n    if (recompute === undefined || recompute === true) {\n        // Resolve any column types that are unknown due to addition or invalidation\n        _fnColumnTypes(settings);\n        if (sort) {\n            _fnSort(settings);\n        }\n        if (filter) {\n            _fnFilterComplete(settings, settings.oPreviousSearch);\n        } else {\n            // No filtering, so we want to just use the display master\n            settings.aiDisplay = settings.aiDisplayMaster.slice();\n        }\n    }\n    if (holdPosition !== true) {\n        settings._iDisplayStart = 0;\n    }\n    // Let any modules know about the draw hold position state (used by\n    // scrolling internally)\n    settings._drawHold = holdPosition;\n    _fnDraw(settings);\n    settings._drawHold = false;\n}\n/*\n * Table is empty - create a row with an empty message in it\n */ function _emptyRow(settings) {\n    var oLang = settings.oLanguage;\n    var zero = oLang.sZeroRecords;\n    var dataSrc = _fnDataSource(settings);\n    // Make use of the fact that settings.json is only set once the initial data has\n    // been loaded. Show loading when that isn't the case\n    if ((dataSrc === \"ssp\" || dataSrc === \"ajax\") && !settings.json) {\n        zero = oLang.sLoadingRecords;\n    } else if (oLang.sEmptyTable && settings.fnRecordsTotal() === 0) {\n        zero = oLang.sEmptyTable;\n    }\n    return $(\"<tr/>\").append($(\"<td />\", {\n        \"colSpan\": _fnVisbleColumns(settings),\n        \"class\": settings.oClasses.empty.row\n    }).html(zero))[0];\n}\n/**\n * Expand the layout items into an object for the rendering function\n */ function _layoutItems(row, align, items) {\n    if (Array.isArray(items)) {\n        for(var i = 0; i < items.length; i++){\n            _layoutItems(row, align, items[i]);\n        }\n        return;\n    }\n    var rowCell = row[align];\n    // If it is an object, then there can be multiple features contained in it\n    if ($.isPlainObject(items)) {\n        // A feature plugin cannot be named \"features\" due to this check\n        if (items.features) {\n            if (items.rowId) {\n                row.id = items.rowId;\n            }\n            if (items.rowClass) {\n                row.className = items.rowClass;\n            }\n            rowCell.id = items.id;\n            rowCell.className = items.className;\n            _layoutItems(row, align, items.features);\n        } else {\n            Object.keys(items).map(function(key) {\n                rowCell.contents.push({\n                    feature: key,\n                    opts: items[key]\n                });\n            });\n        }\n    } else {\n        rowCell.contents.push(items);\n    }\n}\n/**\n * Find, or create a layout row\n */ function _layoutGetRow(rows, rowNum, align) {\n    var row;\n    // Find existing rows\n    for(var i = 0; i < rows.length; i++){\n        row = rows[i];\n        if (row.rowNum === rowNum) {\n            // full is on its own, but start and end share a row\n            if (align === \"full\" && row.full || (align === \"start\" || align === \"end\") && (row.start || row.end)) {\n                if (!row[align]) {\n                    row[align] = {\n                        contents: []\n                    };\n                }\n                return row;\n            }\n        }\n    }\n    // If we get this far, then there was no match, create a new row\n    row = {\n        rowNum: rowNum\n    };\n    row[align] = {\n        contents: []\n    };\n    rows.push(row);\n    return row;\n}\n/**\n * Convert a `layout` object given by a user to the object structure needed\n * for the renderer. This is done twice, once for above and once for below\n * the table. Ordering must also be considered.\n *\n * @param {*} settings DataTables settings object\n * @param {*} layout Layout object to convert\n * @param {string} side `top` or `bottom`\n * @returns Converted array structure - one item for each row.\n */ function _layoutArray(settings, layout, side) {\n    var rows = [];\n    // Split out into an array\n    $.each(layout, function(pos, items) {\n        if (items === null) {\n            return;\n        }\n        var parts = pos.match(/^([a-z]+)([0-9]*)([A-Za-z]*)$/);\n        var rowNum = parts[2] ? parts[2] * 1 : 0;\n        var align = parts[3] ? parts[3].toLowerCase() : \"full\";\n        // Filter out the side we aren't interested in\n        if (parts[1] !== side) {\n            return;\n        }\n        // Get or create the row we should attach to\n        var row = _layoutGetRow(rows, rowNum, align);\n        _layoutItems(row, align, items);\n    });\n    // Order by item identifier\n    rows.sort(function(a, b) {\n        var order1 = a.rowNum;\n        var order2 = b.rowNum;\n        // If both in the same row, then the row with `full` comes first\n        if (order1 === order2) {\n            var ret = a.full && !b.full ? -1 : 1;\n            return side === \"bottom\" ? ret * -1 : ret;\n        }\n        return order2 - order1;\n    });\n    // Invert for below the table\n    if (side === \"bottom\") {\n        rows.reverse();\n    }\n    for(var row = 0; row < rows.length; row++){\n        delete rows[row].rowNum;\n        _layoutResolve(settings, rows[row]);\n    }\n    return rows;\n}\n/**\n * Convert the contents of a row's layout object to nodes that can be inserted\n * into the document by a renderer. Execute functions, look up plug-ins, etc.\n *\n * @param {*} settings DataTables settings object\n * @param {*} row Layout object for this row\n */ function _layoutResolve(settings, row) {\n    var getFeature = function(feature, opts) {\n        if (!_ext.features[feature]) {\n            _fnLog(settings, 0, \"Unknown feature: \" + feature);\n        }\n        return _ext.features[feature].apply(this, [\n            settings,\n            opts\n        ]);\n    };\n    var resolve = function(item) {\n        if (!row[item]) {\n            return;\n        }\n        var line = row[item].contents;\n        for(var i = 0, ien = line.length; i < ien; i++){\n            if (!line[i]) {\n                continue;\n            } else if (typeof line[i] === \"string\") {\n                line[i] = getFeature(line[i], null);\n            } else if ($.isPlainObject(line[i])) {\n                // If it's an object, it just has feature and opts properties from\n                // the transform in _layoutArray\n                line[i] = getFeature(line[i].feature, line[i].opts);\n            } else if (typeof line[i].node === \"function\") {\n                line[i] = line[i].node(settings);\n            } else if (typeof line[i] === \"function\") {\n                var inst = line[i](settings);\n                line[i] = typeof inst.node === \"function\" ? inst.node() : inst;\n            }\n        }\n    };\n    resolve(\"start\");\n    resolve(\"end\");\n    resolve(\"full\");\n}\n/**\n * Add the options to the page HTML for the table\n *  @param {object} settings DataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnAddOptionsHtml(settings) {\n    var classes = settings.oClasses;\n    var table = $(settings.nTable);\n    // Wrapper div around everything DataTables controls\n    var insert = $(\"<div/>\").attr({\n        id: settings.sTableId + \"_wrapper\",\n        \"class\": classes.container\n    }).insertBefore(table);\n    settings.nTableWrapper = insert[0];\n    if (settings.sDom) {\n        // Legacy\n        _fnLayoutDom(settings, settings.sDom, insert);\n    } else {\n        var top = _layoutArray(settings, settings.layout, \"top\");\n        var bottom = _layoutArray(settings, settings.layout, \"bottom\");\n        var renderer = _fnRenderer(settings, \"layout\");\n        // Everything above - the renderer will actually insert the contents into the document\n        top.forEach(function(item) {\n            renderer(settings, insert, item);\n        });\n        // The table - always the center of attention\n        renderer(settings, insert, {\n            full: {\n                table: true,\n                contents: [\n                    _fnFeatureHtmlTable(settings)\n                ]\n            }\n        });\n        // Everything below\n        bottom.forEach(function(item) {\n            renderer(settings, insert, item);\n        });\n    }\n    // Processing floats on top, so it isn't an inserted feature\n    _processingHtml(settings);\n}\n/**\n * Draw the table with the legacy DOM property\n * @param {*} settings DT settings object\n * @param {*} dom DOM string\n * @param {*} insert Insert point\n */ function _fnLayoutDom(settings, dom, insert) {\n    var parts = dom.match(/(\".*?\")|('.*?')|./g);\n    var featureNode, option, newNode, next, attr;\n    for(var i = 0; i < parts.length; i++){\n        featureNode = null;\n        option = parts[i];\n        if (option == \"<\") {\n            // New container div\n            newNode = $(\"<div/>\");\n            // Check to see if we should append an id and/or a class name to the container\n            next = parts[i + 1];\n            if (next[0] == \"'\" || next[0] == '\"') {\n                attr = next.replace(/['\"]/g, \"\");\n                var id = \"\", className;\n                /* The attribute can be in the format of \"#id.class\", \"#id\" or \"class\" This logic\n\t\t\t\t * breaks the string into parts and applies them as needed\n\t\t\t\t */ if (attr.indexOf(\".\") != -1) {\n                    var split = attr.split(\".\");\n                    id = split[0];\n                    className = split[1];\n                } else if (attr[0] == \"#\") {\n                    id = attr;\n                } else {\n                    className = attr;\n                }\n                newNode.attr(\"id\", id.substring(1)).addClass(className);\n                i++; // Move along the position array\n            }\n            insert.append(newNode);\n            insert = newNode;\n        } else if (option == \">\") {\n            // End container div\n            insert = insert.parent();\n        } else if (option == \"t\") {\n            // Table\n            featureNode = _fnFeatureHtmlTable(settings);\n        } else {\n            DataTable.ext.feature.forEach(function(feature) {\n                if (option == feature.cFeature) {\n                    featureNode = feature.fnInit(settings);\n                }\n            });\n        }\n        // Add to the display\n        if (featureNode) {\n            insert.append(featureNode);\n        }\n    }\n}\n/**\n * Use the DOM source to create up an array of header cells. The idea here is to\n * create a layout grid (array) of rows x columns, which contains a reference\n * to the cell that that point in the grid (regardless of col/rowspan), such that\n * any column / row could be removed and the new grid constructed\n *  @param {node} thead The header/footer element for the table\n *  @returns {array} Calculated layout array\n *  @memberof DataTable#oApi\n */ function _fnDetectHeader(settings, thead, write) {\n    var columns = settings.aoColumns;\n    var rows = $(thead).children(\"tr\");\n    var row, cell;\n    var i, k, l, iLen, shifted, column, colspan, rowspan;\n    var titleRow = settings.titleRow;\n    var isHeader = thead && thead.nodeName.toLowerCase() === \"thead\";\n    var layout = [];\n    var unique;\n    var shift = function(a, i, j) {\n        var k = a[i];\n        while(k[j]){\n            j++;\n        }\n        return j;\n    };\n    // We know how many rows there are in the layout - so prep it\n    for(i = 0, iLen = rows.length; i < iLen; i++){\n        layout.push([]);\n    }\n    for(i = 0, iLen = rows.length; i < iLen; i++){\n        row = rows[i];\n        column = 0;\n        // For every cell in the row..\n        cell = row.firstChild;\n        while(cell){\n            if (cell.nodeName.toUpperCase() == \"TD\" || cell.nodeName.toUpperCase() == \"TH\") {\n                var cols = [];\n                var jqCell = $(cell);\n                // Get the col and rowspan attributes from the DOM and sanitise them\n                colspan = cell.getAttribute(\"colspan\") * 1;\n                rowspan = cell.getAttribute(\"rowspan\") * 1;\n                colspan = !colspan || colspan === 0 || colspan === 1 ? 1 : colspan;\n                rowspan = !rowspan || rowspan === 0 || rowspan === 1 ? 1 : rowspan;\n                // There might be colspan cells already in this row, so shift our target\n                // accordingly\n                shifted = shift(layout, i, column);\n                // Cache calculation for unique columns\n                unique = colspan === 1 ? true : false;\n                // Perform header setup\n                if (write) {\n                    if (unique) {\n                        // Allow column options to be set from HTML attributes\n                        _fnColumnOptions(settings, shifted, jqCell.data());\n                        // Get the width for the column. This can be defined from the\n                        // width attribute, style attribute or `columns.width` option\n                        var columnDef = columns[shifted];\n                        var width = cell.getAttribute(\"width\") || null;\n                        var t = cell.style.width.match(/width:\\s*(\\d+[pxem%]+)/);\n                        if (t) {\n                            width = t[1];\n                        }\n                        columnDef.sWidthOrig = columnDef.sWidth || width;\n                        if (isHeader) {\n                            // Column title handling - can be user set, or read from the DOM\n                            // This happens before the render, so the original is still in place\n                            if (columnDef.sTitle !== null && !columnDef.autoTitle) {\n                                if (titleRow === true && i === 0 || // top row\n                                titleRow === false && i === rows.length - 1 || // bottom row\n                                titleRow === i || // specific row\n                                titleRow === null) {\n                                    cell.innerHTML = columnDef.sTitle;\n                                }\n                            }\n                            if (!columnDef.sTitle && unique) {\n                                columnDef.sTitle = _stripHtml(cell.innerHTML);\n                                columnDef.autoTitle = true;\n                            }\n                        } else {\n                            // Footer specific operations\n                            if (columnDef.footer) {\n                                cell.innerHTML = columnDef.footer;\n                            }\n                        }\n                        // Fall back to the aria-label attribute on the table header if no ariaTitle is\n                        // provided.\n                        if (!columnDef.ariaTitle) {\n                            columnDef.ariaTitle = jqCell.attr(\"aria-label\") || columnDef.sTitle;\n                        }\n                        // Column specific class names\n                        if (columnDef.className) {\n                            jqCell.addClass(columnDef.className);\n                        }\n                    }\n                    // Wrap the column title so we can write to it in future\n                    if ($(\"span.dt-column-title\", cell).length === 0) {\n                        $(\"<span>\").addClass(\"dt-column-title\").append(cell.childNodes).appendTo(cell);\n                    }\n                    if (settings.orderIndicators && isHeader && jqCell.filter(\":not([data-dt-order=disable])\").length !== 0 && jqCell.parent(\":not([data-dt-order=disable])\").length !== 0 && $(\"span.dt-column-order\", cell).length === 0) {\n                        $(\"<span>\").addClass(\"dt-column-order\").appendTo(cell);\n                    }\n                    // We need to wrap the elements in the header in another element to use flexbox\n                    // layout for those elements\n                    var headerFooter = isHeader ? \"header\" : \"footer\";\n                    if ($(\"span.dt-column-\" + headerFooter, cell).length === 0) {\n                        $(\"<div>\").addClass(\"dt-column-\" + headerFooter).append(cell.childNodes).appendTo(cell);\n                    }\n                }\n                // If there is col / rowspan, copy the information into the layout grid\n                for(l = 0; l < colspan; l++){\n                    for(k = 0; k < rowspan; k++){\n                        layout[i + k][shifted + l] = {\n                            cell: cell,\n                            unique: unique\n                        };\n                        layout[i + k].row = row;\n                    }\n                    cols.push(shifted + l);\n                }\n                // Assign an attribute so spanning cells can still be identified\n                // as belonging to a column\n                cell.setAttribute(\"data-dt-column\", _unique(cols).join(\",\"));\n            }\n            cell = cell.nextSibling;\n        }\n    }\n    return layout;\n}\n/**\n * Set the start position for draw\n *  @param {object} oSettings dataTables settings object\n */ function _fnStart(oSettings) {\n    var bServerSide = _fnDataSource(oSettings) == \"ssp\";\n    var iInitDisplayStart = oSettings.iInitDisplayStart;\n    // Check and see if we have an initial draw position from state saving\n    if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {\n        oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;\n        oSettings.iInitDisplayStart = -1;\n    }\n}\n/**\n * Create an Ajax call based on the table's settings, taking into account that\n * parameters can have multiple forms, and backwards compatibility.\n *\n * @param {object} oSettings dataTables settings object\n * @param {array} data Data to send to the server, required by\n *     DataTables - may be augmented by developer callbacks\n * @param {function} fn Callback function to run when data is obtained\n */ function _fnBuildAjax(oSettings, data, fn) {\n    var ajaxData;\n    var ajax = oSettings.ajax;\n    var instance = oSettings.oInstance;\n    var callback = function(json) {\n        var status = oSettings.jqXHR ? oSettings.jqXHR.status : null;\n        if (json === null || typeof status === \"number\" && status == 204) {\n            json = {};\n            _fnAjaxDataSrc(oSettings, json, []);\n        }\n        var error = json.error || json.sError;\n        if (error) {\n            _fnLog(oSettings, 0, error);\n        }\n        // Microsoft often wrap JSON as a string in another JSON object\n        // Let's handle that automatically\n        if (json.d && typeof json.d === \"string\") {\n            try {\n                json = JSON.parse(json.d);\n            } catch (e) {\n            // noop\n            }\n        }\n        oSettings.json = json;\n        _fnCallbackFire(oSettings, null, \"xhr\", [\n            oSettings,\n            json,\n            oSettings.jqXHR\n        ], true);\n        fn(json);\n    };\n    if ($.isPlainObject(ajax) && ajax.data) {\n        ajaxData = ajax.data;\n        var newData = typeof ajaxData === \"function\" ? ajaxData(data, oSettings) : ajaxData; // an object object or array to merge\n        // If the function returned something, use that alone\n        data = typeof ajaxData === \"function\" && newData ? newData : $.extend(true, data, newData);\n        // Remove the data property as we've resolved it already and don't want\n        // jQuery to do it again (it is restored at the end of the function)\n        delete ajax.data;\n    }\n    var baseAjax = {\n        \"url\": typeof ajax === \"string\" ? ajax : \"\",\n        \"data\": data,\n        \"success\": callback,\n        \"dataType\": \"json\",\n        \"cache\": false,\n        \"type\": oSettings.sServerMethod,\n        \"error\": function(xhr, error) {\n            var ret = _fnCallbackFire(oSettings, null, \"xhr\", [\n                oSettings,\n                null,\n                oSettings.jqXHR\n            ], true);\n            if (ret.indexOf(true) === -1) {\n                if (error == \"parsererror\") {\n                    _fnLog(oSettings, 0, \"Invalid JSON response\", 1);\n                } else if (xhr.readyState === 4) {\n                    _fnLog(oSettings, 0, \"Ajax error\", 7);\n                }\n            }\n            _fnProcessingDisplay(oSettings, false);\n        }\n    };\n    // If `ajax` option is an object, extend and override our default base\n    if ($.isPlainObject(ajax)) {\n        $.extend(baseAjax, ajax);\n    }\n    // Store the data submitted for the API\n    oSettings.oAjaxData = data;\n    // Allow plug-ins and external processes to modify the data\n    _fnCallbackFire(oSettings, null, \"preXhr\", [\n        oSettings,\n        data,\n        baseAjax\n    ], true);\n    // Custom Ajax option to submit the parameters as a JSON string\n    if (baseAjax.submitAs === \"json\" && typeof data === \"object\") {\n        baseAjax.data = JSON.stringify(data);\n    }\n    if (typeof ajax === \"function\") {\n        // Is a function - let the caller define what needs to be done\n        oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);\n    } else if (ajax.url === \"\") {\n        // No url, so don't load any data. Just apply an empty data array\n        // to the object for the callback.\n        var empty = {};\n        DataTable.util.set(ajax.dataSrc)(empty, []);\n        callback(empty);\n    } else {\n        // Object to extend the base settings\n        oSettings.jqXHR = $.ajax(baseAjax);\n    }\n    // Restore for next time around\n    if (ajaxData) {\n        ajax.data = ajaxData;\n    }\n}\n/**\n * Update the table using an Ajax call\n *  @param {object} settings dataTables settings object\n *  @returns {boolean} Block the table drawing or not\n *  @memberof DataTable#oApi\n */ function _fnAjaxUpdate(settings) {\n    settings.iDraw++;\n    _fnProcessingDisplay(settings, true);\n    _fnBuildAjax(settings, _fnAjaxParameters(settings), function(json) {\n        _fnAjaxUpdateDraw(settings, json);\n    });\n}\n/**\n * Build up the parameters in an object needed for a server-side processing\n * request.\n *  @param {object} oSettings dataTables settings object\n *  @returns {bool} block the table drawing or not\n *  @memberof DataTable#oApi\n */ function _fnAjaxParameters(settings) {\n    var columns = settings.aoColumns, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, colData = function(idx, prop) {\n        return typeof columns[idx][prop] === \"function\" ? \"function\" : columns[idx][prop];\n    };\n    return {\n        draw: settings.iDraw,\n        columns: columns.map(function(column, i) {\n            return {\n                data: colData(i, \"mData\"),\n                name: column.sName,\n                searchable: column.bSearchable,\n                orderable: column.bSortable,\n                search: {\n                    value: preColSearch[i].search,\n                    regex: preColSearch[i].regex,\n                    fixed: Object.keys(column.searchFixed).map(function(name) {\n                        return {\n                            name: name,\n                            term: column.searchFixed[name].toString()\n                        };\n                    })\n                }\n            };\n        }),\n        order: _fnSortFlatten(settings).map(function(val) {\n            return {\n                column: val.col,\n                dir: val.dir,\n                name: colData(val.col, \"sName\")\n            };\n        }),\n        start: settings._iDisplayStart,\n        length: features.bPaginate ? settings._iDisplayLength : -1,\n        search: {\n            value: preSearch.search,\n            regex: preSearch.regex,\n            fixed: Object.keys(settings.searchFixed).map(function(name) {\n                return {\n                    name: name,\n                    term: settings.searchFixed[name].toString()\n                };\n            })\n        }\n    };\n}\n/**\n * Data the data from the server (nuking the old) and redraw the table\n *  @param {object} oSettings dataTables settings object\n *  @param {object} json json data return from the server.\n *  @param {string} json.sEcho Tracking flag for DataTables to match requests\n *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering\n *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering\n *  @param {array} json.aaData The data to display on this page\n *  @param {string} [json.sColumns] Column ordering (sName, comma separated)\n *  @memberof DataTable#oApi\n */ function _fnAjaxUpdateDraw(settings, json) {\n    var data = _fnAjaxDataSrc(settings, json);\n    var draw = _fnAjaxDataSrcParam(settings, \"draw\", json);\n    var recordsTotal = _fnAjaxDataSrcParam(settings, \"recordsTotal\", json);\n    var recordsFiltered = _fnAjaxDataSrcParam(settings, \"recordsFiltered\", json);\n    if (draw !== undefined) {\n        // Protect against out of sequence returns\n        if (draw * 1 < settings.iDraw) {\n            return;\n        }\n        settings.iDraw = draw * 1;\n    }\n    // No data in returned object, so rather than an array, we show an empty table\n    if (!data) {\n        data = [];\n    }\n    _fnClearTable(settings);\n    settings._iRecordsTotal = parseInt(recordsTotal, 10);\n    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);\n    for(var i = 0, ien = data.length; i < ien; i++){\n        _fnAddData(settings, data[i]);\n    }\n    settings.aiDisplay = settings.aiDisplayMaster.slice();\n    _fnColumnTypes(settings);\n    _fnDraw(settings, true);\n    _fnInitComplete(settings);\n    _fnProcessingDisplay(settings, false);\n}\n/**\n * Get the data from the JSON data source to use for drawing a table. Using\n * `_fnGetObjectDataFn` allows the data to be sourced from a property of the\n * source object, or from a processing function.\n *  @param {object} settings dataTables settings object\n *  @param  {object} json Data source object / array from the server\n *  @return {array} Array of data to use\n */ function _fnAjaxDataSrc(settings, json, write) {\n    var dataProp = \"data\";\n    if ($.isPlainObject(settings.ajax) && settings.ajax.dataSrc !== undefined) {\n        // Could in inside a `dataSrc` object, or not!\n        var dataSrc = settings.ajax.dataSrc;\n        // string, function and object are valid types\n        if (typeof dataSrc === \"string\" || typeof dataSrc === \"function\") {\n            dataProp = dataSrc;\n        } else if (dataSrc.data !== undefined) {\n            dataProp = dataSrc.data;\n        }\n    }\n    if (!write) {\n        if (dataProp === \"data\") {\n            // If the default, then we still want to support the old style, and safely ignore\n            // it if possible\n            return json.aaData || json[dataProp];\n        }\n        return dataProp !== \"\" ? _fnGetObjectDataFn(dataProp)(json) : json;\n    }\n    // set\n    _fnSetObjectDataFn(dataProp)(json, write);\n}\n/**\n * Very similar to _fnAjaxDataSrc, but for the other SSP properties\n * @param {*} settings DataTables settings object\n * @param {*} param Target parameter\n * @param {*} json JSON data\n * @returns Resolved value\n */ function _fnAjaxDataSrcParam(settings, param, json) {\n    var dataSrc = $.isPlainObject(settings.ajax) ? settings.ajax.dataSrc : null;\n    if (dataSrc && dataSrc[param]) {\n        // Get from custom location\n        return _fnGetObjectDataFn(dataSrc[param])(json);\n    }\n    // else - Default behaviour\n    var old = \"\";\n    // Legacy support\n    if (param === \"draw\") {\n        old = \"sEcho\";\n    } else if (param === \"recordsTotal\") {\n        old = \"iTotalRecords\";\n    } else if (param === \"recordsFiltered\") {\n        old = \"iTotalDisplayRecords\";\n    }\n    return json[old] !== undefined ? json[old] : json[param];\n}\n/**\n * Filter the table using both the global filter and column based filtering\n *  @param {object} settings dataTables settings object\n *  @param {object} input search information\n *  @memberof DataTable#oApi\n */ function _fnFilterComplete(settings, input) {\n    var columnsSearch = settings.aoPreSearchCols;\n    // In server-side processing all filtering is done by the server, so no point hanging around here\n    if (_fnDataSource(settings) != \"ssp\") {\n        // Check if any of the rows were invalidated\n        _fnFilterData(settings);\n        // Start from the full data set\n        settings.aiDisplay = settings.aiDisplayMaster.slice();\n        // Global filter first\n        _fnFilter(settings.aiDisplay, settings, input.search, input);\n        $.each(settings.searchFixed, function(name, term) {\n            _fnFilter(settings.aiDisplay, settings, term, {});\n        });\n        // Then individual column filters\n        for(var i = 0; i < columnsSearch.length; i++){\n            var col = columnsSearch[i];\n            _fnFilter(settings.aiDisplay, settings, col.search, col, i);\n            $.each(settings.aoColumns[i].searchFixed, function(name, term) {\n                _fnFilter(settings.aiDisplay, settings, term, {}, i);\n            });\n        }\n        // And finally global filtering\n        _fnFilterCustom(settings);\n    }\n    // Tell the draw function we have been filtering\n    settings.bFiltered = true;\n    _fnCallbackFire(settings, null, \"search\", [\n        settings\n    ]);\n}\n/**\n * Apply custom filtering functions\n * \n * This is legacy now that we have named functions, but it is widely used\n * from 1.x, so it is not yet deprecated.\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnFilterCustom(settings) {\n    var filters = DataTable.ext.search;\n    var displayRows = settings.aiDisplay;\n    var row, rowIdx;\n    for(var i = 0, ien = filters.length; i < ien; i++){\n        var rows = [];\n        // Loop over each row and see if it should be included\n        for(var j = 0, jen = displayRows.length; j < jen; j++){\n            rowIdx = displayRows[j];\n            row = settings.aoData[rowIdx];\n            if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {\n                rows.push(rowIdx);\n            }\n        }\n        // So the array reference doesn't break set the results into the\n        // existing array\n        displayRows.length = 0;\n        _fnArrayApply(displayRows, rows);\n    }\n}\n/**\n * Filter the data table based on user input and draw the table\n */ function _fnFilter(searchRows, settings, input, options, column) {\n    if (input === \"\") {\n        return;\n    }\n    var i = 0;\n    var matched = [];\n    // Search term can be a function, regex or string - if a string we apply our\n    // smart filtering regex (assuming the options require that)\n    var searchFunc = typeof input === \"function\" ? input : null;\n    var rpSearch = input instanceof RegExp ? input : searchFunc ? null : _fnFilterCreateSearch(input, options);\n    // Then for each row, does the test pass. If not, lop the row from the array\n    for(i = 0; i < searchRows.length; i++){\n        var row = settings.aoData[searchRows[i]];\n        var data = column === undefined ? row._sFilterRow : row._aFilterData[column];\n        if (searchFunc && searchFunc(data, row._aData, searchRows[i], column) || rpSearch && rpSearch.test(data)) {\n            matched.push(searchRows[i]);\n        }\n    }\n    // Mutate the searchRows array\n    searchRows.length = matched.length;\n    for(i = 0; i < matched.length; i++){\n        searchRows[i] = matched[i];\n    }\n}\n/**\n * Build a regular expression object suitable for searching a table\n *  @param {string} sSearch string to search for\n *  @param {bool} bRegex treat as a regular expression or not\n *  @param {bool} bSmart perform smart filtering or not\n *  @param {bool} bCaseInsensitive Do case insensitive matching or not\n *  @returns {RegExp} constructed object\n *  @memberof DataTable#oApi\n */ function _fnFilterCreateSearch(search, inOpts) {\n    var not = [];\n    var options = $.extend({}, {\n        boundary: false,\n        caseInsensitive: true,\n        exact: false,\n        regex: false,\n        smart: true\n    }, inOpts);\n    if (typeof search !== \"string\") {\n        search = search.toString();\n    }\n    // Remove diacritics if normalize is set up to do so\n    search = _normalize(search);\n    if (options.exact) {\n        return new RegExp(\"^\" + _fnEscapeRegex(search) + \"$\", options.caseInsensitive ? \"i\" : \"\");\n    }\n    search = options.regex ? search : _fnEscapeRegex(search);\n    if (options.smart) {\n        /* For smart filtering we want to allow the search to work regardless of\n\t\t * word order. We also want double quoted text to be preserved, so word\n\t\t * order is important - a la google. And a negative look around for\n\t\t * finding rows which don't contain a given string.\n\t\t * \n\t\t * So this is the sort of thing we want to generate:\n\t\t * \n\t\t * ^(?=.*?\\bone\\b)(?=.*?\\btwo three\\b)(?=.*?\\bfour\\b).*$\n\t\t */ var parts = search.match(/!?[\"\\u201C][^\"\\u201D]+[\"\\u201D]|[^ ]+/g) || [\n            \"\"\n        ];\n        var a = parts.map(function(word) {\n            var negative = false;\n            var m;\n            // Determine if it is a \"does not include\"\n            if (word.charAt(0) === \"!\") {\n                negative = true;\n                word = word.substring(1);\n            }\n            // Strip the quotes from around matched phrases\n            if (word.charAt(0) === '\"') {\n                m = word.match(/^\"(.*)\"$/);\n                word = m ? m[1] : word;\n            } else if (word.charAt(0) === \"“\") {\n                // Smart quote match (iPhone users)\n                m = word.match(/^\\u201C(.*)\\u201D$/);\n                word = m ? m[1] : word;\n            }\n            // For our \"not\" case, we need to modify the string that is\n            // allowed to match at the end of the expression.\n            if (negative) {\n                if (word.length > 1) {\n                    not.push(\"(?!\" + word + \")\");\n                }\n                word = \"\";\n            }\n            return word.replace(/\"/g, \"\");\n        });\n        var match = not.length ? not.join(\"\") : \"\";\n        var boundary = options.boundary ? \"\\\\b\" : \"\";\n        search = \"^(?=.*?\" + boundary + a.join(\")(?=.*?\" + boundary) + \")(\" + match + \".)*$\";\n    }\n    return new RegExp(search, options.caseInsensitive ? \"i\" : \"\");\n}\n/**\n * Escape a string such that it can be used in a regular expression\n *  @param {string} sVal string to escape\n *  @returns {string} escaped string\n *  @memberof DataTable#oApi\n */ var _fnEscapeRegex = DataTable.util.escapeRegex;\nvar __filter_div = $(\"<div>\")[0];\nvar __filter_div_textContent = __filter_div.textContent !== undefined;\n// Update the filtering data for each row if needed (by invalidation or first run)\nfunction _fnFilterData(settings) {\n    var columns = settings.aoColumns;\n    var data = settings.aoData;\n    var column;\n    var j, jen, filterData, cellData, row;\n    var wasInvalidated = false;\n    for(var rowIdx = 0; rowIdx < data.length; rowIdx++){\n        if (!data[rowIdx]) {\n            continue;\n        }\n        row = data[rowIdx];\n        if (!row._aFilterData) {\n            filterData = [];\n            for(j = 0, jen = columns.length; j < jen; j++){\n                column = columns[j];\n                if (column.bSearchable) {\n                    cellData = _fnGetCellData(settings, rowIdx, j, \"filter\");\n                    // Search in DataTables is string based\n                    if (cellData === null) {\n                        cellData = \"\";\n                    }\n                    if (typeof cellData !== \"string\" && cellData.toString) {\n                        cellData = cellData.toString();\n                    }\n                } else {\n                    cellData = \"\";\n                }\n                // If it looks like there is an HTML entity in the string,\n                // attempt to decode it so sorting works as expected. Note that\n                // we could use a single line of jQuery to do this, but the DOM\n                // method used here is much faster https://jsperf.com/html-decode\n                if (cellData.indexOf && cellData.indexOf(\"&\") !== -1) {\n                    __filter_div.innerHTML = cellData;\n                    cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;\n                }\n                if (cellData.replace) {\n                    cellData = cellData.replace(/[\\r\\n\\u2028]/g, \"\");\n                }\n                filterData.push(cellData);\n            }\n            row._aFilterData = filterData;\n            row._sFilterRow = filterData.join(\"  \");\n            wasInvalidated = true;\n        }\n    }\n    return wasInvalidated;\n}\n/**\n * Draw the table for the first time, adding all required features\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnInitialise(settings) {\n    var i;\n    var init = settings.oInit;\n    var deferLoading = settings.deferLoading;\n    var dataSrc = _fnDataSource(settings);\n    // Ensure that the table data is fully initialised\n    if (!settings.bInitialised) {\n        setTimeout(function() {\n            _fnInitialise(settings);\n        }, 200);\n        return;\n    }\n    // Build the header / footer for the table\n    _fnBuildHead(settings, \"header\");\n    _fnBuildHead(settings, \"footer\");\n    // Load the table's state (if needed) and then render around it and draw\n    _fnLoadState(settings, init, function() {\n        // Then draw the header / footer\n        _fnDrawHead(settings, settings.aoHeader);\n        _fnDrawHead(settings, settings.aoFooter);\n        // Cache the paging start point, as the first redraw will reset it\n        var iAjaxStart = settings.iInitDisplayStart;\n        // Local data load\n        // Check if there is data passing into the constructor\n        if (init.aaData) {\n            for(i = 0; i < init.aaData.length; i++){\n                _fnAddData(settings, init.aaData[i]);\n            }\n        } else if (deferLoading || dataSrc == \"dom\") {\n            // Grab the data from the page\n            _fnAddTr(settings, $(settings.nTBody).children(\"tr\"));\n        }\n        // Filter not yet applied - copy the display master\n        settings.aiDisplay = settings.aiDisplayMaster.slice();\n        // Enable features\n        _fnAddOptionsHtml(settings);\n        _fnSortInit(settings);\n        _colGroup(settings);\n        /* Okay to show that something is going on now */ _fnProcessingDisplay(settings, true);\n        _fnCallbackFire(settings, null, \"preInit\", [\n            settings\n        ], true);\n        // If there is default sorting required - let's do it. The sort function\n        // will do the drawing for us. Otherwise we draw the table regardless of the\n        // Ajax source - this allows the table to look initialised for Ajax sourcing\n        // data (show 'loading' message possibly)\n        _fnReDraw(settings);\n        // Server-side processing init complete is done by _fnAjaxUpdateDraw\n        if (dataSrc != \"ssp\" || deferLoading) {\n            // if there is an ajax source load the data\n            if (dataSrc == \"ajax\") {\n                _fnBuildAjax(settings, {}, function(json) {\n                    var aData = _fnAjaxDataSrc(settings, json);\n                    // Got the data - add it to the table\n                    for(i = 0; i < aData.length; i++){\n                        _fnAddData(settings, aData[i]);\n                    }\n                    // Reset the init display for cookie saving. We've already done\n                    // a filter, and therefore cleared it before. So we need to make\n                    // it appear 'fresh'\n                    settings.iInitDisplayStart = iAjaxStart;\n                    _fnReDraw(settings);\n                    _fnProcessingDisplay(settings, false);\n                    _fnInitComplete(settings);\n                }, settings);\n            } else {\n                _fnInitComplete(settings);\n                _fnProcessingDisplay(settings, false);\n            }\n        }\n    });\n}\n/**\n * Draw the table for the first time, adding all required features\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnInitComplete(settings) {\n    if (settings._bInitComplete) {\n        return;\n    }\n    var args = [\n        settings,\n        settings.json\n    ];\n    settings._bInitComplete = true;\n    // Table is fully set up and we have data, so calculate the\n    // column widths\n    _fnAdjustColumnSizing(settings);\n    _fnCallbackFire(settings, null, \"plugin-init\", args, true);\n    _fnCallbackFire(settings, \"aoInitComplete\", \"init\", args, true);\n}\nfunction _fnLengthChange(settings, val) {\n    var len = parseInt(val, 10);\n    settings._iDisplayLength = len;\n    _fnLengthOverflow(settings);\n    // Fire length change event\n    _fnCallbackFire(settings, null, \"length\", [\n        settings,\n        len\n    ]);\n}\n/**\n * Alter the display settings to change the page\n *  @param {object} settings DataTables settings object\n *  @param {string|int} action Paging action to take: \"first\", \"previous\",\n *    \"next\" or \"last\" or page number to jump to (integer)\n *  @param [bool] redraw Automatically draw the update or not\n *  @returns {bool} true page has changed, false - no change\n *  @memberof DataTable#oApi\n */ function _fnPageChange(settings, action, redraw) {\n    var start = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();\n    if (records === 0 || len === -1) {\n        start = 0;\n    } else if (typeof action === \"number\") {\n        start = action * len;\n        if (start > records) {\n            start = 0;\n        }\n    } else if (action == \"first\") {\n        start = 0;\n    } else if (action == \"previous\") {\n        start = len >= 0 ? start - len : 0;\n        if (start < 0) {\n            start = 0;\n        }\n    } else if (action == \"next\") {\n        if (start + len < records) {\n            start += len;\n        }\n    } else if (action == \"last\") {\n        start = Math.floor((records - 1) / len) * len;\n    } else if (action === \"ellipsis\") {\n        return;\n    } else {\n        _fnLog(settings, 0, \"Unknown paging action: \" + action, 5);\n    }\n    var changed = settings._iDisplayStart !== start;\n    settings._iDisplayStart = start;\n    _fnCallbackFire(settings, null, changed ? \"page\" : \"page-nc\", [\n        settings\n    ]);\n    if (changed && redraw) {\n        _fnDraw(settings);\n    }\n    return changed;\n}\n/**\n * Generate the node required for the processing node\n *  @param {object} settings DataTables settings object\n */ function _processingHtml(settings) {\n    var table = settings.nTable;\n    var scrolling = settings.oScroll.sX !== \"\" || settings.oScroll.sY !== \"\";\n    if (settings.oFeatures.bProcessing) {\n        var n = $(\"<div/>\", {\n            \"id\": settings.sTableId + \"_processing\",\n            \"class\": settings.oClasses.processing.container,\n            \"role\": \"status\"\n        }).html(settings.oLanguage.sProcessing).append(\"<div><div></div><div></div><div></div><div></div></div>\");\n        // Different positioning depending on if scrolling is enabled or not\n        if (scrolling) {\n            n.prependTo($(\"div.dt-scroll\", settings.nTableWrapper));\n        } else {\n            n.insertBefore(table);\n        }\n        $(table).on(\"processing.dt.DT\", function(e, s, show) {\n            n.css(\"display\", show ? \"block\" : \"none\");\n        });\n    }\n}\n/**\n * Display or hide the processing indicator\n *  @param {object} settings DataTables settings object\n *  @param {bool} show Show the processing indicator (true) or not (false)\n */ function _fnProcessingDisplay(settings, show) {\n    // Ignore cases when we are still redrawing\n    if (settings.bDrawing && show === false) {\n        return;\n    }\n    _fnCallbackFire(settings, null, \"processing\", [\n        settings,\n        show\n    ]);\n}\n/**\n * Show the processing element if an action takes longer than a given time\n *\n * @param {*} settings DataTables settings object\n * @param {*} enable Do (true) or not (false) async processing (local feature enablement)\n * @param {*} run Function to run\n */ function _fnProcessingRun(settings, enable, run) {\n    if (!enable) {\n        // Immediate execution, synchronous\n        run();\n    } else {\n        _fnProcessingDisplay(settings, true);\n        // Allow the processing display to show if needed\n        setTimeout(function() {\n            run();\n            _fnProcessingDisplay(settings, false);\n        }, 0);\n    }\n}\n/**\n * Add any control elements for the table - specifically scrolling\n *  @param {object} settings dataTables settings object\n *  @returns {node} Node to add to the DOM\n *  @memberof DataTable#oApi\n */ function _fnFeatureHtmlTable(settings) {\n    var table = $(settings.nTable);\n    // Scrolling from here on in\n    var scroll = settings.oScroll;\n    if (scroll.sX === \"\" && scroll.sY === \"\") {\n        return settings.nTable;\n    }\n    var scrollX = scroll.sX;\n    var scrollY = scroll.sY;\n    var classes = settings.oClasses.scrolling;\n    var caption = settings.captionNode;\n    var captionSide = caption ? caption._captionSide : null;\n    var headerClone = $(table[0].cloneNode(false));\n    var footerClone = $(table[0].cloneNode(false));\n    var footer = table.children(\"tfoot\");\n    var _div = \"<div/>\";\n    var size = function(s) {\n        return !s ? null : _fnStringToCss(s);\n    };\n    if (!footer.length) {\n        footer = null;\n    }\n    /*\n\t * The HTML structure that we want to generate in this function is:\n\t *  div - scroller\n\t *    div - scroll head\n\t *      div - scroll head inner\n\t *        table - scroll head table\n\t *          thead - thead\n\t *    div - scroll body\n\t *      table - table (master table)\n\t *        thead - thead clone for sizing\n\t *        tbody - tbody\n\t *    div - scroll foot\n\t *      div - scroll foot inner\n\t *        table - scroll foot table\n\t *          tfoot - tfoot\n\t */ var scroller = $(_div, {\n        \"class\": classes.container\n    }).append($(_div, {\n        \"class\": classes.header.self\n    }).css({\n        overflow: \"hidden\",\n        position: \"relative\",\n        border: 0,\n        width: scrollX ? size(scrollX) : \"100%\"\n    }).append($(_div, {\n        \"class\": classes.header.inner\n    }).css({\n        \"box-sizing\": \"content-box\",\n        width: scroll.sXInner || \"100%\"\n    }).append(headerClone.removeAttr(\"id\").css(\"margin-left\", 0).append(captionSide === \"top\" ? caption : null).append(table.children(\"thead\"))))).append($(_div, {\n        \"class\": classes.body\n    }).css({\n        position: \"relative\",\n        overflow: \"auto\",\n        width: size(scrollX)\n    }).append(table));\n    if (footer) {\n        scroller.append($(_div, {\n            \"class\": classes.footer.self\n        }).css({\n            overflow: \"hidden\",\n            border: 0,\n            width: scrollX ? size(scrollX) : \"100%\"\n        }).append($(_div, {\n            \"class\": classes.footer.inner\n        }).append(footerClone.removeAttr(\"id\").css(\"margin-left\", 0).append(captionSide === \"bottom\" ? caption : null).append(table.children(\"tfoot\")))));\n    }\n    var children = scroller.children();\n    var scrollHead = children[0];\n    var scrollBody = children[1];\n    var scrollFoot = footer ? children[2] : null;\n    // When the body is scrolled, then we also want to scroll the headers\n    $(scrollBody).on(\"scroll.DT\", function() {\n        var scrollLeft = this.scrollLeft;\n        scrollHead.scrollLeft = scrollLeft;\n        if (footer) {\n            scrollFoot.scrollLeft = scrollLeft;\n        }\n    });\n    // When focus is put on the header cells, we might need to scroll the body\n    $(\"th, td\", scrollHead).on(\"focus\", function() {\n        var scrollLeft = scrollHead.scrollLeft;\n        scrollBody.scrollLeft = scrollLeft;\n        if (footer) {\n            scrollBody.scrollLeft = scrollLeft;\n        }\n    });\n    $(scrollBody).css(\"max-height\", scrollY);\n    if (!scroll.bCollapse) {\n        $(scrollBody).css(\"height\", scrollY);\n    }\n    settings.nScrollHead = scrollHead;\n    settings.nScrollBody = scrollBody;\n    settings.nScrollFoot = scrollFoot;\n    // On redraw - align columns\n    settings.aoDrawCallback.push(_fnScrollDraw);\n    return scroller[0];\n}\n/**\n * Update the header, footer and body tables for resizing - i.e. column\n * alignment.\n *\n * Welcome to the most horrible function DataTables. The process that this\n * function follows is basically:\n *   1. Re-create the table inside the scrolling div\n *   2. Correct colgroup > col values if needed\n *   3. Copy colgroup > col over to header and footer\n *   4. Clean up\n *\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnScrollDraw(settings) {\n    // Given that this is such a monster function, a lot of variables are use\n    // to try and keep the minimised size as small as possible\n    var scroll = settings.oScroll, barWidth = scroll.iBarWidth, divHeader = $(settings.nScrollHead), divHeaderInner = divHeader.children(\"div\"), divHeaderTable = divHeaderInner.children(\"table\"), divBodyEl = settings.nScrollBody, divBody = $(divBodyEl), divFooter = $(settings.nScrollFoot), divFooterInner = divFooter.children(\"div\"), divFooterTable = divFooterInner.children(\"table\"), header = $(settings.nTHead), table = $(settings.nTable), footer = settings.nTFoot && $(\"th, td\", settings.nTFoot).length ? $(settings.nTFoot) : null, browser = settings.oBrowser, headerCopy, footerCopy;\n    // If the scrollbar visibility has changed from the last draw, we need to\n    // adjust the column sizes as the table width will have changed to account\n    // for the scrollbar\n    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;\n    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined) {\n        settings.scrollBarVis = scrollBarVis;\n        _fnAdjustColumnSizing(settings);\n        return; // adjust column sizing will call this function again\n    } else {\n        settings.scrollBarVis = scrollBarVis;\n    }\n    // 1. Re-create the table inside the scrolling div\n    // Remove the old minimised thead and tfoot elements in the inner table\n    table.children(\"thead, tfoot\").remove();\n    // Clone the current header and footer elements and then place it into the inner table\n    headerCopy = header.clone().prependTo(table);\n    headerCopy.find(\"th, td\").removeAttr(\"tabindex\");\n    headerCopy.find(\"[id]\").removeAttr(\"id\");\n    if (footer) {\n        footerCopy = footer.clone().prependTo(table);\n        footerCopy.find(\"[id]\").removeAttr(\"id\");\n    }\n    // 2. Correct colgroup > col values if needed\n    // It is possible that the cell sizes are smaller than the content, so we need to\n    // correct colgroup>col for such cases. This can happen if the auto width detection\n    // uses a cell which has a longer string, but isn't the widest! For example \n    // \"Chief Executive Officer (CEO)\" is the longest string in the demo, but\n    // \"Systems Administrator\" is actually the widest string since it doesn't collapse.\n    // Note the use of translating into a column index to get the `col` element. This\n    // is because of Responsive which might remove `col` elements, knocking the alignment\n    // of the indexes out.\n    if (settings.aiDisplay.length) {\n        // Get the column sizes from the first row in the table. This should really be a\n        // [].find, but it wasn't supported in Chrome until Sept 2015, and DT has 10 year\n        // browser support\n        var firstTr = null;\n        var start = _fnDataSource(settings) !== \"ssp\" ? settings._iDisplayStart : 0;\n        for(i = start; i < start + settings.aiDisplay.length; i++){\n            var idx = settings.aiDisplay[i];\n            var tr = settings.aoData[idx].nTr;\n            if (tr) {\n                firstTr = tr;\n                break;\n            }\n        }\n        if (firstTr) {\n            var colSizes = $(firstTr).children(\"th, td\").map(function(vis) {\n                return {\n                    idx: _fnVisibleToColumnIndex(settings, vis),\n                    width: $(this).outerWidth()\n                };\n            });\n            // Check against what the colgroup > col is set to and correct if needed\n            for(var i = 0; i < colSizes.length; i++){\n                var colEl = settings.aoColumns[colSizes[i].idx].colEl[0];\n                var colWidth = colEl.style.width.replace(\"px\", \"\");\n                if (colWidth !== colSizes[i].width) {\n                    colEl.style.width = colSizes[i].width + \"px\";\n                    if (scroll.sX) {\n                        colEl.style.minWidth = colSizes[i].width + \"px\";\n                    }\n                }\n            }\n        }\n    }\n    // 3. Copy the colgroup over to the header and footer\n    divHeaderTable.find(\"colgroup\").remove();\n    divHeaderTable.append(settings.colgroup.clone());\n    if (footer) {\n        divFooterTable.find(\"colgroup\").remove();\n        divFooterTable.append(settings.colgroup.clone());\n    }\n    // \"Hide\" the header and footer that we used for the sizing. We need to keep\n    // the content of the cell so that the width applied to the header and body\n    // both match, but we want to hide it completely.\n    $(\"th, td\", headerCopy).each(function() {\n        $(this.childNodes).wrapAll('<div class=\"dt-scroll-sizing\">');\n    });\n    if (footer) {\n        $(\"th, td\", footerCopy).each(function() {\n            $(this.childNodes).wrapAll('<div class=\"dt-scroll-sizing\">');\n        });\n    }\n    // 4. Clean up\n    // Figure out if there are scrollbar present - if so then we need a the header and footer to\n    // provide a bit more space to allow \"overflow\" scrolling (i.e. past the scrollbar)\n    var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css(\"overflow-y\") == \"scroll\";\n    var paddingSide = \"padding\" + (browser.bScrollbarLeft ? \"Left\" : \"Right\");\n    // Set the width's of the header and footer tables\n    var outerWidth = table.outerWidth();\n    divHeaderTable.css(\"width\", _fnStringToCss(outerWidth));\n    divHeaderInner.css(\"width\", _fnStringToCss(outerWidth)).css(paddingSide, isScrolling ? barWidth + \"px\" : \"0px\");\n    if (footer) {\n        divFooterTable.css(\"width\", _fnStringToCss(outerWidth));\n        divFooterInner.css(\"width\", _fnStringToCss(outerWidth)).css(paddingSide, isScrolling ? barWidth + \"px\" : \"0px\");\n    }\n    // Correct DOM ordering for colgroup - comes before the thead\n    table.children(\"colgroup\").prependTo(table);\n    // Adjust the position of the header in case we loose the y-scrollbar\n    divBody.trigger(\"scroll\");\n    // If sorting or filtering has occurred, jump the scrolling back to the top\n    // only if we aren't holding the position\n    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {\n        divBodyEl.scrollTop = 0;\n    }\n}\n/**\n * Calculate the width of columns for the table\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnCalculateColumnWidths(settings) {\n    // Not interested in doing column width calculation if auto-width is disabled\n    if (!settings.oFeatures.bAutoWidth) {\n        return;\n    }\n    var table = settings.nTable, columns = settings.aoColumns, scroll = settings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, visibleColumns = _fnGetColumns(settings, \"bVisible\"), tableWidthAttr = table.getAttribute(\"width\"), tableContainer = table.parentNode, i, column, columnIdx;\n    var styleWidth = table.style.width;\n    var containerWidth = _fnWrapperWidth(settings);\n    // Don't re-run for the same width as the last time\n    if (containerWidth === settings.containerWidth) {\n        return false;\n    }\n    settings.containerWidth = containerWidth;\n    // If there is no width applied as a CSS style or as an attribute, we assume that\n    // the width is intended to be 100%, which is usually is in CSS, but it is very\n    // difficult to correctly parse the rules to get the final result.\n    if (!styleWidth && !tableWidthAttr) {\n        table.style.width = \"100%\";\n        styleWidth = \"100%\";\n    }\n    if (styleWidth && styleWidth.indexOf(\"%\") !== -1) {\n        tableWidthAttr = styleWidth;\n    }\n    // Let plug-ins know that we are doing a recalc, in case they have changed any of the\n    // visible columns their own way (e.g. Responsive uses display:none).\n    _fnCallbackFire(settings, null, \"column-calc\", {\n        visible: visibleColumns\n    }, false);\n    // Construct a single row, worst case, table with the widest\n    // node in the data, assign any user defined widths, then insert it into\n    // the DOM and allow the browser to do all the hard work of calculating\n    // table widths\n    var tmpTable = $(table.cloneNode()).css(\"visibility\", \"hidden\").removeAttr(\"id\");\n    // Clean up the table body\n    tmpTable.append(\"<tbody>\");\n    var tr = $(\"<tr/>\").appendTo(tmpTable.find(\"tbody\"));\n    // Clone the table header and footer - we can't use the header / footer\n    // from the cloned table, since if scrolling is active, the table's\n    // real header and footer are contained in different table tags\n    tmpTable.append($(settings.nTHead).clone()).append($(settings.nTFoot).clone());\n    // Remove any assigned widths from the footer (from scrolling)\n    tmpTable.find(\"tfoot th, tfoot td\").css(\"width\", \"\");\n    // Apply custom sizing to the cloned header\n    tmpTable.find(\"thead th, thead td\").each(function() {\n        // Get the `width` from the header layout\n        var width = _fnColumnsSumWidth(settings, this, true, false);\n        if (width) {\n            this.style.width = width;\n            // For scrollX we need to force the column width otherwise the\n            // browser will collapse it. If this width is smaller than the\n            // width the column requires, then it will have no effect\n            if (scrollX) {\n                this.style.minWidth = width;\n                $(this).append($(\"<div/>\").css({\n                    width: width,\n                    margin: 0,\n                    padding: 0,\n                    border: 0,\n                    height: 1\n                }));\n            }\n        } else {\n            this.style.width = \"\";\n        }\n    });\n    // Find the widest piece of data for each column and put it into the table\n    for(i = 0; i < visibleColumns.length; i++){\n        columnIdx = visibleColumns[i];\n        column = columns[columnIdx];\n        var longest = _fnGetMaxLenString(settings, columnIdx);\n        var autoClass = _ext.type.className[column.sType];\n        var text = longest + column.sContentPadding;\n        var insert = longest.indexOf(\"<\") === -1 ? document.createTextNode(text) : text;\n        $(\"<td/>\").addClass(autoClass).addClass(column.sClass).append(insert).appendTo(tr);\n    }\n    // Tidy the temporary table - remove name attributes so there aren't\n    // duplicated in the dom (radio elements for example)\n    $(\"[name]\", tmpTable).removeAttr(\"name\");\n    // Table has been built, attach to the document so we can work with it.\n    // A holding element is used, positioned at the top of the container\n    // with minimal height, so it has no effect on if the container scrolls\n    // or not. Otherwise it might trigger scrolling when it actually isn't\n    // needed\n    var holder = $(\"<div/>\").css(scrollX || scrollY ? {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        height: 1,\n        right: 0,\n        overflow: \"hidden\"\n    } : {}).append(tmpTable).appendTo(tableContainer);\n    // When scrolling (X or Y) we want to set the width of the table as \n    // appropriate. However, when not scrolling leave the table width as it\n    // is. This results in slightly different, but I think correct behaviour\n    if (scrollX && scrollXInner) {\n        tmpTable.width(scrollXInner);\n    } else if (scrollX) {\n        tmpTable.css(\"width\", \"auto\");\n        tmpTable.removeAttr(\"width\");\n        // If there is no width attribute or style, then allow the table to\n        // collapse\n        if (tmpTable.outerWidth() < tableContainer.clientWidth && tableWidthAttr) {\n            tmpTable.outerWidth(tableContainer.clientWidth);\n        }\n    } else if (scrollY) {\n        tmpTable.outerWidth(tableContainer.clientWidth);\n    } else if (tableWidthAttr) {\n        tmpTable.outerWidth(tableWidthAttr);\n    }\n    // Get the width of each column in the constructed table\n    var total = 0;\n    var bodyCells = tmpTable.find(\"tbody tr\").eq(0).children();\n    for(i = 0; i < visibleColumns.length; i++){\n        // Use getBounding for sub-pixel accuracy, which we then want to round up!\n        var bounding = bodyCells[i].getBoundingClientRect().width;\n        // Total is tracked to remove any sub-pixel errors as the outerWidth\n        // of the table might not equal the total given here\n        total += bounding;\n        // Width for each column to use\n        columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding);\n    }\n    table.style.width = _fnStringToCss(total);\n    // Finished with the table - ditch it\n    holder.remove();\n    // If there is a width attr, we want to attach an event listener which\n    // allows the table sizing to automatically adjust when the window is\n    // resized. Use the width attr rather than CSS, since we can't know if the\n    // CSS is a relative value or absolute - DOM read is always px.\n    if (tableWidthAttr) {\n        table.style.width = _fnStringToCss(tableWidthAttr);\n    }\n    if ((tableWidthAttr || scrollX) && !settings._reszEvt) {\n        var resize = DataTable.util.throttle(function() {\n            var newWidth = _fnWrapperWidth(settings);\n            // Don't do it if destroying or the container width is 0\n            if (!settings.bDestroying && newWidth !== 0) {\n                _fnAdjustColumnSizing(settings);\n            }\n        });\n        // For browsers that support it (~2020 onwards for wide support) we can watch for the\n        // container changing width.\n        if (window.ResizeObserver) {\n            // This is a tricky beast - if the element is visible when `.observe()` is called,\n            // then the callback is immediately run. Which we don't want. If the element isn't\n            // visible, then it isn't run, but we want it to run when it is then made visible.\n            // This flag allows the above to be satisfied.\n            var first = $(settings.nTableWrapper).is(\":visible\");\n            // Use an empty div to attach the observer so it isn't impacted by height changes\n            var resizer = $(\"<div>\").css({\n                width: \"100%\",\n                height: 0\n            }).addClass(\"dt-autosize\").appendTo(settings.nTableWrapper);\n            settings.resizeObserver = new ResizeObserver(function(e) {\n                if (first) {\n                    first = false;\n                } else {\n                    resize();\n                }\n            });\n            settings.resizeObserver.observe(resizer[0]);\n        } else {\n            // For old browsers, the best we can do is listen for a window resize\n            $(window).on(\"resize.DT-\" + settings.sInstance, resize);\n        }\n        settings._reszEvt = true;\n    }\n}\n/**\n * Get the width of the DataTables wrapper element\n *\n * @param {*} settings DataTables settings object\n * @returns Width\n */ function _fnWrapperWidth(settings) {\n    return $(settings.nTableWrapper).is(\":visible\") ? $(settings.nTableWrapper).width() : 0;\n}\n/**\n * Get the maximum strlen for each data column\n *  @param {object} settings dataTables settings object\n *  @param {int} colIdx column of interest\n *  @returns {string} string of the max length\n *  @memberof DataTable#oApi\n */ function _fnGetMaxLenString(settings, colIdx) {\n    var column = settings.aoColumns[colIdx];\n    if (!column.maxLenString) {\n        var s, max = \"\", maxLen = -1;\n        for(var i = 0, ien = settings.aiDisplayMaster.length; i < ien; i++){\n            var rowIdx = settings.aiDisplayMaster[i];\n            var data = _fnGetRowDisplay(settings, rowIdx)[colIdx];\n            var cellString = data && typeof data === \"object\" && data.nodeType ? data.innerHTML : data + \"\";\n            // Remove id / name attributes from elements so they\n            // don't interfere with existing elements\n            cellString = cellString.replace(/id=\".*?\"/g, \"\").replace(/name=\".*?\"/g, \"\");\n            s = _stripHtml(cellString).replace(/&nbsp;/g, \" \");\n            if (s.length > maxLen) {\n                // We want the HTML in the string, but the length that\n                // is important is the stripped string\n                max = cellString;\n                maxLen = s.length;\n            }\n        }\n        column.maxLenString = max;\n    }\n    return column.maxLenString;\n}\n/**\n * Append a CSS unit (only if required) to a string\n *  @param {string} value to css-ify\n *  @returns {string} value with css unit\n *  @memberof DataTable#oApi\n */ function _fnStringToCss(s) {\n    if (s === null) {\n        return \"0px\";\n    }\n    if (typeof s == \"number\") {\n        return s < 0 ? \"0px\" : s + \"px\";\n    }\n    // Check it has a unit character already\n    return s.match(/\\d$/) ? s + \"px\" : s;\n}\n/**\n * Re-insert the `col` elements for current visibility\n *\n * @param {*} settings DT settings\n */ function _colGroup(settings) {\n    var cols = settings.aoColumns;\n    settings.colgroup.empty();\n    for(i = 0; i < cols.length; i++){\n        if (cols[i].bVisible) {\n            settings.colgroup.append(cols[i].colEl);\n        }\n    }\n}\nfunction _fnSortInit(settings) {\n    var target = settings.nTHead;\n    var headerRows = target.querySelectorAll(\"tr\");\n    var titleRow = settings.titleRow;\n    var notSelector = ':not([data-dt-order=\"disable\"]):not([data-dt-order=\"icon-only\"])';\n    // Legacy support for `orderCellsTop`\n    if (titleRow === true) {\n        target = headerRows[0];\n    } else if (titleRow === false) {\n        target = headerRows[headerRows.length - 1];\n    } else if (titleRow !== null) {\n        target = headerRows[titleRow];\n    }\n    // else - all rows\n    if (settings.orderHandler) {\n        _fnSortAttachListener(settings, target, target === settings.nTHead ? \"tr\" + notSelector + \" th\" + notSelector + \", tr\" + notSelector + \" td\" + notSelector : \"th\" + notSelector + \", td\" + notSelector);\n    }\n    // Need to resolve the user input array into our internal structure\n    var order = [];\n    _fnSortResolve(settings, order, settings.aaSorting);\n    settings.aaSorting = order;\n}\nfunction _fnSortAttachListener(settings, node, selector, column, callback) {\n    _fnBindAction(node, selector, function(e) {\n        var run = false;\n        var columns = column === undefined ? _fnColumnsFromHeader(e.target) : Array.isArray(column) ? column : [\n            column\n        ];\n        if (columns.length) {\n            for(var i = 0, ien = columns.length; i < ien; i++){\n                var ret = _fnSortAdd(settings, columns[i], i, e.shiftKey);\n                if (ret !== false) {\n                    run = true;\n                }\n                // If the first entry is no sort, then subsequent\n                // sort columns are ignored\n                if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === \"\") {\n                    break;\n                }\n            }\n            if (run) {\n                _fnProcessingRun(settings, true, function() {\n                    _fnSort(settings);\n                    _fnSortDisplay(settings, settings.aiDisplay);\n                    _fnReDraw(settings, false, false);\n                    if (callback) {\n                        callback();\n                    }\n                });\n            }\n        }\n    });\n}\n/**\n * Sort the display array to match the master's order\n * @param {*} settings\n */ function _fnSortDisplay(settings, display) {\n    if (display.length < 2) {\n        return;\n    }\n    var master = settings.aiDisplayMaster;\n    var masterMap = {};\n    var map = {};\n    var i;\n    // Rather than needing an `indexOf` on master array, we can create a map\n    for(i = 0; i < master.length; i++){\n        masterMap[master[i]] = i;\n    }\n    // And then cache what would be the indexOf fom the display\n    for(i = 0; i < display.length; i++){\n        map[display[i]] = masterMap[display[i]];\n    }\n    display.sort(function(a, b) {\n        // Short version of this function is simply `master.indexOf(a) - master.indexOf(b);`\n        return map[a] - map[b];\n    });\n}\nfunction _fnSortResolve(settings, nestedSort, sort) {\n    var push = function(a) {\n        if ($.isPlainObject(a)) {\n            if (a.idx !== undefined) {\n                // Index based ordering\n                nestedSort.push([\n                    a.idx,\n                    a.dir\n                ]);\n            } else if (a.name) {\n                // Name based ordering\n                var cols = _pluck(settings.aoColumns, \"sName\");\n                var idx = cols.indexOf(a.name);\n                if (idx !== -1) {\n                    nestedSort.push([\n                        idx,\n                        a.dir\n                    ]);\n                }\n            }\n        } else {\n            // Plain column index and direction pair\n            nestedSort.push(a);\n        }\n    };\n    if ($.isPlainObject(sort)) {\n        // Object\n        push(sort);\n    } else if (sort.length && typeof sort[0] === \"number\") {\n        // 1D array\n        push(sort);\n    } else if (sort.length) {\n        // 2D array\n        for(var z = 0; z < sort.length; z++){\n            push(sort[z]); // Object or array\n        }\n    }\n}\nfunction _fnSortFlatten(settings) {\n    var i, k, kLen, aSort = [], extSort = DataTable.ext.type.order, aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $.isPlainObject(fixed), nestedSort = [];\n    if (!settings.oFeatures.bSort) {\n        return aSort;\n    }\n    // Build the sort array, with pre-fix and post-fix options if they have been\n    // specified\n    if (Array.isArray(fixed)) {\n        _fnSortResolve(settings, nestedSort, fixed);\n    }\n    if (fixedObj && fixed.pre) {\n        _fnSortResolve(settings, nestedSort, fixed.pre);\n    }\n    _fnSortResolve(settings, nestedSort, settings.aaSorting);\n    if (fixedObj && fixed.post) {\n        _fnSortResolve(settings, nestedSort, fixed.post);\n    }\n    for(i = 0; i < nestedSort.length; i++){\n        srcCol = nestedSort[i][0];\n        if (aoColumns[srcCol]) {\n            aDataSort = aoColumns[srcCol].aDataSort;\n            for(k = 0, kLen = aDataSort.length; k < kLen; k++){\n                iCol = aDataSort[k];\n                sType = aoColumns[iCol].sType || \"string\";\n                if (nestedSort[i]._idx === undefined) {\n                    nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);\n                }\n                if (nestedSort[i][1]) {\n                    aSort.push({\n                        src: srcCol,\n                        col: iCol,\n                        dir: nestedSort[i][1],\n                        index: nestedSort[i]._idx,\n                        type: sType,\n                        formatter: extSort[sType + \"-pre\"],\n                        sorter: extSort[sType + \"-\" + nestedSort[i][1]]\n                    });\n                }\n            }\n        }\n    }\n    return aSort;\n}\n/**\n * Change the order of the table\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnSort(oSettings, col, dir) {\n    var i, ien, iLen, aiOrig = [], extSort = DataTable.ext.type.order, aoData = oSettings.aoData, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;\n    // Make sure the columns all have types defined\n    _fnColumnTypes(oSettings);\n    // Allow a specific column to be sorted, which will _not_ alter the display\n    // master\n    if (col !== undefined) {\n        var srcCol = oSettings.aoColumns[col];\n        aSort = [\n            {\n                src: col,\n                col: col,\n                dir: dir,\n                index: 0,\n                type: srcCol.sType,\n                formatter: extSort[srcCol.sType + \"-pre\"],\n                sorter: extSort[srcCol.sType + \"-\" + dir]\n            }\n        ];\n        displayMaster = displayMaster.slice();\n    } else {\n        aSort = _fnSortFlatten(oSettings);\n    }\n    for(i = 0, ien = aSort.length; i < ien; i++){\n        sortCol = aSort[i];\n        // Load the data needed for the sort, for each cell\n        _fnSortData(oSettings, sortCol.col);\n    }\n    /* No sorting required if server-side or no sorting array */ if (_fnDataSource(oSettings) != \"ssp\" && aSort.length !== 0) {\n        // Reset the initial positions on each pass so we get a stable sort\n        for(i = 0, iLen = displayMaster.length; i < iLen; i++){\n            aiOrig[i] = i;\n        }\n        // If the first sort is desc, then reverse the array to preserve original\n        // order, just in reverse\n        if (aSort.length && aSort[0].dir === \"desc\" && oSettings.orderDescReverse) {\n            aiOrig.reverse();\n        }\n        /* Do the sort - here we want multi-column sorting based on a given data source (column)\n\t\t * and sorting function (from oSort) in a certain direction. It's reasonably complex to\n\t\t * follow on it's own, but this is what we want (example two column sorting):\n\t\t *  fnLocalSorting = function(a,b){\n\t\t *    var test;\n\t\t *    test = oSort['string-asc']('data11', 'data12');\n\t\t *      if (test !== 0)\n\t\t *        return test;\n\t\t *    test = oSort['numeric-desc']('data21', 'data22');\n\t\t *    if (test !== 0)\n\t\t *      return test;\n\t\t *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );\n\t\t *  }\n\t\t * Basically we have a test for each sorting column, if the data in that column is equal,\n\t\t * test the next column. If all columns match, then we use a numeric sort on the row\n\t\t * positions in the original data array to provide a stable sort.\n\t\t */ displayMaster.sort(function(a, b) {\n            var x, y, k, test, sort, len = aSort.length, dataA = aoData[a]._aSortData, dataB = aoData[b]._aSortData;\n            for(k = 0; k < len; k++){\n                sort = aSort[k];\n                // Data, which may have already been through a `-pre` function\n                x = dataA[sort.col];\n                y = dataB[sort.col];\n                if (sort.sorter) {\n                    // If there is a custom sorter (`-asc` or `-desc`) for this\n                    // data type, use it\n                    test = sort.sorter(x, y);\n                    if (test !== 0) {\n                        return test;\n                    }\n                } else {\n                    // Otherwise, use generic sorting\n                    test = x < y ? -1 : x > y ? 1 : 0;\n                    if (test !== 0) {\n                        return sort.dir === \"asc\" ? test : -test;\n                    }\n                }\n            }\n            x = aiOrig[a];\n            y = aiOrig[b];\n            return x < y ? -1 : x > y ? 1 : 0;\n        });\n    } else if (aSort.length === 0) {\n        // Apply index order\n        displayMaster.sort(function(x, y) {\n            return x < y ? -1 : x > y ? 1 : 0;\n        });\n    }\n    if (col === undefined) {\n        // Tell the draw function that we have sorted the data\n        oSettings.bSorted = true;\n        oSettings.sortDetails = aSort;\n        _fnCallbackFire(oSettings, null, \"order\", [\n            oSettings,\n            aSort\n        ]);\n    }\n    return displayMaster;\n}\n/**\n * Function to run on user sort request\n *  @param {object} settings dataTables settings object\n *  @param {node} attachTo node to attach the handler to\n *  @param {int} colIdx column sorting index\n *  @param {int} addIndex Counter\n *  @param {boolean} [shift=false] Shift click add\n *  @param {function} [callback] callback function\n *  @memberof DataTable#oApi\n */ function _fnSortAdd(settings, colIdx, addIndex, shift) {\n    var col = settings.aoColumns[colIdx];\n    var sorting = settings.aaSorting;\n    var asSorting = col.asSorting;\n    var nextSortIdx;\n    var next = function(a, overflow) {\n        var idx = a._idx;\n        if (idx === undefined) {\n            idx = asSorting.indexOf(a[1]);\n        }\n        return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;\n    };\n    if (!col.bSortable) {\n        return false;\n    }\n    // Convert to 2D array if needed\n    if (typeof sorting[0] === \"number\") {\n        sorting = settings.aaSorting = [\n            sorting\n        ];\n    }\n    // If appending the sort then we are multi-column sorting\n    if ((shift || addIndex) && settings.oFeatures.bSortMulti) {\n        // Are we already doing some kind of sort on this column?\n        var sortIdx = _pluck(sorting, \"0\").indexOf(colIdx);\n        if (sortIdx !== -1) {\n            // Yes, modify the sort\n            nextSortIdx = next(sorting[sortIdx], true);\n            if (nextSortIdx === null && sorting.length === 1) {\n                nextSortIdx = 0; // can't remove sorting completely\n            }\n            if (nextSortIdx === null) {\n                sorting.splice(sortIdx, 1);\n            } else {\n                sorting[sortIdx][1] = asSorting[nextSortIdx];\n                sorting[sortIdx]._idx = nextSortIdx;\n            }\n        } else if (shift) {\n            // No sort on this column yet, being added by shift click\n            // add it as itself\n            sorting.push([\n                colIdx,\n                asSorting[0],\n                0\n            ]);\n            sorting[sorting.length - 1]._idx = 0;\n        } else {\n            // No sort on this column yet, being added from a colspan\n            // so add with same direction as first column\n            sorting.push([\n                colIdx,\n                sorting[0][1],\n                0\n            ]);\n            sorting[sorting.length - 1]._idx = 0;\n        }\n    } else if (sorting.length && sorting[0][0] == colIdx) {\n        // Single column - already sorting on this column, modify the sort\n        nextSortIdx = next(sorting[0]);\n        sorting.length = 1;\n        sorting[0][1] = asSorting[nextSortIdx];\n        sorting[0]._idx = nextSortIdx;\n    } else {\n        // Single column - sort only on this column\n        sorting.length = 0;\n        sorting.push([\n            colIdx,\n            asSorting[0]\n        ]);\n        sorting[0]._idx = 0;\n    }\n}\n/**\n * Set the sorting classes on table's body, Note: it is safe to call this function\n * when bSort and bSortClasses are false\n *  @param {object} oSettings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnSortingClasses(settings) {\n    var oldSort = settings.aLastSort;\n    var sortClass = settings.oClasses.order.position;\n    var sort = _fnSortFlatten(settings);\n    var features = settings.oFeatures;\n    var i, ien, colIdx;\n    if (features.bSort && features.bSortClasses) {\n        // Remove old sorting classes\n        for(i = 0, ien = oldSort.length; i < ien; i++){\n            colIdx = oldSort[i].src;\n            // Remove column sorting\n            $(_pluck(settings.aoData, \"anCells\", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));\n        }\n        // Add new column sorting\n        for(i = 0, ien = sort.length; i < ien; i++){\n            colIdx = sort[i].src;\n            $(_pluck(settings.aoData, \"anCells\", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));\n        }\n    }\n    settings.aLastSort = sort;\n}\n// Get the data to sort a column, be it from cache, fresh (populating the\n// cache), or from a sort formatter\nfunction _fnSortData(settings, colIdx) {\n    // Custom sorting function - provided by the sort data type\n    var column = settings.aoColumns[colIdx];\n    var customSort = DataTable.ext.order[column.sSortDataType];\n    var customData;\n    if (customSort) {\n        customData = customSort.call(settings.oInstance, settings, colIdx, _fnColumnIndexToVisible(settings, colIdx));\n    }\n    // Use / populate cache\n    var row, cellData;\n    var formatter = DataTable.ext.type.order[column.sType + \"-pre\"];\n    var data = settings.aoData;\n    for(var rowIdx = 0; rowIdx < data.length; rowIdx++){\n        // Sparse array\n        if (!data[rowIdx]) {\n            continue;\n        }\n        row = data[rowIdx];\n        if (!row._aSortData) {\n            row._aSortData = [];\n        }\n        if (!row._aSortData[colIdx] || customSort) {\n            cellData = customSort ? customData[rowIdx] : _fnGetCellData(settings, rowIdx, colIdx, \"sort\");\n            row._aSortData[colIdx] = formatter ? formatter(cellData, settings) : cellData;\n        }\n    }\n}\n/**\n * State information for a table\n *\n * @param {*} settings\n * @returns State object\n */ function _fnSaveState(settings) {\n    if (settings._bLoadingState) {\n        return;\n    }\n    // Sort state saving uses [[idx, order]] structure.\n    var sorting = [];\n    _fnSortResolve(settings, sorting, settings.aaSorting);\n    /* Store the interesting variables */ var columns = settings.aoColumns;\n    var state = {\n        time: +new Date(),\n        start: settings._iDisplayStart,\n        length: settings._iDisplayLength,\n        order: sorting.map(function(sort) {\n            // If a column name is available, use it\n            return columns[sort[0]] && columns[sort[0]].sName ? [\n                columns[sort[0]].sName,\n                sort[1]\n            ] : sort.slice();\n        }),\n        search: $.extend({}, settings.oPreviousSearch),\n        columns: settings.aoColumns.map(function(col, i) {\n            return {\n                name: col.sName,\n                visible: col.bVisible,\n                search: $.extend({}, settings.aoPreSearchCols[i])\n            };\n        })\n    };\n    settings.oSavedState = state;\n    _fnCallbackFire(settings, \"aoStateSaveParams\", \"stateSaveParams\", [\n        settings,\n        state\n    ]);\n    if (settings.oFeatures.bStateSave && !settings.bDestroying) {\n        settings.fnStateSaveCallback.call(settings.oInstance, settings, state);\n    }\n}\n/**\n * Attempt to load a saved table state\n *  @param {object} oSettings dataTables settings object\n *  @param {object} oInit DataTables init object so we can override settings\n *  @param {function} callback Callback to execute when the state has been loaded\n *  @memberof DataTable#oApi\n */ function _fnLoadState(settings, init, callback) {\n    if (!settings.oFeatures.bStateSave) {\n        callback();\n        return;\n    }\n    var loaded = function(state) {\n        _fnImplementState(settings, state, callback);\n    };\n    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);\n    if (state !== undefined) {\n        _fnImplementState(settings, state, callback);\n    }\n    // otherwise, wait for the loaded callback to be executed\n    return true;\n}\nfunction _fnImplementState(settings, s, callback) {\n    var i, ien;\n    var columns = settings.aoColumns;\n    var currentNames = _pluck(settings.aoColumns, \"sName\");\n    settings._bLoadingState = true;\n    // When StateRestore was introduced the state could now be implemented at any time\n    // Not just initialisation. To do this an api instance is required in some places\n    var api = settings._bInitComplete ? new DataTable.Api(settings) : null;\n    if (!s || !s.time) {\n        settings._bLoadingState = false;\n        callback();\n        return;\n    }\n    // Reject old data\n    var duration = settings.iStateDuration;\n    if (duration > 0 && s.time < +new Date() - duration * 1000) {\n        settings._bLoadingState = false;\n        callback();\n        return;\n    }\n    // Allow custom and plug-in manipulation functions to alter the saved data set and\n    // cancelling of loading by returning false\n    var abStateLoad = _fnCallbackFire(settings, \"aoStateLoadParams\", \"stateLoadParams\", [\n        settings,\n        s\n    ]);\n    if (abStateLoad.indexOf(false) !== -1) {\n        settings._bLoadingState = false;\n        callback();\n        return;\n    }\n    // Store the saved state so it might be accessed at any time\n    settings.oLoadedState = $.extend(true, {}, s);\n    // This is needed for ColReorder, which has to happen first to allow all\n    // the stored indexes to be usable. It is not publicly documented.\n    _fnCallbackFire(settings, null, \"stateLoadInit\", [\n        settings,\n        s\n    ], true);\n    // Page Length\n    if (s.length !== undefined) {\n        // If already initialised just set the value directly so that the select element is also updated\n        if (api) {\n            api.page.len(s.length);\n        } else {\n            settings._iDisplayLength = s.length;\n        }\n    }\n    // Restore key features\n    if (s.start !== undefined) {\n        if (api === null) {\n            settings._iDisplayStart = s.start;\n            settings.iInitDisplayStart = s.start;\n        } else {\n            _fnPageChange(settings, s.start / settings._iDisplayLength);\n        }\n    }\n    // Order\n    if (s.order !== undefined) {\n        settings.aaSorting = [];\n        $.each(s.order, function(i, col) {\n            var set = [\n                col[0],\n                col[1]\n            ];\n            // A column name was stored and should be used for restore\n            if (typeof col[0] === \"string\") {\n                // Find the name from the current list of column names\n                var idx = currentNames.indexOf(col[0]);\n                if (idx < 0) {\n                    // If the column was not found ignore it and continue\n                    return;\n                }\n                set[0] = idx;\n            } else if (set[0] >= columns.length) {\n                // If the column index is out of bounds ignore it and continue\n                return;\n            }\n            settings.aaSorting.push(set);\n        });\n    }\n    // Search\n    if (s.search !== undefined) {\n        $.extend(settings.oPreviousSearch, s.search);\n    }\n    // Columns\n    if (s.columns) {\n        var set = s.columns;\n        var incoming = _pluck(s.columns, \"name\");\n        // Check if it is a 2.2 style state object with a `name` property for the columns, and if\n        // the name was defined. If so, then create a new array that will map the state object\n        // given, to the current columns (don't bother if they are already matching tho).\n        if (incoming.join(\"\").length && incoming.join(\"\") !== currentNames.join(\"\")) {\n            set = [];\n            // For each column, try to find the name in the incoming array\n            for(i = 0; i < currentNames.length; i++){\n                if (currentNames[i] != \"\") {\n                    var idx = incoming.indexOf(currentNames[i]);\n                    if (idx >= 0) {\n                        set.push(s.columns[idx]);\n                    } else {\n                        // No matching column name in the state's columns, so this might be a new\n                        // column and thus can't have a state already.\n                        set.push({});\n                    }\n                } else {\n                    // If no name, but other columns did have a name, then there is no knowing\n                    // where this one came from originally so it can't be restored.\n                    set.push({});\n                }\n            }\n        }\n        // If the number of columns to restore is different from current, then all bets are off.\n        if (set.length === columns.length) {\n            for(i = 0, ien = set.length; i < ien; i++){\n                var col = set[i];\n                // Visibility\n                if (col.visible !== undefined) {\n                    // If the api is defined, the table has been initialised so we need to use it rather than internal settings\n                    if (api) {\n                        // Don't redraw the columns on every iteration of this loop, we will do this at the end instead\n                        api.column(i).visible(col.visible, false);\n                    } else {\n                        columns[i].bVisible = col.visible;\n                    }\n                }\n                // Search\n                if (col.search !== undefined) {\n                    $.extend(settings.aoPreSearchCols[i], col.search);\n                }\n            }\n            // If the api is defined then we need to adjust the columns once the visibility has been changed\n            if (api) {\n                api.columns.adjust();\n            }\n        }\n    }\n    settings._bLoadingState = false;\n    _fnCallbackFire(settings, \"aoStateLoaded\", \"stateLoaded\", [\n        settings,\n        s\n    ]);\n    callback();\n}\n/**\n * Log an error message\n *  @param {object} settings dataTables settings object\n *  @param {int} level log error messages, or display them to the user\n *  @param {string} msg error message\n *  @param {int} tn Technical note id to get more information about the error.\n *  @memberof DataTable#oApi\n */ function _fnLog(settings, level, msg, tn) {\n    msg = \"DataTables warning: \" + (settings ? \"table id=\" + settings.sTableId + \" - \" : \"\") + msg;\n    if (tn) {\n        msg += \". For more information about this error, please see \" + \"https://datatables.net/tn/\" + tn;\n    }\n    if (!level) {\n        // Backwards compatibility pre 1.10\n        var ext = DataTable.ext;\n        var type = ext.sErrMode || ext.errMode;\n        if (settings) {\n            _fnCallbackFire(settings, null, \"dt-error\", [\n                settings,\n                tn,\n                msg\n            ], true);\n        }\n        if (type == \"alert\") {\n            alert(msg);\n        } else if (type == \"throw\") {\n            throw new Error(msg);\n        } else if (typeof type == \"function\") {\n            type(settings, tn, msg);\n        }\n    } else if (window.console && console.log) {\n        console.log(msg);\n    }\n}\n/**\n * See if a property is defined on one object, if so assign it to the other object\n *  @param {object} ret target object\n *  @param {object} src source object\n *  @param {string} name property\n *  @param {string} [mappedName] name to map too - optional, name used if not given\n *  @memberof DataTable#oApi\n */ function _fnMap(ret, src, name, mappedName) {\n    if (Array.isArray(name)) {\n        $.each(name, function(i, val) {\n            if (Array.isArray(val)) {\n                _fnMap(ret, src, val[0], val[1]);\n            } else {\n                _fnMap(ret, src, val);\n            }\n        });\n        return;\n    }\n    if (mappedName === undefined) {\n        mappedName = name;\n    }\n    if (src[name] !== undefined) {\n        ret[mappedName] = src[name];\n    }\n}\n/**\n * Extend objects - very similar to jQuery.extend, but deep copy objects, and\n * shallow copy arrays. The reason we need to do this, is that we don't want to\n * deep copy array init values (such as aaSorting) since the dev wouldn't be\n * able to override them, but we do want to deep copy arrays.\n *  @param {object} out Object to extend\n *  @param {object} extender Object from which the properties will be applied to\n *      out\n *  @param {boolean} breakRefs If true, then arrays will be sliced to take an\n *      independent copy with the exception of the `data` or `aaData` parameters\n *      if they are present. This is so you can pass in a collection to\n *      DataTables and have that used as your data source without breaking the\n *      references\n *  @returns {object} out Reference, just for convenience - out === the return.\n *  @memberof DataTable#oApi\n *  @todo This doesn't take account of arrays inside the deep copied objects.\n */ function _fnExtend(out, extender, breakRefs) {\n    var val;\n    for(var prop in extender){\n        if (Object.prototype.hasOwnProperty.call(extender, prop)) {\n            val = extender[prop];\n            if ($.isPlainObject(val)) {\n                if (!$.isPlainObject(out[prop])) {\n                    out[prop] = {};\n                }\n                $.extend(true, out[prop], val);\n            } else if (breakRefs && prop !== \"data\" && prop !== \"aaData\" && Array.isArray(val)) {\n                out[prop] = val.slice();\n            } else {\n                out[prop] = val;\n            }\n        }\n    }\n    return out;\n}\n/**\n * Bind an event handers to allow a click or return key to activate the callback.\n * This is good for accessibility since a return on the keyboard will have the\n * same effect as a click, if the element has focus.\n *  @param {element} n Element to bind the action to\n *  @param {object|string} selector Selector (for delegated events) or data object\n *   to pass to the triggered function\n *  @param {function} fn Callback function for when the event is triggered\n *  @memberof DataTable#oApi\n */ function _fnBindAction(n, selector, fn) {\n    $(n).on(\"click.DT\", selector, function(e) {\n        fn(e);\n    }).on(\"keypress.DT\", selector, function(e) {\n        if (e.which === 13) {\n            e.preventDefault();\n            fn(e);\n        }\n    }).on(\"selectstart.DT\", selector, function() {\n        // Don't want a double click resulting in text selection\n        return false;\n    });\n}\n/**\n * Register a callback function. Easily allows a callback function to be added to\n * an array store of callback functions that can then all be called together.\n *  @param {object} settings dataTables settings object\n *  @param {string} store Name of the array storage for the callbacks in oSettings\n *  @param {function} fn Function to be called back\n *  @memberof DataTable#oApi\n */ function _fnCallbackReg(settings, store, fn) {\n    if (fn) {\n        settings[store].push(fn);\n    }\n}\n/**\n * Fire callback functions and trigger events. Note that the loop over the\n * callback array store is done backwards! Further note that you do not want to\n * fire off triggers in time sensitive applications (for example cell creation)\n * as its slow.\n *  @param {object} settings dataTables settings object\n *  @param {string} callbackArr Name of the array storage for the callbacks in\n *      oSettings\n *  @param {string} eventName Name of the jQuery custom event to trigger. If\n *      null no trigger is fired\n *  @param {array} args Array of arguments to pass to the callback function /\n *      trigger\n *  @param {boolean} [bubbles] True if the event should bubble\n *  @memberof DataTable#oApi\n */ function _fnCallbackFire(settings, callbackArr, eventName, args, bubbles) {\n    var ret = [];\n    if (callbackArr) {\n        ret = settings[callbackArr].slice().reverse().map(function(val) {\n            return val.apply(settings.oInstance, args);\n        });\n    }\n    if (eventName !== null) {\n        var e = $.Event(eventName + \".dt\");\n        var table = $(settings.nTable);\n        // Expose the DataTables API on the event object for easy access\n        e.dt = settings.api;\n        table[bubbles ? \"trigger\" : \"triggerHandler\"](e, args);\n        // If not yet attached to the document, trigger the event\n        // on the body directly to sort of simulate the bubble\n        if (bubbles && table.parents(\"body\").length === 0) {\n            $(\"body\").trigger(e, args);\n        }\n        ret.push(e.result);\n    }\n    return ret;\n}\nfunction _fnLengthOverflow(settings) {\n    var start = settings._iDisplayStart, end = settings.fnDisplayEnd(), len = settings._iDisplayLength;\n    /* If we have space to show extra rows (backing up from the end point - then do so */ if (start >= end) {\n        start = end - len;\n    }\n    // Keep the start record on the current page\n    start -= start % len;\n    if (len === -1 || start < 0) {\n        start = 0;\n    }\n    settings._iDisplayStart = start;\n}\nfunction _fnRenderer(settings, type) {\n    var renderer = settings.renderer;\n    var host = DataTable.ext.renderer[type];\n    if ($.isPlainObject(renderer) && renderer[type]) {\n        // Specific renderer for this type. If available use it, otherwise use\n        // the default.\n        return host[renderer[type]] || host._;\n    } else if (typeof renderer === \"string\") {\n        // Common renderer - if there is one available for this type use it,\n        // otherwise use the default\n        return host[renderer] || host._;\n    }\n    // Use the default\n    return host._;\n}\n/**\n * Detect the data source being used for the table. Used to simplify the code\n * a little (ajax) and to make it compress a little smaller.\n *\n *  @param {object} settings dataTables settings object\n *  @returns {string} Data source\n *  @memberof DataTable#oApi\n */ function _fnDataSource(settings) {\n    if (settings.oFeatures.bServerSide) {\n        return \"ssp\";\n    } else if (settings.ajax) {\n        return \"ajax\";\n    }\n    return \"dom\";\n}\n/**\n * Common replacement for language strings\n *\n * @param {*} settings DT settings object\n * @param {*} str String with values to replace\n * @param {*} entries Plural number for _ENTRIES_ - can be undefined\n * @returns String\n */ function _fnMacros(settings, str, entries) {\n    // When infinite scrolling, we are always starting at 1. _iDisplayStart is\n    // used only internally\n    var formatter = settings.fnFormatNumber, start = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), max = settings.fnRecordsTotal(), all = len === -1;\n    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, max)).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len))).replace(/_ENTRIES_/g, settings.api.i18n(\"entries\", \"\", entries)).replace(/_ENTRIES-MAX_/g, settings.api.i18n(\"entries\", \"\", max)).replace(/_ENTRIES-TOTAL_/g, settings.api.i18n(\"entries\", \"\", vis));\n}\n/**\n * Add elements to an array as quickly as possible, but stack stafe.\n *\n * @param {*} arr Array to add the data to\n * @param {*} data Data array that is to be added\n * @returns \n */ function _fnArrayApply(arr, data) {\n    if (!data) {\n        return;\n    }\n    // Chrome can throw a max stack error if apply is called with\n    // too large an array, but apply is faster.\n    if (data.length < 10000) {\n        arr.push.apply(arr, data);\n    } else {\n        for(i = 0; i < data.length; i++){\n            arr.push(data[i]);\n        }\n    }\n}\n/**\n * Add one or more listeners to the table\n *\n * @param {*} that JQ for the table\n * @param {*} name Event name\n * @param {*} src Listener(s)\n */ function _fnListener(that, name, src) {\n    if (!Array.isArray(src)) {\n        src = [\n            src\n        ];\n    }\n    for(i = 0; i < src.length; i++){\n        that.on(name + \".dt\", src[i]);\n    }\n}\n/**\n * Computed structure of the DataTables API, defined by the options passed to\n * `DataTable.Api.register()` when building the API.\n *\n * The structure is built in order to speed creation and extension of the Api\n * objects since the extensions are effectively pre-parsed.\n *\n * The array is an array of objects with the following structure, where this\n * base array represents the Api prototype base:\n *\n *     [\n *       {\n *         name:      'data'                -- string   - Property name\n *         val:       function () {},       -- function - Api method (or undefined if just an object\n *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n *       },\n *       {\n *         name:     'row'\n *         val:       {},\n *         methodExt: [ ... ],\n *         propExt:   [\n *           {\n *             name:      'data'\n *             val:       function () {},\n *             methodExt: [ ... ],\n *             propExt:   [ ... ]\n *           },\n *           ...\n *         ]\n *       }\n *     ]\n *\n * @type {Array}\n * @ignore\n */ var __apiStruct = [];\n/**\n * `Array.prototype` reference.\n *\n * @type object\n * @ignore\n */ var __arrayProto = Array.prototype;\n/**\n * Abstraction for `context` parameter of the `Api` constructor to allow it to\n * take several different forms for ease of use.\n *\n * Each of the input parameter types will be converted to a DataTables settings\n * object where possible.\n *\n * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one\n *   of:\n *\n *   * `string` - jQuery selector. Any DataTables' matching the given selector\n *     with be found and used.\n *   * `node` - `TABLE` node which has already been formed into a DataTable.\n *   * `jQuery` - A jQuery object of `TABLE` nodes.\n *   * `object` - DataTables settings object\n *   * `DataTables.Api` - API instance\n * @return {array|null} Matching DataTables settings objects. `null` or\n *   `undefined` is returned if no matching DataTable is found.\n * @ignore\n */ var _toSettings = function(mixed) {\n    var idx, jq;\n    var settings = DataTable.settings;\n    var tables = _pluck(settings, \"nTable\");\n    if (!mixed) {\n        return [];\n    } else if (mixed.nTable && mixed.oFeatures) {\n        // DataTables settings object\n        return [\n            mixed\n        ];\n    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === \"table\") {\n        // Table node\n        idx = tables.indexOf(mixed);\n        return idx !== -1 ? [\n            settings[idx]\n        ] : null;\n    } else if (mixed && typeof mixed.settings === \"function\") {\n        return mixed.settings().toArray();\n    } else if (typeof mixed === \"string\") {\n        // jQuery selector\n        jq = $(mixed).get();\n    } else if (mixed instanceof $) {\n        // jQuery object (also DataTables instance)\n        jq = mixed.get();\n    }\n    if (jq) {\n        return settings.filter(function(v, idx) {\n            return jq.includes(tables[idx]);\n        });\n    }\n};\n/**\n * DataTables API class - used to control and interface with  one or more\n * DataTables enhanced tables.\n *\n * The API class is heavily based on jQuery, presenting a chainable interface\n * that you can use to interact with tables. Each instance of the API class has\n * a \"context\" - i.e. the tables that it will operate on. This could be a single\n * table, all tables on a page or a sub-set thereof.\n *\n * Additionally the API is designed to allow you to easily work with the data in\n * the tables, retrieving and manipulating it as required. This is done by\n * presenting the API class as an array like interface. The contents of the\n * array depend upon the actions requested by each method (for example\n * `rows().nodes()` will return an array of nodes, while `rows().data()` will\n * return an array of objects or arrays depending upon your table's\n * configuration). The API object has a number of array like methods (`push`,\n * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,\n * `unique` etc) to assist your working with the data held in a table.\n *\n * Most methods (those which return an Api instance) are chainable, which means\n * the return from a method call also has all of the methods available that the\n * top level object had. For example, these two calls are equivalent:\n *\n *     // Not chained\n *     api.row.add( {...} );\n *     api.draw();\n *\n *     // Chained\n *     api.row.add( {...} ).draw();\n *\n * @class DataTable.Api\n * @param {array|object|string|jQuery} context DataTable identifier. This is\n *   used to define which DataTables enhanced tables this API will operate on.\n *   Can be one of:\n *\n *   * `string` - jQuery selector. Any DataTables' matching the given selector\n *     with be found and used.\n *   * `node` - `TABLE` node which has already been formed into a DataTable.\n *   * `jQuery` - A jQuery object of `TABLE` nodes.\n *   * `object` - DataTables settings object\n * @param {array} [data] Data to initialise the Api instance with.\n *\n * @example\n *   // Direct initialisation during DataTables construction\n *   var api = $('#example').DataTable();\n *\n * @example\n *   // Initialisation using a DataTables jQuery object\n *   var api = $('#example').dataTable().api();\n *\n * @example\n *   // Initialisation as a constructor\n *   var api = new DataTable.Api( 'table.dataTable' );\n */ _Api = function(context, data) {\n    if (!(this instanceof _Api)) {\n        return new _Api(context, data);\n    }\n    var i;\n    var settings = [];\n    var ctxSettings = function(o) {\n        var a = _toSettings(o);\n        if (a) {\n            settings.push.apply(settings, a);\n        }\n    };\n    if (Array.isArray(context)) {\n        for(i = 0; i < context.length; i++){\n            ctxSettings(context[i]);\n        }\n    } else {\n        ctxSettings(context);\n    }\n    // Remove duplicates\n    this.context = settings.length > 1 ? _unique(settings) : settings;\n    // Initial data\n    _fnArrayApply(this, data);\n    // selector\n    this.selector = {\n        rows: null,\n        cols: null,\n        opts: null\n    };\n    _Api.extend(this, this, __apiStruct);\n};\nDataTable.Api = _Api;\n// Don't destroy the existing prototype, just extend it. Required for jQuery 2's\n// isPlainObject.\n$.extend(_Api.prototype, {\n    any: function() {\n        return this.count() !== 0;\n    },\n    context: [],\n    count: function() {\n        return this.flatten().length;\n    },\n    each: function(fn) {\n        for(var i = 0, ien = this.length; i < ien; i++){\n            fn.call(this, this[i], i, this);\n        }\n        return this;\n    },\n    eq: function(idx) {\n        var ctx = this.context;\n        return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null;\n    },\n    filter: function(fn) {\n        var a = __arrayProto.filter.call(this, fn, this);\n        return new _Api(this.context, a);\n    },\n    flatten: function() {\n        var a = [];\n        return new _Api(this.context, a.concat.apply(a, this.toArray()));\n    },\n    get: function(idx) {\n        return this[idx];\n    },\n    join: __arrayProto.join,\n    includes: function(find) {\n        return this.indexOf(find) === -1 ? false : true;\n    },\n    indexOf: __arrayProto.indexOf,\n    iterator: function(flatten, type, fn, alwaysNew) {\n        var a = [], ret, i, ien, j, jen, context = this.context, rows, items, item, selector = this.selector;\n        // Argument shifting\n        if (typeof flatten === \"string\") {\n            alwaysNew = fn;\n            fn = type;\n            type = flatten;\n            flatten = false;\n        }\n        for(i = 0, ien = context.length; i < ien; i++){\n            var apiInst = new _Api(context[i]);\n            if (type === \"table\") {\n                ret = fn.call(apiInst, context[i], i);\n                if (ret !== undefined) {\n                    a.push(ret);\n                }\n            } else if (type === \"columns\" || type === \"rows\") {\n                // this has same length as context - one entry for each table\n                ret = fn.call(apiInst, context[i], this[i], i);\n                if (ret !== undefined) {\n                    a.push(ret);\n                }\n            } else if (type === \"every\" || type === \"column\" || type === \"column-rows\" || type === \"row\" || type === \"cell\") {\n                // columns and rows share the same structure.\n                // 'this' is an array of column indexes for each context\n                items = this[i];\n                if (type === \"column-rows\") {\n                    rows = _selector_row_indexes(context[i], selector.opts);\n                }\n                for(j = 0, jen = items.length; j < jen; j++){\n                    item = items[j];\n                    if (type === \"cell\") {\n                        ret = fn.call(apiInst, context[i], item.row, item.column, i, j);\n                    } else {\n                        ret = fn.call(apiInst, context[i], item, i, j, rows);\n                    }\n                    if (ret !== undefined) {\n                        a.push(ret);\n                    }\n                }\n            }\n        }\n        if (a.length || alwaysNew) {\n            var api = new _Api(context, flatten ? a.concat.apply([], a) : a);\n            var apiSelector = api.selector;\n            apiSelector.rows = selector.rows;\n            apiSelector.cols = selector.cols;\n            apiSelector.opts = selector.opts;\n            return api;\n        }\n        return this;\n    },\n    lastIndexOf: __arrayProto.lastIndexOf,\n    length: 0,\n    map: function(fn) {\n        var a = __arrayProto.map.call(this, fn, this);\n        return new _Api(this.context, a);\n    },\n    pluck: function(prop) {\n        var fn = DataTable.util.get(prop);\n        return this.map(function(el) {\n            return fn(el);\n        });\n    },\n    pop: __arrayProto.pop,\n    push: __arrayProto.push,\n    reduce: __arrayProto.reduce,\n    reduceRight: __arrayProto.reduceRight,\n    reverse: __arrayProto.reverse,\n    // Object with rows, columns and opts\n    selector: null,\n    shift: __arrayProto.shift,\n    slice: function() {\n        return new _Api(this.context, this);\n    },\n    sort: __arrayProto.sort,\n    splice: __arrayProto.splice,\n    toArray: function() {\n        return __arrayProto.slice.call(this);\n    },\n    to$: function() {\n        return $(this);\n    },\n    toJQuery: function() {\n        return $(this);\n    },\n    unique: function() {\n        return new _Api(this.context, _unique(this.toArray()));\n    },\n    unshift: __arrayProto.unshift\n});\nfunction _api_scope(scope, fn, struc) {\n    return function() {\n        var ret = fn.apply(scope || this, arguments);\n        // Method extension\n        _Api.extend(ret, ret, struc.methodExt);\n        return ret;\n    };\n}\nfunction _api_find(src, name) {\n    for(var i = 0, ien = src.length; i < ien; i++){\n        if (src[i].name === name) {\n            return src[i];\n        }\n    }\n    return null;\n}\nwindow.__apiStruct = __apiStruct;\n_Api.extend = function(scope, obj, ext) {\n    // Only extend API instances and static properties of the API\n    if (!ext.length || !obj || !(obj instanceof _Api) && !obj.__dt_wrapper) {\n        return;\n    }\n    var i, ien, struct;\n    for(i = 0, ien = ext.length; i < ien; i++){\n        struct = ext[i];\n        if (struct.name === \"__proto__\") {\n            continue;\n        }\n        // Value\n        obj[struct.name] = struct.type === \"function\" ? _api_scope(scope, struct.val, struct) : struct.type === \"object\" ? {} : struct.val;\n        obj[struct.name].__dt_wrapper = true;\n        // Property extension\n        _Api.extend(scope, obj[struct.name], struct.propExt);\n    }\n};\n//     [\n//       {\n//         name:      'data'                -- string   - Property name\n//         val:       function () {},       -- function - Api method (or undefined if just an object\n//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n//       },\n//       {\n//         name:     'row'\n//         val:       {},\n//         methodExt: [ ... ],\n//         propExt:   [\n//           {\n//             name:      'data'\n//             val:       function () {},\n//             methodExt: [ ... ],\n//             propExt:   [ ... ]\n//           },\n//           ...\n//         ]\n//       }\n//     ]\n_Api.register = _api_register = function(name, val) {\n    if (Array.isArray(name)) {\n        for(var j = 0, jen = name.length; j < jen; j++){\n            _Api.register(name[j], val);\n        }\n        return;\n    }\n    var i, ien, heir = name.split(\".\"), struct = __apiStruct, key, method;\n    for(i = 0, ien = heir.length; i < ien; i++){\n        method = heir[i].indexOf(\"()\") !== -1;\n        key = method ? heir[i].replace(\"()\", \"\") : heir[i];\n        var src = _api_find(struct, key);\n        if (!src) {\n            src = {\n                name: key,\n                val: {},\n                methodExt: [],\n                propExt: [],\n                type: \"object\"\n            };\n            struct.push(src);\n        }\n        if (i === ien - 1) {\n            src.val = val;\n            src.type = typeof val === \"function\" ? \"function\" : $.isPlainObject(val) ? \"object\" : \"other\";\n        } else {\n            struct = method ? src.methodExt : src.propExt;\n        }\n    }\n};\n_Api.registerPlural = _api_registerPlural = function(pluralName, singularName, val) {\n    _Api.register(pluralName, val);\n    _Api.register(singularName, function() {\n        var ret = val.apply(this, arguments);\n        if (ret === this) {\n            // Returned item is the API instance that was passed in, return it\n            return this;\n        } else if (ret instanceof _Api) {\n            // New API instance returned, want the value from the first item\n            // in the returned array for the singular result.\n            return ret.length ? Array.isArray(ret[0]) ? new _Api(ret.context, ret[0]) : ret[0] : undefined;\n        }\n        // Non-API return - just fire it back\n        return ret;\n    });\n};\n/**\n * Selector for HTML tables. Apply the given selector to the give array of\n * DataTables settings objects.\n *\n * @param {string|integer} [selector] jQuery selector string or integer\n * @param  {array} Array of DataTables settings objects to be filtered\n * @return {array}\n * @ignore\n */ var __table_selector = function(selector, a) {\n    if (Array.isArray(selector)) {\n        var result = [];\n        selector.forEach(function(sel) {\n            var inner = __table_selector(sel, a);\n            _fnArrayApply(result, inner);\n        });\n        return result.filter(function(item) {\n            return item;\n        });\n    }\n    // Integer is used to pick out a table by index\n    if (typeof selector === \"number\") {\n        return [\n            a[selector]\n        ];\n    }\n    // Perform a jQuery selector on the table nodes\n    var nodes = a.map(function(el) {\n        return el.nTable;\n    });\n    return $(nodes).filter(selector).map(function() {\n        // Need to translate back from the table node to the settings\n        var idx = nodes.indexOf(this);\n        return a[idx];\n    }).toArray();\n};\n/**\n * Context selector for the API's context (i.e. the tables the API instance\n * refers to.\n *\n * @name    DataTable.Api#tables\n * @param {string|integer} [selector] Selector to pick which tables the iterator\n *   should operate on. If not given, all tables in the current context are\n *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to\n *   select multiple tables or as an integer to select a single table.\n * @returns {DataTable.Api} Returns a new API instance if a selector is given.\n */ _api_register(\"tables()\", function(selector) {\n    // A new instance is created if there was a selector specified\n    return selector !== undefined && selector !== null ? new _Api(__table_selector(selector, this.context)) : this;\n});\n_api_register(\"table()\", function(selector) {\n    var tables = this.tables(selector);\n    var ctx = tables.context;\n    // Truncate to the first matched table\n    return ctx.length ? new _Api(ctx[0]) : tables;\n});\n// Common methods, combined to reduce size\n[\n    [\n        \"nodes\",\n        \"node\",\n        \"nTable\"\n    ],\n    [\n        \"body\",\n        \"body\",\n        \"nTBody\"\n    ],\n    [\n        \"header\",\n        \"header\",\n        \"nTHead\"\n    ],\n    [\n        \"footer\",\n        \"footer\",\n        \"nTFoot\"\n    ]\n].forEach(function(item) {\n    _api_registerPlural(\"tables().\" + item[0] + \"()\", \"table().\" + item[1] + \"()\", function() {\n        return this.iterator(\"table\", function(ctx) {\n            return ctx[item[2]];\n        }, 1);\n    });\n});\n// Structure methods\n[\n    [\n        \"header\",\n        \"aoHeader\"\n    ],\n    [\n        \"footer\",\n        \"aoFooter\"\n    ]\n].forEach(function(item) {\n    _api_register(\"table().\" + item[0] + \".structure()\", function(selector) {\n        var indexes = this.columns(selector).indexes().flatten().toArray();\n        var ctx = this.context[0];\n        var structure = _fnHeaderLayout(ctx, ctx[item[1]], indexes);\n        // The structure is in column index order - but from this method we want the return to be\n        // in the columns() selector API order. In order to do that we need to map from one form\n        // to the other\n        var orderedIndexes = indexes.slice().sort(function(a, b) {\n            return a - b;\n        });\n        return structure.map(function(row) {\n            return indexes.map(function(colIdx) {\n                return row[orderedIndexes.indexOf(colIdx)];\n            });\n        });\n    });\n});\n_api_registerPlural(\"tables().containers()\", \"table().container()\", function() {\n    return this.iterator(\"table\", function(ctx) {\n        return ctx.nTableWrapper;\n    }, 1);\n});\n_api_register(\"tables().every()\", function(fn) {\n    var that = this;\n    return this.iterator(\"table\", function(s, i) {\n        fn.call(that.table(i), i);\n    });\n});\n_api_register(\"caption()\", function(value, side) {\n    var context = this.context;\n    // Getter - return existing node's content\n    if (value === undefined) {\n        var caption = context[0].captionNode;\n        return caption && context.length ? caption.innerHTML : null;\n    }\n    return this.iterator(\"table\", function(ctx) {\n        var table = $(ctx.nTable);\n        var caption = $(ctx.captionNode);\n        var container = $(ctx.nTableWrapper);\n        // Create the node if it doesn't exist yet\n        if (!caption.length) {\n            caption = $(\"<caption/>\").html(value);\n            ctx.captionNode = caption[0];\n            // If side isn't set, we need to insert into the document to let the\n            // CSS decide so we can read it back, otherwise there is no way to\n            // know if the CSS would put it top or bottom for scrolling\n            if (!side) {\n                table.prepend(caption);\n                side = caption.css(\"caption-side\");\n            }\n        }\n        caption.html(value);\n        if (side) {\n            caption.css(\"caption-side\", side);\n            caption[0]._captionSide = side;\n        }\n        if (container.find(\"div.dataTables_scroll\").length) {\n            var selector = side === \"top\" ? \"Head\" : \"Foot\";\n            container.find(\"div.dataTables_scroll\" + selector + \" table\").prepend(caption);\n        } else {\n            table.prepend(caption);\n        }\n    }, 1);\n});\n_api_register(\"caption.node()\", function() {\n    var ctx = this.context;\n    return ctx.length ? ctx[0].captionNode : null;\n});\n/**\n * Redraw the tables in the current context.\n */ _api_register(\"draw()\", function(paging) {\n    return this.iterator(\"table\", function(settings) {\n        if (paging === \"page\") {\n            _fnDraw(settings);\n        } else {\n            if (typeof paging === \"string\") {\n                paging = paging === \"full-hold\" ? false : true;\n            }\n            _fnReDraw(settings, paging === false);\n        }\n    });\n});\n/**\n * Get the current page index.\n *\n * @return {integer} Current page index (zero based)\n */ /**\n * Set the current page.\n *\n * Note that if you attempt to show a page which does not exist, DataTables will\n * not throw an error, but rather reset the paging.\n *\n * @param {integer|string} action The paging action to take. This can be one of:\n *  * `integer` - The page index to jump to\n *  * `string` - An action to take:\n *    * `first` - Jump to first page.\n *    * `next` - Jump to the next page\n *    * `previous` - Jump to previous page\n *    * `last` - Jump to the last page.\n * @returns {DataTables.Api} this\n */ _api_register(\"page()\", function(action) {\n    if (action === undefined) {\n        return this.page.info().page; // not an expensive call\n    }\n    // else, have an action to take on all tables\n    return this.iterator(\"table\", function(settings) {\n        _fnPageChange(settings, action);\n    });\n});\n/**\n * Paging information for the first table in the current context.\n *\n * If you require paging information for another table, use the `table()` method\n * with a suitable selector.\n *\n * @return {object} Object with the following properties set:\n *  * `page` - Current page index (zero based - i.e. the first page is `0`)\n *  * `pages` - Total number of pages\n *  * `start` - Display index for the first record shown on the current page\n *  * `end` - Display index for the last record shown on the current page\n *  * `length` - Display length (number of records). Note that generally `start\n *    + length = end`, but this is not always true, for example if there are\n *    only 2 records to show on the final page, with a length of 10.\n *  * `recordsTotal` - Full data set length\n *  * `recordsDisplay` - Data set length once the current filtering criterion\n *    are applied.\n */ _api_register(\"page.info()\", function() {\n    if (this.context.length === 0) {\n        return undefined;\n    }\n    var settings = this.context[0], start = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all = len === -1;\n    return {\n        \"page\": all ? 0 : Math.floor(start / len),\n        \"pages\": all ? 1 : Math.ceil(visRecords / len),\n        \"start\": start,\n        \"end\": settings.fnDisplayEnd(),\n        \"length\": len,\n        \"recordsTotal\": settings.fnRecordsTotal(),\n        \"recordsDisplay\": visRecords,\n        \"serverSide\": _fnDataSource(settings) === \"ssp\"\n    };\n});\n/**\n * Get the current page length.\n *\n * @return {integer} Current page length. Note `-1` indicates that all records\n *   are to be shown.\n */ /**\n * Set the current page length.\n *\n * @param {integer} Page length to set. Use `-1` to show all records.\n * @returns {DataTables.Api} this\n */ _api_register(\"page.len()\", function(len) {\n    // Note that we can't call this function 'length()' because `length`\n    // is a Javascript property of functions which defines how many arguments\n    // the function expects.\n    if (len === undefined) {\n        return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined;\n    }\n    // else, set the page length\n    return this.iterator(\"table\", function(settings) {\n        _fnLengthChange(settings, len);\n    });\n});\nvar __reload = function(settings, holdPosition, callback) {\n    // Use the draw event to trigger a callback\n    if (callback) {\n        var api = new _Api(settings);\n        api.one(\"draw\", function() {\n            callback(api.ajax.json());\n        });\n    }\n    if (_fnDataSource(settings) == \"ssp\") {\n        _fnReDraw(settings, holdPosition);\n    } else {\n        _fnProcessingDisplay(settings, true);\n        // Cancel an existing request\n        var xhr = settings.jqXHR;\n        if (xhr && xhr.readyState !== 4) {\n            xhr.abort();\n        }\n        // Trigger xhr\n        _fnBuildAjax(settings, {}, function(json) {\n            _fnClearTable(settings);\n            var data = _fnAjaxDataSrc(settings, json);\n            for(var i = 0, ien = data.length; i < ien; i++){\n                _fnAddData(settings, data[i]);\n            }\n            _fnReDraw(settings, holdPosition);\n            _fnInitComplete(settings);\n            _fnProcessingDisplay(settings, false);\n        });\n    }\n};\n/**\n * Get the JSON response from the last Ajax request that DataTables made to the\n * server. Note that this returns the JSON from the first table in the current\n * context.\n *\n * @return {object} JSON received from the server.\n */ _api_register(\"ajax.json()\", function() {\n    var ctx = this.context;\n    if (ctx.length > 0) {\n        return ctx[0].json;\n    }\n// else return undefined;\n});\n/**\n * Get the data submitted in the last Ajax request\n */ _api_register(\"ajax.params()\", function() {\n    var ctx = this.context;\n    if (ctx.length > 0) {\n        return ctx[0].oAjaxData;\n    }\n// else return undefined;\n});\n/**\n * Reload tables from the Ajax data source. Note that this function will\n * automatically re-draw the table when the remote data has been loaded.\n *\n * @param {boolean} [reset=true] Reset (default) or hold the current paging\n *   position. A full re-sort and re-filter is performed when this method is\n *   called, which is why the pagination reset is the default action.\n * @returns {DataTables.Api} this\n */ _api_register(\"ajax.reload()\", function(callback, resetPaging) {\n    return this.iterator(\"table\", function(settings) {\n        __reload(settings, resetPaging === false, callback);\n    });\n});\n/**\n * Get the current Ajax URL. Note that this returns the URL from the first\n * table in the current context.\n *\n * @return {string} Current Ajax source URL\n */ /**\n * Set the Ajax URL. Note that this will set the URL for all tables in the\n * current context.\n *\n * @param {string} url URL to set.\n * @returns {DataTables.Api} this\n */ _api_register(\"ajax.url()\", function(url) {\n    var ctx = this.context;\n    if (url === undefined) {\n        // get\n        if (ctx.length === 0) {\n            return undefined;\n        }\n        ctx = ctx[0];\n        return $.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax;\n    }\n    // set\n    return this.iterator(\"table\", function(settings) {\n        if ($.isPlainObject(settings.ajax)) {\n            settings.ajax.url = url;\n        } else {\n            settings.ajax = url;\n        }\n    });\n});\n/**\n * Load data from the newly set Ajax URL. Note that this method is only\n * available when `ajax.url()` is used to set a URL. Additionally, this method\n * has the same effect as calling `ajax.reload()` but is provided for\n * convenience when setting a new URL. Like `ajax.reload()` it will\n * automatically redraw the table once the remote data has been loaded.\n *\n * @returns {DataTables.Api} this\n */ _api_register(\"ajax.url().load()\", function(callback, resetPaging) {\n    // Same as a reload, but makes sense to present it for easy access after a\n    // url change\n    return this.iterator(\"table\", function(ctx) {\n        __reload(ctx, resetPaging === false, callback);\n    });\n});\nvar _selector_run = function(type, selector, selectFn, settings, opts) {\n    var out = [], res, i, ien, selectorType = typeof selector;\n    // Can't just check for isArray here, as an API or jQuery instance might be\n    // given with their array like look\n    if (!selector || selectorType === \"string\" || selectorType === \"function\" || selector.length === undefined) {\n        selector = [\n            selector\n        ];\n    }\n    for(i = 0, ien = selector.length; i < ien; i++){\n        res = selectFn(typeof selector[i] === \"string\" ? selector[i].trim() : selector[i]);\n        // Remove empty items\n        res = res.filter(function(item) {\n            return item !== null && item !== undefined;\n        });\n        if (res && res.length) {\n            out = out.concat(res);\n        }\n    }\n    // selector extensions\n    var ext = _ext.selector[type];\n    if (ext.length) {\n        for(i = 0, ien = ext.length; i < ien; i++){\n            out = ext[i](settings, opts, out);\n        }\n    }\n    return _unique(out);\n};\nvar _selector_opts = function(opts) {\n    if (!opts) {\n        opts = {};\n    }\n    // Backwards compatibility for 1.9- which used the terminology filter rather\n    // than search\n    if (opts.filter && opts.search === undefined) {\n        opts.search = opts.filter;\n    }\n    return $.extend({\n        columnOrder: \"implied\",\n        search: \"none\",\n        order: \"current\",\n        page: \"all\"\n    }, opts);\n};\n// Reduce the API instance to the first item found\nvar _selector_first = function(old) {\n    var inst = new _Api(old.context[0]);\n    // Use a push rather than passing to the constructor, since it will\n    // merge arrays down automatically, which isn't what is wanted here\n    if (old.length) {\n        inst.push(old[0]);\n    }\n    inst.selector = old.selector;\n    // Limit to a single row / column / cell\n    if (inst.length && inst[0].length > 1) {\n        inst[0].splice(1);\n    }\n    return inst;\n};\nvar _selector_row_indexes = function(settings, opts) {\n    var i, ien, tmp, a = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;\n    var search = opts.search, order = opts.order, page = opts.page; // all, current\n    if (_fnDataSource(settings) == \"ssp\") {\n        // In server-side processing mode, most options are irrelevant since\n        // rows not shown don't exist and the index order is the applied order\n        // Removed is a special case - for consistency just return an empty\n        // array\n        return search === \"removed\" ? [] : _range(0, displayMaster.length);\n    }\n    if (page == \"current\") {\n        // Current page implies that order=current and filter=applied, since it is\n        // fairly senseless otherwise, regardless of what order and search actually\n        // are\n        for(i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++){\n            a.push(displayFiltered[i]);\n        }\n    } else if (order == \"current\" || order == \"applied\") {\n        if (search == \"none\") {\n            a = displayMaster.slice();\n        } else if (search == \"applied\") {\n            a = displayFiltered.slice();\n        } else if (search == \"removed\") {\n            // O(n+m) solution by creating a hash map\n            var displayFilteredMap = {};\n            for(i = 0, ien = displayFiltered.length; i < ien; i++){\n                displayFilteredMap[displayFiltered[i]] = null;\n            }\n            displayMaster.forEach(function(item) {\n                if (!Object.prototype.hasOwnProperty.call(displayFilteredMap, item)) {\n                    a.push(item);\n                }\n            });\n        }\n    } else if (order == \"index\" || order == \"original\") {\n        for(i = 0, ien = settings.aoData.length; i < ien; i++){\n            if (!settings.aoData[i]) {\n                continue;\n            }\n            if (search == \"none\") {\n                a.push(i);\n            } else {\n                tmp = displayFiltered.indexOf(i);\n                if (tmp === -1 && search == \"removed\" || tmp >= 0 && search == \"applied\") {\n                    a.push(i);\n                }\n            }\n        }\n    } else if (typeof order === \"number\") {\n        // Order the rows by the given column\n        var ordered = _fnSort(settings, order, \"asc\");\n        if (search === \"none\") {\n            a = ordered;\n        } else {\n            for(i = 0; i < ordered.length; i++){\n                tmp = displayFiltered.indexOf(ordered[i]);\n                if (tmp === -1 && search == \"removed\" || tmp >= 0 && search == \"applied\") {\n                    a.push(ordered[i]);\n                }\n            }\n        }\n    }\n    return a;\n};\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Rows\n *\n * {}          - no selector - use all available rows\n * {integer}   - row aoData index\n * {node}      - TR node\n * {string}    - jQuery selector to apply to the TR elements\n * {array}     - jQuery array of nodes, or simply an array of TR nodes\n *\n */ var __row_selector = function(settings, selector, opts) {\n    var rows;\n    var run = function(sel) {\n        var selInt = _intVal(sel);\n        var aoData = settings.aoData;\n        // Short cut - selector is a number and no options provided (default is\n        // all records, so no need to check if the index is in there, since it\n        // must be - dev error if the index doesn't exist).\n        if (selInt !== null && !opts) {\n            return [\n                selInt\n            ];\n        }\n        if (!rows) {\n            rows = _selector_row_indexes(settings, opts);\n        }\n        if (selInt !== null && rows.indexOf(selInt) !== -1) {\n            // Selector - integer\n            return [\n                selInt\n            ];\n        } else if (sel === null || sel === undefined || sel === \"\") {\n            // Selector - none\n            return rows;\n        }\n        // Selector - function\n        if (typeof sel === \"function\") {\n            return rows.map(function(idx) {\n                var row = aoData[idx];\n                return sel(idx, row._aData, row.nTr) ? idx : null;\n            });\n        }\n        // Selector - node\n        if (sel.nodeName) {\n            var rowIdx = sel._DT_RowIndex; // Property added by DT for fast lookup\n            var cellIdx = sel._DT_CellIndex;\n            if (rowIdx !== undefined) {\n                // Make sure that the row is actually still present in the table\n                return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [\n                    rowIdx\n                ] : [];\n            } else if (cellIdx) {\n                return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [\n                    cellIdx.row\n                ] : [];\n            } else {\n                var host = $(sel).closest(\"*[data-dt-row]\");\n                return host.length ? [\n                    host.data(\"dt-row\")\n                ] : [];\n            }\n        }\n        // ID selector. Want to always be able to select rows by id, regardless\n        // of if the tr element has been created or not, so can't rely upon\n        // jQuery here - hence a custom implementation. This does not match\n        // Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,\n        // but to select it using a CSS selector engine (like Sizzle or\n        // querySelect) it would need to need to be escaped for some characters.\n        // DataTables simplifies this for row selectors since you can select\n        // only a row. A # indicates an id any anything that follows is the id -\n        // unescaped.\n        if (typeof sel === \"string\" && sel.charAt(0) === \"#\") {\n            // get row index from id\n            var rowObj = settings.aIds[sel.replace(/^#/, \"\")];\n            if (rowObj !== undefined) {\n                return [\n                    rowObj.idx\n                ];\n            }\n        // need to fall through to jQuery in case there is DOM id that\n        // matches\n        }\n        // Get nodes in the order from the `rows` array with null values removed\n        var nodes = _removeEmpty(_pluck_order(settings.aoData, rows, \"nTr\"));\n        // Selector - jQuery selector string, array of nodes or jQuery object/\n        // As jQuery's .filter() allows jQuery objects to be passed in filter,\n        // it also allows arrays, so this will cope with all three options\n        return $(nodes).filter(sel).map(function() {\n            return this._DT_RowIndex;\n        }).toArray();\n    };\n    var matched = _selector_run(\"row\", selector, run, settings, opts);\n    if (opts.order === \"current\" || opts.order === \"applied\") {\n        _fnSortDisplay(settings, matched);\n    }\n    return matched;\n};\n_api_register(\"rows()\", function(selector, opts) {\n    // argument shifting\n    if (selector === undefined) {\n        selector = \"\";\n    } else if ($.isPlainObject(selector)) {\n        opts = selector;\n        selector = \"\";\n    }\n    opts = _selector_opts(opts);\n    var inst = this.iterator(\"table\", function(settings) {\n        return __row_selector(settings, selector, opts);\n    }, 1);\n    // Want argument shifting here and in __row_selector?\n    inst.selector.rows = selector;\n    inst.selector.opts = opts;\n    return inst;\n});\n_api_register(\"rows().nodes()\", function() {\n    return this.iterator(\"row\", function(settings, row) {\n        return settings.aoData[row].nTr || undefined;\n    }, 1);\n});\n_api_register(\"rows().data()\", function() {\n    return this.iterator(true, \"rows\", function(settings, rows) {\n        return _pluck_order(settings.aoData, rows, \"_aData\");\n    }, 1);\n});\n_api_registerPlural(\"rows().cache()\", \"row().cache()\", function(type) {\n    return this.iterator(\"row\", function(settings, row) {\n        var r = settings.aoData[row];\n        return type === \"search\" ? r._aFilterData : r._aSortData;\n    }, 1);\n});\n_api_registerPlural(\"rows().invalidate()\", \"row().invalidate()\", function(src) {\n    return this.iterator(\"row\", function(settings, row) {\n        _fnInvalidate(settings, row, src);\n    });\n});\n_api_registerPlural(\"rows().indexes()\", \"row().index()\", function() {\n    return this.iterator(\"row\", function(settings, row) {\n        return row;\n    }, 1);\n});\n_api_registerPlural(\"rows().ids()\", \"row().id()\", function(hash) {\n    var a = [];\n    var context = this.context;\n    // `iterator` will drop undefined values, but in this case we want them\n    for(var i = 0, ien = context.length; i < ien; i++){\n        for(var j = 0, jen = this[i].length; j < jen; j++){\n            var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);\n            a.push((hash === true ? \"#\" : \"\") + id);\n        }\n    }\n    return new _Api(context, a);\n});\n_api_registerPlural(\"rows().remove()\", \"row().remove()\", function() {\n    this.iterator(\"row\", function(settings, row) {\n        var data = settings.aoData;\n        var rowData = data[row];\n        // Delete from the display arrays\n        var idx = settings.aiDisplayMaster.indexOf(row);\n        if (idx !== -1) {\n            settings.aiDisplayMaster.splice(idx, 1);\n        }\n        // For server-side processing tables - subtract the deleted row from the count\n        if (settings._iRecordsDisplay > 0) {\n            settings._iRecordsDisplay--;\n        }\n        // Check for an 'overflow' they case for displaying the table\n        _fnLengthOverflow(settings);\n        // Remove the row's ID reference if there is one\n        var id = settings.rowIdFn(rowData._aData);\n        if (id !== undefined) {\n            delete settings.aIds[id];\n        }\n        data[row] = null;\n    });\n    return this;\n});\n_api_register(\"rows.add()\", function(rows) {\n    var newRows = this.iterator(\"table\", function(settings) {\n        var row, i, ien;\n        var out = [];\n        for(i = 0, ien = rows.length; i < ien; i++){\n            row = rows[i];\n            if (row.nodeName && row.nodeName.toUpperCase() === \"TR\") {\n                out.push(_fnAddTr(settings, row)[0]);\n            } else {\n                out.push(_fnAddData(settings, row));\n            }\n        }\n        return out;\n    }, 1);\n    // Return an Api.rows() extended instance, so rows().nodes() etc can be used\n    var modRows = this.rows(-1);\n    modRows.pop();\n    _fnArrayApply(modRows, newRows);\n    return modRows;\n});\n/**\n *\n */ _api_register(\"row()\", function(selector, opts) {\n    return _selector_first(this.rows(selector, opts));\n});\n_api_register(\"row().data()\", function(data) {\n    var ctx = this.context;\n    if (data === undefined) {\n        // Get\n        return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]]._aData : undefined;\n    }\n    // Set\n    var row = ctx[0].aoData[this[0]];\n    row._aData = data;\n    // If the DOM has an id, and the data source is an array\n    if (Array.isArray(data) && row.nTr && row.nTr.id) {\n        _fnSetObjectDataFn(ctx[0].rowId)(data, row.nTr.id);\n    }\n    // Automatically invalidate\n    _fnInvalidate(ctx[0], this[0], \"data\");\n    return this;\n});\n_api_register(\"row().node()\", function() {\n    var ctx = this.context;\n    if (ctx.length && this.length && this[0].length) {\n        var row = ctx[0].aoData[this[0]];\n        if (row && row.nTr) {\n            return row.nTr;\n        }\n    }\n    return null;\n});\n_api_register(\"row.add()\", function(row) {\n    // Allow a jQuery object to be passed in - only a single row is added from\n    // it though - the first element in the set\n    if (row instanceof $ && row.length) {\n        row = row[0];\n    }\n    var rows = this.iterator(\"table\", function(settings) {\n        if (row.nodeName && row.nodeName.toUpperCase() === \"TR\") {\n            return _fnAddTr(settings, row)[0];\n        }\n        return _fnAddData(settings, row);\n    });\n    // Return an Api.rows() extended instance, with the newly added row selected\n    return this.row(rows[0]);\n});\n$(document).on(\"plugin-init.dt\", function(e, context) {\n    var api = new _Api(context);\n    api.on(\"stateSaveParams.DT\", function(e, settings, d) {\n        // This could be more compact with the API, but it is a lot faster as a simple\n        // internal loop\n        var idFn = settings.rowIdFn;\n        var rows = settings.aiDisplayMaster;\n        var ids = [];\n        for(var i = 0; i < rows.length; i++){\n            var rowIdx = rows[i];\n            var data = settings.aoData[rowIdx];\n            if (data._detailsShow) {\n                ids.push(\"#\" + idFn(data._aData));\n            }\n        }\n        d.childRows = ids;\n    });\n    // For future state loads (e.g. with StateRestore)\n    api.on(\"stateLoaded.DT\", function(e, settings, state) {\n        __details_state_load(api, state);\n    });\n    // And the initial load state\n    __details_state_load(api, api.state.loaded());\n});\nvar __details_state_load = function(api, state) {\n    if (state && state.childRows) {\n        api.rows(state.childRows.map(function(id) {\n            // Escape any `:` characters from the row id. Accounts for\n            // already escaped characters.\n            return id.replace(/([^:\\\\]*(?:\\\\.[^:\\\\]*)*):/g, \"$1\\\\:\");\n        })).every(function() {\n            _fnCallbackFire(api.settings()[0], null, \"requestChild\", [\n                this\n            ]);\n        });\n    }\n};\nvar __details_add = function(ctx, row, data, klass) {\n    // Convert to array of TR elements\n    var rows = [];\n    var addRow = function(r, k) {\n        // Recursion to allow for arrays of jQuery objects\n        if (Array.isArray(r) || r instanceof $) {\n            for(var i = 0, ien = r.length; i < ien; i++){\n                addRow(r[i], k);\n            }\n            return;\n        }\n        // If we get a TR element, then just add it directly - up to the dev\n        // to add the correct number of columns etc\n        if (r.nodeName && r.nodeName.toLowerCase() === \"tr\") {\n            r.setAttribute(\"data-dt-row\", row.idx);\n            rows.push(r);\n        } else {\n            // Otherwise create a row with a wrapper\n            var created = $(\"<tr><td></td></tr>\").attr(\"data-dt-row\", row.idx).addClass(k);\n            $(\"td\", created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx);\n            rows.push(created[0]);\n        }\n    };\n    addRow(data, klass);\n    if (row._details) {\n        row._details.detach();\n    }\n    row._details = $(rows);\n    // If the children were already shown, that state should be retained\n    if (row._detailsShow) {\n        row._details.insertAfter(row.nTr);\n    }\n};\n// Make state saving of child row details async to allow them to be batch processed\nvar __details_state = DataTable.util.throttle(function(ctx) {\n    _fnSaveState(ctx[0]);\n}, 500);\nvar __details_remove = function(api, idx) {\n    var ctx = api.context;\n    if (ctx.length) {\n        var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];\n        if (row && row._details) {\n            row._details.remove();\n            row._detailsShow = undefined;\n            row._details = undefined;\n            $(row.nTr).removeClass(\"dt-hasChild\");\n            __details_state(ctx);\n        }\n    }\n};\nvar __details_display = function(api, show) {\n    var ctx = api.context;\n    if (ctx.length && api.length) {\n        var row = ctx[0].aoData[api[0]];\n        if (row._details) {\n            row._detailsShow = show;\n            if (show) {\n                row._details.insertAfter(row.nTr);\n                $(row.nTr).addClass(\"dt-hasChild\");\n            } else {\n                row._details.detach();\n                $(row.nTr).removeClass(\"dt-hasChild\");\n            }\n            _fnCallbackFire(ctx[0], null, \"childRow\", [\n                show,\n                api.row(api[0])\n            ]);\n            __details_events(ctx[0]);\n            __details_state(ctx);\n        }\n    }\n};\nvar __details_events = function(settings) {\n    var api = new _Api(settings);\n    var namespace = \".dt.DT_details\";\n    var drawEvent = \"draw\" + namespace;\n    var colvisEvent = \"column-sizing\" + namespace;\n    var destroyEvent = \"destroy\" + namespace;\n    var data = settings.aoData;\n    api.off(drawEvent + \" \" + colvisEvent + \" \" + destroyEvent);\n    if (_pluck(data, \"_details\").length > 0) {\n        // On each draw, insert the required elements into the document\n        api.on(drawEvent, function(e, ctx) {\n            if (settings !== ctx) {\n                return;\n            }\n            api.rows({\n                page: \"current\"\n            }).eq(0).each(function(idx) {\n                // Internal data grab\n                var row = data[idx];\n                if (row._detailsShow) {\n                    row._details.insertAfter(row.nTr);\n                }\n            });\n        });\n        // Column visibility change - update the colspan\n        api.on(colvisEvent, function(e, ctx) {\n            if (settings !== ctx) {\n                return;\n            }\n            // Update the colspan for the details rows (note, only if it already has\n            // a colspan)\n            var row, visible = _fnVisbleColumns(ctx);\n            for(var i = 0, ien = data.length; i < ien; i++){\n                row = data[i];\n                if (row && row._details) {\n                    row._details.each(function() {\n                        var el = $(this).children(\"td\");\n                        if (el.length == 1) {\n                            el.attr(\"colspan\", visible);\n                        }\n                    });\n                }\n            }\n        });\n        // Table destroyed - nuke any child rows\n        api.on(destroyEvent, function(e, ctx) {\n            if (settings !== ctx) {\n                return;\n            }\n            for(var i = 0, ien = data.length; i < ien; i++){\n                if (data[i] && data[i]._details) {\n                    __details_remove(api, i);\n                }\n            }\n        });\n    }\n};\n// Strings for the method names to help minification\nvar _emp = \"\";\nvar _child_obj = _emp + \"row().child\";\nvar _child_mth = _child_obj + \"()\";\n// data can be:\n//  tr\n//  string\n//  jQuery or array of any of the above\n_api_register(_child_mth, function(data, klass) {\n    var ctx = this.context;\n    if (data === undefined) {\n        // get\n        return ctx.length && this.length && ctx[0].aoData[this[0]] ? ctx[0].aoData[this[0]]._details : undefined;\n    } else if (data === true) {\n        // show\n        this.child.show();\n    } else if (data === false) {\n        // remove\n        __details_remove(this);\n    } else if (ctx.length && this.length) {\n        // set\n        __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);\n    }\n    return this;\n});\n_api_register([\n    _child_obj + \".show()\",\n    _child_mth + \".show()\" // only when `child()` was called with parameters (without\n], function() {\n    __details_display(this, true);\n    return this;\n});\n_api_register([\n    _child_obj + \".hide()\",\n    _child_mth + \".hide()\" // only when `child()` was called with parameters (without\n], function() {\n    __details_display(this, false);\n    return this;\n});\n_api_register([\n    _child_obj + \".remove()\",\n    _child_mth + \".remove()\" // only when `child()` was called with parameters (without\n], function() {\n    __details_remove(this);\n    return this;\n});\n_api_register(_child_obj + \".isShown()\", function() {\n    var ctx = this.context;\n    if (ctx.length && this.length && ctx[0].aoData[this[0]]) {\n        // _detailsShown as false or undefined will fall through to return false\n        return ctx[0].aoData[this[0]]._detailsShow || false;\n    }\n    return false;\n});\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Columns\n *\n * {integer}           - column index (>=0 count from left, <0 count from right)\n * \"{integer}:visIdx\"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)\n * \"{integer}:visible\" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)\n * \"{string}:name\"     - column name\n * \"{string}\"          - jQuery selector on column header nodes\n *\n */ // can be an array of these items, comma separated list, or an array of comma\n// separated lists\nvar __re_column_selector = /^([^:]+)?:(name|title|visIdx|visible)$/;\n// r1 and r2 are redundant - but it means that the parameters match for the\n// iterator callback in columns().data()\nvar __columnData = function(settings, column, r1, r2, rows, type) {\n    var a = [];\n    for(var row = 0, ien = rows.length; row < ien; row++){\n        a.push(_fnGetCellData(settings, rows[row], column, type));\n    }\n    return a;\n};\nvar __column_header = function(settings, column, row) {\n    var header = settings.aoHeader;\n    var titleRow = settings.titleRow;\n    var target = null;\n    if (row !== undefined) {\n        target = row;\n    } else if (titleRow === true) {\n        target = 0;\n    } else if (titleRow === false) {\n        target = header.length - 1;\n    } else if (titleRow !== null) {\n        target = titleRow;\n    } else {\n        // Automatic - find the _last_ unique cell from the top that is not empty (last for\n        // backwards compatibility)\n        for(var i = 0; i < header.length; i++){\n            if (header[i][column].unique && $(\"span.dt-column-title\", header[i][column].cell).text()) {\n                target = i;\n            }\n        }\n        if (target === null) {\n            target = 0;\n        }\n    }\n    return header[target][column].cell;\n};\nvar __column_header_cells = function(header) {\n    var out = [];\n    for(var i = 0; i < header.length; i++){\n        for(var j = 0; j < header[i].length; j++){\n            var cell = header[i][j].cell;\n            if (!out.includes(cell)) {\n                out.push(cell);\n            }\n        }\n    }\n    return out;\n};\nvar __column_selector = function(settings, selector, opts) {\n    var columns = settings.aoColumns, names, titles, nodes = __column_header_cells(settings.aoHeader);\n    var run = function(s) {\n        var selInt = _intVal(s);\n        // Selector - all\n        if (s === \"\") {\n            return _range(columns.length);\n        }\n        // Selector - index\n        if (selInt !== null) {\n            return [\n                selInt >= 0 ? selInt : columns.length + selInt // Count from right (+ because its a negative value)\n            ];\n        }\n        // Selector = function\n        if (typeof s === \"function\") {\n            var rows = _selector_row_indexes(settings, opts);\n            return columns.map(function(col, idx) {\n                return s(idx, __columnData(settings, idx, 0, 0, rows), __column_header(settings, idx)) ? idx : null;\n            });\n        }\n        // jQuery or string selector\n        var match = typeof s === \"string\" ? s.match(__re_column_selector) : \"\";\n        if (match) {\n            switch(match[2]){\n                case \"visIdx\":\n                case \"visible\":\n                    // Selector is a column index\n                    if (match[1] && match[1].match(/^\\d+$/)) {\n                        var idx = parseInt(match[1], 10);\n                        // Visible index given, convert to column index\n                        if (idx < 0) {\n                            // Counting from the right\n                            var visColumns = columns.map(function(col, i) {\n                                return col.bVisible ? i : null;\n                            });\n                            return [\n                                visColumns[visColumns.length + idx]\n                            ];\n                        }\n                        // Counting from the left\n                        return [\n                            _fnVisibleToColumnIndex(settings, idx)\n                        ];\n                    }\n                    return columns.map(function(col, idx) {\n                        // Not visible, can't match\n                        if (!col.bVisible) {\n                            return null;\n                        }\n                        // Selector\n                        if (match[1]) {\n                            return $(nodes[idx]).filter(match[1]).length > 0 ? idx : null;\n                        }\n                        // `:visible` on its own\n                        return idx;\n                    });\n                case \"name\":\n                    // Don't get names, unless needed, and only get once if it is\n                    if (!names) {\n                        names = _pluck(columns, \"sName\");\n                    }\n                    // match by name. `names` is column index complete and in order\n                    return names.map(function(name, i) {\n                        return name === match[1] ? i : null;\n                    });\n                case \"title\":\n                    if (!titles) {\n                        titles = _pluck(columns, \"sTitle\");\n                    }\n                    // match by column title\n                    return titles.map(function(title, i) {\n                        return title === match[1] ? i : null;\n                    });\n                default:\n                    return [];\n            }\n        }\n        // Cell in the table body\n        if (s.nodeName && s._DT_CellIndex) {\n            return [\n                s._DT_CellIndex.column\n            ];\n        }\n        // jQuery selector on the TH elements for the columns\n        var jqResult = $(nodes).filter(s).map(function() {\n            return _fnColumnsFromHeader(this); // `nodes` is column index complete and in order\n        }).toArray().sort(function(a, b) {\n            return a - b;\n        });\n        if (jqResult.length || !s.nodeName) {\n            return jqResult;\n        }\n        // Otherwise a node which might have a `dt-column` data attribute, or be\n        // a child or such an element\n        var host = $(s).closest(\"*[data-dt-column]\");\n        return host.length ? [\n            host.data(\"dt-column\")\n        ] : [];\n    };\n    var selected = _selector_run(\"column\", selector, run, settings, opts);\n    return opts.columnOrder && opts.columnOrder === \"index\" ? selected.sort(function(a, b) {\n        return a - b;\n    }) : selected; // implied\n};\nvar __setColumnVis = function(settings, column, vis) {\n    var cols = settings.aoColumns, col = cols[column], data = settings.aoData, cells, i, ien, tr;\n    // Get\n    if (vis === undefined) {\n        return col.bVisible;\n    }\n    // Set\n    // No change\n    if (col.bVisible === vis) {\n        return false;\n    }\n    if (vis) {\n        // Insert column\n        // Need to decide if we should use appendChild or insertBefore\n        var insertBefore = _pluck(cols, \"bVisible\").indexOf(true, column + 1);\n        for(i = 0, ien = data.length; i < ien; i++){\n            if (data[i]) {\n                tr = data[i].nTr;\n                cells = data[i].anCells;\n                if (tr) {\n                    // insertBefore can act like appendChild if 2nd arg is null\n                    tr.insertBefore(cells[column], cells[insertBefore] || null);\n                }\n            }\n        }\n    } else {\n        // Remove column\n        $(_pluck(settings.aoData, \"anCells\", column)).detach();\n    }\n    // Common actions\n    col.bVisible = vis;\n    _colGroup(settings);\n    return true;\n};\n_api_register(\"columns()\", function(selector, opts) {\n    // argument shifting\n    if (selector === undefined) {\n        selector = \"\";\n    } else if ($.isPlainObject(selector)) {\n        opts = selector;\n        selector = \"\";\n    }\n    opts = _selector_opts(opts);\n    var inst = this.iterator(\"table\", function(settings) {\n        return __column_selector(settings, selector, opts);\n    }, 1);\n    // Want argument shifting here and in _row_selector?\n    inst.selector.cols = selector;\n    inst.selector.opts = opts;\n    return inst;\n});\n_api_registerPlural(\"columns().header()\", \"column().header()\", function(row) {\n    return this.iterator(\"column\", function(settings, column) {\n        return __column_header(settings, column, row);\n    }, 1);\n});\n_api_registerPlural(\"columns().footer()\", \"column().footer()\", function(row) {\n    return this.iterator(\"column\", function(settings, column) {\n        var footer = settings.aoFooter;\n        if (!footer.length) {\n            return null;\n        }\n        return settings.aoFooter[row !== undefined ? row : 0][column].cell;\n    }, 1);\n});\n_api_registerPlural(\"columns().data()\", \"column().data()\", function() {\n    return this.iterator(\"column-rows\", __columnData, 1);\n});\n_api_registerPlural(\"columns().render()\", \"column().render()\", function(type) {\n    return this.iterator(\"column-rows\", function(settings, column, i, j, rows) {\n        return __columnData(settings, column, i, j, rows, type);\n    }, 1);\n});\n_api_registerPlural(\"columns().dataSrc()\", \"column().dataSrc()\", function() {\n    return this.iterator(\"column\", function(settings, column) {\n        return settings.aoColumns[column].mData;\n    }, 1);\n});\n_api_registerPlural(\"columns().cache()\", \"column().cache()\", function(type) {\n    return this.iterator(\"column-rows\", function(settings, column, i, j, rows) {\n        return _pluck_order(settings.aoData, rows, type === \"search\" ? \"_aFilterData\" : \"_aSortData\", column);\n    }, 1);\n});\n_api_registerPlural(\"columns().init()\", \"column().init()\", function() {\n    return this.iterator(\"column\", function(settings, column) {\n        return settings.aoColumns[column];\n    }, 1);\n});\n_api_registerPlural(\"columns().names()\", \"column().name()\", function() {\n    return this.iterator(\"column\", function(settings, column) {\n        return settings.aoColumns[column].sName;\n    }, 1);\n});\n_api_registerPlural(\"columns().nodes()\", \"column().nodes()\", function() {\n    return this.iterator(\"column-rows\", function(settings, column, i, j, rows) {\n        return _pluck_order(settings.aoData, rows, \"anCells\", column);\n    }, 1);\n});\n_api_registerPlural(\"columns().titles()\", \"column().title()\", function(title, row) {\n    return this.iterator(\"column\", function(settings, column) {\n        // Argument shifting\n        if (typeof title === \"number\") {\n            row = title;\n            title = undefined;\n        }\n        var span = $(\"span.dt-column-title\", this.column(column).header(row));\n        if (title !== undefined) {\n            span.html(title);\n            return this;\n        }\n        return span.html();\n    }, 1);\n});\n_api_registerPlural(\"columns().types()\", \"column().type()\", function() {\n    return this.iterator(\"column\", function(settings, column) {\n        var type = settings.aoColumns[column].sType;\n        // If the type was invalidated, then resolve it. This actually does\n        // all columns at the moment. Would only happen once if getting all\n        // column's data types.\n        if (!type) {\n            _fnColumnTypes(settings);\n        }\n        return type;\n    }, 1);\n});\n_api_registerPlural(\"columns().visible()\", \"column().visible()\", function(vis, calc) {\n    var that = this;\n    var changed = [];\n    var ret = this.iterator(\"column\", function(settings, column) {\n        if (vis === undefined) {\n            return settings.aoColumns[column].bVisible;\n        } // else\n        if (__setColumnVis(settings, column, vis)) {\n            changed.push(column);\n        }\n    });\n    // Group the column visibility changes\n    if (vis !== undefined) {\n        this.iterator(\"table\", function(settings) {\n            // Redraw the header after changes\n            _fnDrawHead(settings, settings.aoHeader);\n            _fnDrawHead(settings, settings.aoFooter);\n            // Update colspan for no records display. Child rows and extensions will use their own\n            // listeners to do this - only need to update the empty table item here\n            if (!settings.aiDisplay.length) {\n                $(settings.nTBody).find(\"td[colspan]\").attr(\"colspan\", _fnVisbleColumns(settings));\n            }\n            _fnSaveState(settings);\n            // Second loop once the first is done for events\n            that.iterator(\"column\", function(settings, column) {\n                if (changed.includes(column)) {\n                    _fnCallbackFire(settings, null, \"column-visibility\", [\n                        settings,\n                        column,\n                        vis,\n                        calc\n                    ]);\n                }\n            });\n            if (changed.length && (calc === undefined || calc)) {\n                that.columns.adjust();\n            }\n        });\n    }\n    return ret;\n});\n_api_registerPlural(\"columns().widths()\", \"column().width()\", function() {\n    // Injects a fake row into the table for just a moment so the widths can\n    // be read, regardless of colspan in the header and rows being present in\n    // the body\n    var columns = this.columns(\":visible\").count();\n    var row = $(\"<tr>\").html(\"<td>\" + Array(columns).join(\"</td><td>\") + \"</td>\");\n    $(this.table().body()).append(row);\n    var widths = row.children().map(function() {\n        return $(this).outerWidth();\n    });\n    row.remove();\n    return this.iterator(\"column\", function(settings, column) {\n        var visIdx = _fnColumnIndexToVisible(settings, column);\n        return visIdx !== null ? widths[visIdx] : 0;\n    }, 1);\n});\n_api_registerPlural(\"columns().indexes()\", \"column().index()\", function(type) {\n    return this.iterator(\"column\", function(settings, column) {\n        return type === \"visible\" ? _fnColumnIndexToVisible(settings, column) : column;\n    }, 1);\n});\n_api_register(\"columns.adjust()\", function() {\n    return this.iterator(\"table\", function(settings) {\n        // Force a column sizing to happen with a manual call - otherwise it can skip\n        // if the size hasn't changed\n        settings.containerWidth = -1;\n        _fnAdjustColumnSizing(settings);\n    }, 1);\n});\n_api_register(\"column.index()\", function(type, idx) {\n    if (this.context.length !== 0) {\n        var ctx = this.context[0];\n        if (type === \"fromVisible\" || type === \"toData\") {\n            return _fnVisibleToColumnIndex(ctx, idx);\n        } else if (type === \"fromData\" || type === \"toVisible\") {\n            return _fnColumnIndexToVisible(ctx, idx);\n        }\n    }\n});\n_api_register(\"column()\", function(selector, opts) {\n    return _selector_first(this.columns(selector, opts));\n});\nvar __cell_selector = function(settings, selector, opts) {\n    var data = settings.aoData;\n    var rows = _selector_row_indexes(settings, opts);\n    var cells = _removeEmpty(_pluck_order(data, rows, \"anCells\"));\n    var allCells = $(_flatten([], cells));\n    var row;\n    var columns = settings.aoColumns.length;\n    var a, i, ien, j, o, host;\n    var run = function(s) {\n        var fnSelector = typeof s === \"function\";\n        if (s === null || s === undefined || fnSelector) {\n            // All cells and function selectors\n            a = [];\n            for(i = 0, ien = rows.length; i < ien; i++){\n                row = rows[i];\n                for(j = 0; j < columns; j++){\n                    o = {\n                        row: row,\n                        column: j\n                    };\n                    if (fnSelector) {\n                        // Selector - function\n                        host = data[row];\n                        if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {\n                            a.push(o);\n                        }\n                    } else {\n                        // Selector - all\n                        a.push(o);\n                    }\n                }\n            }\n            return a;\n        }\n        // Selector - index\n        if ($.isPlainObject(s)) {\n            // Valid cell index and its in the array of selectable rows\n            return s.column !== undefined && s.row !== undefined && rows.indexOf(s.row) !== -1 ? [\n                s\n            ] : [];\n        }\n        // Selector - jQuery filtered cells\n        var jqResult = allCells.filter(s).map(function(i, el) {\n            return {\n                row: el._DT_CellIndex.row,\n                column: el._DT_CellIndex.column\n            };\n        }).toArray();\n        if (jqResult.length || !s.nodeName) {\n            return jqResult;\n        }\n        // Otherwise the selector is a node, and there is one last option - the\n        // element might be a child of an element which has dt-row and dt-column\n        // data attributes\n        host = $(s).closest(\"*[data-dt-row]\");\n        return host.length ? [\n            {\n                row: host.data(\"dt-row\"),\n                column: host.data(\"dt-column\")\n            }\n        ] : [];\n    };\n    return _selector_run(\"cell\", selector, run, settings, opts);\n};\n_api_register(\"cells()\", function(rowSelector, columnSelector, opts) {\n    // Argument shifting\n    if ($.isPlainObject(rowSelector)) {\n        // Indexes\n        if (rowSelector.row === undefined) {\n            // Selector options in first parameter\n            opts = rowSelector;\n            rowSelector = null;\n        } else {\n            // Cell index objects in first parameter\n            opts = columnSelector;\n            columnSelector = null;\n        }\n    }\n    if ($.isPlainObject(columnSelector)) {\n        opts = columnSelector;\n        columnSelector = null;\n    }\n    // Cell selector\n    if (columnSelector === null || columnSelector === undefined) {\n        return this.iterator(\"table\", function(settings) {\n            return __cell_selector(settings, rowSelector, _selector_opts(opts));\n        });\n    }\n    // The default built in options need to apply to row and columns\n    var internalOpts = opts ? {\n        page: opts.page,\n        order: opts.order,\n        search: opts.search\n    } : {};\n    // Row + column selector\n    var columns = this.columns(columnSelector, internalOpts);\n    var rows = this.rows(rowSelector, internalOpts);\n    var i, ien, j, jen;\n    var cellsNoOpts = this.iterator(\"table\", function(settings, idx) {\n        var a = [];\n        for(i = 0, ien = rows[idx].length; i < ien; i++){\n            for(j = 0, jen = columns[idx].length; j < jen; j++){\n                a.push({\n                    row: rows[idx][i],\n                    column: columns[idx][j]\n                });\n            }\n        }\n        return a;\n    }, 1);\n    // There is currently only one extension which uses a cell selector extension\n    // It is a _major_ performance drag to run this if it isn't needed, so this is\n    // an extension specific check at the moment\n    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;\n    $.extend(cells.selector, {\n        cols: columnSelector,\n        rows: rowSelector,\n        opts: opts\n    });\n    return cells;\n});\n_api_registerPlural(\"cells().nodes()\", \"cell().node()\", function() {\n    return this.iterator(\"cell\", function(settings, row, column) {\n        var data = settings.aoData[row];\n        return data && data.anCells ? data.anCells[column] : undefined;\n    }, 1);\n});\n_api_register(\"cells().data()\", function() {\n    return this.iterator(\"cell\", function(settings, row, column) {\n        return _fnGetCellData(settings, row, column);\n    }, 1);\n});\n_api_registerPlural(\"cells().cache()\", \"cell().cache()\", function(type) {\n    type = type === \"search\" ? \"_aFilterData\" : \"_aSortData\";\n    return this.iterator(\"cell\", function(settings, row, column) {\n        return settings.aoData[row][type][column];\n    }, 1);\n});\n_api_registerPlural(\"cells().render()\", \"cell().render()\", function(type) {\n    return this.iterator(\"cell\", function(settings, row, column) {\n        return _fnGetCellData(settings, row, column, type);\n    }, 1);\n});\n_api_registerPlural(\"cells().indexes()\", \"cell().index()\", function() {\n    return this.iterator(\"cell\", function(settings, row, column) {\n        return {\n            row: row,\n            column: column,\n            columnVisible: _fnColumnIndexToVisible(settings, column)\n        };\n    }, 1);\n});\n_api_registerPlural(\"cells().invalidate()\", \"cell().invalidate()\", function(src) {\n    return this.iterator(\"cell\", function(settings, row, column) {\n        _fnInvalidate(settings, row, src, column);\n    });\n});\n_api_register(\"cell()\", function(rowSelector, columnSelector, opts) {\n    return _selector_first(this.cells(rowSelector, columnSelector, opts));\n});\n_api_register(\"cell().data()\", function(data) {\n    var ctx = this.context;\n    var cell = this[0];\n    if (data === undefined) {\n        // Get\n        return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined;\n    }\n    // Set\n    _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);\n    _fnInvalidate(ctx[0], cell[0].row, \"data\", cell[0].column);\n    return this;\n});\n/**\n * Get current ordering (sorting) that has been applied to the table.\n *\n * @returns {array} 2D array containing the sorting information for the first\n *   table in the current context. Each element in the parent array represents\n *   a column being sorted upon (i.e. multi-sorting with two columns would have\n *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is\n *   the column index that the sorting condition applies to, the second is the\n *   direction of the sort (`desc` or `asc`) and, optionally, the third is the\n *   index of the sorting order from the `column.sorting` initialisation array.\n */ /**\n * Set the ordering for the table.\n *\n * @param {integer} order Column index to sort upon.\n * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)\n * @returns {DataTables.Api} this\n */ /**\n * Set the ordering for the table.\n *\n * @param {array} order 1D array of sorting information to be applied.\n * @param {array} [...] Optional additional sorting conditions\n * @returns {DataTables.Api} this\n */ /**\n * Set the ordering for the table.\n *\n * @param {array} order 2D array of sorting information to be applied.\n * @returns {DataTables.Api} this\n */ _api_register(\"order()\", function(order, dir) {\n    var ctx = this.context;\n    var args = Array.prototype.slice.call(arguments);\n    if (order === undefined) {\n        // get\n        return ctx.length !== 0 ? ctx[0].aaSorting : undefined;\n    }\n    // set\n    if (typeof order === \"number\") {\n        // Simple column / direction passed in\n        order = [\n            [\n                order,\n                dir\n            ]\n        ];\n    } else if (args.length > 1) {\n        // Arguments passed in (list of 1D arrays)\n        order = args;\n    }\n    // otherwise a 2D array was passed in\n    return this.iterator(\"table\", function(settings) {\n        var resolved = [];\n        _fnSortResolve(settings, resolved, order);\n        settings.aaSorting = resolved;\n    });\n});\n/**\n * Attach a sort listener to an element for a given column\n *\n * @param {node|jQuery|string} node Identifier for the element(s) to attach the\n *   listener to. This can take the form of a single DOM node, a jQuery\n *   collection of nodes or a jQuery selector which will identify the node(s).\n * @param {integer} column the column that a click on this node will sort on\n * @param {function} [callback] callback function when sort is run\n * @returns {DataTables.Api} this\n */ _api_register(\"order.listener()\", function(node, column, callback) {\n    return this.iterator(\"table\", function(settings) {\n        _fnSortAttachListener(settings, node, {}, column, callback);\n    });\n});\n_api_register(\"order.fixed()\", function(set) {\n    if (!set) {\n        var ctx = this.context;\n        var fixed = ctx.length ? ctx[0].aaSortingFixed : undefined;\n        return Array.isArray(fixed) ? {\n            pre: fixed\n        } : fixed;\n    }\n    return this.iterator(\"table\", function(settings) {\n        settings.aaSortingFixed = $.extend(true, {}, set);\n    });\n});\n// Order by the selected column(s)\n_api_register([\n    \"columns().order()\",\n    \"column().order()\"\n], function(dir) {\n    var that = this;\n    if (!dir) {\n        return this.iterator(\"column\", function(settings, idx) {\n            var sort = _fnSortFlatten(settings);\n            for(var i = 0, ien = sort.length; i < ien; i++){\n                if (sort[i].col === idx) {\n                    return sort[i].dir;\n                }\n            }\n            return null;\n        }, 1);\n    } else {\n        return this.iterator(\"table\", function(settings, i) {\n            settings.aaSorting = that[i].map(function(col) {\n                return [\n                    col,\n                    dir\n                ];\n            });\n        });\n    }\n});\n_api_registerPlural(\"columns().orderable()\", \"column().orderable()\", function(directions) {\n    return this.iterator(\"column\", function(settings, idx) {\n        var col = settings.aoColumns[idx];\n        return directions ? col.asSorting : col.bSortable;\n    }, 1);\n});\n_api_register(\"processing()\", function(show) {\n    return this.iterator(\"table\", function(ctx) {\n        _fnProcessingDisplay(ctx, show);\n    });\n});\n_api_register(\"search()\", function(input, regex, smart, caseInsen) {\n    var ctx = this.context;\n    if (input === undefined) {\n        // get\n        return ctx.length !== 0 ? ctx[0].oPreviousSearch.search : undefined;\n    }\n    // set\n    return this.iterator(\"table\", function(settings) {\n        if (!settings.oFeatures.bFilter) {\n            return;\n        }\n        if (typeof regex === \"object\") {\n            // New style options to pass to the search builder\n            _fnFilterComplete(settings, $.extend(settings.oPreviousSearch, regex, {\n                search: input\n            }));\n        } else {\n            // Compat for the old options\n            _fnFilterComplete(settings, $.extend(settings.oPreviousSearch, {\n                search: input,\n                regex: regex === null ? false : regex,\n                smart: smart === null ? true : smart,\n                caseInsensitive: caseInsen === null ? true : caseInsen\n            }));\n        }\n    });\n});\n_api_register(\"search.fixed()\", function(name, search) {\n    var ret = this.iterator(true, \"table\", function(settings) {\n        var fixed = settings.searchFixed;\n        if (!name) {\n            return Object.keys(fixed);\n        } else if (search === undefined) {\n            return fixed[name];\n        } else if (search === null) {\n            delete fixed[name];\n        } else {\n            fixed[name] = search;\n        }\n        return this;\n    });\n    return name !== undefined && search === undefined ? ret[0] : ret;\n});\n_api_registerPlural(\"columns().search()\", \"column().search()\", function(input, regex, smart, caseInsen) {\n    return this.iterator(\"column\", function(settings, column) {\n        var preSearch = settings.aoPreSearchCols;\n        if (input === undefined) {\n            // get\n            return preSearch[column].search;\n        }\n        // set\n        if (!settings.oFeatures.bFilter) {\n            return;\n        }\n        if (typeof regex === \"object\") {\n            // New style options to pass to the search builder\n            $.extend(preSearch[column], regex, {\n                search: input\n            });\n        } else {\n            // Old style (with not all options available)\n            $.extend(preSearch[column], {\n                search: input,\n                regex: regex === null ? false : regex,\n                smart: smart === null ? true : smart,\n                caseInsensitive: caseInsen === null ? true : caseInsen\n            });\n        }\n        _fnFilterComplete(settings, settings.oPreviousSearch);\n    });\n});\n_api_register([\n    \"columns().search.fixed()\",\n    \"column().search.fixed()\"\n], function(name, search) {\n    var ret = this.iterator(true, \"column\", function(settings, colIdx) {\n        var fixed = settings.aoColumns[colIdx].searchFixed;\n        if (!name) {\n            return Object.keys(fixed);\n        } else if (search === undefined) {\n            return fixed[name] || null;\n        } else if (search === null) {\n            delete fixed[name];\n        } else {\n            fixed[name] = search;\n        }\n        return this;\n    });\n    return name !== undefined && search === undefined ? ret[0] : ret;\n});\n/*\n * State API methods\n */ _api_register(\"state()\", function(set, ignoreTime) {\n    // getter\n    if (!set) {\n        return this.context.length ? this.context[0].oSavedState : null;\n    }\n    var setMutate = $.extend(true, {}, set);\n    // setter\n    return this.iterator(\"table\", function(settings) {\n        if (ignoreTime !== false) {\n            setMutate.time = +new Date() + 100;\n        }\n        _fnImplementState(settings, setMutate, function() {});\n    });\n});\n_api_register(\"state.clear()\", function() {\n    return this.iterator(\"table\", function(settings) {\n        // Save an empty object\n        settings.fnStateSaveCallback.call(settings.oInstance, settings, {});\n    });\n});\n_api_register(\"state.loaded()\", function() {\n    return this.context.length ? this.context[0].oLoadedState : null;\n});\n_api_register(\"state.save()\", function() {\n    return this.iterator(\"table\", function(settings) {\n        _fnSaveState(settings);\n    });\n});\n// Can be assigned in DateTable.use() - note luxon and moment vars are in helpers.js\nvar __bootstrap;\nvar __foundation;\n/**\n * Set the libraries that DataTables uses, or the global objects.\n * Note that the arguments can be either way around (legacy support)\n * and the second is optional. See docs.\n */ DataTable.use = function(arg1, arg2) {\n    // Reverse arguments for legacy support\n    var module = typeof arg1 === \"string\" ? arg2 : arg1;\n    var type = typeof arg2 === \"string\" ? arg2 : arg1;\n    // Getter\n    if (module === undefined && typeof type === \"string\") {\n        switch(type){\n            case \"lib\":\n            case \"jq\":\n                return $;\n            case \"win\":\n                return window;\n            case \"datetime\":\n                return DataTable.DateTime;\n            case \"luxon\":\n                return __luxon;\n            case \"moment\":\n                return __moment;\n            case \"bootstrap\":\n                // Use local if set, otherwise try window, which could be undefined\n                return __bootstrap || window.bootstrap;\n            case \"foundation\":\n                // Ditto\n                return __foundation || window.Foundation;\n            default:\n                return null;\n        }\n    }\n    // Setter\n    if (type === \"lib\" || type === \"jq\" || module && module.fn && module.fn.jquery) {\n        $ = module;\n    } else if (type === \"win\" || module && module.document) {\n        window = module;\n        document = module.document;\n    } else if (type === \"datetime\" || module && module.type === \"DateTime\") {\n        DataTable.DateTime = module;\n    } else if (type === \"luxon\" || module && module.FixedOffsetZone) {\n        __luxon = module;\n    } else if (type === \"moment\" || module && module.isMoment) {\n        __moment = module;\n    } else if (type === \"bootstrap\" || module && module.Modal && module.Modal.NAME === \"modal\") {\n        // This is currently for BS5 only. BS3/4 attach to jQuery, so no need to use `.use()`\n        __bootstrap = module;\n    } else if (type === \"foundation\" || module && module.Reveal) {\n        __foundation = module;\n    }\n};\n/**\n * CommonJS factory function pass through. This will check if the arguments\n * given are a window object or a jQuery object. If so they are set\n * accordingly.\n * @param {*} root Window\n * @param {*} jq jQUery\n * @returns {boolean} Indicator\n */ DataTable.factory = function(root, jq) {\n    var is = false;\n    // Test if the first parameter is a window object\n    if (root && root.document) {\n        window = root;\n        document = root.document;\n    }\n    // Test if the second parameter is a jQuery object\n    if (jq && jq.fn && jq.fn.jquery) {\n        $ = jq;\n        is = true;\n    }\n    return is;\n};\n/**\n * Provide a common method for plug-ins to check the version of DataTables being\n * used, in order to ensure compatibility.\n *\n *  @param {string} version Version string to check for, in the format \"X.Y.Z\".\n *    Note that the formats \"X\" and \"X.Y\" are also acceptable.\n *  @param {string} [version2=current DataTables version] As above, but optional.\n *   If not given the current DataTables version will be used.\n *  @returns {boolean} true if this version of DataTables is greater or equal to\n *    the required version, or false if this version of DataTales is not\n *    suitable\n *  @static\n *  @dtopt API-Static\n *\n *  @example\n *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );\n */ DataTable.versionCheck = function(version, version2) {\n    var aThis = version2 ? version2.split(\".\") : DataTable.version.split(\".\");\n    var aThat = version.split(\".\");\n    var iThis, iThat;\n    for(var i = 0, iLen = aThat.length; i < iLen; i++){\n        iThis = parseInt(aThis[i], 10) || 0;\n        iThat = parseInt(aThat[i], 10) || 0;\n        // Parts are the same, keep comparing\n        if (iThis === iThat) {\n            continue;\n        }\n        // Parts are different, return immediately\n        return iThis > iThat;\n    }\n    return true;\n};\n/**\n * Check if a `<table>` node is a DataTable table already or not.\n *\n *  @param {node|jquery|string} table Table node, jQuery object or jQuery\n *      selector for the table to test. Note that if more than more than one\n *      table is passed on, only the first will be checked\n *  @returns {boolean} true the table given is a DataTable, or false otherwise\n *  @static\n *  @dtopt API-Static\n *\n *  @example\n *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {\n *      $('#example').dataTable();\n *    }\n */ DataTable.isDataTable = function(table) {\n    var t = $(table).get(0);\n    var is = false;\n    if (table instanceof DataTable.Api) {\n        return true;\n    }\n    $.each(DataTable.settings, function(i, o) {\n        var head = o.nScrollHead ? $(\"table\", o.nScrollHead)[0] : null;\n        var foot = o.nScrollFoot ? $(\"table\", o.nScrollFoot)[0] : null;\n        if (o.nTable === t || head === t || foot === t) {\n            is = true;\n        }\n    });\n    return is;\n};\n/**\n * Get all DataTable tables that have been initialised - optionally you can\n * select to get only currently visible tables.\n *\n *  @param {boolean} [visible=false] Flag to indicate if you want all (default)\n *    or visible tables only.\n *  @returns {array} Array of `table` nodes (not DataTable instances) which are\n *    DataTables\n *  @static\n *  @dtopt API-Static\n *\n *  @example\n *    $.each( $.fn.dataTable.tables(true), function () {\n *      $(table).DataTable().columns.adjust();\n *    } );\n */ DataTable.tables = function(visible) {\n    var api = false;\n    if ($.isPlainObject(visible)) {\n        api = visible.api;\n        visible = visible.visible;\n    }\n    var a = DataTable.settings.filter(function(o) {\n        return !visible || visible && $(o.nTable).is(\":visible\") ? true : false;\n    }).map(function(o) {\n        return o.nTable;\n    });\n    return api ? new _Api(a) : a;\n};\n/**\n * Convert from camel case parameters to Hungarian notation. This is made public\n * for the extensions to provide the same ability as DataTables core to accept\n * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase\n * parameters.\n *\n *  @param {object} src The model object which holds all parameters that can be\n *    mapped.\n *  @param {object} user The object to convert from camel case to Hungarian.\n *  @param {boolean} force When set to `true`, properties which already have a\n *    Hungarian value in the `user` object will be overwritten. Otherwise they\n *    won't be.\n */ DataTable.camelToHungarian = _fnCamelToHungarian;\n/**\n *\n */ _api_register(\"$()\", function(selector, opts) {\n    var rows = this.rows(opts).nodes(), jqRows = $(rows);\n    return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()));\n});\n// jQuery functions to operate on the tables\n$.each([\n    \"on\",\n    \"one\",\n    \"off\"\n], function(i, key) {\n    _api_register(key + \"()\", function() {\n        var args = Array.prototype.slice.call(arguments);\n        // Add the `dt` namespace automatically if it isn't already present\n        args[0] = args[0].split(/\\s/).map(function(e) {\n            return !e.match(/\\.dt\\b/) ? e + \".dt\" : e;\n        }).join(\" \");\n        var inst = $(this.tables().nodes());\n        inst[key].apply(inst, args);\n        return this;\n    });\n});\n_api_register(\"clear()\", function() {\n    return this.iterator(\"table\", function(settings) {\n        _fnClearTable(settings);\n    });\n});\n_api_register(\"error()\", function(msg) {\n    return this.iterator(\"table\", function(settings) {\n        _fnLog(settings, 0, msg);\n    });\n});\n_api_register(\"settings()\", function() {\n    return new _Api(this.context, this.context);\n});\n_api_register(\"init()\", function() {\n    var ctx = this.context;\n    return ctx.length ? ctx[0].oInit : null;\n});\n_api_register(\"data()\", function() {\n    return this.iterator(\"table\", function(settings) {\n        return _pluck(settings.aoData, \"_aData\");\n    }).flatten();\n});\n_api_register(\"trigger()\", function(name, args, bubbles) {\n    return this.iterator(\"table\", function(settings) {\n        return _fnCallbackFire(settings, null, name, args, bubbles);\n    }).flatten();\n});\n_api_register(\"ready()\", function(fn) {\n    var ctx = this.context;\n    // Get status of first table\n    if (!fn) {\n        return ctx.length ? ctx[0]._bInitComplete || false : null;\n    }\n    // Function to run either once the table becomes ready or\n    // immediately if it is already ready.\n    return this.tables().every(function() {\n        var api = this;\n        if (this.context[0]._bInitComplete) {\n            fn.call(api);\n        } else {\n            this.on(\"init.dt.DT\", function() {\n                fn.call(api);\n            });\n        }\n    });\n});\n_api_register(\"destroy()\", function(remove) {\n    remove = remove || false;\n    return this.iterator(\"table\", function(settings) {\n        var classes = settings.oClasses;\n        var table = settings.nTable;\n        var tbody = settings.nTBody;\n        var thead = settings.nTHead;\n        var tfoot = settings.nTFoot;\n        var jqTable = $(table);\n        var jqTbody = $(tbody);\n        var jqWrapper = $(settings.nTableWrapper);\n        var rows = settings.aoData.map(function(r) {\n            return r ? r.nTr : null;\n        });\n        var orderClasses = classes.order;\n        // Flag to note that the table is currently being destroyed - no action\n        // should be taken\n        settings.bDestroying = true;\n        // Fire off the destroy callbacks for plug-ins etc\n        _fnCallbackFire(settings, \"aoDestroyCallback\", \"destroy\", [\n            settings\n        ], true);\n        // If not being removed from the document, make all columns visible\n        if (!remove) {\n            new _Api(settings).columns().visible(true);\n        }\n        // Container width change listener\n        if (settings.resizeObserver) {\n            settings.resizeObserver.disconnect();\n        }\n        // Blitz all `DT` namespaced events (these are internal events, the\n        // lowercase, `dt` events are user subscribed and they are responsible\n        // for removing them\n        jqWrapper.off(\".DT\").find(\":not(tbody *)\").off(\".DT\");\n        $(window).off(\".DT-\" + settings.sInstance);\n        // When scrolling we had to break the table up - restore it\n        if (table != thead.parentNode) {\n            jqTable.children(\"thead\").detach();\n            jqTable.append(thead);\n        }\n        if (tfoot && table != tfoot.parentNode) {\n            jqTable.children(\"tfoot\").detach();\n            jqTable.append(tfoot);\n        }\n        // Clean up the header / footer\n        cleanHeader(thead, \"header\");\n        cleanHeader(tfoot, \"footer\");\n        settings.colgroup.remove();\n        settings.aaSorting = [];\n        settings.aaSortingFixed = [];\n        _fnSortingClasses(settings);\n        $(jqTable).find(\"th, td\").removeClass($.map(DataTable.ext.type.className, function(v) {\n            return v;\n        }).join(\" \"));\n        $(\"th, td\", thead).removeClass(orderClasses.none + \" \" + orderClasses.canAsc + \" \" + orderClasses.canDesc + \" \" + orderClasses.isAsc + \" \" + orderClasses.isDesc).css(\"width\", \"\").removeAttr(\"aria-sort\");\n        // Add the TR elements back into the table in their original order\n        jqTbody.children().detach();\n        jqTbody.append(rows);\n        var orig = settings.nTableWrapper.parentNode;\n        var insertBefore = settings.nTableWrapper.nextSibling;\n        // Remove the DataTables generated nodes, events and classes\n        var removedMethod = remove ? \"remove\" : \"detach\";\n        jqTable[removedMethod]();\n        jqWrapper[removedMethod]();\n        // If we need to reattach the table to the document\n        if (!remove && orig) {\n            // insertBefore acts like appendChild if !arg[1]\n            orig.insertBefore(table, insertBefore);\n            // Restore the width of the original table - was read from the style property,\n            // so we can restore directly to that\n            jqTable.css(\"width\", settings.sDestroyWidth).removeClass(classes.table);\n        }\n        /* Remove the settings object from the settings array */ var idx = DataTable.settings.indexOf(settings);\n        if (idx !== -1) {\n            DataTable.settings.splice(idx, 1);\n        }\n    });\n});\n// Add the `every()` method for rows, columns and cells in a compact form\n$.each([\n    \"column\",\n    \"row\",\n    \"cell\"\n], function(i, type) {\n    _api_register(type + \"s().every()\", function(fn) {\n        var opts = this.selector.opts;\n        var api = this;\n        var inst;\n        var counter = 0;\n        return this.iterator(\"every\", function(settings, selectedIdx, tableIdx) {\n            inst = api[type](selectedIdx, opts);\n            if (type === \"cell\") {\n                fn.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);\n            } else {\n                fn.call(inst, selectedIdx, tableIdx, counter);\n            }\n            counter++;\n        });\n    });\n});\n// i18n method for extensions to be able to use the language object from the\n// DataTable\n_api_register(\"i18n()\", function(token, def, plural) {\n    var ctx = this.context[0];\n    var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);\n    if (resolved === undefined) {\n        resolved = def;\n    }\n    if ($.isPlainObject(resolved)) {\n        resolved = plural !== undefined && resolved[plural] !== undefined ? resolved[plural] : resolved._;\n    }\n    return typeof resolved === \"string\" ? resolved.replace(\"%d\", plural) // nb: plural might be undefined,\n     : resolved;\n});\n// Needed for header and footer, so pulled into its own function\nfunction cleanHeader(node, className) {\n    $(node).find(\"span.dt-column-order\").remove();\n    $(node).find(\"span.dt-column-title\").each(function() {\n        var title = $(this).html();\n        $(this).parent().parent().append(title);\n        $(this).remove();\n    });\n    $(node).find(\"div.dt-column-\" + className).remove();\n    $(\"th, td\", node).removeAttr(\"data-dt-column\");\n}\n/**\n * Version string for plug-ins to check compatibility. Allowed format is\n * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used\n * only for non-release builds. See https://semver.org/ for more information.\n *  @member\n *  @type string\n *  @default Version number\n */ DataTable.version = \"2.3.0\";\n/**\n * Private data store, containing all of the settings objects that are\n * created for the tables on a given page.\n *\n * Note that the `DataTable.settings` object is aliased to\n * `jQuery.fn.dataTableExt` through which it may be accessed and\n * manipulated, or `jQuery.fn.dataTable.settings`.\n *  @member\n *  @type array\n *  @default []\n *  @private\n */ DataTable.settings = [];\n/**\n * Object models container, for the various models that DataTables has\n * available to it. These models define the objects that are used to hold\n * the active state and configuration of the table.\n *  @namespace\n */ DataTable.models = {};\n/**\n * Template object for the way in which DataTables holds information about\n * search information for the global filter and individual column filters.\n *  @namespace\n */ DataTable.models.oSearch = {\n    /**\n\t * Flag to indicate if the filtering should be case insensitive or not\n\t */ \"caseInsensitive\": true,\n    /**\n\t * Applied search term\n\t */ \"search\": \"\",\n    /**\n\t * Flag to indicate if the search term should be interpreted as a\n\t * regular expression (true) or not (false) and therefore and special\n\t * regex characters escaped.\n\t */ \"regex\": false,\n    /**\n\t * Flag to indicate if DataTables is to use its smart filtering or not.\n\t */ \"smart\": true,\n    /**\n\t * Flag to indicate if DataTables should only trigger a search when\n\t * the return key is pressed.\n\t */ \"return\": false\n};\n/**\n * Template object for the way in which DataTables holds information about\n * each individual row. This is the object format used for the settings\n * aoData array.\n *  @namespace\n */ DataTable.models.oRow = {\n    /**\n\t * TR element for the row\n\t */ \"nTr\": null,\n    /**\n\t * Array of TD elements for each row. This is null until the row has been\n\t * created.\n\t */ \"anCells\": null,\n    /**\n\t * Data object from the original data source for the row. This is either\n\t * an array if using the traditional form of DataTables, or an object if\n\t * using mData options. The exact type will depend on the passed in\n\t * data from the data source, or will be an array if using DOM a data\n\t * source.\n\t */ \"_aData\": [],\n    /**\n\t * Sorting data cache - this array is ostensibly the same length as the\n\t * number of columns (although each index is generated only as it is\n\t * needed), and holds the data that is used for sorting each column in the\n\t * row. We do this cache generation at the start of the sort in order that\n\t * the formatting of the sort data need be done only once for each cell\n\t * per sort. This array should not be read from or written to by anything\n\t * other than the master sorting methods.\n\t */ \"_aSortData\": null,\n    /**\n\t * Per cell filtering data cache. As per the sort data cache, used to\n\t * increase the performance of the filtering in DataTables\n\t */ \"_aFilterData\": null,\n    /**\n\t * Filtering data cache. This is the same as the cell filtering cache, but\n\t * in this case a string rather than an array. This is easily computed with\n\t * a join on `_aFilterData`, but is provided as a cache so the join isn't\n\t * needed on every search (memory traded for performance)\n\t */ \"_sFilterRow\": null,\n    /**\n\t * Denote if the original data source was from the DOM, or the data source\n\t * object. This is used for invalidating data, so DataTables can\n\t * automatically read data from the original source, unless uninstructed\n\t * otherwise.\n\t */ \"src\": null,\n    /**\n\t * Index in the aoData array. This saves an indexOf lookup when we have the\n\t * object, but want to know the index\n\t */ \"idx\": -1,\n    /**\n\t * Cached display value\n\t */ displayData: null\n};\n/**\n * Template object for the column information object in DataTables. This object\n * is held in the settings aoColumns array and contains all the information that\n * DataTables needs about each individual column.\n *\n * Note that this object is related to {@link DataTable.defaults.column}\n * but this one is the internal data store for DataTables's cache of columns.\n * It should NOT be manipulated outside of DataTables. Any configuration should\n * be done through the initialisation options.\n *  @namespace\n */ DataTable.models.oColumn = {\n    /**\n\t * Column index.\n\t */ \"idx\": null,\n    /**\n\t * A list of the columns that sorting should occur on when this column\n\t * is sorted. That this property is an array allows multi-column sorting\n\t * to be defined for a column (for example first name / last name columns\n\t * would benefit from this). The values are integers pointing to the\n\t * columns to be sorted on (typically it will be a single integer pointing\n\t * at itself, but that doesn't need to be the case).\n\t */ \"aDataSort\": null,\n    /**\n\t * Define the sorting directions that are applied to the column, in sequence\n\t * as the column is repeatedly sorted upon - i.e. the first value is used\n\t * as the sorting direction when the column if first sorted (clicked on).\n\t * Sort it again (click again) and it will move on to the next index.\n\t * Repeat until loop.\n\t */ \"asSorting\": null,\n    /**\n\t * Flag to indicate if the column is searchable, and thus should be included\n\t * in the filtering or not.\n\t */ \"bSearchable\": null,\n    /**\n\t * Flag to indicate if the column is sortable or not.\n\t */ \"bSortable\": null,\n    /**\n\t * Flag to indicate if the column is currently visible in the table or not\n\t */ \"bVisible\": null,\n    /**\n\t * Store for manual type assignment using the `column.type` option. This\n\t * is held in store so we can manipulate the column's `sType` property.\n\t */ \"_sManualType\": null,\n    /**\n\t * Flag to indicate if HTML5 data attributes should be used as the data\n\t * source for filtering or sorting. True is either are.\n\t */ \"_bAttrSrc\": false,\n    /**\n\t * Developer definable function that is called whenever a cell is created (Ajax source,\n\t * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n\t * allowing you to modify the DOM element (add background colour for example) when the\n\t * element is available.\n\t */ \"fnCreatedCell\": null,\n    /**\n\t * Function to get data from a cell in a column. You should <b>never</b>\n\t * access data directly through _aData internally in DataTables - always use\n\t * the method attached to this property. It allows mData to function as\n\t * required. This function is automatically assigned by the column\n\t * initialisation method\n\t */ \"fnGetData\": null,\n    /**\n\t * Function to set data for a cell in the column. You should <b>never</b>\n\t * set the data directly to _aData internally in DataTables - always use\n\t * this method. It allows mData to function as required. This function\n\t * is automatically assigned by the column initialisation method\n\t */ \"fnSetData\": null,\n    /**\n\t * Property to read the value for the cells in the column from the data\n\t * source array / object. If null, then the default content is used, if a\n\t * function is given then the return from the function is used.\n\t */ \"mData\": null,\n    /**\n\t * Partner property to mData which is used (only when defined) to get\n\t * the data - i.e. it is basically the same as mData, but without the\n\t * 'set' option, and also the data fed to it is the result from mData.\n\t * This is the rendering method to match the data method of mData.\n\t */ \"mRender\": null,\n    /**\n\t * The class to apply to all TD elements in the table's TBODY for the column\n\t */ \"sClass\": null,\n    /**\n\t * When DataTables calculates the column widths to assign to each column,\n\t * it finds the longest string in each column and then constructs a\n\t * temporary table and reads the widths from that. The problem with this\n\t * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n\t * string - thus the calculation can go wrong (doing it properly and putting\n\t * it into an DOM object and measuring that is horribly(!) slow). Thus as\n\t * a \"work around\" we provide this option. It will append its value to the\n\t * text that is found to be the longest string for the column - i.e. padding.\n\t */ \"sContentPadding\": null,\n    /**\n\t * Allows a default value to be given for a column's data, and will be used\n\t * whenever a null data source is encountered (this can be because mData\n\t * is set to null, or because the data source itself is null).\n\t */ \"sDefaultContent\": null,\n    /**\n\t * Name for the column, allowing reference to the column by name as well as\n\t * by index (needs a lookup to work by name).\n\t */ \"sName\": null,\n    /**\n\t * Custom sorting data type - defines which of the available plug-ins in\n\t * afnSortData the custom sorting will use - if any is defined.\n\t */ \"sSortDataType\": \"std\",\n    /**\n\t * Class to be applied to the header element when sorting on this column\n\t */ \"sSortingClass\": null,\n    /**\n\t * Title of the column - what is seen in the TH element (nTh).\n\t */ \"sTitle\": null,\n    /**\n\t * Column sorting and filtering type\n\t */ \"sType\": null,\n    /**\n\t * Width of the column\n\t */ \"sWidth\": null,\n    /**\n\t * Width of the column when it was first \"encountered\"\n\t */ \"sWidthOrig\": null,\n    /** Cached string which is the longest in the column */ maxLenString: null,\n    /**\n\t * Store for named searches\n\t */ searchFixed: null\n};\n/*\n * Developer note: The properties of the object below are given in Hungarian\n * notation, that was used as the interface for DataTables prior to v1.10, however\n * from v1.10 onwards the primary interface is camel case. In order to avoid\n * breaking backwards compatibility utterly with this change, the Hungarian\n * version is still, internally the primary interface, but is is not documented\n * - hence the @name tags in each doc comment. This allows a Javascript function\n * to create a map from Hungarian notation to camel case (going the other direction\n * would require each property to be listed, which would add around 3K to the size\n * of DataTables, while this method is about a 0.5K hit).\n *\n * Ultimately this does pave the way for Hungarian notation to be dropped\n * completely, but that is a massive amount of work and will break current\n * installs (therefore is on-hold until v2).\n */ /**\n * Initialisation options that can be given to DataTables at initialisation\n * time.\n *  @namespace\n */ DataTable.defaults = {\n    /**\n\t * An array of data to use for the table, passed in at initialisation which\n\t * will be used in preference to any data which is already in the DOM. This is\n\t * particularly useful for constructing tables purely in Javascript, for\n\t * example with a custom Ajax call.\n\t */ \"aaData\": null,\n    /**\n\t * If ordering is enabled, then DataTables will perform a first pass sort on\n\t * initialisation. You can define which column(s) the sort is performed\n\t * upon, and the sorting direction, with this variable. The `sorting` array\n\t * should contain an array for each column to be sorted initially containing\n\t * the column's index and a direction string ('asc' or 'desc').\n\t */ \"aaSorting\": [\n        [\n            0,\n            \"asc\"\n        ]\n    ],\n    /**\n\t * This parameter is basically identical to the `sorting` parameter, but\n\t * cannot be overridden by user interaction with the table. What this means\n\t * is that you could have a column (visible or hidden) which the sorting\n\t * will always be forced on first - any sorting after that (from the user)\n\t * will then be performed as required. This can be useful for grouping rows\n\t * together.\n\t */ \"aaSortingFixed\": [],\n    /**\n\t * DataTables can be instructed to load data to display in the table from a\n\t * Ajax source. This option defines how that Ajax call is made and where to.\n\t *\n\t * The `ajax` property has three different modes of operation, depending on\n\t * how it is defined. These are:\n\t *\n\t * * `string` - Set the URL from where the data should be loaded from.\n\t * * `object` - Define properties for `jQuery.ajax`.\n\t * * `function` - Custom data get function\n\t *\n\t * `string`\n\t * --------\n\t *\n\t * As a string, the `ajax` property simply defines the URL from which\n\t * DataTables will load data.\n\t *\n\t * `object`\n\t * --------\n\t *\n\t * As an object, the parameters in the object are passed to\n\t * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control\n\t * of the Ajax request. DataTables has a number of default parameters which\n\t * you can override using this option. Please refer to the jQuery\n\t * documentation for a full description of the options available, although\n\t * the following parameters provide additional options in DataTables or\n\t * require special consideration:\n\t *\n\t * * `data` - As with jQuery, `data` can be provided as an object, but it\n\t *   can also be used as a function to manipulate the data DataTables sends\n\t *   to the server. The function takes a single parameter, an object of\n\t *   parameters with the values that DataTables has readied for sending. An\n\t *   object may be returned which will be merged into the DataTables\n\t *   defaults, or you can add the items to the object that was passed in and\n\t *   not return anything from the function. This supersedes `fnServerParams`\n\t *   from DataTables 1.9-.\n\t *\n\t * * `dataSrc` - By default DataTables will look for the property `data` (or\n\t *   `aaData` for compatibility with DataTables 1.9-) when obtaining data\n\t *   from an Ajax source or for server-side processing - this parameter\n\t *   allows that property to be changed. You can use Javascript dotted\n\t *   object notation to get a data source for multiple levels of nesting, or\n\t *   it my be used as a function. As a function it takes a single parameter,\n\t *   the JSON returned from the server, which can be manipulated as\n\t *   required, with the returned value being that used by DataTables as the\n\t *   data source for the table.\n\t *\n\t * * `success` - Should not be overridden it is used internally in\n\t *   DataTables. To manipulate / transform the data returned by the server\n\t *   use `ajax.dataSrc`, or use `ajax` as a function (see below).\n\t *\n\t * `function`\n\t * ----------\n\t *\n\t * As a function, making the Ajax call is left up to yourself allowing\n\t * complete control of the Ajax request. Indeed, if desired, a method other\n\t * than Ajax could be used to obtain the required data, such as Web storage\n\t * or an AIR database.\n\t *\n\t * The function is given four parameters and no return is required. The\n\t * parameters are:\n\t *\n\t * 1. _object_ - Data to send to the server\n\t * 2. _function_ - Callback function that must be executed when the required\n\t *    data has been obtained. That data should be passed into the callback\n\t *    as the only parameter\n\t * 3. _object_ - DataTables settings object for the table\n\t */ \"ajax\": null,\n    /**\n\t * This parameter allows you to readily specify the entries in the length drop\n\t * down menu that DataTables shows when pagination is enabled. It can be\n\t * either a 1D array of options which will be used for both the displayed\n\t * option and the value, or a 2D array which will use the array in the first\n\t * position as the value, and the array in the second position as the\n\t * displayed options (useful for language strings such as 'All').\n\t *\n\t * Note that the `pageLength` property will be automatically set to the\n\t * first value given in this array, unless `pageLength` is also provided.\n\t */ \"aLengthMenu\": [\n        10,\n        25,\n        50,\n        100\n    ],\n    /**\n\t * The `columns` option in the initialisation parameter allows you to define\n\t * details about the way individual columns behave. For a full list of\n\t * column options that can be set, please see\n\t * {@link DataTable.defaults.column}. Note that if you use `columns` to\n\t * define your columns, you must have an entry in the array for every single\n\t * column that you have in your table (these can be null if you don't which\n\t * to specify any options).\n\t */ \"aoColumns\": null,\n    /**\n\t * Very similar to `columns`, `columnDefs` allows you to target a specific\n\t * column, multiple columns, or all columns, using the `targets` property of\n\t * each object in the array. This allows great flexibility when creating\n\t * tables, as the `columnDefs` arrays can be of any length, targeting the\n\t * columns you specifically want. `columnDefs` may use any of the column\n\t * options available: {@link DataTable.defaults.column}, but it _must_\n\t * have `targets` defined in each object in the array. Values in the `targets`\n\t * array may be:\n\t *   <ul>\n\t *     <li>a string - class name will be matched on the TH for the column</li>\n\t *     <li>0 or a positive integer - column index counting from the left</li>\n\t *     <li>a negative integer - column index counting from the right</li>\n\t *     <li>the string \"_all\" - all columns (i.e. assign a default)</li>\n\t *   </ul>\n\t */ \"aoColumnDefs\": null,\n    /**\n\t * Basically the same as `search`, this parameter defines the individual column\n\t * filtering state at initialisation time. The array must be of the same size\n\t * as the number of columns, and each element be an object with the parameters\n\t * `search` and `escapeRegex` (the latter is optional). 'null' is also\n\t * accepted and the default will be used.\n\t */ \"aoSearchCols\": [],\n    /**\n\t * Enable or disable automatic column width calculation. This can be disabled\n\t * as an optimisation (it takes some time to calculate the widths) if the\n\t * tables widths are passed in using `columns`.\n\t */ \"bAutoWidth\": true,\n    /**\n\t * Deferred rendering can provide DataTables with a huge speed boost when you\n\t * are using an Ajax or JS data source for the table. This option, when set to\n\t * true, will cause DataTables to defer the creation of the table elements for\n\t * each row until they are needed for a draw - saving a significant amount of\n\t * time.\n\t */ \"bDeferRender\": true,\n    /**\n\t * Replace a DataTable which matches the given selector and replace it with\n\t * one which has the properties of the new initialisation object passed. If no\n\t * table matches the selector, then the new DataTable will be constructed as\n\t * per normal.\n\t */ \"bDestroy\": false,\n    /**\n\t * Enable or disable filtering of data. Filtering in DataTables is \"smart\" in\n\t * that it allows the end user to input multiple words (space separated) and\n\t * will match a row containing those words, even if not in the order that was\n\t * specified (this allow matching across multiple columns). Note that if you\n\t * wish to use filtering in DataTables this must remain 'true' - to remove the\n\t * default filtering input box and retain filtering abilities, please use\n\t * {@link DataTable.defaults.dom}.\n\t */ \"bFilter\": true,\n    /**\n\t * Used only for compatiblity with DT1\n\t * @deprecated\n\t */ \"bInfo\": true,\n    /**\n\t * Used only for compatiblity with DT1\n\t * @deprecated\n\t */ \"bLengthChange\": true,\n    /**\n\t * Enable or disable pagination.\n\t */ \"bPaginate\": true,\n    /**\n\t * Enable or disable the display of a 'processing' indicator when the table is\n\t * being processed (e.g. a sort). This is particularly useful for tables with\n\t * large amounts of data where it can take a noticeable amount of time to sort\n\t * the entries.\n\t */ \"bProcessing\": false,\n    /**\n\t * Retrieve the DataTables object for the given selector. Note that if the\n\t * table has already been initialised, this parameter will cause DataTables\n\t * to simply return the object that has already been set up - it will not take\n\t * account of any changes you might have made to the initialisation object\n\t * passed to DataTables (setting this parameter to true is an acknowledgement\n\t * that you understand this). `destroy` can be used to reinitialise a table if\n\t * you need.\n\t */ \"bRetrieve\": false,\n    /**\n\t * When vertical (y) scrolling is enabled, DataTables will force the height of\n\t * the table's viewport to the given height at all times (useful for layout).\n\t * However, this can look odd when filtering data down to a small data set,\n\t * and the footer is left \"floating\" further down. This parameter (when\n\t * enabled) will cause DataTables to collapse the table's viewport down when\n\t * the result set will fit within the given Y height.\n\t */ \"bScrollCollapse\": false,\n    /**\n\t * Configure DataTables to use server-side processing. Note that the\n\t * `ajax` parameter must also be given in order to give DataTables a\n\t * source to obtain the required data for each draw.\n\t */ \"bServerSide\": false,\n    /**\n\t * Enable or disable sorting of columns. Sorting of individual columns can be\n\t * disabled by the `sortable` option for each column.\n\t */ \"bSort\": true,\n    /**\n\t * Enable or display DataTables' ability to sort multiple columns at the\n\t * same time (activated by shift-click by the user).\n\t */ \"bSortMulti\": true,\n    /**\n\t * Allows control over whether DataTables should use the top (true) unique\n\t * cell that is found for a single column, or the bottom (false - default).\n\t * This is useful when using complex headers.\n\t */ \"bSortCellsTop\": null,\n    /** Specify which row is the title row in the header. Replacement for bSortCellsTop */ titleRow: null,\n    /**\n\t * Enable or disable the addition of the classes `sorting\\_1`, `sorting\\_2` and\n\t * `sorting\\_3` to the columns which are currently being sorted on. This is\n\t * presented as a feature switch as it can increase processing time (while\n\t * classes are removed and added) so for large data sets you might want to\n\t * turn this off.\n\t */ \"bSortClasses\": true,\n    /**\n\t * Enable or disable state saving. When enabled HTML5 `localStorage` will be\n\t * used to save table display information such as pagination information,\n\t * display length, filtering and sorting. As such when the end user reloads\n\t * the page the display display will match what thy had previously set up.\n\t */ \"bStateSave\": false,\n    /**\n\t * This function is called when a TR element is created (and all TD child\n\t * elements have been inserted), or registered if using a DOM source, allowing\n\t * manipulation of the TR element (adding classes etc).\n\t */ \"fnCreatedRow\": null,\n    /**\n\t * This function is called on every 'draw' event, and allows you to\n\t * dynamically modify any aspect you want about the created DOM.\n\t */ \"fnDrawCallback\": null,\n    /**\n\t * Identical to fnHeaderCallback() but for the table footer this function\n\t * allows you to modify the table footer on every 'draw' event.\n\t */ \"fnFooterCallback\": null,\n    /**\n\t * When rendering large numbers in the information element for the table\n\t * (i.e. \"Showing 1 to 10 of 57 entries\") DataTables will render large numbers\n\t * to have a comma separator for the 'thousands' units (e.g. 1 million is\n\t * rendered as \"1,000,000\") to help readability for the end user. This\n\t * function will override the default method DataTables uses.\n\t */ \"fnFormatNumber\": function(toFormat) {\n        return toFormat.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.oLanguage.sThousands);\n    },\n    /**\n\t * This function is called on every 'draw' event, and allows you to\n\t * dynamically modify the header row. This can be used to calculate and\n\t * display useful information about the table.\n\t */ \"fnHeaderCallback\": null,\n    /**\n\t * The information element can be used to convey information about the current\n\t * state of the table. Although the internationalisation options presented by\n\t * DataTables are quite capable of dealing with most customisations, there may\n\t * be times where you wish to customise the string further. This callback\n\t * allows you to do exactly that.\n\t */ \"fnInfoCallback\": null,\n    /**\n\t * Called when the table has been initialised. Normally DataTables will\n\t * initialise sequentially and there will be no need for this function,\n\t * however, this does not hold true when using external language information\n\t * since that is obtained using an async XHR call.\n\t */ \"fnInitComplete\": null,\n    /**\n\t * Called at the very start of each table draw and can be used to cancel the\n\t * draw by returning false, any other return (including undefined) results in\n\t * the full draw occurring).\n\t */ \"fnPreDrawCallback\": null,\n    /**\n\t * This function allows you to 'post process' each row after it have been\n\t * generated for each table draw, but before it is rendered on screen. This\n\t * function might be used for setting the row class name etc.\n\t */ \"fnRowCallback\": null,\n    /**\n\t * Load the table state. With this function you can define from where, and how, the\n\t * state of a table is loaded. By default DataTables will load from `localStorage`\n\t * but you might wish to use a server-side database or cookies.\n\t */ \"fnStateLoadCallback\": function(settings) {\n        try {\n            return JSON.parse((settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(\"DataTables_\" + settings.sInstance + \"_\" + location.pathname));\n        } catch (e) {\n            return {};\n        }\n    },\n    /**\n\t * Callback which allows modification of the saved state prior to loading that state.\n\t * This callback is called when the table is loading state from the stored data, but\n\t * prior to the settings object being modified by the saved state. Note that for\n\t * plug-in authors, you should use the `stateLoadParams` event to load parameters for\n\t * a plug-in.\n\t */ \"fnStateLoadParams\": null,\n    /**\n\t * Callback that is called when the state has been loaded from the state saving method\n\t * and the DataTables settings object has been modified as a result of the loaded state.\n\t */ \"fnStateLoaded\": null,\n    /**\n\t * Save the table state. This function allows you to define where and how the state\n\t * information for the table is stored By default DataTables will use `localStorage`\n\t * but you might wish to use a server-side database or cookies.\n\t */ \"fnStateSaveCallback\": function(settings, data) {\n        try {\n            (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(\"DataTables_\" + settings.sInstance + \"_\" + location.pathname, JSON.stringify(data));\n        } catch (e) {\n        // noop\n        }\n    },\n    /**\n\t * Callback which allows modification of the state to be saved. Called when the table\n\t * has changed state a new state save is required. This method allows modification of\n\t * the state saving object prior to actually doing the save, including addition or\n\t * other state properties or modification. Note that for plug-in authors, you should\n\t * use the `stateSaveParams` event to save parameters for a plug-in.\n\t */ \"fnStateSaveParams\": null,\n    /**\n\t * Duration for which the saved state information is considered valid. After this period\n\t * has elapsed the state will be returned to the default.\n\t * Value is given in seconds.\n\t */ \"iStateDuration\": 7200,\n    /**\n\t * Number of rows to display on a single page when using pagination. If\n\t * feature enabled (`lengthChange`) then the end user will be able to override\n\t * this to a custom setting using a pop-up menu.\n\t */ \"iDisplayLength\": 10,\n    /**\n\t * Define the starting point for data display when using DataTables with\n\t * pagination. Note that this parameter is the number of records, rather than\n\t * the page number, so if you have 10 records per page and want to start on\n\t * the third page, it should be \"20\".\n\t */ \"iDisplayStart\": 0,\n    /**\n\t * By default DataTables allows keyboard navigation of the table (sorting, paging,\n\t * and filtering) by adding a `tabindex` attribute to the required elements. This\n\t * allows you to tab through the controls and press the enter key to activate them.\n\t * The tabindex is default 0, meaning that the tab follows the flow of the document.\n\t * You can overrule this using this parameter if you wish. Use a value of -1 to\n\t * disable built-in keyboard navigation.\n\t */ \"iTabIndex\": 0,\n    /**\n\t * Classes that DataTables assigns to the various components and features\n\t * that it adds to the HTML table. This allows classes to be configured\n\t * during initialisation in addition to through the static\n\t * {@link DataTable.ext.oStdClasses} object).\n\t */ \"oClasses\": {},\n    /**\n\t * All strings that DataTables uses in the user interface that it creates\n\t * are defined in this object, allowing you to modified them individually or\n\t * completely replace them all as required.\n\t */ \"oLanguage\": {\n        /**\n\t\t * Strings that are used for WAI-ARIA labels and controls only (these are not\n\t\t * actually visible on the page, but will be read by screenreaders, and thus\n\t\t * must be internationalised as well).\n\t\t */ \"oAria\": {\n            /**\n\t\t\t * ARIA label that is added to the table headers when the column may be sorted\n\t\t\t */ \"orderable\": \": Activate to sort\",\n            /**\n\t\t\t * ARIA label that is added to the table headers when the column is currently being sorted\n\t\t\t */ \"orderableReverse\": \": Activate to invert sorting\",\n            /**\n\t\t\t * ARIA label that is added to the table headers when the column is currently being \n\t\t\t * sorted and next step is to remove sorting\n\t\t\t */ \"orderableRemove\": \": Activate to remove sorting\",\n            paginate: {\n                first: \"First\",\n                last: \"Last\",\n                next: \"Next\",\n                previous: \"Previous\",\n                number: \"\"\n            }\n        },\n        /**\n\t\t * Pagination string used by DataTables for the built-in pagination\n\t\t * control types.\n\t\t */ \"oPaginate\": {\n            /**\n\t\t\t * Label and character for first page button («)\n\t\t\t */ \"sFirst\": \"\\xab\",\n            /**\n\t\t\t * Last page button (»)\n\t\t\t */ \"sLast\": \"\\xbb\",\n            /**\n\t\t\t * Next page button (›)\n\t\t\t */ \"sNext\": \"›\",\n            /**\n\t\t\t * Previous page button (‹)\n\t\t\t */ \"sPrevious\": \"‹\"\n        },\n        /**\n\t\t * Plural object for the data type the table is showing\n\t\t */ entries: {\n            _: \"entries\",\n            1: \"entry\"\n        },\n        /**\n\t\t * Page length options\n\t\t */ lengthLabels: {\n            \"-1\": \"All\"\n        },\n        /**\n\t\t * This string is shown in preference to `zeroRecords` when the table is\n\t\t * empty of data (regardless of filtering). Note that this is an optional\n\t\t * parameter - if it is not given, the value of `zeroRecords` will be used\n\t\t * instead (either the default or given value).\n\t\t */ \"sEmptyTable\": \"No data available in table\",\n        /**\n\t\t * This string gives information to the end user about the information\n\t\t * that is current on display on the page. The following tokens can be\n\t\t * used in the string and will be dynamically replaced as the table\n\t\t * display updates. This tokens can be placed anywhere in the string, or\n\t\t * removed as needed by the language requires:\n\t\t *\n\t\t * * `\\_START\\_` - Display index of the first record on the current page\n\t\t * * `\\_END\\_` - Display index of the last record on the current page\n\t\t * * `\\_TOTAL\\_` - Number of records in the table after filtering\n\t\t * * `\\_MAX\\_` - Number of records in the table without filtering\n\t\t * * `\\_PAGE\\_` - Current page number\n\t\t * * `\\_PAGES\\_` - Total number of pages of data in the table\n\t\t */ \"sInfo\": \"Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_\",\n        /**\n\t\t * Display information string for when the table is empty. Typically the\n\t\t * format of this string should match `info`.\n\t\t */ \"sInfoEmpty\": \"Showing 0 to 0 of 0 _ENTRIES-TOTAL_\",\n        /**\n\t\t * When a user filters the information in a table, this string is appended\n\t\t * to the information (`info`) to give an idea of how strong the filtering\n\t\t * is. The variable _MAX_ is dynamically updated.\n\t\t */ \"sInfoFiltered\": \"(filtered from _MAX_ total _ENTRIES-MAX_)\",\n        /**\n\t\t * If can be useful to append extra information to the info string at times,\n\t\t * and this variable does exactly that. This information will be appended to\n\t\t * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are\n\t\t * being used) at all times.\n\t\t */ \"sInfoPostFix\": \"\",\n        /**\n\t\t * This decimal place operator is a little different from the other\n\t\t * language options since DataTables doesn't output floating point\n\t\t * numbers, so it won't ever use this for display of a number. Rather,\n\t\t * what this parameter does is modify the sort methods of the table so\n\t\t * that numbers which are in a format which has a character other than\n\t\t * a period (`.`) as a decimal place will be sorted numerically.\n\t\t *\n\t\t * Note that numbers with different decimal places cannot be shown in\n\t\t * the same table and still be sortable, the table must be consistent.\n\t\t * However, multiple different tables on the page can use different\n\t\t * decimal place characters.\n\t\t */ \"sDecimal\": \"\",\n        /**\n\t\t * DataTables has a build in number formatter (`formatNumber`) which is\n\t\t * used to format large numbers that are used in the table information.\n\t\t * By default a comma is used, but this can be trivially changed to any\n\t\t * character you wish with this parameter.\n\t\t */ \"sThousands\": \",\",\n        /**\n\t\t * Detail the action that will be taken when the drop down menu for the\n\t\t * pagination length option is changed. The '_MENU_' variable is replaced\n\t\t * with a default select list of 10, 25, 50 and 100, and can be replaced\n\t\t * with a custom select box if required.\n\t\t */ \"sLengthMenu\": \"_MENU_ _ENTRIES_ per page\",\n        /**\n\t\t * When using Ajax sourced data and during the first draw when DataTables is\n\t\t * gathering the data, this message is shown in an empty row in the table to\n\t\t * indicate to the end user the the data is being loaded. Note that this\n\t\t * parameter is not used when loading data by server-side processing, just\n\t\t * Ajax sourced data with client-side processing.\n\t\t */ \"sLoadingRecords\": \"Loading...\",\n        /**\n\t\t * Text which is displayed when the table is processing a user action\n\t\t * (usually a sort command or similar).\n\t\t */ \"sProcessing\": \"\",\n        /**\n\t\t * Details the actions that will be taken when the user types into the\n\t\t * filtering input text box. The variable \"_INPUT_\", if used in the string,\n\t\t * is replaced with the HTML text box for the filtering input allowing\n\t\t * control over where it appears in the string. If \"_INPUT_\" is not given\n\t\t * then the input box is appended to the string automatically.\n\t\t */ \"sSearch\": \"Search:\",\n        /**\n\t\t * Assign a `placeholder` attribute to the search `input` element\n\t\t *  @type string\n\t\t *  @default \n\t\t *\n\t\t *  @dtopt Language\n\t\t *  @name DataTable.defaults.language.searchPlaceholder\n\t\t */ \"sSearchPlaceholder\": \"\",\n        /**\n\t\t * All of the language information can be stored in a file on the\n\t\t * server-side, which DataTables will look up if this parameter is passed.\n\t\t * It must store the URL of the language file, which is in a JSON format,\n\t\t * and the object has the same properties as the oLanguage object in the\n\t\t * initialiser object (i.e. the above parameters). Please refer to one of\n\t\t * the example language files to see how this works in action.\n\t\t */ \"sUrl\": \"\",\n        /**\n\t\t * Text shown inside the table records when the is no information to be\n\t\t * displayed after filtering. `emptyTable` is shown when there is simply no\n\t\t * information in the table at all (regardless of filtering).\n\t\t */ \"sZeroRecords\": \"No matching records found\"\n    },\n    /** The initial data order is reversed when `desc` ordering */ orderDescReverse: true,\n    /**\n\t * This parameter allows you to have define the global filtering state at\n\t * initialisation time. As an object the `search` parameter must be\n\t * defined, but all other parameters are optional. When `regex` is true,\n\t * the search string will be treated as a regular expression, when false\n\t * (default) it will be treated as a straight string. When `smart`\n\t * DataTables will use it's smart filtering methods (to word match at\n\t * any point in the data), when false this will not be done.\n\t */ \"oSearch\": $.extend({}, DataTable.models.oSearch),\n    /**\n\t * Table and control layout. This replaces the legacy `dom` option.\n\t */ layout: {\n        topStart: \"pageLength\",\n        topEnd: \"search\",\n        bottomStart: \"info\",\n        bottomEnd: \"paging\"\n    },\n    /**\n\t * Legacy DOM layout option\n\t */ \"sDom\": null,\n    /**\n\t * Search delay option. This will throttle full table searches that use the\n\t * DataTables provided search input element (it does not effect calls to\n\t * `dt-api search()`, providing a delay before the search is made.\n\t */ \"searchDelay\": null,\n    /**\n\t * DataTables features six different built-in options for the buttons to\n\t * display for pagination control:\n\t *\n\t * * `numbers` - Page number buttons only\n\t * * `simple` - 'Previous' and 'Next' buttons only\n\t * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers\n\t * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons\n\t * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers\n\t * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers\n\t */ \"sPaginationType\": \"\",\n    /**\n\t * Enable horizontal scrolling. When a table is too wide to fit into a\n\t * certain layout, or you have a large number of columns in the table, you\n\t * can enable x-scrolling to show the table in a viewport, which can be\n\t * scrolled. This property can be `true` which will allow the table to\n\t * scroll horizontally when needed, or any CSS unit, or a number (in which\n\t * case it will be treated as a pixel measurement). Setting as simply `true`\n\t * is recommended.\n\t */ \"sScrollX\": \"\",\n    /**\n\t * This property can be used to force a DataTable to use more width than it\n\t * might otherwise do when x-scrolling is enabled. For example if you have a\n\t * table which requires to be well spaced, this parameter is useful for\n\t * \"over-sizing\" the table, and thus forcing scrolling. This property can by\n\t * any CSS unit, or a number (in which case it will be treated as a pixel\n\t * measurement).\n\t */ \"sScrollXInner\": \"\",\n    /**\n\t * Enable vertical scrolling. Vertical scrolling will constrain the DataTable\n\t * to the given height, and enable scrolling for any data which overflows the\n\t * current viewport. This can be used as an alternative to paging to display\n\t * a lot of data in a small area (although paging and scrolling can both be\n\t * enabled at the same time). This property can be any CSS unit, or a number\n\t * (in which case it will be treated as a pixel measurement).\n\t */ \"sScrollY\": \"\",\n    /**\n\t * __Deprecated__ The functionality provided by this parameter has now been\n\t * superseded by that provided through `ajax`, which should be used instead.\n\t *\n\t * Set the HTTP method that is used to make the Ajax call for server-side\n\t * processing or Ajax sourced data.\n\t */ \"sServerMethod\": \"GET\",\n    /**\n\t * DataTables makes use of renderers when displaying HTML elements for\n\t * a table. These renderers can be added or modified by plug-ins to\n\t * generate suitable mark-up for a site. For example the Bootstrap\n\t * integration plug-in for DataTables uses a paging button renderer to\n\t * display pagination buttons in the mark-up required by Bootstrap.\n\t *\n\t * For further information about the renderers available see\n\t * DataTable.ext.renderer\n\t */ \"renderer\": null,\n    /**\n\t * Set the data property name that DataTables should use to get a row's id\n\t * to set as the `id` property in the node.\n\t */ \"rowId\": \"DT_RowId\",\n    /**\n\t * Caption value\n\t */ \"caption\": null,\n    /**\n\t * For server-side processing - use the data from the DOM for the first draw\n\t */ iDeferLoading: null,\n    /** Event listeners */ on: null\n};\n_fnHungarianMap(DataTable.defaults);\n/*\n * Developer note - See note in model.defaults.js about the use of Hungarian\n * notation and camel case.\n */ /**\n * Column options that can be given to DataTables at initialisation time.\n *  @namespace\n */ DataTable.defaults.column = {\n    /**\n\t * Define which column(s) an order will occur on for this column. This\n\t * allows a column's ordering to take multiple columns into account when\n\t * doing a sort or use the data from a different column. For example first\n\t * name / last name columns make sense to do a multi-column sort over the\n\t * two columns.\n\t */ \"aDataSort\": null,\n    \"iDataSort\": -1,\n    ariaTitle: \"\",\n    /**\n\t * You can control the default ordering direction, and even alter the\n\t * behaviour of the sort handler (i.e. only allow ascending ordering etc)\n\t * using this parameter.\n\t */ \"asSorting\": [\n        \"asc\",\n        \"desc\",\n        \"\"\n    ],\n    /**\n\t * Enable or disable filtering on the data in this column.\n\t */ \"bSearchable\": true,\n    /**\n\t * Enable or disable ordering on this column.\n\t */ \"bSortable\": true,\n    /**\n\t * Enable or disable the display of this column.\n\t */ \"bVisible\": true,\n    /**\n\t * Developer definable function that is called whenever a cell is created (Ajax source,\n\t * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n\t * allowing you to modify the DOM element (add background colour for example) when the\n\t * element is available.\n\t */ \"fnCreatedCell\": null,\n    /**\n\t * This property can be used to read data from any data source property,\n\t * including deeply nested objects / properties. `data` can be given in a\n\t * number of different ways which effect its behaviour:\n\t *\n\t * * `integer` - treated as an array index for the data source. This is the\n\t *   default that DataTables uses (incrementally increased for each column).\n\t * * `string` - read an object property from the data source. There are\n\t *   three 'special' options that can be used in the string to alter how\n\t *   DataTables reads the data from the source object:\n\t *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n\t *      Javascript to read from nested objects, so to can the options\n\t *      specified in `data`. For example: `browser.version` or\n\t *      `browser.name`. If your object parameter name contains a period, use\n\t *      `\\\\` to escape it - i.e. `first\\\\.name`.\n\t *    * `[]` - Array notation. DataTables can automatically combine data\n\t *      from and array source, joining the data with the characters provided\n\t *      between the two brackets. For example: `name[, ]` would provide a\n\t *      comma-space separated list from the source array. If no characters\n\t *      are provided between the brackets, the original array source is\n\t *      returned.\n\t *    * `()` - Function notation. Adding `()` to the end of a parameter will\n\t *      execute a function of the name given. For example: `browser()` for a\n\t *      simple function on the data source, `browser.version()` for a\n\t *      function in a nested property or even `browser().version` to get an\n\t *      object property if the function called returns an object. Note that\n\t *      function notation is recommended for use in `render` rather than\n\t *      `data` as it is much simpler to use as a renderer.\n\t * * `null` - use the original data source for the row rather than plucking\n\t *   data directly from it. This action has effects on two other\n\t *   initialisation options:\n\t *    * `defaultContent` - When null is given as the `data` option and\n\t *      `defaultContent` is specified for the column, the value defined by\n\t *      `defaultContent` will be used for the cell.\n\t *    * `render` - When null is used for the `data` option and the `render`\n\t *      option is specified for the column, the whole data source for the\n\t *      row is used for the renderer.\n\t * * `function` - the function given will be executed whenever DataTables\n\t *   needs to set or get the data for a cell in the column. The function\n\t *   takes three parameters:\n\t *    * Parameters:\n\t *      * `{array|object}` The data source for the row\n\t *      * `{string}` The type call data requested - this will be 'set' when\n\t *        setting data or 'filter', 'display', 'type', 'sort' or undefined\n\t *        when gathering data. Note that when `undefined` is given for the\n\t *        type DataTables expects to get the raw data for the object back<\n\t *      * `{*}` Data to set when the second parameter is 'set'.\n\t *    * Return:\n\t *      * The return value from the function is not required when 'set' is\n\t *        the type of call, but otherwise the return is what will be used\n\t *        for the data requested.\n\t *\n\t * Note that `data` is a getter and setter option. If you just require\n\t * formatting of data for output, you will likely want to use `render` which\n\t * is simply a getter and thus simpler to use.\n\t *\n\t * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The\n\t * name change reflects the flexibility of this property and is consistent\n\t * with the naming of mRender. If 'mDataProp' is given, then it will still\n\t * be used by DataTables, as it automatically maps the old name to the new\n\t * if required.\n\t */ \"mData\": null,\n    /**\n\t * This property is the rendering partner to `data` and it is suggested that\n\t * when you want to manipulate data for display (including filtering,\n\t * sorting etc) without altering the underlying data for the table, use this\n\t * property. `render` can be considered to be the the read only companion to\n\t * `data` which is read / write (then as such more complex). Like `data`\n\t * this option can be given in a number of different ways to effect its\n\t * behaviour:\n\t *\n\t * * `integer` - treated as an array index for the data source. This is the\n\t *   default that DataTables uses (incrementally increased for each column).\n\t * * `string` - read an object property from the data source. There are\n\t *   three 'special' options that can be used in the string to alter how\n\t *   DataTables reads the data from the source object:\n\t *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n\t *      Javascript to read from nested objects, so to can the options\n\t *      specified in `data`. For example: `browser.version` or\n\t *      `browser.name`. If your object parameter name contains a period, use\n\t *      `\\\\` to escape it - i.e. `first\\\\.name`.\n\t *    * `[]` - Array notation. DataTables can automatically combine data\n\t *      from and array source, joining the data with the characters provided\n\t *      between the two brackets. For example: `name[, ]` would provide a\n\t *      comma-space separated list from the source array. If no characters\n\t *      are provided between the brackets, the original array source is\n\t *      returned.\n\t *    * `()` - Function notation. Adding `()` to the end of a parameter will\n\t *      execute a function of the name given. For example: `browser()` for a\n\t *      simple function on the data source, `browser.version()` for a\n\t *      function in a nested property or even `browser().version` to get an\n\t *      object property if the function called returns an object.\n\t * * `object` - use different data for the different data types requested by\n\t *   DataTables ('filter', 'display', 'type' or 'sort'). The property names\n\t *   of the object is the data type the property refers to and the value can\n\t *   defined using an integer, string or function using the same rules as\n\t *   `render` normally does. Note that an `_` option _must_ be specified.\n\t *   This is the default value to use if you haven't specified a value for\n\t *   the data type requested by DataTables.\n\t * * `function` - the function given will be executed whenever DataTables\n\t *   needs to set or get the data for a cell in the column. The function\n\t *   takes three parameters:\n\t *    * Parameters:\n\t *      * {array|object} The data source for the row (based on `data`)\n\t *      * {string} The type call data requested - this will be 'filter',\n\t *        'display', 'type' or 'sort'.\n\t *      * {array|object} The full data source for the row (not based on\n\t *        `data`)\n\t *    * Return:\n\t *      * The return value from the function is what will be used for the\n\t *        data requested.\n\t */ \"mRender\": null,\n    /**\n\t * Change the cell type created for the column - either TD cells or TH cells. This\n\t * can be useful as TH cells have semantic meaning in the table body, allowing them\n\t * to act as a header for a row (you may wish to add scope='row' to the TH elements).\n\t */ \"sCellType\": \"td\",\n    /**\n\t * Class to give to each cell in this column.\n\t */ \"sClass\": \"\",\n    /**\n\t * When DataTables calculates the column widths to assign to each column,\n\t * it finds the longest string in each column and then constructs a\n\t * temporary table and reads the widths from that. The problem with this\n\t * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n\t * string - thus the calculation can go wrong (doing it properly and putting\n\t * it into an DOM object and measuring that is horribly(!) slow). Thus as\n\t * a \"work around\" we provide this option. It will append its value to the\n\t * text that is found to be the longest string for the column - i.e. padding.\n\t * Generally you shouldn't need this!\n\t */ \"sContentPadding\": \"\",\n    /**\n\t * Allows a default value to be given for a column's data, and will be used\n\t * whenever a null data source is encountered (this can be because `data`\n\t * is set to null, or because the data source itself is null).\n\t */ \"sDefaultContent\": null,\n    /**\n\t * This parameter is only used in DataTables' server-side processing. It can\n\t * be exceptionally useful to know what columns are being displayed on the\n\t * client side, and to map these to database fields. When defined, the names\n\t * also allow DataTables to reorder information from the server if it comes\n\t * back in an unexpected order (i.e. if you switch your columns around on the\n\t * client-side, your server-side code does not also need updating).\n\t */ \"sName\": \"\",\n    /**\n\t * Defines a data source type for the ordering which can be used to read\n\t * real-time information from the table (updating the internally cached\n\t * version) prior to ordering. This allows ordering to occur on user\n\t * editable elements such as form inputs.\n\t */ \"sSortDataType\": \"std\",\n    /**\n\t * The title of this column.\n\t */ \"sTitle\": null,\n    /**\n\t * The type allows you to specify how the data for this column will be\n\t * ordered. Four types (string, numeric, date and html (which will strip\n\t * HTML tags before ordering)) are currently available. Note that only date\n\t * formats understood by Javascript's Date() object will be accepted as type\n\t * date. For example: \"Mar 26, 2008 5:03 PM\". May take the values: 'string',\n\t * 'numeric', 'date' or 'html' (by default). Further types can be adding\n\t * through plug-ins.\n\t */ \"sType\": null,\n    /**\n\t * Defining the width of the column, this parameter may take any CSS value\n\t * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not\n\t * been given a specific width through this interface ensuring that the table\n\t * remains readable.\n\t */ \"sWidth\": null\n};\n_fnHungarianMap(DataTable.defaults.column);\n/**\n * DataTables settings object - this holds all the information needed for a\n * given table, including configuration, data and current application of the\n * table options. DataTables does not have a single instance for each DataTable\n * with the settings attached to that instance, but rather instances of the\n * DataTable \"class\" are created on-the-fly as needed (typically by a\n * $().dataTable() call) and the settings object is then applied to that\n * instance.\n *\n * Note that this object is related to {@link DataTable.defaults} but this\n * one is the internal data store for DataTables's cache of columns. It should\n * NOT be manipulated outside of DataTables. Any configuration should be done\n * through the initialisation options.\n */ DataTable.models.oSettings = {\n    /**\n\t * Primary features of DataTables and their enablement state.\n\t */ \"oFeatures\": {\n        /**\n\t\t * Flag to say if DataTables should automatically try to calculate the\n\t\t * optimum table and columns widths (true) or not (false).\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"bAutoWidth\": null,\n        /**\n\t\t * Delay the creation of TR and TD elements until they are actually\n\t\t * needed by a driven page draw. This can give a significant speed\n\t\t * increase for Ajax source and Javascript source data, but makes no\n\t\t * difference at all for DOM and server-side processing tables.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"bDeferRender\": null,\n        /**\n\t\t * Enable filtering on the table or not. Note that if this is disabled\n\t\t * then there is no filtering at all on the table, including fnFilter.\n\t\t * To just remove the filtering input use sDom and remove the 'f' option.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"bFilter\": null,\n        /**\n\t\t * Used only for compatiblity with DT1\n\t\t * @deprecated\n\t\t */ \"bInfo\": true,\n        /**\n\t\t * Used only for compatiblity with DT1\n\t\t * @deprecated\n\t\t */ \"bLengthChange\": true,\n        /**\n\t\t * Pagination enabled or not. Note that if this is disabled then length\n\t\t * changing must also be disabled.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"bPaginate\": null,\n        /**\n\t\t * Processing indicator enable flag whenever DataTables is enacting a\n\t\t * user request - typically an Ajax request for server-side processing.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"bProcessing\": null,\n        /**\n\t\t * Server-side processing enabled flag - when enabled DataTables will\n\t\t * get all data from the server for every draw - there is no filtering,\n\t\t * sorting or paging done on the client-side.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"bServerSide\": null,\n        /**\n\t\t * Sorting enablement flag.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"bSort\": null,\n        /**\n\t\t * Multi-column sorting\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"bSortMulti\": null,\n        /**\n\t\t * Apply a class to the columns which are being sorted to provide a\n\t\t * visual highlight or not. This can slow things down when enabled since\n\t\t * there is a lot of DOM interaction.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"bSortClasses\": null,\n        /**\n\t\t * State saving enablement flag.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"bStateSave\": null\n    },\n    /**\n\t * Scrolling settings for a table.\n\t */ \"oScroll\": {\n        /**\n\t\t * When the table is shorter in height than sScrollY, collapse the\n\t\t * table container down to the height of the table (when true).\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"bCollapse\": null,\n        /**\n\t\t * Width of the scrollbar for the web-browser's platform. Calculated\n\t\t * during table initialisation.\n\t\t */ \"iBarWidth\": 0,\n        /**\n\t\t * Viewport width for horizontal scrolling. Horizontal scrolling is\n\t\t * disabled if an empty string.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"sX\": null,\n        /**\n\t\t * Width to expand the table to when using x-scrolling. Typically you\n\t\t * should not need to use this.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t *  @deprecated\n\t\t */ \"sXInner\": null,\n        /**\n\t\t * Viewport height for vertical scrolling. Vertical scrolling is disabled\n\t\t * if an empty string.\n\t\t * Note that this parameter will be set by the initialisation routine. To\n\t\t * set a default use {@link DataTable.defaults}.\n\t\t */ \"sY\": null\n    },\n    /**\n\t * Language information for the table.\n\t */ \"oLanguage\": {\n        /**\n\t\t * Information callback function. See\n\t\t * {@link DataTable.defaults.fnInfoCallback}\n\t\t */ \"fnInfoCallback\": null\n    },\n    /**\n\t * Browser support parameters\n\t */ \"oBrowser\": {\n        /**\n\t\t * Determine if the vertical scrollbar is on the right or left of the\n\t\t * scrolling container - needed for rtl language layout, although not\n\t\t * all browsers move the scrollbar (Safari).\n\t\t */ \"bScrollbarLeft\": false,\n        /**\n\t\t * Browser scrollbar width\n\t\t */ \"barWidth\": 0\n    },\n    \"ajax\": null,\n    /**\n\t * Array referencing the nodes which are used for the features. The\n\t * parameters of this object match what is allowed by sDom - i.e.\n\t *   <ul>\n\t *     <li>'l' - Length changing</li>\n\t *     <li>'f' - Filtering input</li>\n\t *     <li>'t' - The table!</li>\n\t *     <li>'i' - Information</li>\n\t *     <li>'p' - Pagination</li>\n\t *     <li>'r' - pRocessing</li>\n\t *   </ul>\n\t */ \"aanFeatures\": [],\n    /**\n\t * Store data information - see {@link DataTable.models.oRow} for detailed\n\t * information.\n\t */ \"aoData\": [],\n    /**\n\t * Array of indexes which are in the current display (after filtering etc)\n\t */ \"aiDisplay\": [],\n    /**\n\t * Array of indexes for display - no filtering\n\t */ \"aiDisplayMaster\": [],\n    /**\n\t * Map of row ids to data indexes\n\t */ \"aIds\": {},\n    /**\n\t * Store information about each column that is in use\n\t */ \"aoColumns\": [],\n    /**\n\t * Store information about the table's header\n\t */ \"aoHeader\": [],\n    /**\n\t * Store information about the table's footer\n\t */ \"aoFooter\": [],\n    /**\n\t * Store the applied global search information in case we want to force a\n\t * research or compare the old search to a new one.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t */ \"oPreviousSearch\": {},\n    /**\n\t * Store for named searches\n\t */ searchFixed: {},\n    /**\n\t * Store the applied search for each column - see\n\t * {@link DataTable.models.oSearch} for the format that is used for the\n\t * filtering information for each column.\n\t */ \"aoPreSearchCols\": [],\n    /**\n\t * Sorting that is applied to the table. Note that the inner arrays are\n\t * used in the following manner:\n\t * <ul>\n\t *   <li>Index 0 - column number</li>\n\t *   <li>Index 1 - current sorting direction</li>\n\t * </ul>\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t */ \"aaSorting\": null,\n    /**\n\t * Sorting that is always applied to the table (i.e. prefixed in front of\n\t * aaSorting).\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t */ \"aaSortingFixed\": [],\n    /**\n\t * If restoring a table - we should restore its width\n\t */ \"sDestroyWidth\": 0,\n    /**\n\t * Callback functions array for every time a row is inserted (i.e. on a draw).\n\t */ \"aoRowCallback\": [],\n    /**\n\t * Callback functions for the header on each draw.\n\t */ \"aoHeaderCallback\": [],\n    /**\n\t * Callback function for the footer on each draw.\n\t */ \"aoFooterCallback\": [],\n    /**\n\t * Array of callback functions for draw callback functions\n\t */ \"aoDrawCallback\": [],\n    /**\n\t * Array of callback functions for row created function\n\t */ \"aoRowCreatedCallback\": [],\n    /**\n\t * Callback functions for just before the table is redrawn. A return of\n\t * false will be used to cancel the draw.\n\t */ \"aoPreDrawCallback\": [],\n    /**\n\t * Callback functions for when the table has been initialised.\n\t */ \"aoInitComplete\": [],\n    /**\n\t * Callbacks for modifying the settings to be stored for state saving, prior to\n\t * saving state.\n\t */ \"aoStateSaveParams\": [],\n    /**\n\t * Callbacks for modifying the settings that have been stored for state saving\n\t * prior to using the stored values to restore the state.\n\t */ \"aoStateLoadParams\": [],\n    /**\n\t * Callbacks for operating on the settings object once the saved state has been\n\t * loaded\n\t */ \"aoStateLoaded\": [],\n    /**\n\t * Cache the table ID for quick access\n\t */ \"sTableId\": \"\",\n    /**\n\t * The TABLE node for the main table\n\t */ \"nTable\": null,\n    /**\n\t * Permanent ref to the thead element\n\t */ \"nTHead\": null,\n    /**\n\t * Permanent ref to the tfoot element - if it exists\n\t */ \"nTFoot\": null,\n    /**\n\t * Permanent ref to the tbody element\n\t */ \"nTBody\": null,\n    /**\n\t * Cache the wrapper node (contains all DataTables controlled elements)\n\t */ \"nTableWrapper\": null,\n    /**\n\t * Indicate if all required information has been read in\n\t */ \"bInitialised\": false,\n    /**\n\t * Information about open rows. Each object in the array has the parameters\n\t * 'nTr' and 'nParent'\n\t */ \"aoOpenRows\": [],\n    /**\n\t * Dictate the positioning of DataTables' control elements - see\n\t * {@link DataTable.model.oInit.sDom}.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t */ \"sDom\": null,\n    /**\n\t * Search delay (in mS)\n\t */ \"searchDelay\": null,\n    /**\n\t * Which type of pagination should be used.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t */ \"sPaginationType\": \"two_button\",\n    /**\n\t * Number of paging controls on the page. Only used for backwards compatibility\n\t */ pagingControls: 0,\n    /**\n\t * The state duration (for `stateSave`) in seconds.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t */ \"iStateDuration\": 0,\n    /**\n\t * Array of callback functions for state saving. Each array element is an\n\t * object with the following parameters:\n\t *   <ul>\n\t *     <li>function:fn - function to call. Takes two parameters, oSettings\n\t *       and the JSON string to save that has been thus far created. Returns\n\t *       a JSON string to be inserted into a json object\n\t *       (i.e. '\"param\": [ 0, 1, 2]')</li>\n\t *     <li>string:sName - name of callback</li>\n\t *   </ul>\n\t */ \"aoStateSave\": [],\n    /**\n\t * Array of callback functions for state loading. Each array element is an\n\t * object with the following parameters:\n\t *   <ul>\n\t *     <li>function:fn - function to call. Takes two parameters, oSettings\n\t *       and the object stored. May return false to cancel state loading</li>\n\t *     <li>string:sName - name of callback</li>\n\t *   </ul>\n\t */ \"aoStateLoad\": [],\n    /**\n\t * State that was saved. Useful for back reference\n\t */ \"oSavedState\": null,\n    /**\n\t * State that was loaded. Useful for back reference\n\t */ \"oLoadedState\": null,\n    /**\n\t * Note if draw should be blocked while getting data\n\t */ \"bAjaxDataGet\": true,\n    /**\n\t * The last jQuery XHR object that was used for server-side data gathering.\n\t * This can be used for working with the XHR information in one of the\n\t * callbacks\n\t */ \"jqXHR\": null,\n    /**\n\t * JSON returned from the server in the last Ajax request\n\t */ \"json\": undefined,\n    /**\n\t * Data submitted as part of the last Ajax request\n\t */ \"oAjaxData\": undefined,\n    /**\n\t * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if\n\t * required).\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t */ \"sServerMethod\": null,\n    /**\n\t * Format numbers for display.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t */ \"fnFormatNumber\": null,\n    /**\n\t * List of options that can be used for the user selectable length menu.\n\t * Note that this parameter will be set by the initialisation routine. To\n\t * set a default use {@link DataTable.defaults}.\n\t */ \"aLengthMenu\": null,\n    /**\n\t * Counter for the draws that the table does. Also used as a tracker for\n\t * server-side processing\n\t */ \"iDraw\": 0,\n    /**\n\t * Indicate if a redraw is being done - useful for Ajax\n\t */ \"bDrawing\": false,\n    /**\n\t * Draw index (iDraw) of the last error when parsing the returned data\n\t */ \"iDrawError\": -1,\n    /**\n\t * Paging display length\n\t */ \"_iDisplayLength\": 10,\n    /**\n\t * Paging start point - aiDisplay index\n\t */ \"_iDisplayStart\": 0,\n    /**\n\t * Server-side processing - number of records in the result set\n\t * (i.e. before filtering), Use fnRecordsTotal rather than\n\t * this property to get the value of the number of records, regardless of\n\t * the server-side processing setting.\n\t */ \"_iRecordsTotal\": 0,\n    /**\n\t * Server-side processing - number of records in the current display set\n\t * (i.e. after filtering). Use fnRecordsDisplay rather than\n\t * this property to get the value of the number of records, regardless of\n\t * the server-side processing setting.\n\t */ \"_iRecordsDisplay\": 0,\n    /**\n\t * The classes to use for the table\n\t */ \"oClasses\": {},\n    /**\n\t * Flag attached to the settings object so you can check in the draw\n\t * callback if filtering has been done in the draw. Deprecated in favour of\n\t * events.\n\t *  @deprecated\n\t */ \"bFiltered\": false,\n    /**\n\t * Flag attached to the settings object so you can check in the draw\n\t * callback if sorting has been done in the draw. Deprecated in favour of\n\t * events.\n\t *  @deprecated\n\t */ \"bSorted\": false,\n    /**\n\t * Indicate that if multiple rows are in the header and there is more than\n\t * one unique cell per column. Replaced by titleRow\n\t */ \"bSortCellsTop\": null,\n    /**\n\t * Initialisation object that is used for the table\n\t */ \"oInit\": null,\n    /**\n\t * Destroy callback functions - for plug-ins to attach themselves to the\n\t * destroy so they can clean up markup and events.\n\t */ \"aoDestroyCallback\": [],\n    /**\n\t * Get the number of records in the current record set, before filtering\n\t */ \"fnRecordsTotal\": function() {\n        return _fnDataSource(this) == \"ssp\" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;\n    },\n    /**\n\t * Get the number of records in the current record set, after filtering\n\t */ \"fnRecordsDisplay\": function() {\n        return _fnDataSource(this) == \"ssp\" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;\n    },\n    /**\n\t * Get the display end point - aiDisplay index\n\t */ \"fnDisplayEnd\": function() {\n        var len = this._iDisplayLength, start = this._iDisplayStart, calc = start + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;\n        if (features.bServerSide) {\n            return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay);\n        } else {\n            return !paginate || calc > records || len === -1 ? records : calc;\n        }\n    },\n    /**\n\t * The DataTables object for this table\n\t */ \"oInstance\": null,\n    /**\n\t * Unique identifier for each instance of the DataTables object. If there\n\t * is an ID on the table node, then it takes that value, otherwise an\n\t * incrementing internal counter is used.\n\t */ \"sInstance\": null,\n    /**\n\t * tabindex attribute value that is added to DataTables control elements, allowing\n\t * keyboard navigation of the table and its controls.\n\t */ \"iTabIndex\": 0,\n    /**\n\t * DIV container for the footer scrolling table if scrolling\n\t */ \"nScrollHead\": null,\n    /**\n\t * DIV container for the footer scrolling table if scrolling\n\t */ \"nScrollFoot\": null,\n    /**\n\t * Last applied sort\n\t */ \"aLastSort\": [],\n    /**\n\t * Stored plug-in instances\n\t */ \"oPlugins\": {},\n    /**\n\t * Function used to get a row's id from the row's data\n\t */ \"rowIdFn\": null,\n    /**\n\t * Data location where to store a row's id\n\t */ \"rowId\": null,\n    caption: \"\",\n    captionNode: null,\n    colgroup: null,\n    /** Delay loading of data */ deferLoading: null,\n    /** Allow auto type detection */ typeDetect: true,\n    /** ResizeObserver for the container div */ resizeObserver: null,\n    /** Keep a record of the last size of the container, so we can skip duplicates */ containerWidth: -1,\n    /** Reverse the initial order of the data set on desc ordering */ orderDescReverse: null,\n    /** Show / hide ordering indicators in headers */ orderIndicators: true,\n    /** Default ordering listener */ orderHandler: true,\n    /** Title row indicator */ titleRow: null\n};\n/**\n * Extension object for DataTables that is used to provide all extension\n * options.\n *\n * Note that the `DataTable.ext` object is available through\n * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is\n * also aliased to `jQuery.fn.dataTableExt` for historic reasons.\n *  @namespace\n *  @extends DataTable.models.ext\n */ var extPagination = DataTable.ext.pager;\n// Paging buttons configuration\n$.extend(extPagination, {\n    simple: function() {\n        return [\n            \"previous\",\n            \"next\"\n        ];\n    },\n    full: function() {\n        return [\n            \"first\",\n            \"previous\",\n            \"next\",\n            \"last\"\n        ];\n    },\n    numbers: function() {\n        return [\n            \"numbers\"\n        ];\n    },\n    simple_numbers: function() {\n        return [\n            \"previous\",\n            \"numbers\",\n            \"next\"\n        ];\n    },\n    full_numbers: function() {\n        return [\n            \"first\",\n            \"previous\",\n            \"numbers\",\n            \"next\",\n            \"last\"\n        ];\n    },\n    first_last: function() {\n        return [\n            \"first\",\n            \"last\"\n        ];\n    },\n    first_last_numbers: function() {\n        return [\n            \"first\",\n            \"numbers\",\n            \"last\"\n        ];\n    },\n    // For testing and plug-ins to use\n    _numbers: _pagingNumbers,\n    // Number of number buttons - legacy, use `numbers` option for paging feature\n    numbers_length: 7\n});\n$.extend(true, DataTable.ext.renderer, {\n    pagingButton: {\n        _: function(settings, buttonType, content, active, disabled) {\n            var classes = settings.oClasses.paging;\n            var btnClasses = [\n                classes.button\n            ];\n            var btn;\n            if (active) {\n                btnClasses.push(classes.active);\n            }\n            if (disabled) {\n                btnClasses.push(classes.disabled);\n            }\n            if (buttonType === \"ellipsis\") {\n                btn = $('<span class=\"ellipsis\"></span>').html(content)[0];\n            } else {\n                btn = $(\"<button>\", {\n                    class: btnClasses.join(\" \"),\n                    role: \"link\",\n                    type: \"button\"\n                }).html(content);\n            }\n            return {\n                display: btn,\n                clicker: btn\n            };\n        }\n    },\n    pagingContainer: {\n        _: function(settings, buttons) {\n            // No wrapping element - just append directly to the host\n            return buttons;\n        }\n    }\n});\n// Common function to remove new lines, strip HTML and diacritic control\nvar _filterString = function(stripHtml, normalize) {\n    return function(str) {\n        if (_empty(str) || typeof str !== \"string\") {\n            return str;\n        }\n        str = str.replace(_re_new_lines, \" \");\n        if (stripHtml) {\n            str = _stripHtml(str);\n        }\n        if (normalize) {\n            str = _normalize(str, false);\n        }\n        return str;\n    };\n};\n/*\n * Public helper functions. These aren't used internally by DataTables, or\n * called by any of the options passed into DataTables, but they can be used\n * externally by developers working with DataTables. They are helper functions\n * to make working with DataTables a little bit easier.\n */ /**\n * Common logic for moment, luxon or a date action.\n *\n * Happens after __mldObj, so don't need to call `resolveWindowsLibs` again\n */ function __mld(dtLib, momentFn, luxonFn, dateFn, arg1) {\n    if (__moment) {\n        return dtLib[momentFn](arg1);\n    } else if (__luxon) {\n        return dtLib[luxonFn](arg1);\n    }\n    return dateFn ? dtLib[dateFn](arg1) : dtLib;\n}\nvar __mlWarning = false;\nvar __luxon; // Can be assigned in DateTable.use()\nvar __moment; // Can be assigned in DateTable.use()\n/**\n * \n */ function resolveWindowLibs() {\n    if (window.luxon && !__luxon) {\n        __luxon = window.luxon;\n    }\n    if (window.moment && !__moment) {\n        __moment = window.moment;\n    }\n}\nfunction __mldObj(d, format, locale) {\n    var dt;\n    resolveWindowLibs();\n    if (__moment) {\n        dt = __moment.utc(d, format, locale, true);\n        if (!dt.isValid()) {\n            return null;\n        }\n    } else if (__luxon) {\n        dt = format && typeof d === \"string\" ? __luxon.DateTime.fromFormat(d, format) : __luxon.DateTime.fromISO(d);\n        if (!dt.isValid) {\n            return null;\n        }\n        dt = dt.setLocale(locale);\n    } else if (!format) {\n        // No format given, must be ISO\n        dt = new Date(d);\n    } else {\n        if (!__mlWarning) {\n            alert(\"DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17\");\n        }\n        __mlWarning = true;\n    }\n    return dt;\n}\n// Wrapper for date, datetime and time which all operate the same way with the exception of\n// the output string for auto locale support\nfunction __mlHelper(localeString) {\n    return function(from, to, locale, def) {\n        // Luxon and Moment support\n        // Argument shifting\n        if (arguments.length === 0) {\n            locale = \"en\";\n            to = null; // means toLocaleString\n            from = null; // means iso8601\n        } else if (arguments.length === 1) {\n            locale = \"en\";\n            to = from;\n            from = null;\n        } else if (arguments.length === 2) {\n            locale = to;\n            to = from;\n            from = null;\n        }\n        var typeName = \"datetime\" + (to ? \"-\" + to : \"\");\n        // Add type detection and sorting specific to this date format - we need to be able to identify\n        // date type columns as such, rather than as numbers in extensions. Hence the need for this.\n        if (!DataTable.ext.type.order[typeName + \"-pre\"]) {\n            DataTable.type(typeName, {\n                detect: function(d) {\n                    // The renderer will give the value to type detect as the type!\n                    return d === typeName ? typeName : false;\n                },\n                order: {\n                    pre: function(d) {\n                        // The renderer gives us Moment, Luxon or Date obects for the sorting, all of which have a\n                        // `valueOf` which gives milliseconds epoch\n                        return d.valueOf();\n                    }\n                },\n                className: \"dt-right\"\n            });\n        }\n        return function(d, type) {\n            // Allow for a default value\n            if (d === null || d === undefined) {\n                if (def === \"--now\") {\n                    // We treat everything as UTC further down, so no changes are\n                    // made, as such need to get the local date / time as if it were\n                    // UTC\n                    var local = new Date();\n                    d = new Date(Date.UTC(local.getFullYear(), local.getMonth(), local.getDate(), local.getHours(), local.getMinutes(), local.getSeconds()));\n                } else {\n                    d = \"\";\n                }\n            }\n            if (type === \"type\") {\n                // Typing uses the type name for fast matching\n                return typeName;\n            }\n            if (d === \"\") {\n                return type !== \"sort\" ? \"\" : __mldObj(\"0000-01-01 00:00:00\", null, locale);\n            }\n            // Shortcut. If `from` and `to` are the same, we are using the renderer to\n            // format for ordering, not display - its already in the display format.\n            if (to !== null && from === to && type !== \"sort\" && type !== \"type\" && !(d instanceof Date)) {\n                return d;\n            }\n            var dt = __mldObj(d, from, locale);\n            if (dt === null) {\n                return d;\n            }\n            if (type === \"sort\") {\n                return dt;\n            }\n            var formatted = to === null ? __mld(dt, \"toDate\", \"toJSDate\", \"\")[localeString]() : __mld(dt, \"format\", \"toFormat\", \"toISOString\", to);\n            // XSS protection\n            return type === \"display\" ? _escapeHtml(formatted) : formatted;\n        };\n    };\n}\n// Based on locale, determine standard number formatting\n// Fallback for legacy browsers is US English\nvar __thousands = \",\";\nvar __decimal = \".\";\nif (window.Intl !== undefined) {\n    try {\n        var num = new Intl.NumberFormat().formatToParts(100000.1);\n        for(var i = 0; i < num.length; i++){\n            if (num[i].type === \"group\") {\n                __thousands = num[i].value;\n            } else if (num[i].type === \"decimal\") {\n                __decimal = num[i].value;\n            }\n        }\n    } catch (e) {\n    // noop\n    }\n}\n// Formatted date time detection - use by declaring the formats you are going to use\nDataTable.datetime = function(format, locale) {\n    var typeName = \"datetime-\" + format;\n    if (!locale) {\n        locale = \"en\";\n    }\n    if (!DataTable.ext.type.order[typeName]) {\n        DataTable.type(typeName, {\n            detect: function(d) {\n                var dt = __mldObj(d, format, locale);\n                return d === \"\" || dt ? typeName : false;\n            },\n            order: {\n                pre: function(d) {\n                    return __mldObj(d, format, locale) || 0;\n                }\n            },\n            className: \"dt-right\"\n        });\n    }\n};\n/**\n * Helpers for `columns.render`.\n *\n * The options defined here can be used with the `columns.render` initialisation\n * option to provide a display renderer. The following functions are defined:\n *\n * * `moment` - Uses the MomentJS library to convert from a given format into another.\n * This renderer has three overloads:\n *   * 1 parameter:\n *     * `string` - Format to convert to (assumes input is ISO8601 and locale is `en`)\n *   * 2 parameters:\n *     * `string` - Format to convert from\n *     * `string` - Format to convert to. Assumes `en` locale\n *   * 3 parameters:\n *     * `string` - Format to convert from\n *     * `string` - Format to convert to\n *     * `string` - Locale\n * * `number` - Will format numeric data (defined by `columns.data`) for\n *   display, retaining the original unformatted data for sorting and filtering.\n *   It takes 5 parameters:\n *   * `string` - Thousands grouping separator\n *   * `string` - Decimal point indicator\n *   * `integer` - Number of decimal points to show\n *   * `string` (optional) - Prefix.\n *   * `string` (optional) - Postfix (/suffix).\n * * `text` - Escape HTML to help prevent XSS attacks. It has no optional\n *   parameters.\n *\n * @example\n *   // Column definition using the number renderer\n *   {\n *     data: \"salary\",\n *     render: $.fn.dataTable.render.number( '\\'', '.', 0, '$' )\n *   }\n *\n * @namespace\n */ DataTable.render = {\n    date: __mlHelper(\"toLocaleDateString\"),\n    datetime: __mlHelper(\"toLocaleString\"),\n    time: __mlHelper(\"toLocaleTimeString\"),\n    number: function(thousands, decimal, precision, prefix, postfix) {\n        // Auto locale detection\n        if (thousands === null || thousands === undefined) {\n            thousands = __thousands;\n        }\n        if (decimal === null || decimal === undefined) {\n            decimal = __decimal;\n        }\n        return {\n            display: function(d) {\n                if (typeof d !== \"number\" && typeof d !== \"string\") {\n                    return d;\n                }\n                if (d === \"\" || d === null) {\n                    return d;\n                }\n                var negative = d < 0 ? \"-\" : \"\";\n                var flo = parseFloat(d);\n                var abs = Math.abs(flo);\n                // Scientific notation for large and small numbers\n                if (abs >= 100000000000 || abs < 0.0001 && abs !== 0) {\n                    var exp = flo.toExponential(precision).split(/e\\+?/);\n                    return exp[0] + \" x 10<sup>\" + exp[1] + \"</sup>\";\n                }\n                // If NaN then there isn't much formatting that we can do - just\n                // return immediately, escaping any HTML (this was supposed to\n                // be a number after all)\n                if (isNaN(flo)) {\n                    return _escapeHtml(d);\n                }\n                flo = flo.toFixed(precision);\n                d = Math.abs(flo);\n                var intPart = parseInt(d, 10);\n                var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : \"\";\n                // If zero, then can't have a negative prefix\n                if (intPart === 0 && parseFloat(floatPart) === 0) {\n                    negative = \"\";\n                }\n                return negative + (prefix || \"\") + intPart.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousands) + floatPart + (postfix || \"\");\n            }\n        };\n    },\n    text: function() {\n        return {\n            display: _escapeHtml,\n            filter: _escapeHtml\n        };\n    }\n};\nvar _extTypes = DataTable.ext.type;\n// Get / set type\nDataTable.type = function(name, prop, val) {\n    if (!prop) {\n        return {\n            className: _extTypes.className[name],\n            detect: _extTypes.detect.find(function(fn) {\n                return fn._name === name;\n            }),\n            order: {\n                pre: _extTypes.order[name + \"-pre\"],\n                asc: _extTypes.order[name + \"-asc\"],\n                desc: _extTypes.order[name + \"-desc\"]\n            },\n            render: _extTypes.render[name],\n            search: _extTypes.search[name]\n        };\n    }\n    var setProp = function(prop, propVal) {\n        _extTypes[prop][name] = propVal;\n    };\n    var setDetect = function(detect) {\n        // `detect` can be a function or an object - we set a name\n        // property for either - that is used for the detection\n        Object.defineProperty(detect, \"_name\", {\n            value: name\n        });\n        var idx = _extTypes.detect.findIndex(function(item) {\n            return item._name === name;\n        });\n        if (idx === -1) {\n            _extTypes.detect.unshift(detect);\n        } else {\n            _extTypes.detect.splice(idx, 1, detect);\n        }\n    };\n    var setOrder = function(obj) {\n        _extTypes.order[name + \"-pre\"] = obj.pre; // can be undefined\n        _extTypes.order[name + \"-asc\"] = obj.asc; // can be undefined\n        _extTypes.order[name + \"-desc\"] = obj.desc; // can be undefined\n    };\n    // prop is optional\n    if (val === undefined) {\n        val = prop;\n        prop = null;\n    }\n    if (prop === \"className\") {\n        setProp(\"className\", val);\n    } else if (prop === \"detect\") {\n        setDetect(val);\n    } else if (prop === \"order\") {\n        setOrder(val);\n    } else if (prop === \"render\") {\n        setProp(\"render\", val);\n    } else if (prop === \"search\") {\n        setProp(\"search\", val);\n    } else if (!prop) {\n        if (val.className) {\n            setProp(\"className\", val.className);\n        }\n        if (val.detect !== undefined) {\n            setDetect(val.detect);\n        }\n        if (val.order) {\n            setOrder(val.order);\n        }\n        if (val.render !== undefined) {\n            setProp(\"render\", val.render);\n        }\n        if (val.search !== undefined) {\n            setProp(\"search\", val.search);\n        }\n    }\n};\n// Get a list of types\nDataTable.types = function() {\n    return _extTypes.detect.map(function(fn) {\n        return fn._name;\n    });\n};\nvar __diacriticSort = function(a, b) {\n    a = a !== null && a !== undefined ? a.toString().toLowerCase() : \"\";\n    b = b !== null && b !== undefined ? b.toString().toLowerCase() : \"\";\n    // Checked for `navigator.languages` support in `oneOf` so this code can't execute in old\n    // Safari and thus can disable this check\n    // eslint-disable-next-line compat/compat\n    return a.localeCompare(b, navigator.languages[0] || navigator.language, {\n        numeric: true,\n        ignorePunctuation: true\n    });\n};\nvar __diacriticHtmlSort = function(a, b) {\n    a = _stripHtml(a);\n    b = _stripHtml(b);\n    return __diacriticSort(a, b);\n};\n//\n// Built in data types\n//\nDataTable.type(\"string\", {\n    detect: function() {\n        return \"string\";\n    },\n    order: {\n        pre: function(a) {\n            // This is a little complex, but faster than always calling toString,\n            // http://jsperf.com/tostring-v-check\n            return _empty(a) && typeof a !== \"boolean\" ? \"\" : typeof a === \"string\" ? a.toLowerCase() : !a.toString ? \"\" : a.toString();\n        }\n    },\n    search: _filterString(false, true)\n});\nDataTable.type(\"string-utf8\", {\n    detect: {\n        allOf: function(d) {\n            return true;\n        },\n        oneOf: function(d) {\n            // At least one data point must contain a non-ASCII character\n            // This line will also check if navigator.languages is supported or not. If not (Safari 10.0-)\n            // this data type won't be supported.\n            // eslint-disable-next-line compat/compat\n            return !_empty(d) && navigator.languages && typeof d === \"string\" && d.match(/[^\\x00-\\x7F]/);\n        }\n    },\n    order: {\n        asc: __diacriticSort,\n        desc: function(a, b) {\n            return __diacriticSort(a, b) * -1;\n        }\n    },\n    search: _filterString(false, true)\n});\nDataTable.type(\"html\", {\n    detect: {\n        allOf: function(d) {\n            return _empty(d) || typeof d === \"string\" && d.indexOf(\"<\") !== -1;\n        },\n        oneOf: function(d) {\n            // At least one data point must contain a `<`\n            return !_empty(d) && typeof d === \"string\" && d.indexOf(\"<\") !== -1;\n        }\n    },\n    order: {\n        pre: function(a) {\n            return _empty(a) ? \"\" : a.replace ? _stripHtml(a).trim().toLowerCase() : a + \"\";\n        }\n    },\n    search: _filterString(true, true)\n});\nDataTable.type(\"html-utf8\", {\n    detect: {\n        allOf: function(d) {\n            return _empty(d) || typeof d === \"string\" && d.indexOf(\"<\") !== -1;\n        },\n        oneOf: function(d) {\n            // At least one data point must contain a `<` and a non-ASCII character\n            // eslint-disable-next-line compat/compat\n            return navigator.languages && !_empty(d) && typeof d === \"string\" && d.indexOf(\"<\") !== -1 && typeof d === \"string\" && d.match(/[^\\x00-\\x7F]/);\n        }\n    },\n    order: {\n        asc: __diacriticHtmlSort,\n        desc: function(a, b) {\n            return __diacriticHtmlSort(a, b) * -1;\n        }\n    },\n    search: _filterString(true, true)\n});\nDataTable.type(\"date\", {\n    className: \"dt-type-date\",\n    detect: {\n        allOf: function(d) {\n            // V8 tries _very_ hard to make a string passed into `Date.parse()`\n            // valid, so we need to use a regex to restrict date formats. Use a\n            // plug-in for anything other than ISO8601 style strings\n            if (d && !(d instanceof Date) && !_re_date.test(d)) {\n                return null;\n            }\n            var parsed = Date.parse(d);\n            return parsed !== null && !isNaN(parsed) || _empty(d);\n        },\n        oneOf: function(d) {\n            // At least one entry must be a date or a string with a date\n            return d instanceof Date || typeof d === \"string\" && _re_date.test(d);\n        }\n    },\n    order: {\n        pre: function(d) {\n            var ts = Date.parse(d);\n            return isNaN(ts) ? -Infinity : ts;\n        }\n    }\n});\nDataTable.type(\"html-num-fmt\", {\n    className: \"dt-type-numeric\",\n    detect: {\n        allOf: function(d, settings) {\n            var decimal = settings.oLanguage.sDecimal;\n            return _htmlNumeric(d, decimal, true, false);\n        },\n        oneOf: function(d, settings) {\n            // At least one data point must contain a numeric value\n            var decimal = settings.oLanguage.sDecimal;\n            return _htmlNumeric(d, decimal, true, false);\n        }\n    },\n    order: {\n        pre: function(d, s) {\n            var dp = s.oLanguage.sDecimal;\n            return __numericReplace(d, dp, _re_html, _re_formatted_numeric);\n        }\n    },\n    search: _filterString(true, true)\n});\nDataTable.type(\"html-num\", {\n    className: \"dt-type-numeric\",\n    detect: {\n        allOf: function(d, settings) {\n            var decimal = settings.oLanguage.sDecimal;\n            return _htmlNumeric(d, decimal, false, true);\n        },\n        oneOf: function(d, settings) {\n            // At least one data point must contain a numeric value\n            var decimal = settings.oLanguage.sDecimal;\n            return _htmlNumeric(d, decimal, false, false);\n        }\n    },\n    order: {\n        pre: function(d, s) {\n            var dp = s.oLanguage.sDecimal;\n            return __numericReplace(d, dp, _re_html);\n        }\n    },\n    search: _filterString(true, true)\n});\nDataTable.type(\"num-fmt\", {\n    className: \"dt-type-numeric\",\n    detect: {\n        allOf: function(d, settings) {\n            var decimal = settings.oLanguage.sDecimal;\n            return _isNumber(d, decimal, true, true);\n        },\n        oneOf: function(d, settings) {\n            // At least one data point must contain a numeric value\n            var decimal = settings.oLanguage.sDecimal;\n            return _isNumber(d, decimal, true, false);\n        }\n    },\n    order: {\n        pre: function(d, s) {\n            var dp = s.oLanguage.sDecimal;\n            return __numericReplace(d, dp, _re_formatted_numeric);\n        }\n    }\n});\nDataTable.type(\"num\", {\n    className: \"dt-type-numeric\",\n    detect: {\n        allOf: function(d, settings) {\n            var decimal = settings.oLanguage.sDecimal;\n            return _isNumber(d, decimal, false, true);\n        },\n        oneOf: function(d, settings) {\n            // At least one data point must contain a numeric value\n            var decimal = settings.oLanguage.sDecimal;\n            return _isNumber(d, decimal, false, false);\n        }\n    },\n    order: {\n        pre: function(d, s) {\n            var dp = s.oLanguage.sDecimal;\n            return __numericReplace(d, dp);\n        }\n    }\n});\nvar __numericReplace = function(d, decimalPlace, re1, re2) {\n    if (d !== 0 && (!d || d === \"-\")) {\n        return -Infinity;\n    }\n    var type = typeof d;\n    if (type === \"number\" || type === \"bigint\") {\n        return d;\n    }\n    // If a decimal place other than `.` is used, it needs to be given to the\n    // function so we can detect it and replace with a `.` which is the only\n    // decimal place Javascript recognises - it is not locale aware.\n    if (decimalPlace) {\n        d = _numToDecimal(d, decimalPlace);\n    }\n    if (d.replace) {\n        if (re1) {\n            d = d.replace(re1, \"\");\n        }\n        if (re2) {\n            d = d.replace(re2, \"\");\n        }\n    }\n    return d * 1;\n};\n$.extend(true, DataTable.ext.renderer, {\n    footer: {\n        _: function(settings, cell, classes) {\n            cell.addClass(classes.tfoot.cell);\n        }\n    },\n    header: {\n        _: function(settings, cell, classes) {\n            cell.addClass(classes.thead.cell);\n            if (!settings.oFeatures.bSort) {\n                cell.addClass(classes.order.none);\n            }\n            var titleRow = settings.titleRow;\n            var headerRows = cell.closest(\"thead\").find(\"tr\");\n            var rowIdx = cell.parent().index();\n            // Conditions to not apply the ordering icons\n            if (// Cells and rows which have the attribute to disable the icons\n            cell.attr(\"data-dt-order\") === \"disable\" || cell.parent().attr(\"data-dt-order\") === \"disable\" || // titleRow support, for defining a specific row in the header\n            titleRow === true && rowIdx !== 0 || titleRow === false && rowIdx !== headerRows.length - 1 || typeof titleRow === \"number\" && rowIdx !== titleRow) {\n                return;\n            }\n            // No additional mark-up required\n            // Attach a sort listener to update on sort - note that using the\n            // `DT` namespace will allow the event to be removed automatically\n            // on destroy, while the `dt` namespaced event is the one we are\n            // listening for\n            $(settings.nTable).on(\"order.dt.DT column-visibility.dt.DT\", function(e, ctx, column) {\n                if (settings !== ctx) {\n                    return; // table, not a nested one\n                }\n                var sorting = ctx.sortDetails;\n                if (!sorting) {\n                    return;\n                }\n                var orderedColumns = _pluck(sorting, \"col\");\n                // This handler is only needed on column visibility if the column is part of the\n                // ordering. If it isn't, then we can bail out to save performance. It could be a\n                // separate event handler, but this is a balance between code reuse / size and performance\n                // console.log(e, e.name, column, orderedColumns, orderedColumns.includes(column))\n                if (e.type === \"column-visibility\" && !orderedColumns.includes(column)) {\n                    return;\n                }\n                var i;\n                var orderClasses = classes.order;\n                var columns = ctx.api.columns(cell);\n                var col = settings.aoColumns[columns.flatten()[0]];\n                var orderable = columns.orderable().includes(true);\n                var ariaType = \"\";\n                var indexes = columns.indexes();\n                var sortDirs = columns.orderable(true).flatten();\n                var tabIndex = settings.iTabIndex;\n                var canOrder = ctx.orderHandler && orderable;\n                cell.removeClass(orderClasses.isAsc + \" \" + orderClasses.isDesc).toggleClass(orderClasses.none, !orderable).toggleClass(orderClasses.canAsc, canOrder && sortDirs.includes(\"asc\")).toggleClass(orderClasses.canDesc, canOrder && sortDirs.includes(\"desc\"));\n                // Determine if all of the columns that this cell covers are included in the\n                // current ordering\n                var isOrdering = true;\n                for(i = 0; i < indexes.length; i++){\n                    if (!orderedColumns.includes(indexes[i])) {\n                        isOrdering = false;\n                    }\n                }\n                if (isOrdering) {\n                    // Get the ordering direction for the columns under this cell\n                    // Note that it is possible for a cell to be asc and desc sorting\n                    // (column spanning cells)\n                    var orderDirs = columns.order();\n                    cell.addClass(orderDirs.includes(\"asc\") ? orderClasses.isAsc : \"\" + orderDirs.includes(\"desc\") ? orderClasses.isDesc : \"\");\n                }\n                // Find the first visible column that has ordering applied to it - it get's\n                // the aria information, as the ARIA spec says that only one column should\n                // be marked with aria-sort\n                var firstVis = -1; // column index\n                for(i = 0; i < orderedColumns.length; i++){\n                    if (settings.aoColumns[orderedColumns[i]].bVisible) {\n                        firstVis = orderedColumns[i];\n                        break;\n                    }\n                }\n                if (indexes[0] == firstVis) {\n                    var firstSort = sorting[0];\n                    var sortOrder = col.asSorting;\n                    cell.attr(\"aria-sort\", firstSort.dir === \"asc\" ? \"ascending\" : \"descending\");\n                    // Determine if the next click will remove sorting or change the sort\n                    ariaType = !sortOrder[firstSort.index + 1] ? \"Remove\" : \"Reverse\";\n                } else {\n                    cell.removeAttr(\"aria-sort\");\n                }\n                // Make the headers tab-able for keyboard navigation\n                if (orderable) {\n                    var orderSpan = cell.find(\".dt-column-order\");\n                    orderSpan.attr(\"role\", \"button\").attr(\"aria-label\", orderable ? col.ariaTitle + ctx.api.i18n(\"oAria.orderable\" + ariaType) : col.ariaTitle);\n                    if (tabIndex !== -1) {\n                        orderSpan.attr(\"tabindex\", tabIndex);\n                    }\n                }\n            });\n        }\n    },\n    layout: {\n        _: function(settings, container, items) {\n            var classes = settings.oClasses.layout;\n            var row = $(\"<div/>\").attr(\"id\", items.id || null).addClass(items.className || classes.row).appendTo(container);\n            DataTable.ext.renderer.layout._forLayoutRow(items, function(key, val) {\n                if (key === \"id\" || key === \"className\") {\n                    return;\n                }\n                var klass = \"\";\n                if (val.table) {\n                    row.addClass(classes.tableRow);\n                    klass += classes.tableCell + \" \";\n                }\n                if (key === \"start\") {\n                    klass += classes.start;\n                } else if (key === \"end\") {\n                    klass += classes.end;\n                } else {\n                    klass += classes.full;\n                }\n                $(\"<div/>\").attr({\n                    id: val.id || null,\n                    \"class\": val.className ? val.className : classes.cell + \" \" + klass\n                }).append(val.contents).appendTo(row);\n            });\n        },\n        // Shared for use by the styling frameworks\n        _forLayoutRow: function(items, fn) {\n            // As we are inserting dom elements, we need start / end in a\n            // specific order, this function is used for sorting the layout\n            // keys.\n            var layoutEnum = function(x) {\n                switch(x){\n                    case \"\":\n                        return 0;\n                    case \"start\":\n                        return 1;\n                    case \"end\":\n                        return 2;\n                    default:\n                        return 3;\n                }\n            };\n            Object.keys(items).sort(function(a, b) {\n                return layoutEnum(a) - layoutEnum(b);\n            }).forEach(function(key) {\n                fn(key, items[key]);\n            });\n        }\n    }\n});\nDataTable.feature = {};\n// Third parameter is internal only!\nDataTable.feature.register = function(name, cb, legacy) {\n    DataTable.ext.features[name] = cb;\n    if (legacy) {\n        _ext.feature.push({\n            cFeature: legacy,\n            fnInit: cb\n        });\n    }\n};\nfunction _divProp(el, prop, val) {\n    if (val) {\n        el[prop] = val;\n    }\n}\nDataTable.feature.register(\"div\", function(settings, opts) {\n    var n = $(\"<div>\")[0];\n    if (opts) {\n        _divProp(n, \"className\", opts.className);\n        _divProp(n, \"id\", opts.id);\n        _divProp(n, \"innerHTML\", opts.html);\n        _divProp(n, \"textContent\", opts.text);\n    }\n    return n;\n});\nDataTable.feature.register(\"info\", function(settings, opts) {\n    // For compatibility with the legacy `info` top level option\n    if (!settings.oFeatures.bInfo) {\n        return null;\n    }\n    var lang = settings.oLanguage, tid = settings.sTableId, n = $(\"<div/>\", {\n        \"class\": settings.oClasses.info.container\n    });\n    opts = $.extend({\n        callback: lang.fnInfoCallback,\n        empty: lang.sInfoEmpty,\n        postfix: lang.sInfoPostFix,\n        search: lang.sInfoFiltered,\n        text: lang.sInfo\n    }, opts);\n    // Update display on each draw\n    settings.aoDrawCallback.push(function(s) {\n        _fnUpdateInfo(s, opts, n);\n    });\n    // For the first info display in the table, we add a callback and aria information.\n    if (!settings._infoEl) {\n        n.attr({\n            \"aria-live\": \"polite\",\n            id: tid + \"_info\",\n            role: \"status\"\n        });\n        // Table is described by our info div\n        $(settings.nTable).attr(\"aria-describedby\", tid + \"_info\");\n        settings._infoEl = n;\n    }\n    return n;\n}, \"i\");\n/**\n * Update the information elements in the display\n *  @param {object} settings dataTables settings object\n *  @memberof DataTable#oApi\n */ function _fnUpdateInfo(settings, opts, node) {\n    var start = settings._iDisplayStart + 1, end = settings.fnDisplayEnd(), max = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? opts.text : opts.empty;\n    if (total !== max) {\n        // Record set after filtering\n        out += \" \" + opts.search;\n    }\n    // Convert the macros\n    out += opts.postfix;\n    out = _fnMacros(settings, out);\n    if (opts.callback) {\n        out = opts.callback.call(settings.oInstance, settings, start, end, max, total, out);\n    }\n    node.html(out);\n    _fnCallbackFire(settings, null, \"info\", [\n        settings,\n        node[0],\n        out\n    ]);\n}\nvar __searchCounter = 0;\n// opts\n// - text\n// - placeholder\nDataTable.feature.register(\"search\", function(settings, opts) {\n    // Don't show the input if filtering isn't available on the table\n    if (!settings.oFeatures.bFilter) {\n        return null;\n    }\n    var classes = settings.oClasses.search;\n    var tableId = settings.sTableId;\n    var language = settings.oLanguage;\n    var previousSearch = settings.oPreviousSearch;\n    var input = '<input type=\"search\" class=\"' + classes.input + '\"/>';\n    opts = $.extend({\n        placeholder: language.sSearchPlaceholder,\n        processing: false,\n        text: language.sSearch\n    }, opts);\n    // The _INPUT_ is optional - is appended if not present\n    if (opts.text.indexOf(\"_INPUT_\") === -1) {\n        opts.text += \"_INPUT_\";\n    }\n    opts.text = _fnMacros(settings, opts.text);\n    // We can put the <input> outside of the label if it is at the start or end\n    // which helps improve accessability (not all screen readers like implicit\n    // for elements).\n    var end = opts.text.match(/_INPUT_$/);\n    var start = opts.text.match(/^_INPUT_/);\n    var removed = opts.text.replace(/_INPUT_/, \"\");\n    var str = \"<label>\" + opts.text + \"</label>\";\n    if (start) {\n        str = \"_INPUT_<label>\" + removed + \"</label>\";\n    } else if (end) {\n        str = \"<label>\" + removed + \"</label>_INPUT_\";\n    }\n    var filter = $(\"<div>\").addClass(classes.container).append(str.replace(/_INPUT_/, input));\n    // add for and id to label and input\n    filter.find(\"label\").attr(\"for\", \"dt-search-\" + __searchCounter);\n    filter.find(\"input\").attr(\"id\", \"dt-search-\" + __searchCounter);\n    __searchCounter++;\n    var searchFn = function(event) {\n        var val = this.value;\n        if (previousSearch.return && event.key !== \"Enter\") {\n            return;\n        }\n        /* Now do the filter */ if (val != previousSearch.search) {\n            _fnProcessingRun(settings, opts.processing, function() {\n                previousSearch.search = val;\n                _fnFilterComplete(settings, previousSearch);\n                // Need to redraw, without resorting\n                settings._iDisplayStart = 0;\n                _fnDraw(settings);\n            });\n        }\n    };\n    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : 0;\n    var jqFilter = $(\"input\", filter).val(previousSearch.search).attr(\"placeholder\", opts.placeholder).on(\"keyup.DT search.DT input.DT paste.DT cut.DT\", searchDelay ? DataTable.util.debounce(searchFn, searchDelay) : searchFn).on(\"mouseup.DT\", function(e) {\n        // Edge fix! Edge 17 does not trigger anything other than mouse events when clicking\n        // on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`\n        // checks the value to see if it has changed. In other browsers it won't have.\n        setTimeout(function() {\n            searchFn.call(jqFilter[0], e);\n        }, 10);\n    }).on(\"keypress.DT\", function(e) {\n        /* Prevent form submission */ if (e.keyCode == 13) {\n            return false;\n        }\n    }).attr(\"aria-controls\", tableId);\n    // Update the input elements whenever the table is filtered\n    $(settings.nTable).on(\"search.dt.DT\", function(ev, s) {\n        if (settings === s && jqFilter[0] !== document.activeElement) {\n            jqFilter.val(typeof previousSearch.search !== \"function\" ? previousSearch.search : \"\");\n        }\n    });\n    return filter;\n}, \"f\");\n// opts\n// - type - button configuration\n// - buttons - number of buttons to show - must be odd\nDataTable.feature.register(\"paging\", function(settings, opts) {\n    // Don't show the paging input if the table doesn't have paging enabled\n    if (!settings.oFeatures.bPaginate) {\n        return null;\n    }\n    opts = $.extend({\n        buttons: DataTable.ext.pager.numbers_length,\n        type: settings.sPaginationType,\n        boundaryNumbers: true,\n        firstLast: true,\n        previousNext: true,\n        numbers: true\n    }, opts);\n    var host = $(\"<div/>\").addClass(settings.oClasses.paging.container + (opts.type ? \" paging_\" + opts.type : \"\")).append($(\"<nav>\").attr(\"aria-label\", \"pagination\").addClass(settings.oClasses.paging.nav));\n    var draw = function() {\n        _pagingDraw(settings, host.children(), opts);\n    };\n    settings.aoDrawCallback.push(draw);\n    // Responsive redraw of paging control\n    $(settings.nTable).on(\"column-sizing.dt.DT\", draw);\n    return host;\n}, \"p\");\n/**\n * Dynamically create the button type array based on the configuration options.\n * This will only happen if the paging type is not defined.\n */ function _pagingDynamic(opts) {\n    var out = [];\n    if (opts.numbers) {\n        out.push(\"numbers\");\n    }\n    if (opts.previousNext) {\n        out.unshift(\"previous\");\n        out.push(\"next\");\n    }\n    if (opts.firstLast) {\n        out.unshift(\"first\");\n        out.push(\"last\");\n    }\n    return out;\n}\nfunction _pagingDraw(settings, host, opts) {\n    if (!settings._bInitComplete) {\n        return;\n    }\n    var plugin = opts.type ? DataTable.ext.pager[opts.type] : _pagingDynamic, aria = settings.oLanguage.oAria.paginate || {}, start = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = [], buttonEls = [], buttonsNested = plugin(opts).map(function(val) {\n        return val === \"numbers\" ? _pagingNumbers(page, pages, opts.buttons, opts.boundaryNumbers) : val;\n    });\n    // .flat() would be better, but not supported in old Safari\n    buttons = buttons.concat.apply(buttons, buttonsNested);\n    for(var i = 0; i < buttons.length; i++){\n        var button = buttons[i];\n        var btnInfo = _pagingButtonInfo(settings, button, page, pages);\n        var btn = _fnRenderer(settings, \"pagingButton\")(settings, button, btnInfo.display, btnInfo.active, btnInfo.disabled);\n        var ariaLabel = typeof button === \"string\" ? aria[button] : aria.number ? aria.number + (button + 1) : null;\n        // Common attributes\n        $(btn.clicker).attr({\n            \"aria-controls\": settings.sTableId,\n            \"aria-disabled\": btnInfo.disabled ? \"true\" : null,\n            \"aria-current\": btnInfo.active ? \"page\" : null,\n            \"aria-label\": ariaLabel,\n            \"data-dt-idx\": button,\n            \"tabIndex\": btnInfo.disabled ? -1 : settings.iTabIndex && btn.clicker[0].nodeName.toLowerCase() !== \"span\" ? settings.iTabIndex : null\n        });\n        if (typeof button !== \"number\") {\n            $(btn.clicker).addClass(button);\n        }\n        _fnBindAction(btn.clicker, {\n            action: button\n        }, function(e) {\n            e.preventDefault();\n            _fnPageChange(settings, e.data.action, true);\n        });\n        buttonEls.push(btn.display);\n    }\n    var wrapped = _fnRenderer(settings, \"pagingContainer\")(settings, buttonEls);\n    var activeEl = host.find(document.activeElement).data(\"dt-idx\");\n    host.empty().append(wrapped);\n    if (activeEl !== undefined) {\n        host.find(\"[data-dt-idx=\" + activeEl + \"]\").trigger(\"focus\");\n    }\n    // Responsive - check if the buttons are over two lines based on the\n    // height of the buttons and the container.\n    if (buttonEls.length) {\n        var outerHeight = $(buttonEls[0]).outerHeight();\n        if (opts.buttons > 1 && // prevent infinite\n        outerHeight > 0 && // will be 0 if hidden\n        $(host).height() >= outerHeight * 2 - 10) {\n            _pagingDraw(settings, host, $.extend({}, opts, {\n                buttons: opts.buttons - 2\n            }));\n        }\n    }\n}\n/**\n * Get properties for a button based on the current paging state of the table\n *\n * @param {*} settings DT settings object\n * @param {*} button The button type in question\n * @param {*} page Table's current page\n * @param {*} pages Number of pages\n * @returns Info object\n */ function _pagingButtonInfo(settings, button, page, pages) {\n    var lang = settings.oLanguage.oPaginate;\n    var o = {\n        display: \"\",\n        active: false,\n        disabled: false\n    };\n    switch(button){\n        case \"ellipsis\":\n            o.display = \"&#x2026;\";\n            break;\n        case \"first\":\n            o.display = lang.sFirst;\n            if (page === 0) {\n                o.disabled = true;\n            }\n            break;\n        case \"previous\":\n            o.display = lang.sPrevious;\n            if (page === 0) {\n                o.disabled = true;\n            }\n            break;\n        case \"next\":\n            o.display = lang.sNext;\n            if (pages === 0 || page === pages - 1) {\n                o.disabled = true;\n            }\n            break;\n        case \"last\":\n            o.display = lang.sLast;\n            if (pages === 0 || page === pages - 1) {\n                o.disabled = true;\n            }\n            break;\n        default:\n            if (typeof button === \"number\") {\n                o.display = settings.fnFormatNumber(button + 1);\n                if (page === button) {\n                    o.active = true;\n                }\n            }\n            break;\n    }\n    return o;\n}\n/**\n * Compute what number buttons to show in the paging control\n *\n * @param {*} page Current page\n * @param {*} pages Total number of pages\n * @param {*} buttons Target number of number buttons\n * @param {boolean} addFirstLast Indicate if page 1 and end should be included\n * @returns Buttons to show\n */ function _pagingNumbers(page, pages, buttons, addFirstLast) {\n    var numbers = [], half = Math.floor(buttons / 2), before = addFirstLast ? 2 : 1, after = addFirstLast ? 1 : 0;\n    if (pages <= buttons) {\n        numbers = _range(0, pages);\n    } else if (buttons === 1) {\n        // Single button - current page only\n        numbers = [\n            page\n        ];\n    } else if (buttons === 3) {\n        // Special logic for just three buttons\n        if (page <= 1) {\n            numbers = [\n                0,\n                1,\n                \"ellipsis\"\n            ];\n        } else if (page >= pages - 2) {\n            numbers = _range(pages - 2, pages);\n            numbers.unshift(\"ellipsis\");\n        } else {\n            numbers = [\n                \"ellipsis\",\n                page,\n                \"ellipsis\"\n            ];\n        }\n    } else if (page <= half) {\n        numbers = _range(0, buttons - before);\n        numbers.push(\"ellipsis\");\n        if (addFirstLast) {\n            numbers.push(pages - 1);\n        }\n    } else if (page >= pages - 1 - half) {\n        numbers = _range(pages - (buttons - before), pages);\n        numbers.unshift(\"ellipsis\");\n        if (addFirstLast) {\n            numbers.unshift(0);\n        }\n    } else {\n        numbers = _range(page - half + before, page + half - after);\n        numbers.push(\"ellipsis\");\n        numbers.unshift(\"ellipsis\");\n        if (addFirstLast) {\n            numbers.push(pages - 1);\n            numbers.unshift(0);\n        }\n    }\n    return numbers;\n}\nvar __lengthCounter = 0;\n// opts\n// - menu\n// - text\nDataTable.feature.register(\"pageLength\", function(settings, opts) {\n    var features = settings.oFeatures;\n    // For compatibility with the legacy `pageLength` top level option\n    if (!features.bPaginate || !features.bLengthChange) {\n        return null;\n    }\n    opts = $.extend({\n        menu: settings.aLengthMenu,\n        text: settings.oLanguage.sLengthMenu\n    }, opts);\n    var classes = settings.oClasses.length, tableId = settings.sTableId, menu = opts.menu, lengths = [], language = [], i;\n    // Options can be given in a number of ways\n    if (Array.isArray(menu[0])) {\n        // Old 1.x style - 2D array\n        lengths = menu[0];\n        language = menu[1];\n    } else {\n        for(i = 0; i < menu.length; i++){\n            // An object with different label and value\n            if ($.isPlainObject(menu[i])) {\n                lengths.push(menu[i].value);\n                language.push(menu[i].label);\n            } else {\n                // Or just a number to display and use\n                lengths.push(menu[i]);\n                language.push(menu[i]);\n            }\n        }\n    }\n    // We can put the <select> outside of the label if it is at the start or\n    // end which helps improve accessability (not all screen readers like\n    // implicit for elements).\n    var end = opts.text.match(/_MENU_$/);\n    var start = opts.text.match(/^_MENU_/);\n    var removed = opts.text.replace(/_MENU_/, \"\");\n    var str = \"<label>\" + opts.text + \"</label>\";\n    if (start) {\n        str = \"_MENU_<label>\" + removed + \"</label>\";\n    } else if (end) {\n        str = \"<label>\" + removed + \"</label>_MENU_\";\n    }\n    // Wrapper element - use a span as a holder for where the select will go\n    var tmpId = \"tmp-\" + +new Date();\n    var div = $(\"<div/>\").addClass(classes.container).append(str.replace(\"_MENU_\", '<span id=\"' + tmpId + '\"></span>'));\n    // Save text node content for macro updating\n    var textNodes = [];\n    Array.prototype.slice.call(div.find(\"label\")[0].childNodes).forEach(function(el) {\n        if (el.nodeType === Node.TEXT_NODE) {\n            textNodes.push({\n                el: el,\n                text: el.textContent\n            });\n        }\n    });\n    // Update the label text in case it has an entries value\n    var updateEntries = function(len) {\n        textNodes.forEach(function(node) {\n            node.el.textContent = _fnMacros(settings, node.text, len);\n        });\n    };\n    // Next, the select itself, along with the options\n    var select = $(\"<select/>\", {\n        \"aria-controls\": tableId,\n        \"class\": classes.select\n    });\n    for(i = 0; i < lengths.length; i++){\n        // Attempt to look up the length from the i18n options\n        var label = settings.api.i18n(\"lengthLabels.\" + lengths[i], null);\n        if (label === null) {\n            // If not present, fallback to old style\n            label = typeof language[i] === \"number\" ? settings.fnFormatNumber(language[i]) : language[i];\n        }\n        select[0][i] = new Option(label, lengths[i]);\n    }\n    // add for and id to label and input\n    div.find(\"label\").attr(\"for\", \"dt-length-\" + __lengthCounter);\n    select.attr(\"id\", \"dt-length-\" + __lengthCounter);\n    __lengthCounter++;\n    // Swap in the select list\n    div.find(\"#\" + tmpId).replaceWith(select);\n    // Can't use `select` variable as user might provide their own and the\n    // reference is broken by the use of outerHTML\n    $(\"select\", div).val(settings._iDisplayLength).on(\"change.DT\", function() {\n        _fnLengthChange(settings, $(this).val());\n        _fnDraw(settings);\n    });\n    // Update node value whenever anything changes the table's length\n    $(settings.nTable).on(\"length.dt.DT\", function(e, s, len) {\n        if (settings === s) {\n            $(\"select\", div).val(len);\n            // Resolve plurals in the text for the new length\n            updateEntries(len);\n        }\n    });\n    updateEntries(settings._iDisplayLength);\n    return div;\n}, \"l\");\n// jQuery access\n$.fn.dataTable = DataTable;\n// Provide access to the host jQuery object (circular reference)\nDataTable.$ = $;\n// Legacy aliases\n$.fn.dataTableSettings = DataTable.settings;\n$.fn.dataTableExt = DataTable.ext;\n// With a capital `D` we return a DataTables API instance rather than a\n// jQuery object\n$.fn.DataTable = function(opts) {\n    return $(this).dataTable(opts).api();\n};\n// All properties that are available to $.fn.dataTable should also be\n// available on $.fn.DataTable\n$.each(DataTable, function(prop, val) {\n    $.fn.DataTable[prop] = val;\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataTable);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQvanMvZGF0YVRhYmxlcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Q0FFQyxHQUUyQjtBQUU1QiwrREFBK0Q7QUFDL0QsNERBQTREO0FBQzVELElBQUlDLElBQUlELG1DQUFNQTtBQUdkLElBQUlFLFlBQVksU0FBV0MsUUFBUSxFQUFFQyxPQUFPO0lBRTNDLDJFQUEyRTtJQUMzRSxzQ0FBc0M7SUFDdEMsSUFBSUYsVUFBVUcsT0FBTyxDQUFDRixVQUFVQyxVQUFVO1FBQ3pDLE9BQU9GO0lBQ1I7SUFFQSwrRUFBK0U7SUFDL0UsSUFBSSxJQUFJLFlBQVlBLFdBQVc7UUFDOUIsT0FBT0QsRUFBRUUsVUFBVUQsU0FBUyxDQUFDRTtJQUM5QixPQUNLO1FBQ0oscUJBQXFCO1FBQ3JCQSxVQUFVRDtJQUNYO0lBRUEsSUFBSUcsUUFBUSxJQUFJO0lBQ2hCLElBQUlDLFlBQVlILFlBQVlJO0lBQzVCLElBQUlDLE1BQU0sSUFBSSxDQUFDQyxNQUFNO0lBRXJCLElBQUtILFdBQVk7UUFDaEJILFVBQVUsQ0FBQztJQUNaO0lBRUEsbURBQW1EO0lBQ25ELElBQUksQ0FBQ08sR0FBRyxHQUFHO1FBRVYsT0FBTyxJQUFJQyxLQUFNLElBQUk7SUFDdEI7SUFFQSxJQUFJLENBQUNDLElBQUksQ0FBQztRQUNULG9FQUFvRTtRQUNwRSxtQ0FBbUM7UUFDbkMsSUFBSUMsSUFBSSxDQUFDO1FBQ1QsSUFBSUMsUUFBUU4sTUFBTSxJQUNqQk8sVUFBV0YsR0FBR1YsU0FBUyxRQUN2QkE7UUFHRCxJQUFJYSxJQUFFLEdBQUdDO1FBQ1QsSUFBSUMsTUFBTSxJQUFJLENBQUNDLFlBQVksQ0FBRTtRQUM3QixJQUFJQyxXQUFXbkIsVUFBVW1CLFFBQVE7UUFDakMsSUFBSUMsUUFBUXJCLEVBQUUsSUFBSTtRQUVsQixlQUFlO1FBQ2YsSUFBSyxJQUFJLENBQUNzQixRQUFRLENBQUNDLFdBQVcsTUFBTSxTQUNwQztZQUNDQyxPQUFR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LEVBQUV2bUIsQ0FBQyxFQUFFNUIsR0FBRztRQUN6RCxJQUFLMkIsYUFBYUMsR0FBSTtZQUNyQnBDLEVBQUUsVUFBVW91QyxLQUFLaDlCLEdBQUcsQ0FBRTVRO1lBRXRCLGlEQUFpRDtZQUNqRGd1QyxjQUFjaHVDO1FBQ2Y7SUFDRDtJQUVBZ3VDLGNBQWNyc0MsU0FBUytuQixlQUFlO0lBRXRDLE9BQU9ra0I7QUFDUixHQUFHO0FBRUgsZ0JBQWdCO0FBQ2hCcHVDLEVBQUVtUyxFQUFFLENBQUNyTyxTQUFTLEdBQUc3RDtBQUVqQixnRUFBZ0U7QUFDaEVBLFVBQVVELENBQUMsR0FBR0E7QUFFZCxpQkFBaUI7QUFDakJBLEVBQUVtUyxFQUFFLENBQUN3OEIsaUJBQWlCLEdBQUcxdUMsVUFBVWtDLFFBQVE7QUFDM0NuQyxFQUFFbVMsRUFBRSxDQUFDeThCLFlBQVksR0FBRzN1QyxVQUFVZ0QsR0FBRztBQUVqQyx1RUFBdUU7QUFDdkUsZ0JBQWdCO0FBQ2hCakQsRUFBRW1TLEVBQUUsQ0FBQ2xTLFNBQVMsR0FBRyxTQUFXa2xCLElBQUk7SUFDL0IsT0FBT25sQixFQUFFLElBQUksRUFBRThELFNBQVMsQ0FBRXFoQixNQUFPemtCLEdBQUc7QUFDckM7QUFFQSxxRUFBcUU7QUFDckUsOEJBQThCO0FBQzlCVixFQUFFWSxJQUFJLENBQUVYLFdBQVcsU0FBVzhQLElBQUksRUFBRXFCLEdBQUc7SUFDdENwUixFQUFFbVMsRUFBRSxDQUFDbFMsU0FBUyxDQUFFOFAsS0FBTSxHQUFHcUI7QUFDMUI7QUFFQSxpRUFBZW5SLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQvanMvZGF0YVRhYmxlcy5tanM/MTUyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgRGF0YVRhYmxlcyAyLjMuMFxuICogwqkgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgalF1ZXJ5IGZyb20gJ2pxdWVyeSc7XG5cbi8vIERhdGFUYWJsZXMgY29kZSB1c2VzICQgaW50ZXJuYWxseSwgYnV0IHdlIHdhbnQgdG8gYmUgYWJsZSB0b1xuLy8gcmVhc3NpZ24gJCB3aXRoIHRoZSBgdXNlYCBtZXRob2QsIHNvIGl0IGlzIGEgcmVndWxhciB2YXIuXG52YXIgJCA9IGpRdWVyeTtcblxuXG52YXIgRGF0YVRhYmxlID0gZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0aW9ucyApXG57XG5cdC8vIENoZWNrIGlmIGNhbGxlZCB3aXRoIGEgd2luZG93IG9yIGpRdWVyeSBvYmplY3QgZm9yIERPTSBsZXNzIGFwcGxpY2F0aW9uc1xuXHQvLyBUaGlzIGlzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRpZiAoRGF0YVRhYmxlLmZhY3Rvcnkoc2VsZWN0b3IsIG9wdGlvbnMpKSB7XG5cdFx0cmV0dXJuIERhdGFUYWJsZTtcblx0fVxuXG5cdC8vIFdoZW4gY3JlYXRpbmcgd2l0aCBgbmV3YCwgY3JlYXRlIGEgbmV3IERhdGFUYWJsZSwgcmV0dXJuaW5nIHRoZSBBUEkgaW5zdGFuY2Vcblx0aWYgKHRoaXMgaW5zdGFuY2VvZiBEYXRhVGFibGUpIHtcblx0XHRyZXR1cm4gJChzZWxlY3RvcikuRGF0YVRhYmxlKG9wdGlvbnMpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEFyZ3VtZW50IHN3aXRjaGluZ1xuXHRcdG9wdGlvbnMgPSBzZWxlY3Rvcjtcblx0fVxuXG5cdHZhciBfdGhhdCA9IHRoaXM7XG5cdHZhciBlbXB0eUluaXQgPSBvcHRpb25zID09PSB1bmRlZmluZWQ7XG5cdHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuXHRpZiAoIGVtcHR5SW5pdCApIHtcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHQvLyBNZXRob2QgdG8gZ2V0IERUIEFQSSBpbnN0YW5jZSBmcm9tIGpRdWVyeSBvYmplY3Rcblx0dGhpcy5hcGkgPSBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzICk7XG5cdH07XG5cblx0dGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuXHRcdC8vIEZvciBlYWNoIGluaXRpYWxpc2F0aW9uIHdlIHdhbnQgdG8gZ2l2ZSBpdCBhIGNsZWFuIGluaXRpYWxpc2F0aW9uXG5cdFx0Ly8gb2JqZWN0IHRoYXQgY2FuIGJlIGJhc2hlZCBhcm91bmRcblx0XHR2YXIgbyA9IHt9O1xuXHRcdHZhciBvSW5pdCA9IGxlbiA+IDEgPyAvLyBvcHRpbWlzYXRpb24gZm9yIHNpbmdsZSB0YWJsZSBjYXNlXG5cdFx0XHRfZm5FeHRlbmQoIG8sIG9wdGlvbnMsIHRydWUgKSA6XG5cdFx0XHRvcHRpb25zO1xuXG5cdFx0XG5cdFx0dmFyIGk9MCwgaUxlbjtcblx0XHR2YXIgc0lkID0gdGhpcy5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHR2YXIgZGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHM7XG5cdFx0dmFyICR0aGlzID0gJCh0aGlzKTtcblx0XHRcblx0XHQvLyBTYW5pdHkgY2hlY2tcblx0XHRpZiAoIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSAndGFibGUnIClcblx0XHR7XG5cdFx0XHRfZm5Mb2coIG51bGwsIDAsICdOb24tdGFibGUgbm9kZSBpbml0aWFsaXNhdGlvbiAoJyt0aGlzLm5vZGVOYW1lKycpJywgMiApO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRcblx0XHQvLyBTcGVjaWFsIGNhc2UgZm9yIG9wdGlvbnNcblx0XHRpZiAob0luaXQub24gJiYgb0luaXQub24ub3B0aW9ucykge1xuXHRcdFx0X2ZuTGlzdGVuZXIoJHRoaXMsICdvcHRpb25zJywgb0luaXQub24ub3B0aW9ucyk7XHRcblx0XHR9XG5cdFx0XG5cdFx0JHRoaXMudHJpZ2dlciggJ29wdGlvbnMuZHQnLCBvSW5pdCApO1xuXHRcdFxuXHRcdC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciB0aGUgZGVmYXVsdHMgKi9cblx0XHRfZm5Db21wYXRPcHRzKCBkZWZhdWx0cyApO1xuXHRcdF9mbkNvbXBhdENvbHMoIGRlZmF1bHRzLmNvbHVtbiApO1xuXHRcdFxuXHRcdC8qIENvbnZlcnQgdGhlIGNhbWVsLWNhc2UgZGVmYXVsdHMgdG8gSHVuZ2FyaWFuICovXG5cdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggZGVmYXVsdHMsIGRlZmF1bHRzLCB0cnVlICk7XG5cdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggZGVmYXVsdHMuY29sdW1uLCBkZWZhdWx0cy5jb2x1bW4sIHRydWUgKTtcblx0XHRcblx0XHQvKiBTZXR0aW5nIHVwIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3QgKi9cblx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBkZWZhdWx0cywgJC5leHRlbmQoIG9Jbml0LCAkdGhpcy5kYXRhKCkgKSwgdHJ1ZSApO1xuXHRcdFxuXHRcdFxuXHRcdFxuXHRcdC8qIENoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgcmUtaW5pdGlhbGlzaW5nIGEgdGFibGUgKi9cblx0XHR2YXIgYWxsU2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG5cdFx0Zm9yICggaT0wLCBpTGVuPWFsbFNldHRpbmdzLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdFx0e1xuXHRcdFx0dmFyIHMgPSBhbGxTZXR0aW5nc1tpXTtcblx0XHRcblx0XHRcdC8qIEJhc2UgY2hlY2sgb24gdGFibGUgbm9kZSAqL1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRzLm5UYWJsZSA9PSB0aGlzIHx8XG5cdFx0XHRcdChzLm5USGVhZCAmJiBzLm5USGVhZC5wYXJlbnROb2RlID09IHRoaXMpIHx8XG5cdFx0XHRcdChzLm5URm9vdCAmJiBzLm5URm9vdC5wYXJlbnROb2RlID09IHRoaXMpXG5cdFx0XHQpIHtcblx0XHRcdFx0dmFyIGJSZXRyaWV2ZSA9IG9Jbml0LmJSZXRyaWV2ZSAhPT0gdW5kZWZpbmVkID8gb0luaXQuYlJldHJpZXZlIDogZGVmYXVsdHMuYlJldHJpZXZlO1xuXHRcdFx0XHR2YXIgYkRlc3Ryb3kgPSBvSW5pdC5iRGVzdHJveSAhPT0gdW5kZWZpbmVkID8gb0luaXQuYkRlc3Ryb3kgOiBkZWZhdWx0cy5iRGVzdHJveTtcblx0XHRcblx0XHRcdFx0aWYgKCBlbXB0eUluaXQgfHwgYlJldHJpZXZlIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiBzLm9JbnN0YW5jZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggYkRlc3Ryb3kgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmV3IERhdGFUYWJsZS5BcGkocykuZGVzdHJveSgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdF9mbkxvZyggcywgMCwgJ0Nhbm5vdCByZWluaXRpYWxpc2UgRGF0YVRhYmxlJywgMyApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFxuXHRcdFx0LyogSWYgdGhlIGVsZW1lbnQgd2UgYXJlIGluaXRpYWxpc2luZyBoYXMgdGhlIHNhbWUgSUQgYXMgYSB0YWJsZSB3aGljaCB3YXMgcHJldmlvdXNseVxuXHRcdFx0ICogaW5pdGlhbGlzZWQsIGJ1dCB0aGUgdGFibGUgbm9kZXMgZG9uJ3QgbWF0Y2ggKGZyb20gYmVmb3JlKSB0aGVuIHdlIGRlc3Ryb3kgdGhlIG9sZFxuXHRcdFx0ICogaW5zdGFuY2UgYnkgc2ltcGx5IGRlbGV0aW5nIGl0LiBUaGlzIGlzIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhlIHRhYmxlIGhhcyBiZWVuXG5cdFx0XHQgKiBkZXN0cm95ZWQgYnkgb3RoZXIgbWV0aG9kcy4gQW55b25lIHVzaW5nIG5vbi1pZCBzZWxlY3RvcnMgd2lsbCBuZWVkIHRvIGRvIHRoaXMgbWFudWFsbHlcblx0XHRcdCAqL1xuXHRcdFx0aWYgKCBzLnNUYWJsZUlkID09IHRoaXMuaWQgKVxuXHRcdFx0e1xuXHRcdFx0XHRhbGxTZXR0aW5ncy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qIEVuc3VyZSB0aGUgdGFibGUgaGFzIGFuIElEIC0gcmVxdWlyZWQgZm9yIGFjY2Vzc2liaWxpdHkgKi9cblx0XHRpZiAoIHNJZCA9PT0gbnVsbCB8fCBzSWQgPT09IFwiXCIgKVxuXHRcdHtcblx0XHRcdHNJZCA9IFwiRGF0YVRhYmxlc19UYWJsZV9cIisoRGF0YVRhYmxlLmV4dC5fdW5pcXVlKyspO1xuXHRcdFx0dGhpcy5pZCA9IHNJZDtcblx0XHR9XG5cdFx0XG5cdFx0LyogQ3JlYXRlIHRoZSBzZXR0aW5ncyBvYmplY3QgZm9yIHRoaXMgdGFibGUgYW5kIHNldCBzb21lIG9mIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMgKi9cblx0XHR2YXIgb1NldHRpbmdzID0gJC5leHRlbmQoIHRydWUsIHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncywge1xuXHRcdFx0XCJzRGVzdHJveVdpZHRoXCI6ICR0aGlzWzBdLnN0eWxlLndpZHRoLFxuXHRcdFx0XCJzSW5zdGFuY2VcIjogICAgIHNJZCxcblx0XHRcdFwic1RhYmxlSWRcIjogICAgICBzSWQsXG5cdFx0XHRjb2xncm91cDogJCgnPGNvbGdyb3VwPicpLnByZXBlbmRUbyh0aGlzKSxcblx0XHRcdGZhc3REYXRhOiBmdW5jdGlvbiAocm93LCBjb2x1bW4sIHR5cGUpIHtcblx0XHRcdFx0cmV0dXJuIF9mbkdldENlbGxEYXRhKG9TZXR0aW5ncywgcm93LCBjb2x1bW4sIHR5cGUpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRvU2V0dGluZ3MublRhYmxlID0gdGhpcztcblx0XHRvU2V0dGluZ3Mub0luaXQgID0gb0luaXQ7XG5cdFx0XG5cdFx0YWxsU2V0dGluZ3MucHVzaCggb1NldHRpbmdzICk7XG5cdFx0XG5cdFx0Ly8gTWFrZSBhIHNpbmdsZSBBUEkgaW5zdGFuY2UgYXZhaWxhYmxlIGZvciBpbnRlcm5hbCBoYW5kbGluZ1xuXHRcdG9TZXR0aW5ncy5hcGkgPSBuZXcgX0FwaSggb1NldHRpbmdzICk7XG5cdFx0XG5cdFx0Ly8gTmVlZCB0byBhZGQgdGhlIGluc3RhbmNlIGFmdGVyIHRoZSBpbnN0YW5jZSBhZnRlciB0aGUgc2V0dGluZ3Mgb2JqZWN0IGhhcyBiZWVuIGFkZGVkXG5cdFx0Ly8gdG8gdGhlIHNldHRpbmdzIGFycmF5LCBzbyB3ZSBjYW4gc2VsZiByZWZlcmVuY2UgdGhlIHRhYmxlIGluc3RhbmNlIGlmIG1vcmUgdGhhbiBvbmVcblx0XHRvU2V0dGluZ3Mub0luc3RhbmNlID0gKF90aGF0Lmxlbmd0aD09PTEpID8gX3RoYXQgOiAkdGhpcy5kYXRhVGFibGUoKTtcblx0XHRcblx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmVmb3JlIHdlIGFwcGx5IGFsbCB0aGUgZGVmYXVsdHNcblx0XHRfZm5Db21wYXRPcHRzKCBvSW5pdCApO1xuXHRcdFxuXHRcdC8vIElmIHRoZSBsZW5ndGggbWVudSBpcyBnaXZlbiwgYnV0IHRoZSBpbml0IGRpc3BsYXkgbGVuZ3RoIGlzIG5vdCwgdXNlIHRoZSBsZW5ndGggbWVudVxuXHRcdGlmICggb0luaXQuYUxlbmd0aE1lbnUgJiYgISBvSW5pdC5pRGlzcGxheUxlbmd0aCApXG5cdFx0e1xuXHRcdFx0b0luaXQuaURpc3BsYXlMZW5ndGggPSBBcnJheS5pc0FycmF5KG9Jbml0LmFMZW5ndGhNZW51WzBdKVxuXHRcdFx0XHQ/IG9Jbml0LmFMZW5ndGhNZW51WzBdWzBdXG5cdFx0XHRcdDogJC5pc1BsYWluT2JqZWN0KCBvSW5pdC5hTGVuZ3RoTWVudVswXSApXG5cdFx0XHRcdFx0PyBvSW5pdC5hTGVuZ3RoTWVudVswXS52YWx1ZVxuXHRcdFx0XHRcdDogb0luaXQuYUxlbmd0aE1lbnVbMF07XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEFwcGx5IHRoZSBkZWZhdWx0cyBhbmQgaW5pdCBvcHRpb25zIHRvIG1ha2UgYSBzaW5nbGUgaW5pdCBvYmplY3Qgd2lsbCBhbGxcblx0XHQvLyBvcHRpb25zIGRlZmluZWQgZnJvbSBkZWZhdWx0cyBhbmQgaW5zdGFuY2Ugb3B0aW9ucy5cblx0XHRvSW5pdCA9IF9mbkV4dGVuZCggJC5leHRlbmQoIHRydWUsIHt9LCBkZWZhdWx0cyApLCBvSW5pdCApO1xuXHRcdFxuXHRcdFxuXHRcdC8vIE1hcCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucyBvbnRvIHRoZSBzZXR0aW5ncyBvYmplY3Rcblx0XHRfZm5NYXAoIG9TZXR0aW5ncy5vRmVhdHVyZXMsIG9Jbml0LCBbXG5cdFx0XHRcImJQYWdpbmF0ZVwiLFxuXHRcdFx0XCJiTGVuZ3RoQ2hhbmdlXCIsXG5cdFx0XHRcImJGaWx0ZXJcIixcblx0XHRcdFwiYlNvcnRcIixcblx0XHRcdFwiYlNvcnRNdWx0aVwiLFxuXHRcdFx0XCJiSW5mb1wiLFxuXHRcdFx0XCJiUHJvY2Vzc2luZ1wiLFxuXHRcdFx0XCJiQXV0b1dpZHRoXCIsXG5cdFx0XHRcImJTb3J0Q2xhc3Nlc1wiLFxuXHRcdFx0XCJiU2VydmVyU2lkZVwiLFxuXHRcdFx0XCJiRGVmZXJSZW5kZXJcIlxuXHRcdF0gKTtcblx0XHRfZm5NYXAoIG9TZXR0aW5ncywgb0luaXQsIFtcblx0XHRcdFwiYWpheFwiLFxuXHRcdFx0XCJmbkZvcm1hdE51bWJlclwiLFxuXHRcdFx0XCJzU2VydmVyTWV0aG9kXCIsXG5cdFx0XHRcImFhU29ydGluZ1wiLFxuXHRcdFx0XCJhYVNvcnRpbmdGaXhlZFwiLFxuXHRcdFx0XCJhTGVuZ3RoTWVudVwiLFxuXHRcdFx0XCJzUGFnaW5hdGlvblR5cGVcIixcblx0XHRcdFwiaVN0YXRlRHVyYXRpb25cIixcblx0XHRcdFwiYlNvcnRDZWxsc1RvcFwiLFxuXHRcdFx0XCJpVGFiSW5kZXhcIixcblx0XHRcdFwic0RvbVwiLFxuXHRcdFx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCIsXG5cdFx0XHRcImZuU3RhdGVTYXZlQ2FsbGJhY2tcIixcblx0XHRcdFwicmVuZGVyZXJcIixcblx0XHRcdFwic2VhcmNoRGVsYXlcIixcblx0XHRcdFwicm93SWRcIixcblx0XHRcdFwiY2FwdGlvblwiLFxuXHRcdFx0XCJsYXlvdXRcIixcblx0XHRcdFwib3JkZXJEZXNjUmV2ZXJzZVwiLFxuXHRcdFx0XCJvcmRlckluZGljYXRvcnNcIixcblx0XHRcdFwib3JkZXJIYW5kbGVyXCIsXG5cdFx0XHRcInRpdGxlUm93XCIsXG5cdFx0XHRcInR5cGVEZXRlY3RcIixcblx0XHRcdFsgXCJpQ29va2llRHVyYXRpb25cIiwgXCJpU3RhdGVEdXJhdGlvblwiIF0sIC8vIGJhY2t3YXJkcyBjb21wYXRcblx0XHRcdFsgXCJvU2VhcmNoXCIsIFwib1ByZXZpb3VzU2VhcmNoXCIgXSxcblx0XHRcdFsgXCJhb1NlYXJjaENvbHNcIiwgXCJhb1ByZVNlYXJjaENvbHNcIiBdLFxuXHRcdFx0WyBcImlEaXNwbGF5TGVuZ3RoXCIsIFwiX2lEaXNwbGF5TGVuZ3RoXCIgXVxuXHRcdF0gKTtcblx0XHRfZm5NYXAoIG9TZXR0aW5ncy5vU2Nyb2xsLCBvSW5pdCwgW1xuXHRcdFx0WyBcInNTY3JvbGxYXCIsIFwic1hcIiBdLFxuXHRcdFx0WyBcInNTY3JvbGxYSW5uZXJcIiwgXCJzWElubmVyXCIgXSxcblx0XHRcdFsgXCJzU2Nyb2xsWVwiLCBcInNZXCIgXSxcblx0XHRcdFsgXCJiU2Nyb2xsQ29sbGFwc2VcIiwgXCJiQ29sbGFwc2VcIiBdXG5cdFx0XSApO1xuXHRcdF9mbk1hcCggb1NldHRpbmdzLm9MYW5ndWFnZSwgb0luaXQsIFwiZm5JbmZvQ2FsbGJhY2tcIiApO1xuXHRcdFxuXHRcdC8qIENhbGxiYWNrIGZ1bmN0aW9ucyB3aGljaCBhcmUgYXJyYXkgZHJpdmVuICovXG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgICAgICAgb0luaXQuZm5EcmF3Q2FsbGJhY2sgKTtcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9TdGF0ZVNhdmVQYXJhbXMnLCAgICBvSW5pdC5mblN0YXRlU2F2ZVBhcmFtcyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlTG9hZFBhcmFtcycsICAgIG9Jbml0LmZuU3RhdGVMb2FkUGFyYW1zICk7XG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvU3RhdGVMb2FkZWQnLCAgICAgICAgb0luaXQuZm5TdGF0ZUxvYWRlZCApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1Jvd0NhbGxiYWNrJywgICAgICAgIG9Jbml0LmZuUm93Q2FsbGJhY2sgKTtcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBvSW5pdC5mbkNyZWF0ZWRSb3cgKTtcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9IZWFkZXJDYWxsYmFjaycsICAgICBvSW5pdC5mbkhlYWRlckNhbGxiYWNrICk7XG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRm9vdGVyQ2FsbGJhY2snLCAgICAgb0luaXQuZm5Gb290ZXJDYWxsYmFjayApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0luaXRDb21wbGV0ZScsICAgICAgIG9Jbml0LmZuSW5pdENvbXBsZXRlICk7XG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvUHJlRHJhd0NhbGxiYWNrJywgICAgb0luaXQuZm5QcmVEcmF3Q2FsbGJhY2sgKTtcblx0XHRcblx0XHRvU2V0dGluZ3Mucm93SWRGbiA9IF9mbkdldE9iamVjdERhdGFGbiggb0luaXQucm93SWQgKTtcblx0XHRcblx0XHQvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG5cdFx0aWYgKG9Jbml0Lm9uKSB7XG5cdFx0XHRPYmplY3Qua2V5cyhvSW5pdC5vbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdF9mbkxpc3RlbmVyKCR0aGlzLCBrZXksIG9Jbml0Lm9uW2tleV0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdFxuXHRcdC8qIEJyb3dzZXIgc3VwcG9ydCBkZXRlY3Rpb24gKi9cblx0XHRfZm5Ccm93c2VyRGV0ZWN0KCBvU2V0dGluZ3MgKTtcblx0XHRcblx0XHR2YXIgb0NsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0XG5cdFx0JC5leHRlbmQoIG9DbGFzc2VzLCBEYXRhVGFibGUuZXh0LmNsYXNzZXMsIG9Jbml0Lm9DbGFzc2VzICk7XG5cdFx0JHRoaXMuYWRkQ2xhc3MoIG9DbGFzc2VzLnRhYmxlICk7XG5cdFx0XG5cdFx0aWYgKCEgb1NldHRpbmdzLm9GZWF0dXJlcy5iUGFnaW5hdGUpIHtcblx0XHRcdG9Jbml0LmlEaXNwbGF5U3RhcnQgPSAwO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoIG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9PT0gdW5kZWZpbmVkIClcblx0XHR7XG5cdFx0XHQvKiBEaXNwbGF5IHN0YXJ0IHBvaW50LCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBzYXZlIHNhdmluZyAqL1xuXHRcdFx0b1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gb0luaXQuaURpc3BsYXlTdGFydDtcblx0XHRcdG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0fVxuXHRcdFxuXHRcdHZhciBkZWZlciA9IG9Jbml0LmlEZWZlckxvYWRpbmc7XG5cdFx0aWYgKCBkZWZlciAhPT0gbnVsbCApXG5cdFx0e1xuXHRcdFx0b1NldHRpbmdzLmRlZmVyTG9hZGluZyA9IHRydWU7XG5cdFx0XG5cdFx0XHR2YXIgdG1wID0gQXJyYXkuaXNBcnJheShkZWZlcik7XG5cdFx0XHRvU2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA9IHRtcCA/IGRlZmVyWzBdIDogZGVmZXI7XG5cdFx0XHRvU2V0dGluZ3MuX2lSZWNvcmRzVG90YWwgPSB0bXAgPyBkZWZlclsxXSA6IGRlZmVyO1xuXHRcdH1cblx0XHRcblx0XHQvKlxuXHRcdCAqIENvbHVtbnNcblx0XHQgKiBTZWUgaWYgd2Ugc2hvdWxkIGxvYWQgY29sdW1ucyBhdXRvbWF0aWNhbGx5IG9yIHVzZSBkZWZpbmVkIG9uZXNcblx0XHQgKi9cblx0XHR2YXIgY29sdW1uc0luaXQgPSBbXTtcblx0XHR2YXIgdGhlYWQgPSB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aGVhZCcpO1xuXHRcdHZhciBpbml0SGVhZGVyTGF5b3V0ID0gX2ZuRGV0ZWN0SGVhZGVyKCBvU2V0dGluZ3MsIHRoZWFkWzBdICk7XG5cdFx0XG5cdFx0Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNvbHVtbnMgYXJyYXksIHRoZW4gZ2VuZXJhdGUgb25lIHdpdGggbnVsbHNcblx0XHRpZiAoIG9Jbml0LmFvQ29sdW1ucyApIHtcblx0XHRcdGNvbHVtbnNJbml0ID0gb0luaXQuYW9Db2x1bW5zO1xuXHRcdH1cblx0XHRlbHNlIGlmICggaW5pdEhlYWRlckxheW91dC5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCBpPTAsIGlMZW49aW5pdEhlYWRlckxheW91dFswXS5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRcdGNvbHVtbnNJbml0LnB1c2goIG51bGwgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gQWRkIHRoZSBjb2x1bW5zXG5cdFx0Zm9yICggaT0wLCBpTGVuPWNvbHVtbnNJbml0Lmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdF9mbkFkZENvbHVtbiggb1NldHRpbmdzICk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEFwcGx5IHRoZSBjb2x1bW4gZGVmaW5pdGlvbnNcblx0XHRfZm5BcHBseUNvbHVtbkRlZnMoIG9TZXR0aW5ncywgb0luaXQuYW9Db2x1bW5EZWZzLCBjb2x1bW5zSW5pdCwgaW5pdEhlYWRlckxheW91dCwgZnVuY3Rpb24gKGlDb2wsIG9EZWYpIHtcblx0XHRcdF9mbkNvbHVtbk9wdGlvbnMoIG9TZXR0aW5ncywgaUNvbCwgb0RlZiApO1xuXHRcdH0gKTtcblx0XHRcblx0XHQvKiBIVE1MNSBhdHRyaWJ1dGUgZGV0ZWN0aW9uIC0gYnVpbGQgYW4gbURhdGEgb2JqZWN0IGF1dG9tYXRpY2FsbHkgaWYgdGhlXG5cdFx0ICogYXR0cmlidXRlcyBhcmUgZm91bmRcblx0XHQgKi9cblx0XHR2YXIgcm93T25lID0gJHRoaXMuY2hpbGRyZW4oJ3Rib2R5JykuZmluZCgndHI6Zmlyc3QtY2hpbGQnKS5lcSgwKTtcblx0XHRcblx0XHRpZiAoIHJvd09uZS5sZW5ndGggKSB7XG5cdFx0XHR2YXIgYSA9IGZ1bmN0aW9uICggY2VsbCwgbmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIGNlbGwuZ2V0QXR0cmlidXRlKCAnZGF0YS0nK25hbWUgKSAhPT0gbnVsbCA/IG5hbWUgOiBudWxsO1xuXHRcdFx0fTtcblx0XHRcblx0XHRcdCQoIHJvd09uZVswXSApLmNoaWxkcmVuKCd0aCwgdGQnKS5lYWNoKCBmdW5jdGlvbiAoaSwgY2VsbCkge1xuXHRcdFx0XHR2YXIgY29sID0gb1NldHRpbmdzLmFvQ29sdW1uc1tpXTtcblx0XHRcblx0XHRcdFx0aWYgKCEgY29sKSB7XG5cdFx0XHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsICdJbmNvcnJlY3QgY29sdW1uIGNvdW50JywgMTggKTtcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRpZiAoIGNvbC5tRGF0YSA9PT0gaSApIHtcblx0XHRcdFx0XHR2YXIgc29ydCA9IGEoIGNlbGwsICdzb3J0JyApIHx8IGEoIGNlbGwsICdvcmRlcicgKTtcblx0XHRcdFx0XHR2YXIgZmlsdGVyID0gYSggY2VsbCwgJ2ZpbHRlcicgKSB8fCBhKCBjZWxsLCAnc2VhcmNoJyApO1xuXHRcdFxuXHRcdFx0XHRcdGlmICggc29ydCAhPT0gbnVsbCB8fCBmaWx0ZXIgIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRjb2wubURhdGEgPSB7XG5cdFx0XHRcdFx0XHRcdF86ICAgICAgaSsnLmRpc3BsYXknLFxuXHRcdFx0XHRcdFx0XHRzb3J0OiAgIHNvcnQgIT09IG51bGwgICA/IGkrJy5AZGF0YS0nK3NvcnQgICA6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdFx0dHlwZTogICBzb3J0ICE9PSBudWxsICAgPyBpKycuQGRhdGEtJytzb3J0ICAgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdGZpbHRlcjogZmlsdGVyICE9PSBudWxsID8gaSsnLkBkYXRhLScrZmlsdGVyIDogdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0Y29sLl9pc0FycmF5SG9zdCA9IHRydWU7XG5cdFx0XG5cdFx0XHRcdFx0XHRfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gTXVzdCBiZSBkb25lIGFmdGVyIGV2ZXJ5dGhpbmcgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN0YXRlIHNhdmluZyFcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBfZm5TYXZlU3RhdGUgKTtcblx0XHRcblx0XHR2YXIgZmVhdHVyZXMgPSBvU2V0dGluZ3Mub0ZlYXR1cmVzO1xuXHRcdGlmICggb0luaXQuYlN0YXRlU2F2ZSApXG5cdFx0e1xuXHRcdFx0ZmVhdHVyZXMuYlN0YXRlU2F2ZSA9IHRydWU7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIElmIGFhU29ydGluZyBpcyBub3QgZGVmaW5lZCwgdGhlbiB3ZSB1c2UgdGhlIGZpcnN0IGluZGljYXRvciBpbiBhc1NvcnRpbmdcblx0XHQvLyBpbiBjYXNlIHRoYXQgaGFzIGJlZW4gYWx0ZXJlZCwgc28gdGhlIGRlZmF1bHQgc29ydCByZWZsZWN0cyB0aGF0IG9wdGlvblxuXHRcdGlmICggb0luaXQuYWFTb3J0aW5nID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YXIgc29ydGluZyA9IG9TZXR0aW5ncy5hYVNvcnRpbmc7XG5cdFx0XHRmb3IgKCBpPTAsIGlMZW49c29ydGluZy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRcdHNvcnRpbmdbaV1bMV0gPSBvU2V0dGluZ3MuYW9Db2x1bW5zWyBpIF0uYXNTb3J0aW5nWzBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvLyBEbyBhIGZpcnN0IHBhc3Mgb24gdGhlIHNvcnRpbmcgY2xhc3NlcyAoYWxsb3dzIGFueSBzaXplIGNoYW5nZXMgdG8gYmUgdGFrZW4gaW50b1xuXHRcdC8vIGFjY291bnQsIGFuZCBhbHNvIHdpbGwgYXBwbHkgc29ydGluZyBkaXNhYmxlZCBjbGFzc2VzIGlmIGRpc2FibGVkXG5cdFx0X2ZuU29ydGluZ0NsYXNzZXMoIG9TZXR0aW5ncyApO1xuXHRcdFxuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICggb1NldHRpbmdzLmJTb3J0ZWQgfHwgX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgPT09ICdzc3AnIHx8IGZlYXR1cmVzLmJEZWZlclJlbmRlciApIHtcblx0XHRcdFx0X2ZuU29ydGluZ0NsYXNzZXMoIG9TZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRcblx0XHRcblx0XHQvKlxuXHRcdCAqIFRhYmxlIEhUTUwgaW5pdFxuXHRcdCAqIENhY2hlIHRoZSBoZWFkZXIsIGJvZHkgYW5kIGZvb3RlciBhcyByZXF1aXJlZCwgY3JlYXRpbmcgdGhlbSBpZiBuZWVkZWRcblx0XHQgKi9cblx0XHR2YXIgY2FwdGlvbiA9ICR0aGlzLmNoaWxkcmVuKCdjYXB0aW9uJyk7XG5cdFx0XG5cdFx0aWYgKCBvU2V0dGluZ3MuY2FwdGlvbiApIHtcblx0XHRcdGlmICggY2FwdGlvbi5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdGNhcHRpb24gPSAkKCc8Y2FwdGlvbi8+JykuYXBwZW5kVG8oICR0aGlzICk7XG5cdFx0XHR9XG5cdFx0XG5cdFx0XHRjYXB0aW9uLmh0bWwoIG9TZXR0aW5ncy5jYXB0aW9uICk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFN0b3JlIHRoZSBjYXB0aW9uIHNpZGUsIHNvIHdlIGNhbiByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgZG9jdW1lbnRcblx0XHQvLyB3aGVuIGNyZWF0aW5nIHRoZSBlbGVtZW50XG5cdFx0aWYgKGNhcHRpb24ubGVuZ3RoKSB7XG5cdFx0XHRjYXB0aW9uWzBdLl9jYXB0aW9uU2lkZSA9IGNhcHRpb24uY3NzKCdjYXB0aW9uLXNpZGUnKTtcblx0XHRcdG9TZXR0aW5ncy5jYXB0aW9uTm9kZSA9IGNhcHRpb25bMF07XG5cdFx0fVxuXHRcdFxuXHRcdGlmICggdGhlYWQubGVuZ3RoID09PSAwICkge1xuXHRcdFx0dGhlYWQgPSAkKCc8dGhlYWQvPicpLmFwcGVuZFRvKCR0aGlzKTtcblx0XHR9XG5cdFx0b1NldHRpbmdzLm5USGVhZCA9IHRoZWFkWzBdO1xuXHRcdFxuXHRcdHZhciB0Ym9keSA9ICR0aGlzLmNoaWxkcmVuKCd0Ym9keScpO1xuXHRcdGlmICggdGJvZHkubGVuZ3RoID09PSAwICkge1xuXHRcdFx0dGJvZHkgPSAkKCc8dGJvZHkvPicpLmluc2VydEFmdGVyKHRoZWFkKTtcblx0XHR9XG5cdFx0b1NldHRpbmdzLm5UQm9keSA9IHRib2R5WzBdO1xuXHRcdFxuXHRcdHZhciB0Zm9vdCA9ICR0aGlzLmNoaWxkcmVuKCd0Zm9vdCcpO1xuXHRcdGlmICggdGZvb3QubGVuZ3RoID09PSAwICkge1xuXHRcdFx0Ly8gSWYgd2UgYXJlIGEgc2Nyb2xsaW5nIHRhYmxlLCBhbmQgbm8gZm9vdGVyIGhhcyBiZWVuIGdpdmVuLCB0aGVuIHdlIG5lZWQgdG8gY3JlYXRlXG5cdFx0XHQvLyBhIHRmb290IGVsZW1lbnQgZm9yIHRoZSBjYXB0aW9uIGVsZW1lbnQgdG8gYmUgYXBwZW5kZWQgdG9cblx0XHRcdHRmb290ID0gJCgnPHRmb290Lz4nKS5hcHBlbmRUbygkdGhpcyk7XG5cdFx0fVxuXHRcdG9TZXR0aW5ncy5uVEZvb3QgPSB0Zm9vdFswXTtcblx0XHRcblx0XHQvLyBDb3B5IHRoZSBkYXRhIGluZGV4IGFycmF5XG5cdFx0b1NldHRpbmdzLmFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHRcblx0XHQvLyBJbml0aWFsaXNhdGlvbiBjb21wbGV0ZSAtIHRhYmxlIGNhbiBiZSBkcmF3blxuXHRcdG9TZXR0aW5ncy5iSW5pdGlhbGlzZWQgPSB0cnVlO1xuXHRcdFxuXHRcdC8vIExhbmd1YWdlIGRlZmluaXRpb25zXG5cdFx0dmFyIG9MYW5ndWFnZSA9IG9TZXR0aW5ncy5vTGFuZ3VhZ2U7XG5cdFx0JC5leHRlbmQoIHRydWUsIG9MYW5ndWFnZSwgb0luaXQub0xhbmd1YWdlICk7XG5cdFx0XG5cdFx0aWYgKCBvTGFuZ3VhZ2Uuc1VybCApIHtcblx0XHRcdC8vIEdldCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgZnJvbSBhIGZpbGVcblx0XHRcdCQuYWpheCgge1xuXHRcdFx0XHRkYXRhVHlwZTogJ2pzb24nLFxuXHRcdFx0XHR1cmw6IG9MYW5ndWFnZS5zVXJsLFxuXHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cdFx0XHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggZGVmYXVsdHMub0xhbmd1YWdlLCBqc29uICk7XG5cdFx0XHRcdFx0JC5leHRlbmQoIHRydWUsIG9MYW5ndWFnZSwganNvbiwgb1NldHRpbmdzLm9Jbml0Lm9MYW5ndWFnZSApO1xuXHRcdFxuXHRcdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAnaTE4bicsIFtvU2V0dGluZ3NdLCB0cnVlKTtcblx0XHRcdFx0XHRfZm5Jbml0aWFsaXNlKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQvLyBFcnJvciBvY2N1cnJlZCBsb2FkaW5nIGxhbmd1YWdlIGZpbGVcblx0XHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgJ2kxOG4gZmlsZSBsb2FkaW5nIGVycm9yJywgMjEgKTtcblx0XHRcblx0XHRcdFx0XHQvLyBDb250aW51ZSBvbiBhcyBiZXN0IHdlIGNhblxuXHRcdFx0XHRcdF9mbkluaXRpYWxpc2UoIG9TZXR0aW5ncyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICdpMThuJywgW29TZXR0aW5nc10sIHRydWUpO1xuXHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0fVxuXHR9ICk7XG5cdF90aGF0ID0gbnVsbDtcblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuLyoqXG4gKiBEYXRhVGFibGVzIGV4dGVuc2lvbnNcbiAqIFxuICogVGhpcyBuYW1lc3BhY2UgYWN0cyBhcyBhIGNvbGxlY3Rpb24gYXJlYSBmb3IgcGx1Zy1pbnMgdGhhdCBjYW4gYmUgdXNlZCB0b1xuICogZXh0ZW5kIERhdGFUYWJsZXMgY2FwYWJpbGl0aWVzLiBJbmRlZWQgbWFueSBvZiB0aGUgYnVpbGQgaW4gbWV0aG9kc1xuICogdXNlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGUgdGhlaXIgb3duIGNhcGFiaWxpdGllcyAoc29ydGluZyBtZXRob2RzIGZvclxuICogZXhhbXBsZSkuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbmFtZXNwYWNlIGlzIGFsaWFzZWQgdG8gYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIGZvciBsZWdhY3lcbiAqIHJlYXNvbnNcbiAqXG4gKiAgQG5hbWVzcGFjZVxuICovXG5EYXRhVGFibGUuZXh0ID0gX2V4dCA9IHtcblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgYnVpbGQgdHlwZSAoZXhwYW5kZWQgYnkgdGhlIGRvd25sb2FkIGJ1aWxkZXIpXG5cdCAqXG5cdCAqICBAdHlwZSBzdHJpbmdcblx0ICovXG5cdGJ1aWxkZXI6IFwiLXNvdXJjZS1cIixcblxuXHQvKipcblx0ICogQnV0dG9ucy4gRm9yIHVzZSB3aXRoIHRoZSBCdXR0b25zIGV4dGVuc2lvbiBmb3IgRGF0YVRhYmxlcy4gVGhpcyBpc1xuXHQgKiBkZWZpbmVkIGhlcmUgc28gb3RoZXIgZXh0ZW5zaW9ucyBjYW4gZGVmaW5lIGJ1dHRvbnMgcmVnYXJkbGVzcyBvZiBsb2FkXG5cdCAqIG9yZGVyLiBJdCBpcyBfbm90XyB1c2VkIGJ5IERhdGFUYWJsZXMgY29yZS5cblx0ICpcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKiAgQGRlZmF1bHQge31cblx0ICovXG5cdGJ1dHRvbnM6IHt9LFxuXG5cblx0LyoqXG5cdCAqIENvbHVtbkNvbnRyb2wgYnV0dG9ucyBhbmQgY29udGVudFxuXHQgKlxuXHQgKiAgQHR5cGUgb2JqZWN0XG5cdCAqL1xuXHRjY0NvbnRlbnQ6IHt9LFxuXG5cblx0LyoqXG5cdCAqIEVsZW1lbnQgY2xhc3MgbmFtZXNcblx0ICpcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKiAgQGRlZmF1bHQge31cblx0ICovXG5cdGNsYXNzZXM6IHt9LFxuXG5cblx0LyoqXG5cdCAqIEVycm9yIHJlcG9ydGluZy5cblx0ICogXG5cdCAqIEhvdyBzaG91bGQgRGF0YVRhYmxlcyByZXBvcnQgYW4gZXJyb3IuIENhbiB0YWtlIHRoZSB2YWx1ZSAnYWxlcnQnLFxuXHQgKiAndGhyb3cnLCAnbm9uZScgb3IgYSBmdW5jdGlvbi5cblx0ICpcblx0ICogIEB0eXBlIHN0cmluZ3xmdW5jdGlvblxuXHQgKiAgQGRlZmF1bHQgYWxlcnRcblx0ICovXG5cdGVyck1vZGU6IFwiYWxlcnRcIixcblxuXG5cdC8qKlxuXHQgKiBMZWdhY3kgc28gdjEgcGx1Zy1pbnMgZG9uJ3QgdGhyb3cganMgZXJyb3JzIG9uIGxvYWRcblx0ICovXG5cdGZlYXR1cmU6IFtdLFxuXG5cdC8qKlxuXHQgKiBGZWF0dXJlIHBsdWctaW5zLlxuXHQgKiBcblx0ICogVGhpcyBpcyBhbiBvYmplY3Qgb2YgY2FsbGJhY2tzIHdoaWNoIHByb3ZpZGUgdGhlIGZlYXR1cmVzIGZvciBEYXRhVGFibGVzXG5cdCAqIHRvIGJlIGluaXRpYWxpc2VkIHZpYSB0aGUgYGxheW91dGAgb3B0aW9uLlxuXHQgKi9cblx0ZmVhdHVyZXM6IHt9LFxuXG5cblx0LyoqXG5cdCAqIFJvdyBzZWFyY2hpbmcuXG5cdCAqIFxuXHQgKiBUaGlzIG1ldGhvZCBvZiBzZWFyY2hpbmcgaXMgY29tcGxpbWVudGFyeSB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkXG5cdCAqIHNlYXJjaGluZywgYW5kIGEgbG90IG1vcmUgY29tcHJlaGVuc2l2ZSBhcyBpdCBhbGxvd3MgeW91IGNvbXBsZXRlIGNvbnRyb2xcblx0ICogb3ZlciB0aGUgc2VhcmNoaW5nIGxvZ2ljLiBFYWNoIGVsZW1lbnQgaW4gdGhpcyBhcnJheSBpcyBhIGZ1bmN0aW9uXG5cdCAqIChwYXJhbWV0ZXJzIGRlc2NyaWJlZCBiZWxvdykgdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHJvdyBpbiB0aGUgdGFibGUsXG5cdCAqIGFuZCB5b3VyIGxvZ2ljIGRlY2lkZXMgaWYgaXQgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSBzZWFyY2hpbmcgZGF0YSBzZXRcblx0ICogb3Igbm90LlxuXHQgKlxuXHQgKiBTZWFyY2hpbmcgZnVuY3Rpb25zIGhhdmUgdGhlIGZvbGxvd2luZyBpbnB1dCBwYXJhbWV0ZXJzOlxuXHQgKlxuXHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0ICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKiAyLiBge2FycmF5fG9iamVjdH1gIERhdGEgZm9yIHRoZSByb3cgdG8gYmUgcHJvY2Vzc2VkIChzYW1lIGFzIHRoZVxuXHQgKiAgICBvcmlnaW5hbCBmb3JtYXQgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBkYXRhIHNvdXJjZSwgb3IgYW4gYXJyYXlcblx0ICogICAgZnJvbSBhIERPTSBkYXRhIHNvdXJjZVxuXHQgKiAzLiBge2ludH1gIFJvdyBpbmRleCAoe0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzLmFvRGF0YX0pLCB3aGljaFxuXHQgKiAgICBjYW4gYmUgdXNlZnVsIHRvIHJldHJpZXZlIHRoZSBgVFJgIGVsZW1lbnQgaWYgeW91IG5lZWQgRE9NIGludGVyYWN0aW9uLlxuXHQgKlxuXHQgKiBBbmQgdGhlIGZvbGxvd2luZyByZXR1cm4gaXMgZXhwZWN0ZWQ6XG5cdCAqXG5cdCAqICoge2Jvb2xlYW59IEluY2x1ZGUgdGhlIHJvdyBpbiB0aGUgc2VhcmNoZWQgcmVzdWx0IHNldCAodHJ1ZSkgb3Igbm90XG5cdCAqICAgKGZhbHNlKVxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgYXMgd2l0aCB0aGUgbWFpbiBzZWFyY2ggYWJpbGl0eSBpbiBEYXRhVGFibGVzLCB0ZWNobmljYWxseSB0aGlzXG5cdCAqIGlzIFwiZmlsdGVyaW5nXCIsIHNpbmNlIGl0IGlzIHN1YnRyYWN0aXZlLiBIb3dldmVyLCBmb3IgY29uc2lzdGVuY3kgaW5cblx0ICogbmFtaW5nIHdlIGNhbGwgaXQgc2VhcmNoaW5nIGhlcmUuXG5cdCAqXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKiAgQGRlZmF1bHQgW11cblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjdXN0b20gc2VhcmNoIGJlaW5nIGFwcGxpZWQgdG8gdGhlXG5cdCAqICAgIC8vIGZvdXJ0aCBjb2x1bW4gKGkuZS4gdGhlIGRhdGFbM10gaW5kZXgpIGJhc2VkIG9uIHR3byBpbnB1dCB2YWx1ZXNcblx0ICogICAgLy8gZnJvbSB0aGUgZW5kLXVzZXIsIG1hdGNoaW5nIHRoZSBkYXRhIGluIGEgY2VydGFpbiByYW5nZS5cblx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxuXHQgKiAgICAgIGZ1bmN0aW9uKCBzZXR0aW5ncywgZGF0YSwgZGF0YUluZGV4ICkge1xuXHQgKiAgICAgICAgdmFyIG1pbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtaW4nKS52YWx1ZSAqIDE7XG5cdCAqICAgICAgICB2YXIgbWF4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heCcpLnZhbHVlICogMTtcblx0ICogICAgICAgIHZhciB2ZXJzaW9uID0gZGF0YVszXSA9PSBcIi1cIiA/IDAgOiBkYXRhWzNdKjE7XG5cdCAqXG5cdCAqICAgICAgICBpZiAoIG1pbiA9PSBcIlwiICYmIG1heCA9PSBcIlwiICkge1xuXHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICogICAgICAgIH1cblx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPT0gXCJcIiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xuXHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICogICAgICAgIH1cblx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIFwiXCIgPT0gbWF4ICkge1xuXHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICogICAgICAgIH1cblx0ICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIHZlcnNpb24gPCBtYXggKSB7XG5cdCAqICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgKiAgICAgICAgfVxuXHQgKiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgKiAgICAgIH1cblx0ICogICAgKTtcblx0ICovXG5cdHNlYXJjaDogW10sXG5cblxuXHQvKipcblx0ICogU2VsZWN0b3IgZXh0ZW5zaW9uc1xuXHQgKlxuXHQgKiBUaGUgYHNlbGVjdG9yYCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gZXh0ZW5kIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlXG5cdCAqIHNlbGVjdG9yIG1vZGlmaWVyIG9wdGlvbnMgKGBzZWxlY3Rvci1tb2RpZmllcmAgb2JqZWN0IGRhdGEgdHlwZSkgdGhhdFxuXHQgKiBlYWNoIG9mIHRoZSB0aHJlZSBidWlsdCBpbiBzZWxlY3RvciB0eXBlcyBvZmZlciAocm93LCBjb2x1bW4gYW5kIGNlbGwgK1xuXHQgKiB0aGVpciBwbHVyYWwgY291bnRlcnBhcnRzKS4gRm9yIGV4YW1wbGUgdGhlIFNlbGVjdCBleHRlbnNpb24gdXNlcyB0aGlzXG5cdCAqIG1lY2hhbmlzbSB0byBwcm92aWRlIGFuIG9wdGlvbiB0byBzZWxlY3Qgb25seSByb3dzLCBjb2x1bW5zIGFuZCBjZWxsc1xuXHQgKiB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgc2VsZWN0ZWQgYnkgdGhlIGVuZCB1c2VyIChge3NlbGVjdGVkOiB0cnVlfWApLFxuXHQgKiB3aGljaCBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBleGlzdGluZyBidWlsdCBpbiBzZWxlY3RvclxuXHQgKiBvcHRpb25zLlxuXHQgKlxuXHQgKiBFYWNoIHByb3BlcnR5IGlzIGFuIGFycmF5IHRvIHdoaWNoIGZ1bmN0aW9ucyBjYW4gYmUgcHVzaGVkLiBUaGUgZnVuY3Rpb25zXG5cdCAqIHRha2UgdGhyZWUgYXR0cmlidXRlczpcblx0ICpcblx0ICogKiBTZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBob3N0IHRhYmxlXG5cdCAqICogT3B0aW9ucyBvYmplY3QgKGBzZWxlY3Rvci1tb2RpZmllcmAgb2JqZWN0IHR5cGUpXG5cdCAqICogQXJyYXkgb2Ygc2VsZWN0ZWQgaXRlbSBpbmRleGVzXG5cdCAqXG5cdCAqIFRoZSByZXR1cm4gaXMgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdGluZyBpdGVtIGluZGV4ZXMgYWZ0ZXIgdGhlIGN1c3RvbVxuXHQgKiBzZWxlY3RvciBoYXMgYmVlbiBhcHBsaWVkLlxuXHQgKlxuXHQgKiAgQHR5cGUgb2JqZWN0XG5cdCAqL1xuXHRzZWxlY3Rvcjoge1xuXHRcdGNlbGw6IFtdLFxuXHRcdGNvbHVtbjogW10sXG5cdFx0cm93OiBbXVxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIExlZ2FjeSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIEVuYWJsZSBhbmQgZGlzYWJsZSBsZWdhY3kgb3B0aW9ucyB0aGF0XG5cdCAqIGFyZSBhdmFpbGFibGUgaW4gRGF0YVRhYmxlcy5cblx0ICpcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKi9cblx0bGVnYWN5OiB7XG5cdFx0LyoqXG5cdFx0ICogRW5hYmxlIC8gZGlzYWJsZSBEYXRhVGFibGVzIDEuOSBjb21wYXRpYmxlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmdcblx0XHQgKiByZXF1ZXN0c1xuXHRcdCAqXG5cdFx0ICogIEB0eXBlIGJvb2xlYW5cblx0XHQgKiAgQGRlZmF1bHQgbnVsbFxuXHRcdCAqL1xuXHRcdGFqYXg6IG51bGxcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBQYWdpbmF0aW9uIHBsdWctaW4gbWV0aG9kcy5cblx0ICogXG5cdCAqIEVhY2ggZW50cnkgaW4gdGhpcyBvYmplY3QgaXMgYSBmdW5jdGlvbiBhbmQgZGVmaW5lcyB3aGljaCBidXR0b25zIHNob3VsZFxuXHQgKiBiZSBzaG93biBieSB0aGUgcGFnaW5hdGlvbiByZW5kZXJpbmcgbWV0aG9kIHRoYXQgaXMgdXNlZCBmb3IgdGhlIHRhYmxlOlxuXHQgKiB7QGxpbmsgRGF0YVRhYmxlLmV4dC5yZW5kZXJlci5wYWdlQnV0dG9ufS4gVGhlIHJlbmRlcmVyIGFkZHJlc3NlcyBob3cgdGhlXG5cdCAqIGJ1dHRvbnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgZG9jdW1lbnQsIHdoaWxlIHRoZSBmdW5jdGlvbnMgaGVyZSB0ZWxsIGl0XG5cdCAqIHdoYXQgYnV0dG9ucyB0byBkaXNwbGF5LiBUaGlzIGlzIGRvbmUgYnkgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGJ1dHRvblxuXHQgKiBkZXNjcmlwdGlvbnMgKHdoYXQgZWFjaCBidXR0b24gd2lsbCBkbykuXG5cdCAqXG5cdCAqIFBhZ2luYXRpb24gdHlwZXMgKHRoZSBmb3VyIGJ1aWx0IGluIG9wdGlvbnMgYW5kIGFueSBhZGRpdGlvbmFsIHBsdWctaW5cblx0ICogb3B0aW9ucyBkZWZpbmVkIGhlcmUpIGNhbiBiZSB1c2VkIHRocm91Z2ggdGhlIGBwYWdpbmF0aW9uVHlwZWBcblx0ICogaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyLlxuXHQgKlxuXHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcblx0ICpcblx0ICogMS4gYHtpbnR9IHBhZ2VgIFRoZSBjdXJyZW50IHBhZ2UgaW5kZXhcblx0ICogMi4gYHtpbnR9IHBhZ2VzYCBUaGUgbnVtYmVyIG9mIHBhZ2VzIGluIHRoZSB0YWJsZVxuXHQgKlxuXHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBhcnJheSB3aGVyZSBlYWNoIGVsZW1lbnQgb2YgdGhlXG5cdCAqIGFycmF5IGNhbiBiZSBvbmUgb2Y6XG5cdCAqXG5cdCAqICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHQgKiAqIGBsYXN0YCAtIEp1bXAgdG8gbGFzdCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdCAqICogYHByZXZpb3VzYCAtIFNob3cgcHJldmlvdXMgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHQgKiAqIGBuZXh0YCAtIFNob3cgbmV4dCBwYWdlIHdoZW4gYWN0aXZhdGVkXG5cdCAqICogYHtpbnR9YCAtIFNob3cgcGFnZSBvZiB0aGUgaW5kZXggZ2l2ZW5cblx0ICogKiBge2FycmF5fWAgLSBBIG5lc3RlZCBhcnJheSBjb250YWluaW5nIHRoZSBhYm92ZSBlbGVtZW50cyB0byBhZGQgYVxuXHQgKiAgIGNvbnRhaW5pbmcgJ0RJVicgZWxlbWVudCAobWlnaHQgYmUgdXNlZnVsIGZvciBzdHlsaW5nKS5cblx0ICpcblx0ICogTm90ZSB0aGF0IERhdGFUYWJsZXMgdjEuOS0gdXNlZCB0aGlzIG9iamVjdCBzbGlnaHRseSBkaWZmZXJlbnRseSB3aGVyZWJ5XG5cdCAqIGFuIG9iamVjdCB3aXRoIHR3byBmdW5jdGlvbnMgd291bGQgYmUgZGVmaW5lZCBmb3IgZWFjaCBwbHVnLWluLiBUaGF0XG5cdCAqIGFiaWxpdHkgaXMgc3RpbGwgc3VwcG9ydGVkIGJ5IERhdGFUYWJsZXMgMS4xMCsgdG8gcHJvdmlkZSBiYWNrd2FyZHNcblx0ICogY29tcGF0aWJpbGl0eSwgYnV0IHRoaXMgb3B0aW9uIG9mIHVzZSBpcyBub3cgZGVjcmVtZW50ZWQgYW5kIG5vIGxvbmdlclxuXHQgKiBkb2N1bWVudGVkIGluIERhdGFUYWJsZXMgMS4xMCsuXG5cdCAqXG5cdCAqICBAdHlwZSBvYmplY3Rcblx0ICogIEBkZWZhdWx0IHt9XG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBTaG93IHByZXZpb3VzLCBuZXh0IGFuZCBjdXJyZW50IHBhZ2UgYnV0dG9ucyBvbmx5XG5cdCAqICAgICQuZm4uZGF0YVRhYmxlRXh0Lm9QYWdpbmF0aW9uLmN1cnJlbnQgPSBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xuXHQgKiAgICAgIHJldHVybiBbICdwcmV2aW91cycsIHBhZ2UsICduZXh0JyBdO1xuXHQgKiAgICB9O1xuXHQgKi9cblx0cGFnZXI6IHt9LFxuXG5cblx0cmVuZGVyZXI6IHtcblx0XHRwYWdlQnV0dG9uOiB7fSxcblx0XHRoZWFkZXI6IHt9XG5cdH0sXG5cblxuXHQvKipcblx0ICogT3JkZXJpbmcgcGx1Zy1pbnMgLSBjdXN0b20gZGF0YSBzb3VyY2Vcblx0ICogXG5cdCAqIFRoZSBleHRlbnNpb24gb3B0aW9ucyBmb3Igb3JkZXJpbmcgb2YgZGF0YSBhdmFpbGFibGUgaGVyZSBpcyBjb21wbGltZW50YXJ5XG5cdCAqIHRvIHRoZSBkZWZhdWx0IHR5cGUgYmFzZWQgb3JkZXJpbmcgdGhhdCBEYXRhVGFibGVzIHR5cGljYWxseSB1c2VzLiBJdFxuXHQgKiBhbGxvd3MgbXVjaCBncmVhdGVyIGNvbnRyb2wgb3ZlciB0aGUgdGhlIGRhdGEgdGhhdCBpcyBiZWluZyB1c2VkIHRvXG5cdCAqIG9yZGVyIGEgY29sdW1uLCBidXQgaXMgbmVjZXNzYXJpbHkgdGhlcmVmb3JlIG1vcmUgY29tcGxleC5cblx0ICogXG5cdCAqIFRoaXMgdHlwZSBvZiBvcmRlcmluZyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gZG8gb3JkZXJpbmcgYmFzZWQgb24gZGF0YVxuXHQgKiBsaXZlIGZyb20gdGhlIERPTSAoZm9yIGV4YW1wbGUgdGhlIGNvbnRlbnRzIG9mIGFuICdpbnB1dCcgZWxlbWVudCkgcmF0aGVyXG5cdCAqIHRoYW4ganVzdCB0aGUgc3RhdGljIHN0cmluZyB0aGF0IERhdGFUYWJsZXMga25vd3Mgb2YuXG5cdCAqIFxuXHQgKiBUaGUgd2F5IHRoZXNlIHBsdWctaW5zIHdvcmsgaXMgdGhhdCB5b3UgY3JlYXRlIGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgeW91XG5cdCAqIHdpc2ggdG8gYmUgb3JkZXJpbmcgZm9yIHRoZSBjb2x1bW4gaW4gcXVlc3Rpb24gYW5kIHRoZW4gcmV0dXJuIHRoYXRcblx0ICogYXJyYXkuIFRoZSBkYXRhIGluIHRoZSBhcnJheSBtdWNoIGJlIGluIHRoZSBpbmRleCBvcmRlciBvZiB0aGUgcm93cyBpblxuXHQgKiB0aGUgdGFibGUgKG5vdCB0aGUgY3VycmVudGx5IG9yZGVyaW5nIG9yZGVyISkuIFdoaWNoIG9yZGVyIGRhdGEgZ2F0aGVyaW5nXG5cdCAqIGZ1bmN0aW9uIGlzIHJ1biBoZXJlIGRlcGVuZHMgb24gdGhlIGBkdC1pbml0IGNvbHVtbnMub3JkZXJEYXRhVHlwZWBcblx0ICogcGFyYW1ldGVyIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGNvbHVtbiAoaWYgYW55KS5cblx0ICpcblx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdCAqXG5cdCAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxuXHQgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG5cdCAqIDIuIGB7aW50fWAgVGFyZ2V0IGNvbHVtbiBpbmRleFxuXHQgKlxuXHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBhcnJheTpcblx0ICpcblx0ICogKiBge2FycmF5fWAgRGF0YSBmb3IgdGhlIGNvbHVtbiB0byBiZSBvcmRlcmluZyB1cG9uXG5cdCAqXG5cdCAqICBAdHlwZSBhcnJheVxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gT3JkZXJpbmcgdXNpbmcgYGlucHV0YCBub2RlIHZhbHVlc1xuXHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXJbJ2RvbS10ZXh0J10gPSBmdW5jdGlvbiAgKCBzZXR0aW5ncywgY29sIClcblx0ICogICAge1xuXHQgKiAgICAgIHJldHVybiB0aGlzLmFwaSgpLmNvbHVtbiggY29sLCB7b3JkZXI6J2luZGV4J30gKS5ub2RlcygpLm1hcCggZnVuY3Rpb24gKCB0ZCwgaSApIHtcblx0ICogICAgICAgIHJldHVybiAkKCdpbnB1dCcsIHRkKS52YWwoKTtcblx0ICogICAgICB9ICk7XG5cdCAqICAgIH1cblx0ICovXG5cdG9yZGVyOiB7fSxcblxuXG5cdC8qKlxuXHQgKiBUeXBlIGJhc2VkIHBsdWctaW5zLlxuXHQgKlxuXHQgKiBFYWNoIGNvbHVtbiBpbiBEYXRhVGFibGVzIGhhcyBhIHR5cGUgYXNzaWduZWQgdG8gaXQsIGVpdGhlciBieSBhdXRvbWF0aWNcblx0ICogZGV0ZWN0aW9uIG9yIGJ5IGRpcmVjdCBhc3NpZ25tZW50IHVzaW5nIHRoZSBgdHlwZWAgb3B0aW9uIGZvciB0aGUgY29sdW1uLlxuXHQgKiBUaGUgdHlwZSBvZiBhIGNvbHVtbiB3aWxsIGVmZmVjdCBob3cgaXQgaXMgb3JkZXJpbmcgYW5kIHNlYXJjaCAocGx1Zy1pbnNcblx0ICogY2FuIGFsc28gbWFrZSB1c2Ugb2YgdGhlIGNvbHVtbiB0eXBlIGlmIHJlcXVpcmVkKS5cblx0ICpcblx0ICogQG5hbWVzcGFjZVxuXHQgKi9cblx0dHlwZToge1xuXHRcdC8qKlxuXHRcdCAqIEF1dG9tYXRpYyBjb2x1bW4gY2xhc3MgYXNzaWdubWVudFxuXHRcdCAqL1xuXHRcdGNsYXNzTmFtZToge30sXG5cblx0XHQvKipcblx0XHQgKiBUeXBlIGRldGVjdGlvbiBmdW5jdGlvbnMuXG5cdFx0ICpcblx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgaW4gdGhpcyBvYmplY3QgYXJlIHVzZWQgdG8gYXV0b21hdGljYWxseSBkZXRlY3Rcblx0XHQgKiBhIGNvbHVtbidzIHR5cGUsIG1ha2luZyBpbml0aWFsaXNhdGlvbiBvZiBEYXRhVGFibGVzIHN1cGVyIGVhc3ksIGV2ZW5cblx0XHQgKiB3aGVuIGNvbXBsZXggZGF0YSBpcyBpbiB0aGUgdGFibGUuXG5cdFx0ICpcblx0XHQgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcblx0XHQgKlxuXHQgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgYW5hbHlzZWRcblx0ICAgICAqICAyLiBge3NldHRpbmdzfWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QuIFRoaXMgY2FuIGJlIHVzZWQgdG9cblx0ICAgICAqICAgICBwZXJmb3JtIGNvbnRleHQgc3BlY2lmaWMgdHlwZSBkZXRlY3Rpb24gLSBmb3IgZXhhbXBsZSBkZXRlY3Rpb25cblx0ICAgICAqICAgICBiYXNlZCBvbiBsYW5ndWFnZSBzZXR0aW5ncyBzdWNoIGFzIHVzaW5nIGEgY29tbWEgZm9yIGEgZGVjaW1hbFxuXHQgICAgICogICAgIHBsYWNlLiBHZW5lcmFsbHkgc3BlYWtpbmcgdGhlIG9wdGlvbnMgZnJvbSB0aGUgc2V0dGluZ3Mgd2lsbCBub3Rcblx0ICAgICAqICAgICBiZSByZXF1aXJlZFxuXHRcdCAqXG5cdFx0ICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XG5cdFx0ICpcblx0XHQgKiAqIGB7c3RyaW5nfG51bGx9YCBEYXRhIHR5cGUgZGV0ZWN0ZWQsIG9yIG51bGwgaWYgdW5rbm93biAoYW5kIHRodXNcblx0XHQgKiAgIHBhc3MgaXQgb24gdG8gdGhlIG90aGVyIHR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9ucy5cblx0XHQgKlxuXHRcdCAqICBAdHlwZSBhcnJheVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gQ3VycmVuY3kgdHlwZSBkZXRlY3Rpb24gcGx1Zy1pbjpcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQudHlwZS5kZXRlY3QucHVzaChcblx0XHQgKiAgICAgIGZ1bmN0aW9uICggZGF0YSwgc2V0dGluZ3MgKSB7XG5cdFx0ICogICAgICAgIC8vIENoZWNrIHRoZSBudW1lcmljIHBhcnRcblx0XHQgKiAgICAgICAgaWYgKCAhIGRhdGEuc3Vic3RyaW5nKDEpLm1hdGNoKC9bMC05XS8pICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiBudWxsO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICpcblx0XHQgKiAgICAgICAgLy8gQ2hlY2sgcHJlZml4ZWQgYnkgY3VycmVuY3lcblx0XHQgKiAgICAgICAgaWYgKCBkYXRhLmNoYXJBdCgwKSA9PSAnJCcgfHwgZGF0YS5jaGFyQXQoMCkgPT0gJyZwb3VuZDsnICkge1xuXHRcdCAqICAgICAgICAgIHJldHVybiAnY3VycmVuY3knO1xuXHRcdCAqICAgICAgICB9XG5cdFx0ICogICAgICAgIHJldHVybiBudWxsO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgICk7XG5cdFx0ICovXG5cdFx0ZGV0ZWN0OiBbXSxcblxuXHRcdC8qKlxuXHRcdCAqIEF1dG9tYXRpYyByZW5kZXJlciBhc3NpZ25tZW50XG5cdFx0ICovXG5cdFx0cmVuZGVyOiB7fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogVHlwZSBiYXNlZCBzZWFyY2ggZm9ybWF0dGluZy5cblx0XHQgKlxuXHRcdCAqIFRoZSB0eXBlIGJhc2VkIHNlYXJjaGluZyBmdW5jdGlvbnMgY2FuIGJlIHVzZWQgdG8gcHJlLWZvcm1hdCB0aGVcblx0XHQgKiBkYXRhIHRvIGJlIHNlYXJjaCBvbi4gRm9yIGV4YW1wbGUsIGl0IGNhbiBiZSB1c2VkIHRvIHN0cmlwIEhUTUxcblx0XHQgKiB0YWdzIG9yIHRvIGRlLWZvcm1hdCB0ZWxlcGhvbmUgbnVtYmVycyBmb3IgbnVtZXJpYyBvbmx5IHNlYXJjaGluZy5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBpcyBhIHNlYXJjaCBpcyBub3QgZGVmaW5lZCBmb3IgYSBjb2x1bW4gb2YgYSBnaXZlbiB0eXBlLFxuXHRcdCAqIG5vIHNlYXJjaCBmb3JtYXR0aW5nIHdpbGwgYmUgcGVyZm9ybWVkLlxuXHRcdCAqIFxuXHRcdCAqIFByZS1wcm9jZXNzaW5nIG9mIHNlYXJjaGluZyBkYXRhIHBsdWctaW5zIC0gV2hlbiB5b3UgYXNzaWduIHRoZSBzVHlwZVxuXHRcdCAqIGZvciBhIGNvbHVtbiAob3IgaGF2ZSBpdCBhdXRvbWF0aWNhbGx5IGRldGVjdGVkIGZvciB5b3UgYnkgRGF0YVRhYmxlc1xuXHRcdCAqIG9yIGEgdHlwZSBkZXRlY3Rpb24gcGx1Zy1pbiksIHlvdSB3aWxsIHR5cGljYWxseSBiZSB1c2luZyB0aGlzIGZvclxuXHRcdCAqIGN1c3RvbSBzb3J0aW5nLCBidXQgaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlIGN1c3RvbSBzZWFyY2hpbmdcblx0XHQgKiBieSBhbGxvd2luZyB5b3UgdG8gcHJlLXByb2Nlc3NpbmcgdGhlIGRhdGEgYW5kIHJldHVybmluZyB0aGUgZGF0YSBpblxuXHRcdCAqIHRoZSBmb3JtYXQgdGhhdCBzaG91bGQgYmUgc2VhcmNoZWQgdXBvbi4gVGhpcyBpcyBkb25lIGJ5IGFkZGluZ1xuXHRcdCAqIGZ1bmN0aW9ucyB0aGlzIG9iamVjdCB3aXRoIGEgcGFyYW1ldGVyIG5hbWUgd2hpY2ggbWF0Y2hlcyB0aGUgc1R5cGVcblx0XHQgKiBmb3IgdGhhdCB0YXJnZXQgY29sdW1uLiBUaGlzIGlzIHRoZSBjb3JvbGxhcnkgb2YgPGk+YWZuU29ydERhdGE8L2k+XG5cdFx0ICogZm9yIHNlYXJjaGluZyBkYXRhLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgYSBzaW5nbGUgcGFyYW1ldGVyOlxuXHRcdCAqXG5cdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igc2VhcmNoaW5nXG5cdFx0ICpcblx0XHQgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybjpcblx0XHQgKlxuXHRcdCAqICogYHtzdHJpbmd8bnVsbH1gIEZvcm1hdHRlZCBzdHJpbmcgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZSBzZWFyY2hpbmcuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQudHlwZS5zZWFyY2hbJ3RpdGxlLW51bWVyaWMnXSA9IGZ1bmN0aW9uICggZCApIHtcblx0XHQgKiAgICAgIHJldHVybiBkLnJlcGxhY2UoL1xcbi9nLFwiIFwiKS5yZXBsYWNlKCAvPC4qPz4vZywgXCJcIiApO1xuXHRcdCAqICAgIH1cblx0XHQgKi9cblx0XHRzZWFyY2g6IHt9LFxuXG5cblx0XHQvKipcblx0XHQgKiBUeXBlIGJhc2VkIG9yZGVyaW5nLlxuXHRcdCAqXG5cdFx0ICogVGhlIGNvbHVtbiB0eXBlIHRlbGxzIERhdGFUYWJsZXMgd2hhdCBvcmRlcmluZyB0byBhcHBseSB0byB0aGUgdGFibGVcblx0XHQgKiB3aGVuIGEgY29sdW1uIGlzIHNvcnRlZCB1cG9uLiBUaGUgb3JkZXIgZm9yIGVhY2ggdHlwZSB0aGF0IGlzIGRlZmluZWQsXG5cdFx0ICogaXMgZGVmaW5lZCBieSB0aGUgZnVuY3Rpb25zIGF2YWlsYWJsZSBpbiB0aGlzIG9iamVjdC5cblx0XHQgKlxuXHRcdCAqIEVhY2ggb3JkZXJpbmcgb3B0aW9uIGNhbiBiZSBkZXNjcmliZWQgYnkgdGhyZWUgcHJvcGVydGllcyBhZGRlZCB0b1xuXHRcdCAqIHRoaXMgb2JqZWN0OlxuXHRcdCAqXG5cdFx0ICogKiBge3R5cGV9LXByZWAgLSBQcmUtZm9ybWF0dGluZyBmdW5jdGlvblxuXHRcdCAqICogYHt0eXBlfS1hc2NgIC0gQXNjZW5kaW5nIG9yZGVyIGZ1bmN0aW9uXG5cdFx0ICogKiBge3R5cGV9LWRlc2NgIC0gRGVzY2VuZGluZyBvcmRlciBmdW5jdGlvblxuXHRcdCAqXG5cdFx0ICogQWxsIHRocmVlIGNhbiBiZSB1c2VkIHRvZ2V0aGVyLCBvbmx5IGB7dHlwZX0tcHJlYCBvciBvbmx5XG5cdFx0ICogYHt0eXBlfS1hc2NgIGFuZCBge3R5cGV9LWRlc2NgIHRvZ2V0aGVyLiBJdCBpcyBnZW5lcmFsbHkgcmVjb21tZW5kZWRcblx0XHQgKiB0aGF0IG9ubHkgYHt0eXBlfS1wcmVgIGlzIHVzZWQsIGFzIHRoaXMgcHJvdmlkZXMgdGhlIG9wdGltYWxcblx0XHQgKiBpbXBsZW1lbnRhdGlvbiBpbiB0ZXJtcyBvZiBzcGVlZCwgYWx0aG91Z2ggdGhlIG90aGVycyBhcmUgcHJvdmlkZWRcblx0XHQgKiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIEphdmFzY3JpcHQgc29ydCBmdW5jdGlvbnMuXG5cdFx0ICpcblx0XHQgKiBge3R5cGV9LXByZWA6IEZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgYSBzaW5nbGUgcGFyYW1ldGVyOlxuXHRcdCAqXG5cdCAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igb3JkZXJpbmdcblx0XHQgKlxuXHRcdCAqIEFuZCByZXR1cm46XG5cdFx0ICpcblx0XHQgKiAqIGB7Kn1gIERhdGEgdG8gYmUgc29ydGVkIHVwb25cblx0XHQgKlxuXHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYDogRnVuY3Rpb25zIGFyZSB0eXBpY2FsIEphdmFzY3JpcHQgc29ydFxuXHRcdCAqIGZ1bmN0aW9ucywgdGFraW5nIHR3byBwYXJhbWV0ZXJzOlxuXHRcdCAqXG5cdCAgICAgKiAgMS4gYHsqfWAgRGF0YSB0byBjb21wYXJlIHRvIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG5cdCAgICAgKiAgMi4gYHsqfWAgRGF0YSB0byBjb21wYXJlIHRvIHRoZSBmaXJzdCBwYXJhbWV0ZXJcblx0XHQgKlxuXHRcdCAqIEFuZCByZXR1cm5pbmc6XG5cdFx0ICpcblx0XHQgKiAqIGB7Kn1gIE9yZGVyaW5nIG1hdGNoOiA8MCBpZiBmaXJzdCBwYXJhbWV0ZXIgc2hvdWxkIGJlIHNvcnRlZCBsb3dlclxuXHRcdCAqICAgdGhhbiB0aGUgc2Vjb25kIHBhcmFtZXRlciwgPT09MCBpZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlIGVxdWFsIGFuZFxuXHRcdCAqICAgPjAgaWYgdGhlIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYmUgc29ydGVkIGhlaWdodCB0aGFuIHRoZSBzZWNvbmRcblx0XHQgKiAgIHBhcmFtZXRlci5cblx0XHQgKiBcblx0XHQgKiAgQHR5cGUgb2JqZWN0XG5cdFx0ICogIEBkZWZhdWx0IHt9XG5cdFx0ICpcblx0XHQgKiAgQGV4YW1wbGVcblx0XHQgKiAgICAvLyBOdW1lcmljIG9yZGVyaW5nIG9mIGZvcm1hdHRlZCBudW1iZXJzIHdpdGggYSBwcmUtZm9ybWF0dGVyXG5cdFx0ICogICAgJC5leHRlbmQoICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLCB7XG5cdFx0ICogICAgICBcInN0cmluZy1wcmVcIjogZnVuY3Rpb24oeCkge1xuXHRcdCAqICAgICAgICBhID0gKGEgPT09IFwiLVwiIHx8IGEgPT09IFwiXCIpID8gMCA6IGEucmVwbGFjZSggL1teXFxkXFwtXFwuXS9nLCBcIlwiICk7XG5cdFx0ICogICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBhICk7XG5cdFx0ICogICAgICB9XG5cdFx0ICogICAgfSApO1xuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gQ2FzZS1zZW5zaXRpdmUgc3RyaW5nIG9yZGVyaW5nLCB3aXRoIG5vIHByZS1mb3JtYXR0aW5nIG1ldGhvZFxuXHRcdCAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXIsIHtcblx0XHQgKiAgICAgIFwic3RyaW5nLWNhc2UtYXNjXCI6IGZ1bmN0aW9uKHgseSkge1xuXHRcdCAqICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAtMSA6ICgoeCA+IHkpID8gMSA6IDApKTtcblx0XHQgKiAgICAgIH0sXG5cdFx0ICogICAgICBcInN0cmluZy1jYXNlLWRlc2NcIjogZnVuY3Rpb24oeCx5KSB7XG5cdFx0ICogICAgICAgIHJldHVybiAoKHggPCB5KSA/IDEgOiAoKHggPiB5KSA/IC0xIDogMCkpO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgIH0gKTtcblx0XHQgKi9cblx0XHRvcmRlcjoge31cblx0fSxcblxuXHQvKipcblx0ICogVW5pcXVlIERhdGFUYWJsZXMgaW5zdGFuY2UgY291bnRlclxuXHQgKlxuXHQgKiBAdHlwZSBpbnRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF91bmlxdWU6IDAsXG5cblxuXHQvL1xuXHQvLyBEZXByZWNpYXRlZFxuXHQvLyBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBvbmx5LlxuXHQvLyBUaGUgc2hvdWxkIG5vdCBiZSB1c2VkIGluIG5ldyBwcm9qZWN0cyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlXG5cdC8vIHZlcnNpb25cblx0Ly9cblxuXHQvKipcblx0ICogVmVyc2lvbiBjaGVjayBmdW5jdGlvbi5cblx0ICogIEB0eXBlIGZ1bmN0aW9uXG5cdCAqICBAZGVwcmVjaWF0ZWQgU2luY2UgMS4xMFxuXHQgKi9cblx0Zm5WZXJzaW9uQ2hlY2s6IERhdGFUYWJsZS5mblZlcnNpb25DaGVjayxcblxuXG5cdC8qKlxuXHQgKiBJbmRleCBmb3Igd2hhdCAndGhpcycgaW5kZXggQVBJIGZ1bmN0aW9ucyBzaG91bGQgdXNlXG5cdCAqICBAdHlwZSBpbnRcblx0ICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG5cdCAqL1xuXHRpQXBpSW5kZXg6IDAsXG5cblxuXHQvKipcblx0ICogU29mdHdhcmUgdmVyc2lvblxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHQgKi9cblx0c1ZlcnNpb246IERhdGFUYWJsZS52ZXJzaW9uXG59O1xuXG5cbi8vXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gQWxpYXMgdG8gcHJlIDEuMTAgSHVuZ2FyaWFuIG5vdGF0aW9uIGNvdW50ZXIgcGFydHNcbi8vXG4kLmV4dGVuZCggX2V4dCwge1xuXHRhZm5GaWx0ZXJpbmc6IF9leHQuc2VhcmNoLFxuXHRhVHlwZXM6ICAgICAgIF9leHQudHlwZS5kZXRlY3QsXG5cdG9mblNlYXJjaDogICAgX2V4dC50eXBlLnNlYXJjaCxcblx0b1NvcnQ6ICAgICAgICBfZXh0LnR5cGUub3JkZXIsXG5cdGFmblNvcnREYXRhOiAgX2V4dC5vcmRlcixcblx0YW9GZWF0dXJlczogICBfZXh0LmZlYXR1cmUsXG5cdG9TdGRDbGFzc2VzOiAgX2V4dC5jbGFzc2VzLFxuXHRvUGFnaW5hdGlvbjogIF9leHQucGFnZXJcbn0gKTtcblxuXG4kLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCB7XG5cdGNvbnRhaW5lcjogJ2R0LWNvbnRhaW5lcicsXG5cdGVtcHR5OiB7XG5cdFx0cm93OiAnZHQtZW1wdHknXG5cdH0sXG5cdGluZm86IHtcblx0XHRjb250YWluZXI6ICdkdC1pbmZvJ1xuXHR9LFxuXHRsYXlvdXQ6IHtcblx0XHRyb3c6ICdkdC1sYXlvdXQtcm93Jyxcblx0XHRjZWxsOiAnZHQtbGF5b3V0LWNlbGwnLFxuXHRcdHRhYmxlUm93OiAnZHQtbGF5b3V0LXRhYmxlJyxcblx0XHR0YWJsZUNlbGw6ICcnLFxuXHRcdHN0YXJ0OiAnZHQtbGF5b3V0LXN0YXJ0Jyxcblx0XHRlbmQ6ICdkdC1sYXlvdXQtZW5kJyxcblx0XHRmdWxsOiAnZHQtbGF5b3V0LWZ1bGwnXG5cdH0sXG5cdGxlbmd0aDoge1xuXHRcdGNvbnRhaW5lcjogJ2R0LWxlbmd0aCcsXG5cdFx0c2VsZWN0OiAnZHQtaW5wdXQnXG5cdH0sXG5cdG9yZGVyOiB7XG5cdFx0Y2FuQXNjOiAnZHQtb3JkZXJhYmxlLWFzYycsXG5cdFx0Y2FuRGVzYzogJ2R0LW9yZGVyYWJsZS1kZXNjJyxcblx0XHRpc0FzYzogJ2R0LW9yZGVyaW5nLWFzYycsXG5cdFx0aXNEZXNjOiAnZHQtb3JkZXJpbmctZGVzYycsXG5cdFx0bm9uZTogJ2R0LW9yZGVyYWJsZS1ub25lJyxcblx0XHRwb3NpdGlvbjogJ3NvcnRpbmdfJ1xuXHR9LFxuXHRwcm9jZXNzaW5nOiB7XG5cdFx0Y29udGFpbmVyOiAnZHQtcHJvY2Vzc2luZydcblx0fSxcblx0c2Nyb2xsaW5nOiB7XG5cdFx0Ym9keTogJ2R0LXNjcm9sbC1ib2R5Jyxcblx0XHRjb250YWluZXI6ICdkdC1zY3JvbGwnLFxuXHRcdGZvb3Rlcjoge1xuXHRcdFx0c2VsZjogJ2R0LXNjcm9sbC1mb290Jyxcblx0XHRcdGlubmVyOiAnZHQtc2Nyb2xsLWZvb3RJbm5lcidcblx0XHR9LFxuXHRcdGhlYWRlcjoge1xuXHRcdFx0c2VsZjogJ2R0LXNjcm9sbC1oZWFkJyxcblx0XHRcdGlubmVyOiAnZHQtc2Nyb2xsLWhlYWRJbm5lcidcblx0XHR9XG5cdH0sXG5cdHNlYXJjaDoge1xuXHRcdGNvbnRhaW5lcjogJ2R0LXNlYXJjaCcsXG5cdFx0aW5wdXQ6ICdkdC1pbnB1dCdcblx0fSxcblx0dGFibGU6ICdkYXRhVGFibGUnLFx0XG5cdHRib2R5OiB7XG5cdFx0Y2VsbDogJycsXG5cdFx0cm93OiAnJ1xuXHR9LFxuXHR0aGVhZDoge1xuXHRcdGNlbGw6ICcnLFxuXHRcdHJvdzogJydcblx0fSxcblx0dGZvb3Q6IHtcblx0XHRjZWxsOiAnJyxcblx0XHRyb3c6ICcnXG5cdH0sXG5cdHBhZ2luZzoge1xuXHRcdGFjdGl2ZTogJ2N1cnJlbnQnLFxuXHRcdGJ1dHRvbjogJ2R0LXBhZ2luZy1idXR0b24nLFxuXHRcdGNvbnRhaW5lcjogJ2R0LXBhZ2luZycsXG5cdFx0ZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG5cdFx0bmF2OiAnJ1xuXHR9XG59ICk7XG5cblxuLypcbiAqIEl0IGlzIHVzZWZ1bCB0byBoYXZlIHZhcmlhYmxlcyB3aGljaCBhcmUgc2NvcGVkIGxvY2FsbHkgc28gb25seSB0aGVcbiAqIERhdGFUYWJsZXMgZnVuY3Rpb25zIGNhbiBhY2Nlc3MgdGhlbSBhbmQgdGhleSBkb24ndCBsZWFrIGludG8gZ2xvYmFsIHNwYWNlLlxuICogQXQgdGhlIHNhbWUgdGltZSB0aGVzZSBmdW5jdGlvbnMgYXJlIG9mdGVuIHVzZWZ1bCBvdmVyIG11bHRpcGxlIGZpbGVzIGluIHRoZVxuICogY29yZSBhbmQgQVBJLCBzbyB3ZSBsaXN0LCBvciBhdCBsZWFzdCBkb2N1bWVudCwgYWxsIHZhcmlhYmxlcyB3aGljaCBhcmUgdXNlZFxuICogYnkgRGF0YVRhYmxlcyBhcyBwcml2YXRlIHZhcmlhYmxlcyBoZXJlLiBUaGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZXJlIGlzIG5vXG4gKiBjbGFzaGluZyBvZiB2YXJpYWJsZSBuYW1lcyBhbmQgdGhhdCB0aGV5IGNhbiBlYXNpbHkgcmVmZXJlbmNlZCBmb3IgcmV1c2UuXG4gKi9cblxuXG4vLyBEZWZpbmVkIGVsc2Ugd2hlcmVcbi8vICBfc2VsZWN0b3JfcnVuXG4vLyAgX3NlbGVjdG9yX29wdHNcbi8vICBfc2VsZWN0b3Jfcm93X2luZGV4ZXNcblxudmFyIF9leHQ7IC8vIERhdGFUYWJsZS5leHRcbnZhciBfQXBpOyAvLyBEYXRhVGFibGUuQXBpXG52YXIgX2FwaV9yZWdpc3RlcjsgLy8gRGF0YVRhYmxlLkFwaS5yZWdpc3RlclxudmFyIF9hcGlfcmVnaXN0ZXJQbHVyYWw7IC8vIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWxcblxudmFyIF9yZV9kaWMgPSB7fTtcbnZhciBfcmVfbmV3X2xpbmVzID0gL1tcXHJcXG5cXHUyMDI4XS9nO1xudmFyIF9yZV9odG1sID0gLzwoW14+XSo+KS9nO1xudmFyIF9tYXhfc3RyX2xlbiA9IE1hdGgucG93KDIsIDI4KTtcblxuLy8gVGhpcyBpcyBub3Qgc3RyaWN0IElTTzg2MDEgLSBEYXRlLnBhcnNlKCkgaXMgcXVpdGUgbGF4LCBhbHRob3VnaFxuLy8gaW1wbGVtZW50YXRpb25zIGRpZmZlciBiZXR3ZWVuIGJyb3dzZXJzLlxudmFyIF9yZV9kYXRlID0gL15cXGR7Miw0fVsuLy1dXFxkezEsMn1bLi8tXVxcZHsxLDJ9KFtUIF17MX1cXGR7MSwyfVs6Ll1cXGR7Mn0oWy46XVxcZHsyfSk/KT8kLztcblxuLy8gRXNjYXBlIHJlZ3VsYXIgZXhwcmVzc2lvbiBzcGVjaWFsIGNoYXJhY3RlcnNcbnZhciBfcmVfZXNjYXBlX3JlZ2V4ID0gbmV3IFJlZ0V4cCggJyhcXFxcJyArIFsgJy8nLCAnLicsICcqJywgJysnLCAnPycsICd8JywgJygnLCAnKScsICdbJywgJ10nLCAneycsICd9JywgJ1xcXFwnLCAnJCcsICdeJywgJy0nIF0uam9pbignfFxcXFwnKSArICcpJywgJ2cnICk7XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZvcmVpZ25fZXhjaGFuZ2VfbWFya2V0XG4vLyAtIFxcdTIwQkQgLSBSdXNzaWFuIHJ1YmxlLlxuLy8gLSBcXHUyMGE5IC0gU291dGggS29yZWFuIFdvblxuLy8gLSBcXHUyMEJBIC0gVHVya2lzaCBMaXJhXG4vLyAtIFxcdTIwQjkgLSBJbmRpYW4gUnVwZWVcbi8vIC0gUiAtIEJyYXppbCAoUiQpIGFuZCBTb3V0aCBBZnJpY2Fcbi8vIC0gZnIgLSBTd2lzcyBGcmFuY1xuLy8gLSBrciAtIFN3ZWRpc2gga3JvbmEsIE5vcndlZ2lhbiBrcm9uZSBhbmQgRGFuaXNoIGtyb25lXG4vLyAtIFxcdTIwMDkgaXMgdGhpbiBzcGFjZSBhbmQgXFx1MjAyRiBpcyBuYXJyb3cgbm8tYnJlYWsgc3BhY2UsIGJvdGggdXNlZCBpbiBtYW55XG4vLyAtIMmDIC0gQml0Y29pblxuLy8gLSDOniAtIEV0aGVyZXVtXG4vLyAgIHN0YW5kYXJkcyBhcyB0aG91c2FuZHMgc2VwYXJhdG9ycy5cbnZhciBfcmVfZm9ybWF0dGVkX251bWVyaWMgPSAvWydcXHUwMEEwLCTCo+KCrMKlJVxcdTIwMDlcXHUyMDJGXFx1MjBCRFxcdTIwYTlcXHUyMEJBcmZryYPOnl0vZ2k7XG5cblxudmFyIF9lbXB0eSA9IGZ1bmN0aW9uICggZCApIHtcblx0cmV0dXJuICFkIHx8IGQgPT09IHRydWUgfHwgZCA9PT0gJy0nID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxuXG52YXIgX2ludFZhbCA9IGZ1bmN0aW9uICggcyApIHtcblx0dmFyIGludGVnZXIgPSBwYXJzZUludCggcywgMTAgKTtcblx0cmV0dXJuICFpc05hTihpbnRlZ2VyKSAmJiBpc0Zpbml0ZShzKSA/IGludGVnZXIgOiBudWxsO1xufTtcblxuLy8gQ29udmVydCBmcm9tIGEgZm9ybWF0dGVkIG51bWJlciB3aXRoIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBgLmAgYXMgdGhlXG4vLyBkZWNpbWFsIHBsYWNlLCB0byBhIEphdmFzY3JpcHQgbnVtYmVyXG52YXIgX251bVRvRGVjaW1hbCA9IGZ1bmN0aW9uICggbnVtLCBkZWNpbWFsUG9pbnQgKSB7XG5cdC8vIENhY2hlIGNyZWF0ZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3Igc3BlZWQgYXMgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb2Z0ZW5cblx0aWYgKCAhIF9yZV9kaWNbIGRlY2ltYWxQb2ludCBdICkge1xuXHRcdF9yZV9kaWNbIGRlY2ltYWxQb2ludCBdID0gbmV3IFJlZ0V4cCggX2ZuRXNjYXBlUmVnZXgoIGRlY2ltYWxQb2ludCApLCAnZycgKTtcblx0fVxuXHRyZXR1cm4gdHlwZW9mIG51bSA9PT0gJ3N0cmluZycgJiYgZGVjaW1hbFBvaW50ICE9PSAnLicgP1xuXHRcdG51bS5yZXBsYWNlKCAvXFwuL2csICcnICkucmVwbGFjZSggX3JlX2RpY1sgZGVjaW1hbFBvaW50IF0sICcuJyApIDpcblx0XHRudW07XG59O1xuXG5cbnZhciBfaXNOdW1iZXIgPSBmdW5jdGlvbiAoIGQsIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkLCBhbGxvd0VtcHR5ICkge1xuXHR2YXIgdHlwZSA9IHR5cGVvZiBkO1xuXHR2YXIgc3RyVHlwZSA9IHR5cGUgPT09ICdzdHJpbmcnO1xuXG5cdGlmICggdHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ2JpZ2ludCcpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIElmIGVtcHR5IHJldHVybiBpbW1lZGlhdGVseSBzbyB0aGVyZSBtdXN0IGJlIGEgbnVtYmVyIGlmIGl0IGlzIGFcblx0Ly8gZm9ybWF0dGVkIHN0cmluZyAodGhpcyBzdG9wcyB0aGUgc3RyaW5nIFwia1wiLCBvciBcImtyXCIsIGV0YyBiZWluZyBkZXRlY3RlZFxuXHQvLyBhcyBhIGZvcm1hdHRlZCBudW1iZXIgZm9yIGN1cnJlbmN5XG5cdGlmICggYWxsb3dFbXB0eSAmJiBfZW1wdHkoIGQgKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGVjaW1hbFBvaW50ICYmIHN0clR5cGUgKSB7XG5cdFx0ZCA9IF9udW1Ub0RlY2ltYWwoIGQsIGRlY2ltYWxQb2ludCApO1xuXHR9XG5cblx0aWYgKCBmb3JtYXR0ZWQgJiYgc3RyVHlwZSApIHtcblx0XHRkID0gZC5yZXBsYWNlKCBfcmVfZm9ybWF0dGVkX251bWVyaWMsICcnICk7XG5cdH1cblxuXHRyZXR1cm4gIWlzTmFOKCBwYXJzZUZsb2F0KGQpICkgJiYgaXNGaW5pdGUoIGQgKTtcbn07XG5cblxuLy8gQSBzdHJpbmcgd2l0aG91dCBIVE1MIGluIGl0IGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIEhUTUwgc3RpbGxcbnZhciBfaXNIdG1sID0gZnVuY3Rpb24gKCBkICkge1xuXHRyZXR1cm4gX2VtcHR5KCBkICkgfHwgdHlwZW9mIGQgPT09ICdzdHJpbmcnO1xufTtcblxuLy8gSXMgYSBzdHJpbmcgYSBudW1iZXIgc3Vycm91bmRlZCBieSBIVE1MP1xudmFyIF9odG1sTnVtZXJpYyA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQsIGFsbG93RW1wdHkgKSB7XG5cdGlmICggYWxsb3dFbXB0eSAmJiBfZW1wdHkoIGQgKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIGlucHV0IGFuZCBzZWxlY3Qgc3RyaW5ncyBtZWFuIHRoYXQgdGhpcyBpc24ndCBqdXN0IGEgbnVtYmVyXG5cdGlmICh0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5tYXRjaCgvPChpbnB1dHxzZWxlY3QpL2kpKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgaHRtbCA9IF9pc0h0bWwoIGQgKTtcblx0cmV0dXJuICEgaHRtbCA/XG5cdFx0bnVsbCA6XG5cdFx0X2lzTnVtYmVyKCBfc3RyaXBIdG1sKCBkICksIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkLCBhbGxvd0VtcHR5ICkgP1xuXHRcdFx0dHJ1ZSA6XG5cdFx0XHRudWxsO1xufTtcblxuXG52YXIgX3BsdWNrID0gZnVuY3Rpb24gKCBhLCBwcm9wLCBwcm9wMiApIHtcblx0dmFyIG91dCA9IFtdO1xuXHR2YXIgaT0wLCBpZW49YS5sZW5ndGg7XG5cblx0Ly8gQ291bGQgaGF2ZSB0aGUgdGVzdCBpbiB0aGUgbG9vcCBmb3Igc2xpZ2h0bHkgc21hbGxlciBjb2RlLCBidXQgc3BlZWRcblx0Ly8gaXMgZXNzZW50aWFsIGhlcmVcblx0aWYgKCBwcm9wMiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGZvciAoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFbaV0gJiYgYVtpXVsgcHJvcCBdICkge1xuXHRcdFx0XHRvdXQucHVzaCggYVtpXVsgcHJvcCBdWyBwcm9wMiBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdGZvciAoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFbaV0gKSB7XG5cdFx0XHRcdG91dC5wdXNoKCBhW2ldWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufTtcblxuXG4vLyBCYXNpY2FsbHkgdGhlIHNhbWUgYXMgX3BsdWNrLCBidXQgcmF0aGVyIHRoYW4gbG9vcGluZyBvdmVyIGBhYCB3ZSB1c2UgYG9yZGVyYFxuLy8gYXMgdGhlIGluZGV4ZXMgdG8gcGljayBmcm9tIGBhYFxudmFyIF9wbHVja19vcmRlciA9IGZ1bmN0aW9uICggYSwgb3JkZXIsIHByb3AsIHByb3AyIClcbntcblx0dmFyIG91dCA9IFtdO1xuXHR2YXIgaT0wLCBpZW49b3JkZXIubGVuZ3RoO1xuXG5cdC8vIENvdWxkIGhhdmUgdGhlIHRlc3QgaW4gdGhlIGxvb3AgZm9yIHNsaWdodGx5IHNtYWxsZXIgY29kZSwgYnV0IHNwZWVkXG5cdC8vIGlzIGVzc2VudGlhbCBoZXJlXG5cdGlmICggcHJvcDIgIT09IHVuZGVmaW5lZCApIHtcblx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBhWyBvcmRlcltpXSBdICYmIGFbIG9yZGVyW2ldIF1bIHByb3AgXSApIHtcblx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXVsgcHJvcDIgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBhWyBvcmRlcltpXSBdICkge1xuXHRcdFx0XHRvdXQucHVzaCggYVsgb3JkZXJbaV0gXVsgcHJvcCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn07XG5cblxudmFyIF9yYW5nZSA9IGZ1bmN0aW9uICggbGVuLCBzdGFydCApXG57XG5cdHZhciBvdXQgPSBbXTtcblx0dmFyIGVuZDtcblxuXHRpZiAoIHN0YXJ0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0c3RhcnQgPSAwO1xuXHRcdGVuZCA9IGxlbjtcblx0fVxuXHRlbHNlIHtcblx0XHRlbmQgPSBzdGFydDtcblx0XHRzdGFydCA9IGxlbjtcblx0fVxuXG5cdGZvciAoIHZhciBpPXN0YXJ0IDsgaTxlbmQgOyBpKysgKSB7XG5cdFx0b3V0LnB1c2goIGkgKTtcblx0fVxuXG5cdHJldHVybiBvdXQ7XG59O1xuXG5cbnZhciBfcmVtb3ZlRW1wdHkgPSBmdW5jdGlvbiAoIGEgKVxue1xuXHR2YXIgb3V0ID0gW107XG5cblx0Zm9yICggdmFyIGk9MCwgaWVuPWEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0aWYgKCBhW2ldICkgeyAvLyBjYXJlZnVsIC0gd2lsbCByZW1vdmUgYWxsIGZhbHN5IHZhbHVlcyFcblx0XHRcdG91dC5wdXNoKCBhW2ldICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn07XG5cbi8vIFJlcGxhY2VhYmxlIGZ1bmN0aW9uIGluIGFwaS51dGlsXG52YXIgX3N0cmlwSHRtbCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXHRpZiAoISBpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIGlucHV0O1xuXHR9XG5cblx0Ly8gSXJyZWxldmFudCBjaGVjayB0byB3b3JrYXJvdW5kIENvZGVRTCdzIGZhbHNlIHBvc2l0aXZlIG9uIHRoZSByZWdleFxuXHRpZiAoaW5wdXQubGVuZ3RoID4gX21heF9zdHJfbGVuKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdFeGNlZWRlZCBtYXggc3RyIGxlbicpO1xuXHR9XG5cblx0dmFyIHByZXZpb3VzO1xuXG5cdGlucHV0ID0gaW5wdXQucmVwbGFjZShfcmVfaHRtbCwgJycpOyAvLyBDb21wbGV0ZSB0YWdzXG5cblx0Ly8gU2FmZXR5IGZvciBpbmNvbXBsZXRlIHNjcmlwdCB0YWcgLSB1c2UgZG8gLyB3aGlsZSB0byBlbnN1cmUgdGhhdFxuXHQvLyB3ZSBnZXQgYWxsIGluc3RhbmNlc1xuXHRkbyB7XG5cdFx0cHJldmlvdXMgPSBpbnB1dDtcblx0XHRpbnB1dCA9IGlucHV0LnJlcGxhY2UoLzxzY3JpcHQvaSwgJycpO1xuXHR9IHdoaWxlIChpbnB1dCAhPT0gcHJldmlvdXMpO1xuXG5cdHJldHVybiBwcmV2aW91cztcbn07XG5cbi8vIFJlcGxhY2VhYmxlIGZ1bmN0aW9uIGluIGFwaS51dGlsXG52YXIgX2VzY2FwZUh0bWwgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KGQpKSB7XG5cdFx0ZCA9IGQuam9pbignLCcpO1xuXHR9XG5cblx0cmV0dXJuIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/XG5cdFx0ZFxuXHRcdFx0LnJlcGxhY2UoLyYvZywgJyZhbXA7Jylcblx0XHRcdC5yZXBsYWNlKC88L2csICcmbHQ7Jylcblx0XHRcdC5yZXBsYWNlKC8+L2csICcmZ3Q7Jylcblx0XHRcdC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykgOlxuXHRcdGQ7XG59O1xuXG4vLyBSZW1vdmUgZGlhY3JpdGljcyBmcm9tIGEgc3RyaW5nIGJ5IGRlY29tcG9zaW5nIGl0IGFuZCB0aGVuIHJlbW92aW5nXG4vLyBub24tYXNjaWkgY2hhcmFjdGVyc1xudmFyIF9ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyLCBib3RoKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiBzdHI7XG5cdH1cblxuXHQvLyBJdCBpcyBmYXN0ZXIgdG8ganVzdCBydW4gYG5vcm1hbGl6ZWAgdGhhbiBpdCBpcyB0byBjaGVjayBpZlxuXHQvLyB3ZSBuZWVkIHRvIHdpdGggYSByZWdleCEgKENoZWNrIGFzIGl0IGlzbid0IGF2YWlsYWJsZSBpbiBvbGRcblx0Ly8gU2FmYXJpKVxuXHR2YXIgcmVzID0gc3RyLm5vcm1hbGl6ZVxuXHRcdD8gc3RyLm5vcm1hbGl6ZShcIk5GRFwiKVxuXHRcdDogc3RyO1xuXG5cdC8vIEVxdWFsbHksIGhlcmUgd2UgY2hlY2sgaWYgYSByZWdleCBpcyBuZWVkZWQgb3Igbm90XG5cdHJldHVybiByZXMubGVuZ3RoICE9PSBzdHIubGVuZ3RoXG5cdFx0PyAoYm90aCA9PT0gdHJ1ZSA/IHN0ciArICcgJyA6ICcnICkgKyByZXMucmVwbGFjZSgvW1xcdTAzMDAtXFx1MDM2Zl0vZywgXCJcIilcblx0XHQ6IHJlcztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYWxsIHZhbHVlcyBpbiB0aGUgYXJyYXkgYXJlIHVuaXF1ZS4gVGhpcyBtZWFucyB3ZSBjYW4gc2hvcnRcbiAqIGN1dCB0aGUgX3VuaXF1ZSBtZXRob2QgYXQgdGhlIGNvc3Qgb2YgYSBzaW5nbGUgbG9vcC4gQSBzb3J0ZWQgYXJyYXkgaXMgdXNlZFxuICogdG8gZWFzaWx5IGNoZWNrIHRoZSB2YWx1ZXMuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYWxsIHVuaXF1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAaWdub3JlXG4gKi9cbnZhciBfYXJlQWxsVW5pcXVlID0gZnVuY3Rpb24gKCBzcmMgKSB7XG5cdGlmICggc3JjLmxlbmd0aCA8IDIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHR2YXIgc29ydGVkID0gc3JjLnNsaWNlKCkuc29ydCgpO1xuXHR2YXIgbGFzdCA9IHNvcnRlZFswXTtcblxuXHRmb3IgKCB2YXIgaT0xLCBpZW49c29ydGVkLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdGlmICggc29ydGVkW2ldID09PSBsYXN0ICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGxhc3QgPSBzb3J0ZWRbaV07XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBGaW5kIHRoZSB1bmlxdWUgZWxlbWVudHMgaW4gYSBzb3VyY2UgYXJyYXkuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcbiAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiB1bmlxdWUgaXRlbXNcbiAqIEBpZ25vcmVcbiAqL1xudmFyIF91bmlxdWUgPSBmdW5jdGlvbiAoIHNyYyApXG57XG5cdGlmIChBcnJheS5mcm9tICYmIFNldCkge1xuXHRcdHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoc3JjKSk7XG5cdH1cblxuXHRpZiAoIF9hcmVBbGxVbmlxdWUoIHNyYyApICkge1xuXHRcdHJldHVybiBzcmMuc2xpY2UoKTtcblx0fVxuXG5cdC8vIEEgZmFzdGVyIHVuaXF1ZSBtZXRob2QgaXMgdG8gdXNlIG9iamVjdCBrZXlzIHRvIGlkZW50aWZ5IHVzZWQgdmFsdWVzLFxuXHQvLyBidXQgdGhpcyBkb2Vzbid0IHdvcmsgd2l0aCBhcnJheXMgb3Igb2JqZWN0cywgd2hpY2ggd2UgbXVzdCBhbHNvXG5cdC8vIGNvbnNpZGVyLiBTZWUganNwZXJmLmFwcC9jb21wYXJlLWFycmF5LXVuaXF1ZS12ZXJzaW9ucy80IGZvciBtb3JlXG5cdC8vIGluZm9ybWF0aW9uLlxuXHR2YXJcblx0XHRvdXQgPSBbXSxcblx0XHR2YWwsXG5cdFx0aSwgaWVuPXNyYy5sZW5ndGgsXG5cdFx0aiwgaz0wO1xuXG5cdGFnYWluOiBmb3IgKCBpPTAgOyBpPGllbiA7IGkrKyApIHtcblx0XHR2YWwgPSBzcmNbaV07XG5cblx0XHRmb3IgKCBqPTAgOyBqPGsgOyBqKysgKSB7XG5cdFx0XHRpZiAoIG91dFtqXSA9PT0gdmFsICkge1xuXHRcdFx0XHRjb250aW51ZSBhZ2Fpbjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvdXQucHVzaCggdmFsICk7XG5cdFx0aysrO1xuXHR9XG5cblx0cmV0dXJuIG91dDtcbn07XG5cbi8vIFN1cnByaXNpbmdseSB0aGlzIGlzIGZhc3RlciB0aGFuIFtdLmNvbmNhdC5hcHBseVxuLy8gaHR0cHM6Ly9qc3BlcmYuY29tL2ZsYXR0ZW4tYW4tYXJyYXktbG9vcC12cy1yZWR1Y2UvMlxudmFyIF9mbGF0dGVuID0gZnVuY3Rpb24gKG91dCwgdmFsKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0XHRmb3IgKHZhciBpPTAgOyBpPHZhbC5sZW5ndGggOyBpKyspIHtcblx0XHRcdF9mbGF0dGVuKG91dCwgdmFsW2ldKTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0b3V0LnB1c2godmFsKTtcblx0fVxuXG5cdHJldHVybiBvdXQ7XG59XG5cbi8vIFNpbWlsYXIgdG8galF1ZXJ5J3MgYWRkQ2xhc3MsIGJ1dCB1c2UgY2xhc3NMaXN0LmFkZFxuZnVuY3Rpb24gX2FkZENsYXNzKGVsLCBuYW1lKSB7XG5cdGlmIChuYW1lKSB7XG5cdFx0bmFtZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcblx0XHRcdGlmIChuKSB7XG5cdFx0XHRcdC8vIGBhZGRgIGRvZXMgZGVkdXBsaWNhdGlvbiwgc28gbm8gbmVlZCB0byBjaGVjayBgY29udGFpbnNgXG5cdFx0XHRcdGVsLmNsYXNzTGlzdC5hZGQobik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBEYXRhVGFibGVzIHV0aWxpdHkgbWV0aG9kc1xuICogXG4gKiBUaGlzIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgbWV0aG9kcyB0aGF0IERhdGFUYWJsZXMgdXNlcyBpbnRlcm5hbGx5IHRvXG4gKiBjcmVhdGUgYSBEYXRhVGFibGUsIGJ1dCB3aGljaCBhcmUgbm90IGV4Y2x1c2l2ZWx5IHVzZWQgb25seSBmb3IgRGF0YVRhYmxlcy5cbiAqIFRoZXNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGF1dGhvcnMgdG8gc2F2ZSB0aGUgZHVwbGljYXRpb24gb2ZcbiAqIGNvZGUuXG4gKlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLnV0aWwgPSB7XG5cdC8qKlxuXHQgKiBSZXR1cm4gYSBzdHJpbmcgd2l0aCBkaWFjcml0aWMgY2hhcmFjdGVycyBkZWNvbXBvc2VkXG5cdCAqIEBwYXJhbSB7Kn0gbWl4ZWQgRnVuY3Rpb24gb3Igc3RyaW5nIHRvIG5vcm1hbGl6ZVxuXHQgKiBAcGFyYW0geyp9IGJvdGggUmV0dXJuIG9yaWdpbmFsIHN0cmluZyBhbmQgdGhlIG5vcm1hbGl6ZWQgc3RyaW5nXG5cdCAqIEByZXR1cm5zIFN0cmluZyBvciB1bmRlZmluZWRcblx0ICovXG5cdGRpYWNyaXRpY3M6IGZ1bmN0aW9uIChtaXhlZCwgYm90aCkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIG1peGVkO1xuXG5cdFx0aWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBfbm9ybWFsaXplKG1peGVkLCBib3RoKTtcblx0XHR9XG5cdFx0X25vcm1hbGl6ZSA9IG1peGVkO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZWJvdW5jZSBhIGZ1bmN0aW9uXG5cdCAqXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuXHQgKiBAcGFyYW0ge2ludGVnZXJ9IGZyZXEgQ2FsbCBmcmVxdWVuY3kgaW4gbVNcblx0ICogQHJldHVybiB7ZnVuY3Rpb259IFdyYXBwZWQgZnVuY3Rpb25cblx0ICovXG5cdGRlYm91bmNlOiBmdW5jdGlvbiAoIGZuLCB0aW1lb3V0ICkge1xuXHRcdHZhciB0aW1lcjtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuXHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xuXHRcdFx0fSwgdGltZW91dCB8fCAyNTAgKTtcblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaHJvdHRsZSB0aGUgY2FsbHMgdG8gYSBmdW5jdGlvbi4gQXJndW1lbnRzIGFuZCBjb250ZXh0IGFyZSBtYWludGFpbmVkXG5cdCAqIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBmcmVxIENhbGwgZnJlcXVlbmN5IGluIG1TXG5cdCAqIEByZXR1cm4ge2Z1bmN0aW9ufSBXcmFwcGVkIGZ1bmN0aW9uXG5cdCAqL1xuXHR0aHJvdHRsZTogZnVuY3Rpb24gKCBmbiwgZnJlcSApIHtcblx0XHR2YXJcblx0XHRcdGZyZXF1ZW5jeSA9IGZyZXEgIT09IHVuZGVmaW5lZCA/IGZyZXEgOiAyMDAsXG5cdFx0XHRsYXN0LFxuXHRcdFx0dGltZXI7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyXG5cdFx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRub3cgID0gK25ldyBEYXRlKCksXG5cdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHM7XG5cblx0XHRcdGlmICggbGFzdCAmJiBub3cgPCBsYXN0ICsgZnJlcXVlbmN5ICkge1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVyICk7XG5cblx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bGFzdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRmbi5hcHBseSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHR9LCBmcmVxdWVuY3kgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRsYXN0ID0gbm93O1xuXHRcdFx0XHRmbi5hcHBseSggdGhhdCwgYXJncyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cblx0ICpcblx0ICogIEBwYXJhbSB7c3RyaW5nfSB2YWwgc3RyaW5nIHRvIGVzY2FwZVxuXHQgKiAgQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcblx0ICovXG5cdGVzY2FwZVJlZ2V4OiBmdW5jdGlvbiAoIHZhbCApIHtcblx0XHRyZXR1cm4gdmFsLnJlcGxhY2UoIF9yZV9lc2NhcGVfcmVnZXgsICdcXFxcJDEnICk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCB3cml0ZSB0byBhIG5lc3RlZCBvYmplY3Qgb3IgYXJyYXlcblx0ICogQHBhcmFtIHsqfSBzb3VyY2UgSlNPTiBub3RhdGlvbiBzdHJpbmdcblx0ICogQHJldHVybnMgV3JpdGUgZnVuY3Rpb25cblx0ICovXG5cdHNldDogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHNvdXJjZSApICkge1xuXHRcdFx0LyogVW5saWtlIGdldCwgb25seSB0aGUgdW5kZXJzY29yZSAoZ2xvYmFsKSBvcHRpb24gaXMgdXNlZCBmb3IgZm9yXG5cdFx0XHQgKiBzZXR0aW5nIGRhdGEgc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBoZXJlLiBUaGlzIGlzIHdoeSBhbiBvYmplY3Rcblx0XHRcdCAqIG9wdGlvbiBpcyBub3QgZG9jdW1lbnRlZCBmb3IgYG1EYXRhYCAod2hpY2ggaXMgcmVhZC93cml0ZSksIGJ1dCBpdCBpc1xuXHRcdFx0ICogZm9yIGBtUmVuZGVyYCB3aGljaCBpcyByZWFkIG9ubHkuXG5cdFx0XHQgKi9cblx0XHRcdHJldHVybiBEYXRhVGFibGUudXRpbC5zZXQoIHNvdXJjZS5fICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzb3VyY2UgPT09IG51bGwgKSB7XG5cdFx0XHQvLyBOb3RoaW5nIHRvIGRvIHdoZW4gdGhlIGRhdGEgc291cmNlIGlzIG51bGxcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCwgbWV0YSkge1xuXHRcdFx0XHRzb3VyY2UoIGRhdGEsICdzZXQnLCB2YWwsIG1ldGEgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKFxuXHRcdFx0dHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgKHNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG5cdFx0XHRzb3VyY2UuaW5kZXhPZignWycpICE9PSAtMSB8fCBzb3VyY2UuaW5kZXhPZignKCcpICE9PSAtMSlcblx0XHQpIHtcblx0XHRcdC8vIExpa2UgdGhlIGdldCwgd2UgbmVlZCB0byBnZXQgZGF0YSBmcm9tIGEgbmVzdGVkIG9iamVjdFxuXHRcdFx0dmFyIHNldERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgdmFsLCBzcmMpIHtcblx0XHRcdFx0dmFyIGEgPSBfZm5TcGxpdE9iak5vdGF0aW9uKCBzcmMgKSwgYjtcblx0XHRcdFx0dmFyIGFMYXN0ID0gYVthLmxlbmd0aC0xXTtcblx0XHRcdFx0dmFyIGFycmF5Tm90YXRpb24sIGZ1bmNOb3RhdGlvbiwgbywgaW5uZXJTcmM7XG5cdFxuXHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWEubGVuZ3RoLTEgOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0Ly8gUHJvdGVjdCBhZ2FpbnN0IHByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0XHRpZiAoYVtpXSA9PT0gJ19fcHJvdG9fXycgfHwgYVtpXSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IHByb3RvdHlwZSB2YWx1ZXMnKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIENoZWNrIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggYW4gYXJyYXkgbm90YXRpb24gcmVxdWVzdFxuXHRcdFx0XHRcdGFycmF5Tm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVBcnJheSk7XG5cdFx0XHRcdFx0ZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xuXHRcblx0XHRcdFx0XHRpZiAoIGFycmF5Tm90YXRpb24gKSB7XG5cdFx0XHRcdFx0XHRhW2ldID0gYVtpXS5yZXBsYWNlKF9fcmVBcnJheSwgJycpO1xuXHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdID0gW107XG5cdFxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSByZW1haW5kZXIgb2YgdGhlIG5lc3RlZCBvYmplY3QgdG8gc2V0IHNvIHdlIGNhbiByZWN1cnNlXG5cdFx0XHRcdFx0XHRiID0gYS5zbGljZSgpO1xuXHRcdFx0XHRcdFx0Yi5zcGxpY2UoIDAsIGkrMSApO1xuXHRcdFx0XHRcdFx0aW5uZXJTcmMgPSBiLmpvaW4oJy4nKTtcblx0XG5cdFx0XHRcdFx0XHQvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBzZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxuXHRcdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGo9MCwgakxlbj12YWwubGVuZ3RoIDsgajxqTGVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0XHRcdG8gPSB7fTtcblx0XHRcdFx0XHRcdFx0XHRzZXREYXRhKCBvLCB2YWxbal0sIGlubmVyU3JjICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdLnB1c2goIG8gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFdlJ3ZlIGJlZW4gYXNrZWQgdG8gc2F2ZSBkYXRhIHRvIGFuIGFycmF5LCBidXQgaXRcblx0XHRcdFx0XHRcdFx0Ly8gaXNuJ3QgYXJyYXkgZGF0YSB0byBiZSBzYXZlZC4gQmVzdCB0aGF0IGNhbiBiZSBkb25lXG5cdFx0XHRcdFx0XHRcdC8vIGlzIHRvIGp1c3Qgc2F2ZSB0aGUgdmFsdWUuXG5cdFx0XHRcdFx0XHRcdGRhdGFbIGFbaV0gXSA9IHZhbDtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHQvLyBUaGUgaW5uZXIgY2FsbCB0byBzZXREYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcblx0XHRcdFx0XHRcdC8vIG9mIHRoZSBzb3VyY2UgYW5kIGhhcyBzZXQgdGhlIGRhdGEsIHRodXMgd2UgY2FuIGV4aXQgaGVyZVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmICggZnVuY05vdGF0aW9uICkge1xuXHRcdFx0XHRcdFx0Ly8gRnVuY3Rpb24gY2FsbFxuXHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcblx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oIHZhbCApO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG5lc3RlZCBvYmplY3QgZG9lc24ndCBjdXJyZW50bHkgZXhpc3QgLSBzaW5jZSB3ZSBhcmVcblx0XHRcdFx0XHQvLyB0cnlpbmcgdG8gc2V0IHRoZSB2YWx1ZSAtIGNyZWF0ZSBpdFxuXHRcdFx0XHRcdGlmICggZGF0YVsgYVtpXSBdID09PSBudWxsIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0ZGF0YVsgYVtpXSBdID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdC8vIExhc3QgaXRlbSBpbiB0aGUgaW5wdXQgLSBpLmUsIHRoZSBhY3R1YWwgc2V0XG5cdFx0XHRcdGlmICggYUxhc3QubWF0Y2goX19yZUZuICkgKSB7XG5cdFx0XHRcdFx0Ly8gRnVuY3Rpb24gY2FsbFxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhTGFzdC5yZXBsYWNlKF9fcmVGbiwgJycpIF0oIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIElmIGFycmF5IG5vdGF0aW9uIGlzIHVzZWQsIHdlIGp1c3Qgd2FudCB0byBzdHJpcCBpdCBhbmQgdXNlIHRoZSBwcm9wZXJ0eSBuYW1lXG5cdFx0XHRcdFx0Ly8gYW5kIGFzc2lnbiB0aGUgdmFsdWUuIElmIGl0IGlzbid0IHVzZWQsIHRoZW4gd2UgZ2V0IHRoZSByZXN1bHQgd2Ugd2FudCBhbnl3YXlcblx0XHRcdFx0XHRkYXRhWyBhTGFzdC5yZXBsYWNlKF9fcmVBcnJheSwgJycpIF0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwpIHsgLy8gbWV0YSBpcyBhbHNvIHBhc3NlZCBpbiwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBzZXREYXRhKCBkYXRhLCB2YWwsIHNvdXJjZSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBBcnJheSBvciBmbGF0IG9iamVjdCBtYXBwaW5nXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCkgeyAvLyBtZXRhIGlzIGFsc28gcGFzc2VkIGluLCBidXQgbm90IHVzZWRcblx0XHRcdFx0ZGF0YVtzb3VyY2VdID0gdmFsO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZWFkIG5lc3RlZCBvYmplY3RzIGZyb20gYXJyYXlzLCBiYXNlZCBvbiBKU09OIG5vdGF0aW9uXG5cdCAqIEBwYXJhbSB7Kn0gc291cmNlIEpTT04gbm90YXRpb24gc3RyaW5nXG5cdCAqIEByZXR1cm5zIFZhbHVlIHJlYWRcblx0ICovXG5cdGdldDogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHNvdXJjZSApICkge1xuXHRcdFx0Ly8gQnVpbGQgYW4gb2JqZWN0IG9mIGdldCBmdW5jdGlvbnMsIGFuZCB3cmFwIHRoZW0gaW4gYSBzaW5nbGUgY2FsbFxuXHRcdFx0dmFyIG8gPSB7fTtcblx0XHRcdCQuZWFjaCggc291cmNlLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0b1trZXldID0gRGF0YVRhYmxlLnV0aWwuZ2V0KCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XG5cdFx0XHRcdHZhciB0ID0gb1t0eXBlXSB8fCBvLl87XG5cdFx0XHRcdHJldHVybiB0ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdHQoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSA6XG5cdFx0XHRcdFx0ZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzb3VyY2UgPT09IG51bGwgKSB7XG5cdFx0XHQvLyBHaXZlIGFuIGVtcHR5IHN0cmluZyBmb3IgcmVuZGVyaW5nIC8gc29ydGluZyBldGNcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSkgeyAvLyB0eXBlLCByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3csIG1ldGEpIHtcblx0XHRcdFx0cmV0dXJuIHNvdXJjZSggZGF0YSwgdHlwZSwgcm93LCBtZXRhICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIGlmIChcblx0XHRcdHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmIChzb3VyY2UuaW5kZXhPZignLicpICE9PSAtMSB8fFxuXHRcdFx0c291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgc291cmNlLmluZGV4T2YoJygnKSAhPT0gLTEpXG5cdFx0KSB7XG5cdFx0XHQvKiBJZiB0aGVyZSBpcyBhIC4gaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlbiB0aGUgZGF0YSBzb3VyY2UgaXMgaW4gYVxuXHRcdFx0ICogbmVzdGVkIG9iamVjdCBzbyB3ZSBsb29wIG92ZXIgdGhlIGRhdGEgZm9yIGVhY2ggbGV2ZWwgdG8gZ2V0IHRoZSBuZXh0XG5cdFx0XHQgKiBsZXZlbCBkb3duLiBPbiBlYWNoIGxvb3Agd2UgdGVzdCBmb3IgdW5kZWZpbmVkLCBhbmQgaWYgZm91bmQgaW1tZWRpYXRlbHlcblx0XHRcdCAqIHJldHVybi4gVGhpcyBhbGxvd3MgZW50aXJlIG9iamVjdHMgdG8gYmUgbWlzc2luZyBhbmQgc0RlZmF1bHRDb250ZW50IHRvXG5cdFx0XHQgKiBiZSB1c2VkIGlmIGRlZmluZWQsIHJhdGhlciB0aGFuIHRocm93aW5nIGFuIGVycm9yXG5cdFx0XHQgKi9cblx0XHRcdHZhciBmZXRjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgc3JjKSB7XG5cdFx0XHRcdHZhciBhcnJheU5vdGF0aW9uLCBmdW5jTm90YXRpb24sIG91dCwgaW5uZXJTcmM7XG5cdFxuXHRcdFx0XHRpZiAoIHNyYyAhPT0gXCJcIiApIHtcblx0XHRcdFx0XHR2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oIHNyYyApO1xuXHRcblx0XHRcdFx0XHRmb3IgKCB2YXIgaT0wLCBpTGVuPWEubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBzcGVjaWFsIG5vdGF0aW9uXG5cdFx0XHRcdFx0XHRhcnJheU5vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlQXJyYXkpO1xuXHRcdFx0XHRcdFx0ZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xuXHRcblx0XHRcdFx0XHRcdGlmICggYXJyYXlOb3RhdGlvbiApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQXJyYXkgbm90YXRpb25cblx0XHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlQXJyYXksICcnKTtcblx0XG5cdFx0XHRcdFx0XHRcdC8vIENvbmRpdGlvbiBhbGxvd3Mgc2ltcGx5IFtdIHRvIGJlIHBhc3NlZCBpblxuXHRcdFx0XHRcdFx0XHRpZiAoIGFbaV0gIT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRvdXQgPSBbXTtcblx0XG5cdFx0XHRcdFx0XHRcdC8vIEdldCB0aGUgcmVtYWluZGVyIG9mIHRoZSBuZXN0ZWQgb2JqZWN0IHRvIGdldFxuXHRcdFx0XHRcdFx0XHRhLnNwbGljZSggMCwgaSsxICk7XG5cdFx0XHRcdFx0XHRcdGlubmVyU3JjID0gYS5qb2luKCcuJyk7XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBnZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxuXHRcdFx0XHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaj0wLCBqTGVuPWRhdGEubGVuZ3RoIDsgajxqTGVuIDsgaisrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3V0LnB1c2goIGZldGNoRGF0YSggZGF0YVtqXSwgdHlwZSwgaW5uZXJTcmMgKSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0Ly8gSWYgYSBzdHJpbmcgaXMgZ2l2ZW4gaW4gYmV0d2VlbiB0aGUgYXJyYXkgbm90YXRpb24gaW5kaWNhdG9ycywgdGhhdFxuXHRcdFx0XHRcdFx0XHQvLyBpcyB1c2VkIHRvIGpvaW4gdGhlIHN0cmluZ3MgdG9nZXRoZXIsIG90aGVyd2lzZSBhbiBhcnJheSBpcyByZXR1cm5lZFxuXHRcdFx0XHRcdFx0XHR2YXIgam9pbiA9IGFycmF5Tm90YXRpb25bMF0uc3Vic3RyaW5nKDEsIGFycmF5Tm90YXRpb25bMF0ubGVuZ3RoLTEpO1xuXHRcdFx0XHRcdFx0XHRkYXRhID0gKGpvaW49PT1cIlwiKSA/IG91dCA6IG91dC5qb2luKGpvaW4pO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gVGhlIGlubmVyIGNhbGwgdG8gZmV0Y2hEYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcblx0XHRcdFx0XHRcdFx0Ly8gb2YgdGhlIHNvdXJjZSByZXF1ZXN0ZWQsIHNvIHdlIGV4aXQgZnJvbSB0aGUgbG9vcFxuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKCBmdW5jTm90YXRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEZ1bmN0aW9uIGNhbGxcblx0XHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXSgpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRpZiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhWyBhW2ldIF0gPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICggZGF0YSA9PT0gdW5kZWZpbmVkIHx8IGRhdGFbIGFbaV0gXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRkYXRhID0gZGF0YVsgYVtpXSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9O1xuXHRcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkgeyAvLyByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRyZXR1cm4gZmV0Y2hEYXRhKCBkYXRhLCB0eXBlLCBzb3VyY2UgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gQXJyYXkgb3IgZmxhdCBvYmplY3QgbWFwcGluZ1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7IC8vIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdHJldHVybiBkYXRhW3NvdXJjZV07XG5cdFx0XHR9O1xuXHRcdH1cblx0fSxcblxuXHRzdHJpcEh0bWw6IGZ1bmN0aW9uIChtaXhlZCkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIG1peGVkO1xuXG5cdFx0aWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdF9zdHJpcEh0bWwgPSBtaXhlZDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBfc3RyaXBIdG1sKG1peGVkKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1peGVkO1xuXHR9LFxuXG5cdGVzY2FwZUh0bWw6IGZ1bmN0aW9uIChtaXhlZCkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIG1peGVkO1xuXG5cdFx0aWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdF9lc2NhcGVIdG1sID0gbWl4ZWQ7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkobWl4ZWQpKSB7XG5cdFx0XHRyZXR1cm4gX2VzY2FwZUh0bWwobWl4ZWQpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWl4ZWQ7XG5cdH0sXG5cblx0dW5pcXVlOiBfdW5pcXVlXG59O1xuXG5cblxuLyoqXG4gKiBDcmVhdGUgYSBtYXBwaW5nIG9iamVjdCB0aGF0IGFsbG93cyBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gYmUgbG9va2VkIHVwXG4gKiBmb3IgdGhlaXIgSHVuZ2FyaWFuIGNvdW50ZXJwYXJ0cy4gVGhlIG1hcHBpbmcgaXMgc3RvcmVkIGluIGEgcHJpdmF0ZVxuICogcGFyYW1ldGVyIGNhbGxlZCBgX2h1bmdhcmlhbk1hcGAgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIG9uIHRoZSBzb3VyY2Ugb2JqZWN0LlxuICogIEBwYXJhbSB7b2JqZWN0fSBvXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkh1bmdhcmlhbk1hcCAoIG8gKVxue1xuXHR2YXJcblx0XHRodW5nYXJpYW4gPSAnYSBhYSBhaSBhbyBhcyBiIGZuIGkgbSBvIHMgJyxcblx0XHRtYXRjaCxcblx0XHRuZXdLZXksXG5cdFx0bWFwID0ge307XG5cblx0JC5lYWNoKCBvLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0bWF0Y2ggPSBrZXkubWF0Y2goL14oW15BLVpdKz8pKFtBLVpdKS8pO1xuXG5cdFx0aWYgKCBtYXRjaCAmJiBodW5nYXJpYW4uaW5kZXhPZihtYXRjaFsxXSsnICcpICE9PSAtMSApXG5cdFx0e1xuXHRcdFx0bmV3S2V5ID0ga2V5LnJlcGxhY2UoIG1hdGNoWzBdLCBtYXRjaFsyXS50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHRtYXBbIG5ld0tleSBdID0ga2V5O1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdID09PSAnbycgKVxuXHRcdFx0e1xuXHRcdFx0XHRfZm5IdW5nYXJpYW5NYXAoIG9ba2V5XSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXG5cdG8uX2h1bmdhcmlhbk1hcCA9IG1hcDtcbn1cblxuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gSHVuZ2FyaWFuLCBiYXNlZCBvbiBhIEh1bmdhcmlhbiBtYXBcbiAqIGNyZWF0ZWQgYnkgX2ZuSHVuZ2FyaWFuTWFwLlxuICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgVGhlIG1vZGVsIG9iamVjdCB3aGljaCBob2xkcyBhbGwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZVxuICogICAgbWFwcGVkLlxuICogIEBwYXJhbSB7b2JqZWN0fSB1c2VyIFRoZSBvYmplY3QgdG8gY29udmVydCBmcm9tIGNhbWVsIGNhc2UgdG8gSHVuZ2FyaWFuLlxuICogIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgV2hlbiBzZXQgdG8gYHRydWVgLCBwcm9wZXJ0aWVzIHdoaWNoIGFscmVhZHkgaGF2ZSBhXG4gKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcbiAqICAgIHdvbid0IGJlLlxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5DYW1lbFRvSHVuZ2FyaWFuICggc3JjLCB1c2VyLCBmb3JjZSApXG57XG5cdGlmICggISBzcmMuX2h1bmdhcmlhbk1hcCApIHtcblx0XHRfZm5IdW5nYXJpYW5NYXAoIHNyYyApO1xuXHR9XG5cblx0dmFyIGh1bmdhcmlhbktleTtcblxuXHQkLmVhY2goIHVzZXIsIGZ1bmN0aW9uIChrZXkpIHtcblx0XHRodW5nYXJpYW5LZXkgPSBzcmMuX2h1bmdhcmlhbk1hcFsga2V5IF07XG5cblx0XHRpZiAoIGh1bmdhcmlhbktleSAhPT0gdW5kZWZpbmVkICYmIChmb3JjZSB8fCB1c2VyW2h1bmdhcmlhbktleV0gPT09IHVuZGVmaW5lZCkgKVxuXHRcdHtcblx0XHRcdC8vIEZvciBvYmplY3RzLCB3ZSBuZWVkIHRvIGJ1enogZG93biBpbnRvIHRoZSBvYmplY3QgdG8gY29weSBwYXJhbWV0ZXJzXG5cdFx0XHRpZiAoIGh1bmdhcmlhbktleS5jaGFyQXQoMCkgPT09ICdvJyApXG5cdFx0XHR7XG5cdFx0XHRcdC8vIENvcHkgdGhlIGNhbWVsQ2FzZSBvcHRpb25zIG92ZXIgdG8gdGhlIGh1bmdhcmlhblxuXHRcdFx0XHRpZiAoICEgdXNlclsgaHVuZ2FyaWFuS2V5IF0gKSB7XG5cdFx0XHRcdFx0dXNlclsgaHVuZ2FyaWFuS2V5IF0gPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkLmV4dGVuZCggdHJ1ZSwgdXNlcltodW5nYXJpYW5LZXldLCB1c2VyW2tleV0gKTtcblxuXHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBzcmNbaHVuZ2FyaWFuS2V5XSwgdXNlcltodW5nYXJpYW5LZXldLCBmb3JjZSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHVzZXJbaHVuZ2FyaWFuS2V5XSA9IHVzZXJbIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG4vKipcbiAqIE1hcCBvbmUgcGFyYW1ldGVyIG9udG8gYW5vdGhlclxuICogIEBwYXJhbSB7b2JqZWN0fSBvIE9iamVjdCB0byBtYXBcbiAqICBAcGFyYW0geyp9IGtuZXcgVGhlIG5ldyBwYXJhbWV0ZXIgbmFtZVxuICogIEBwYXJhbSB7Kn0gb2xkIFRoZSBvbGQgcGFyYW1ldGVyIG5hbWVcbiAqL1xudmFyIF9mbkNvbXBhdE1hcCA9IGZ1bmN0aW9uICggbywga25ldywgb2xkICkge1xuXHRpZiAoIG9bIGtuZXcgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdG9bIG9sZCBdID0gb1sga25ldyBdO1xuXHR9XG59O1xuXG5cbi8qKlxuICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgdGhlIG1haW4gRFQgb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXdcbiAqIG9wdGlvbnMgYXJlIG1hcHBlZCBvbnRvIHRoZSBvbGQgcGFyYW1ldGVycywgc28gdGhpcyBpcyBhbiBleHRlcm5hbCBpbnRlcmZhY2VcbiAqIGNoYW5nZSBvbmx5LlxuICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcbiAqL1xuZnVuY3Rpb24gX2ZuQ29tcGF0T3B0cyAoIGluaXQgKVxue1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlcmluZycsICAgICAgJ2JTb3J0JyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlck11bHRpJywgICAgJ2JTb3J0TXVsdGknICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyQ2xhc3NlcycsICAnYlNvcnRDbGFzc2VzJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckNlbGxzVG9wJywgJ2JTb3J0Q2VsbHNUb3AnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyJywgICAgICAgICAnYWFTb3J0aW5nJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckZpeGVkJywgICAgJ2FhU29ydGluZ0ZpeGVkJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdwYWdpbmcnLCAgICAgICAgJ2JQYWdpbmF0ZScgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnaW5nVHlwZScsICAgICdzUGFnaW5hdGlvblR5cGUnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2VMZW5ndGgnLCAgICAnaURpc3BsYXlMZW5ndGgnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3NlYXJjaGluZycsICAgICAnYkZpbHRlcicgKTtcblxuXHQvLyBCb29sZWFuIGluaXRpYWxpc2F0aW9uIG9mIHgtc2Nyb2xsaW5nXG5cdGlmICggdHlwZW9mIGluaXQuc1Njcm9sbFggPT09ICdib29sZWFuJyApIHtcblx0XHRpbml0LnNTY3JvbGxYID0gaW5pdC5zU2Nyb2xsWCA/ICcxMDAlJyA6ICcnO1xuXHR9XG5cdGlmICggdHlwZW9mIGluaXQuc2Nyb2xsWCA9PT0gJ2Jvb2xlYW4nICkge1xuXHRcdGluaXQuc2Nyb2xsWCA9IGluaXQuc2Nyb2xsWCA/ICcxMDAlJyA6ICcnO1xuXHR9XG5cblx0Ly8gT2JqZWN0cyBmb3Igb3JkZXJpbmdcblx0aWYgKCB0eXBlb2YgaW5pdC5iU29ydCA9PT0gJ29iamVjdCcgKSB7XG5cdFx0aW5pdC5vcmRlckluZGljYXRvcnMgPSBpbml0LmJTb3J0LmluZGljYXRvcnMgIT09IHVuZGVmaW5lZCA/IGluaXQuYlNvcnQuaW5kaWNhdG9ycyA6IHRydWU7XG5cdFx0aW5pdC5vcmRlckhhbmRsZXIgPSBpbml0LmJTb3J0LmhhbmRsZXIgIT09IHVuZGVmaW5lZCA/IGluaXQuYlNvcnQuaGFuZGxlciA6IHRydWU7XG5cdFx0aW5pdC5iU29ydCA9IHRydWU7XG5cdH1cblx0ZWxzZSBpZiAoaW5pdC5iU29ydCA9PT0gZmFsc2UpIHtcblx0XHRpbml0Lm9yZGVySW5kaWNhdG9ycyA9IGZhbHNlO1xuXHRcdGluaXQub3JkZXJIYW5kbGVyID0gZmFsc2U7XG5cdH1cblxuXHQvLyBXaGljaCBjZWxscyBhcmUgdGhlIHRpdGxlIGNlbGxzP1xuXHRpZiAodHlwZW9mIGluaXQuYlNvcnRDZWxsc1RvcCA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0aW5pdC50aXRsZVJvdyA9IGluaXQuYlNvcnRDZWxsc1RvcDtcblx0fVxuXG5cdC8vIENvbHVtbiBzZWFyY2ggb2JqZWN0cyBhcmUgaW4gYW4gYXJyYXksIHNvIGl0IG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxuXHQvLyBlbGVtZW50IGJ5IGVsZW1lbnRcblx0dmFyIHNlYXJjaENvbHMgPSBpbml0LmFvU2VhcmNoQ29scztcblxuXHRpZiAoIHNlYXJjaENvbHMgKSB7XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNlYXJjaENvbHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIHNlYXJjaENvbHNbaV0gKSB7XG5cdFx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCwgc2VhcmNoQ29sc1tpXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEVuYWJsZSBzZWFyY2ggZGVsYXkgaWYgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBpcyBlbmFibGVkXG5cdGlmIChpbml0LnNlcnZlclNpZGUgJiYgISBpbml0LnNlYXJjaERlbGF5KSB7XG5cdFx0aW5pdC5zZWFyY2hEZWxheSA9IDQwMDtcblx0fVxufVxuXG5cbi8qKlxuICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgY29sdW1uIG9wdGlvbnMuIE5vdGUgdGhhdCB0aGUgbmV3IG9wdGlvbnNcbiAqIGFyZSBtYXBwZWQgb250byB0aGUgb2xkIHBhcmFtZXRlcnMsIHNvIHRoaXMgaXMgYW4gZXh0ZXJuYWwgaW50ZXJmYWNlIGNoYW5nZVxuICogb25seS5cbiAqICBAcGFyYW0ge29iamVjdH0gaW5pdCBPYmplY3QgdG8gbWFwXG4gKi9cbmZ1bmN0aW9uIF9mbkNvbXBhdENvbHMgKCBpbml0IClcbntcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJhYmxlJywgICAgICdiU29ydGFibGUnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRGF0YScsICAgICAnYURhdGFTb3J0JyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlclNlcXVlbmNlJywgJ2FzU29ydGluZycgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJEYXRhVHlwZScsICdzb3J0RGF0YVR5cGUnICk7XG5cblx0Ly8gb3JkZXJEYXRhIGNhbiBiZSBnaXZlbiBhcyBhbiBpbnRlZ2VyXG5cdHZhciBkYXRhU29ydCA9IGluaXQuYURhdGFTb3J0O1xuXHRpZiAoIHR5cGVvZiBkYXRhU29ydCA9PT0gJ251bWJlcicgJiYgISBBcnJheS5pc0FycmF5KCBkYXRhU29ydCApICkge1xuXHRcdGluaXQuYURhdGFTb3J0ID0gWyBkYXRhU29ydCBdO1xuXHR9XG59XG5cblxuLyoqXG4gKiBCcm93c2VyIGZlYXR1cmUgZGV0ZWN0aW9uIGZvciBjYXBhYmlsaXRpZXMsIHF1aXJrc1xuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Ccm93c2VyRGV0ZWN0KCBzZXR0aW5ncyApXG57XG5cdC8vIFdlIGRvbid0IG5lZWQgdG8gZG8gdGhpcyBldmVyeSB0aW1lIERhdGFUYWJsZXMgaXMgY29uc3RydWN0ZWQsIHRoZSB2YWx1ZXNcblx0Ly8gY2FsY3VsYXRlZCBhcmUgc3BlY2lmaWMgdG8gdGhlIGJyb3dzZXIgYW5kIE9TIGNvbmZpZ3VyYXRpb24gd2hpY2ggd2Vcblx0Ly8gZG9uJ3QgZXhwZWN0IHRvIGNoYW5nZSBiZXR3ZWVuIGluaXRpYWxpc2F0aW9uc1xuXHRpZiAoICEgRGF0YVRhYmxlLl9fYnJvd3NlciApIHtcblx0XHR2YXIgYnJvd3NlciA9IHt9O1xuXHRcdERhdGFUYWJsZS5fX2Jyb3dzZXIgPSBicm93c2VyO1xuXG5cdFx0Ly8gU2Nyb2xsaW5nIGZlYXR1cmUgLyBxdWlya3MgZGV0ZWN0aW9uXG5cdFx0dmFyIG4gPSAkKCc8ZGl2Lz4nKVxuXHRcdFx0LmNzcygge1xuXHRcdFx0XHRwb3NpdGlvbjogJ2ZpeGVkJyxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRsZWZ0OiAtMSAqIHdpbmRvdy5wYWdlWE9mZnNldCwgLy8gYWxsb3cgZm9yIHNjcm9sbGluZ1xuXHRcdFx0XHRoZWlnaHQ6IDEsXG5cdFx0XHRcdHdpZHRoOiAxLFxuXHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbidcblx0XHRcdH0gKVxuXHRcdFx0LmFwcGVuZChcblx0XHRcdFx0JCgnPGRpdi8+Jylcblx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdFx0XHRcdHRvcDogMSxcblx0XHRcdFx0XHRcdGxlZnQ6IDEsXG5cdFx0XHRcdFx0XHR3aWR0aDogMTAwLFxuXHRcdFx0XHRcdFx0b3ZlcmZsb3c6ICdzY3JvbGwnXG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdCQoJzxkaXYvPicpXG5cdFx0XHRcdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRcdFx0XHR3aWR0aDogJzEwMCUnLFxuXHRcdFx0XHRcdFx0XHRcdGhlaWdodDogMTBcblx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdFx0LmFwcGVuZFRvKCAnYm9keScgKTtcblxuXHRcdHZhciBvdXRlciA9IG4uY2hpbGRyZW4oKTtcblx0XHR2YXIgaW5uZXIgPSBvdXRlci5jaGlsZHJlbigpO1xuXG5cdFx0Ly8gR2V0IHNjcm9sbGJhciB3aWR0aFxuXHRcdGJyb3dzZXIuYmFyV2lkdGggPSBvdXRlclswXS5vZmZzZXRXaWR0aCAtIG91dGVyWzBdLmNsaWVudFdpZHRoO1xuXG5cdFx0Ly8gSW4gcnRsIHRleHQgbGF5b3V0LCBzb21lIGJyb3dzZXJzIChtb3N0LCBidXQgbm90IGFsbCkgd2lsbCBwbGFjZSB0aGVcblx0XHQvLyBzY3JvbGxiYXIgb24gdGhlIGxlZnQsIHJhdGhlciB0aGFuIHRoZSByaWdodC5cblx0XHRicm93c2VyLmJTY3JvbGxiYXJMZWZ0ID0gTWF0aC5yb3VuZCggaW5uZXIub2Zmc2V0KCkubGVmdCApICE9PSAxO1xuXG5cdFx0bi5yZW1vdmUoKTtcblx0fVxuXG5cdCQuZXh0ZW5kKCBzZXR0aW5ncy5vQnJvd3NlciwgRGF0YVRhYmxlLl9fYnJvd3NlciApO1xuXHRzZXR0aW5ncy5vU2Nyb2xsLmlCYXJXaWR0aCA9IERhdGFUYWJsZS5fX2Jyb3dzZXIuYmFyV2lkdGg7XG59XG5cbi8qKlxuICogQWRkIGEgY29sdW1uIHRvIHRoZSBsaXN0IHVzZWQgZm9yIHRoZSB0YWJsZSB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5BZGRDb2x1bW4oIG9TZXR0aW5ncyApXG57XG5cdC8vIEFkZCBjb2x1bW4gdG8gYW9Db2x1bW5zIGFycmF5XG5cdHZhciBvRGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uO1xuXHR2YXIgaUNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHR2YXIgb0NvbCA9ICQuZXh0ZW5kKCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vQ29sdW1uLCBvRGVmYXVsdHMsIHtcblx0XHRcImFEYXRhU29ydFwiOiBvRGVmYXVsdHMuYURhdGFTb3J0ID8gb0RlZmF1bHRzLmFEYXRhU29ydCA6IFtpQ29sXSxcblx0XHRcIm1EYXRhXCI6IG9EZWZhdWx0cy5tRGF0YSA/IG9EZWZhdWx0cy5tRGF0YSA6IGlDb2wsXG5cdFx0aWR4OiBpQ29sLFxuXHRcdHNlYXJjaEZpeGVkOiB7fSxcblx0XHRjb2xFbDogJCgnPGNvbD4nKS5hdHRyKCdkYXRhLWR0LWNvbHVtbicsIGlDb2wpXG5cdH0gKTtcblx0b1NldHRpbmdzLmFvQ29sdW1ucy5wdXNoKCBvQ29sICk7XG5cblx0Ly8gQWRkIHNlYXJjaCBvYmplY3QgZm9yIGNvbHVtbiBzcGVjaWZpYyBzZWFyY2guIE5vdGUgdGhhdCB0aGUgYHNlYXJjaENvbHNbIGlDb2wgXWBcblx0Ly8gcGFzc2VkIGludG8gZXh0ZW5kIGNhbiBiZSB1bmRlZmluZWQuIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGdpdmUgYSBkZWZhdWx0XG5cdC8vIHdpdGggb25seSBzb21lIG9mIHRoZSBwYXJhbWV0ZXJzIGRlZmluZWQsIGFuZCBhbHNvIG5vdCBnaXZlIGEgZGVmYXVsdFxuXHR2YXIgc2VhcmNoQ29scyA9IG9TZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cdHNlYXJjaENvbHNbIGlDb2wgXSA9ICQuZXh0ZW5kKCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoLCBzZWFyY2hDb2xzWyBpQ29sIF0gKTtcbn1cblxuXG4vKipcbiAqIEFwcGx5IG9wdGlvbnMgZm9yIGEgY29sdW1uXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7aW50fSBpQ29sIGNvbHVtbiBpbmRleCB0byBjb25zaWRlclxuICogIEBwYXJhbSB7b2JqZWN0fSBvT3B0aW9ucyBvYmplY3Qgd2l0aCBzVHlwZSwgYlZpc2libGUgYW5kIGJTZWFyY2hhYmxlIGV0Y1xuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGlDb2wsIG9PcHRpb25zIClcbntcblx0dmFyIG9Db2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zWyBpQ29sIF07XG5cblx0LyogVXNlciBzcGVjaWZpZWQgY29sdW1uIG9wdGlvbnMgKi9cblx0aWYgKCBvT3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9PcHRpb25zICE9PSBudWxsIClcblx0e1xuXHRcdC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdFx0X2ZuQ29tcGF0Q29scyggb09wdGlvbnMgKTtcblxuXHRcdC8vIE1hcCBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gdGhlaXIgSHVuZ2FyaWFuIGNvdW50ZXJwYXJ0c1xuXHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4sIG9PcHRpb25zLCB0cnVlICk7XG5cblx0XHQvKiBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgbURhdGFQcm9wICovXG5cdFx0aWYgKCBvT3B0aW9ucy5tRGF0YVByb3AgIT09IHVuZGVmaW5lZCAmJiAhb09wdGlvbnMubURhdGEgKVxuXHRcdHtcblx0XHRcdG9PcHRpb25zLm1EYXRhID0gb09wdGlvbnMubURhdGFQcm9wO1xuXHRcdH1cblxuXHRcdGlmICggb09wdGlvbnMuc1R5cGUgKVxuXHRcdHtcblx0XHRcdG9Db2wuX3NNYW51YWxUeXBlID0gb09wdGlvbnMuc1R5cGU7XG5cdFx0fVxuXHRcblx0XHQvLyBgY2xhc3NgIGlzIGEgcmVzZXJ2ZWQgd29yZCBpbiBKYXZhc2NyaXB0LCBzbyB3ZSBuZWVkIHRvIHByb3ZpZGVcblx0XHQvLyB0aGUgYWJpbGl0eSB0byB1c2UgYSB2YWxpZCBuYW1lIGZvciB0aGUgY2FtZWwgY2FzZSBpbnB1dFxuXHRcdGlmICggb09wdGlvbnMuY2xhc3NOYW1lICYmICEgb09wdGlvbnMuc0NsYXNzIClcblx0XHR7XG5cdFx0XHRvT3B0aW9ucy5zQ2xhc3MgPSBvT3B0aW9ucy5jbGFzc05hbWU7XG5cdFx0fVxuXG5cdFx0dmFyIG9yaWdDbGFzcyA9IG9Db2wuc0NsYXNzO1xuXG5cdFx0JC5leHRlbmQoIG9Db2wsIG9PcHRpb25zICk7XG5cdFx0X2ZuTWFwKCBvQ29sLCBvT3B0aW9ucywgXCJzV2lkdGhcIiwgXCJzV2lkdGhPcmlnXCIgKTtcblxuXHRcdC8vIE1lcmdlIGNsYXNzIGZyb20gcHJldmlvdXNseSBkZWZpbmVkIGNsYXNzZXMgd2l0aCB0aGlzIG9uZSwgcmF0aGVyIHRoYW4ganVzdFxuXHRcdC8vIG92ZXJ3cml0aW5nIGl0IGluIHRoZSBleHRlbmQgYWJvdmVcblx0XHRpZiAob3JpZ0NsYXNzICE9PSBvQ29sLnNDbGFzcykge1xuXHRcdFx0b0NvbC5zQ2xhc3MgPSBvcmlnQ2xhc3MgKyAnICcgKyBvQ29sLnNDbGFzcztcblx0XHR9XG5cblx0XHQvKiBpRGF0YVNvcnQgdG8gYmUgYXBwbGllZCAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLCBidXQgYURhdGFTb3J0IHdpbGwgdGFrZVxuXHRcdCAqIHByaW9yaXR5IGlmIGRlZmluZWRcblx0XHQgKi9cblx0XHRpZiAoIG9PcHRpb25zLmlEYXRhU29ydCAhPT0gdW5kZWZpbmVkIClcblx0XHR7XG5cdFx0XHRvQ29sLmFEYXRhU29ydCA9IFsgb09wdGlvbnMuaURhdGFTb3J0IF07XG5cdFx0fVxuXHRcdF9mbk1hcCggb0NvbCwgb09wdGlvbnMsIFwiYURhdGFTb3J0XCIgKTtcblx0fVxuXG5cdC8qIENhY2hlIHRoZSBkYXRhIGdldCBhbmQgc2V0IGZ1bmN0aW9ucyBmb3Igc3BlZWQgKi9cblx0dmFyIG1EYXRhU3JjID0gb0NvbC5tRGF0YTtcblx0dmFyIG1EYXRhID0gX2ZuR2V0T2JqZWN0RGF0YUZuKCBtRGF0YVNyYyApO1xuXG5cdC8vIFRoZSBgcmVuZGVyYCBvcHRpb24gY2FuIGJlIGdpdmVuIGFzIGFuIGFycmF5IHRvIGFjY2VzcyB0aGUgaGVscGVyIHJlbmRlcmluZyBtZXRob2RzLlxuXHQvLyBUaGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgcmVuZGVyaW5nIG1ldGhvZCB0byB1c2UsIHRoZSByZXN0IGFyZSB0aGUgcGFyYW1ldGVycyB0byBwYXNzXG5cdGlmICggb0NvbC5tUmVuZGVyICYmIEFycmF5LmlzQXJyYXkoIG9Db2wubVJlbmRlciApICkge1xuXHRcdHZhciBjb3B5ID0gb0NvbC5tUmVuZGVyLnNsaWNlKCk7XG5cdFx0dmFyIG5hbWUgPSBjb3B5LnNoaWZ0KCk7XG5cblx0XHRvQ29sLm1SZW5kZXIgPSBEYXRhVGFibGUucmVuZGVyW25hbWVdLmFwcGx5KHdpbmRvdywgY29weSk7XG5cdH1cblxuXHRvQ29sLl9yZW5kZXIgPSBvQ29sLm1SZW5kZXIgPyBfZm5HZXRPYmplY3REYXRhRm4oIG9Db2wubVJlbmRlciApIDogbnVsbDtcblxuXHR2YXIgYXR0clRlc3QgPSBmdW5jdGlvbiggc3JjICkge1xuXHRcdHJldHVybiB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyAmJiBzcmMuaW5kZXhPZignQCcpICE9PSAtMTtcblx0fTtcblx0b0NvbC5fYkF0dHJTcmMgPSAkLmlzUGxhaW5PYmplY3QoIG1EYXRhU3JjICkgJiYgKFxuXHRcdGF0dHJUZXN0KG1EYXRhU3JjLnNvcnQpIHx8IGF0dHJUZXN0KG1EYXRhU3JjLnR5cGUpIHx8IGF0dHJUZXN0KG1EYXRhU3JjLmZpbHRlcilcblx0KTtcblx0b0NvbC5fc2V0dGVyID0gbnVsbDtcblxuXHRvQ29sLmZuR2V0RGF0YSA9IGZ1bmN0aW9uIChyb3dEYXRhLCB0eXBlLCBtZXRhKSB7XG5cdFx0dmFyIGlubmVyRGF0YSA9IG1EYXRhKCByb3dEYXRhLCB0eXBlLCB1bmRlZmluZWQsIG1ldGEgKTtcblxuXHRcdHJldHVybiBvQ29sLl9yZW5kZXIgJiYgdHlwZSA/XG5cdFx0XHRvQ29sLl9yZW5kZXIoIGlubmVyRGF0YSwgdHlwZSwgcm93RGF0YSwgbWV0YSApIDpcblx0XHRcdGlubmVyRGF0YTtcblx0fTtcblx0b0NvbC5mblNldERhdGEgPSBmdW5jdGlvbiAoIHJvd0RhdGEsIHZhbCwgbWV0YSApIHtcblx0XHRyZXR1cm4gX2ZuU2V0T2JqZWN0RGF0YUZuKCBtRGF0YVNyYyApKCByb3dEYXRhLCB2YWwsIG1ldGEgKTtcblx0fTtcblxuXHQvLyBJbmRpY2F0ZSBpZiBEYXRhVGFibGVzIHNob3VsZCByZWFkIERPTSBkYXRhIGFzIGFuIG9iamVjdCBvciBhcnJheVxuXHQvLyBVc2VkIGluIF9mbkdldFJvd0VsZW1lbnRzXG5cdGlmICggdHlwZW9mIG1EYXRhU3JjICE9PSAnbnVtYmVyJyAmJiAhIG9Db2wuX2lzQXJyYXlIb3N0ICkge1xuXHRcdG9TZXR0aW5ncy5fcm93UmVhZE9iamVjdCA9IHRydWU7XG5cdH1cblxuXHQvKiBGZWF0dXJlIHNvcnRpbmcgb3ZlcnJpZGVzIGNvbHVtbiBzcGVjaWZpYyB3aGVuIG9mZiAqL1xuXHRpZiAoICFvU2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0IClcblx0e1xuXHRcdG9Db2wuYlNvcnRhYmxlID0gZmFsc2U7XG5cdH1cbn1cblxuXG4vKipcbiAqIEFkanVzdCB0aGUgdGFibGUgY29sdW1uIHdpZHRocyBmb3IgbmV3IGRhdGEuIE5vdGU6IHlvdSB3b3VsZCBwcm9iYWJseSB3YW50IHRvXG4gKiBkbyBhIHJlZHJhdyBhZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24hXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkFkanVzdENvbHVtblNpemluZyAoIHNldHRpbmdzIClcbntcblx0X2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzKCBzZXR0aW5ncyApO1xuXHRfZm5Db2x1bW5TaXplcyggc2V0dGluZ3MgKTtcblxuXHR2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcblx0aWYgKCBzY3JvbGwuc1kgIT09ICcnIHx8IHNjcm9sbC5zWCAhPT0gJycpIHtcblx0XHRfZm5TY3JvbGxEcmF3KCBzZXR0aW5ncyApO1xuXHR9XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ2NvbHVtbi1zaXppbmcnLCBbc2V0dGluZ3NdICk7XG59XG5cbi8qKlxuICogQXBwbHkgY29sdW1uIHNpemVzXG4gKlxuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICovXG5mdW5jdGlvbiBfZm5Db2x1bW5TaXplcyAoIHNldHRpbmdzIClcbntcblx0dmFyIGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cblx0Zm9yICh2YXIgaT0wIDsgaTxjb2xzLmxlbmd0aCA7IGkrKykge1xuXHRcdHZhciB3aWR0aCA9IF9mbkNvbHVtbnNTdW1XaWR0aChzZXR0aW5ncywgW2ldLCBmYWxzZSwgZmFsc2UpO1xuXG5cdFx0Y29sc1tpXS5jb2xFbC5jc3MoJ3dpZHRoJywgd2lkdGgpO1xuXG5cdFx0aWYgKHNldHRpbmdzLm9TY3JvbGwuc1gpIHtcblx0XHRcdGNvbHNbaV0uY29sRWwuY3NzKCdtaW4td2lkdGgnLCB3aWR0aCk7XG5cdFx0fVxuXHR9XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBpbmRleCBvZiBhIHZpc2libGUgY29sdW1uIHRvIHRoZSBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSAodGFrZSBhY2NvdW50XG4gKiBvZiBoaWRkZW4gY29sdW1ucylcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBWaXNpYmxlIGNvbHVtbiBpbmRleCB0byBsb29rdXBcbiAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBvU2V0dGluZ3MsIGlNYXRjaCApXG57XG5cdHZhciBhaVZpcyA9IF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgJ2JWaXNpYmxlJyApO1xuXG5cdHJldHVybiB0eXBlb2YgYWlWaXNbaU1hdGNoXSA9PT0gJ251bWJlcicgP1xuXHRcdGFpVmlzW2lNYXRjaF0gOlxuXHRcdG51bGw7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBpbmRleCBvZiBhbiBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSBhbmQgY29udmVydCBpdCB0byB0aGUgdmlzaWJsZVxuICogICBjb2x1bW4gaW5kZXggKHRha2UgYWNjb3VudCBvZiBoaWRkZW4gY29sdW1ucylcbiAqICBAcGFyYW0ge2ludH0gaU1hdGNoIENvbHVtbiBpbmRleCB0byBsb29rdXBcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHJldHVybnMge2ludH0gaSB0aGUgZGF0YSBpbmRleFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggb1NldHRpbmdzLCBpTWF0Y2ggKVxue1xuXHR2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKTtcblx0dmFyIGlQb3MgPSBhaVZpcy5pbmRleE9mKGlNYXRjaCk7XG5cblx0cmV0dXJuIGlQb3MgIT09IC0xID8gaVBvcyA6IG51bGw7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHJldHVybnMge2ludH0gaSB0aGUgbnVtYmVyIG9mIHZpc2libGUgY29sdW1uc1xuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5WaXNibGVDb2x1bW5zKCBzZXR0aW5ncyApXG57XG5cdHZhciBsYXlvdXQgPSBzZXR0aW5ncy5hb0hlYWRlcjtcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHZhciB2aXMgPSAwO1xuXG5cdGlmICggbGF5b3V0Lmxlbmd0aCApIHtcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49bGF5b3V0WzBdLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBjb2x1bW5zW2ldLmJWaXNpYmxlICYmICQobGF5b3V0WzBdW2ldLmNlbGwpLmNzcygnZGlzcGxheScpICE9PSAnbm9uZScgKSB7XG5cdFx0XHRcdHZpcysrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2aXM7XG59XG5cblxuLyoqXG4gKiBHZXQgYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgdGhhdCBtYXRjaCBhIGdpdmVuIHByb3BlcnR5XG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7c3RyaW5nfSBzUGFyYW0gUGFyYW1ldGVyIGluIGFvQ29sdW1ucyB0byBsb29rIGZvciAtIHR5cGljYWxseVxuICogICAgYlZpc2libGUgb3IgYlNlYXJjaGFibGVcbiAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGluZGV4ZXMgd2l0aCBtYXRjaGVkIHByb3BlcnRpZXNcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuR2V0Q29sdW1ucyggb1NldHRpbmdzLCBzUGFyYW0gKVxue1xuXHR2YXIgYSA9IFtdO1xuXG5cdG9TZXR0aW5ncy5hb0NvbHVtbnMubWFwKCBmdW5jdGlvbih2YWwsIGkpIHtcblx0XHRpZiAoIHZhbFtzUGFyYW1dICkge1xuXHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0cmV0dXJuIGE7XG59XG5cbi8qKlxuICogQWxsb3cgdGhlIHJlc3VsdCBmcm9tIGEgdHlwZSBkZXRlY3Rpb24gZnVuY3Rpb24gdG8gYmUgYHRydWVgIHdoaWxlXG4gKiB0cmFuc2xhdGluZyB0aGF0IGludG8gYSBzdHJpbmcuIE9sZCB0eXBlIGRldGVjdGlvbiBmdW5jdGlvbnMgd2lsbFxuICogcmV0dXJuIHRoZSB0eXBlIG5hbWUgaWYgaXQgcGFzc2VzLiBBbiBvYmVjdCBzdG9yZSB3b3VsZCBiZSBiZXR0ZXIsXG4gKiBidXQgbm90IGJhY2t3YXJkcyBjb21wYXRpYmxlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZURldGVjdCBPYmplY3Qgb3IgZnVuY3Rpb24gZm9yIHR5cGUgZGV0ZWN0aW9uXG4gKiBAcGFyYW0geyp9IHJlcyBSZXN1bHQgZnJvbSB0aGUgdHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25cbiAqIEByZXR1cm5zIFR5cGUgbmFtZSBvciBmYWxzZVxuICovXG5mdW5jdGlvbiBfdHlwZVJlc3VsdCAodHlwZURldGVjdCwgcmVzKSB7XG5cdHJldHVybiByZXMgPT09IHRydWVcblx0XHQ/IHR5cGVEZXRlY3QuX25hbWVcblx0XHQ6IHJlcztcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlICd0eXBlJyBvZiBhIGNvbHVtblxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Db2x1bW5UeXBlcyAoIHNldHRpbmdzIClcbntcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHR2YXIgdHlwZXMgPSBEYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0O1xuXHR2YXIgaSwgaWVuLCBqLCBqZW4sIGssIGtlbjtcblx0dmFyIGNvbCwgZGV0ZWN0ZWRUeXBlLCBjYWNoZTtcblxuXHQvLyBGb3IgZWFjaCBjb2x1bW4sIHNwaW4gb3ZlciB0aGUgZGF0YSB0eXBlIGRldGVjdGlvbiBmdW5jdGlvbnMsIHNlZWluZyBpZiBvbmUgbWF0Y2hlc1xuXHRmb3IgKCBpPTAsIGllbj1jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdGNvbCA9IGNvbHVtbnNbaV07XG5cdFx0Y2FjaGUgPSBbXTtcblxuXHRcdGlmICggISBjb2wuc1R5cGUgJiYgY29sLl9zTWFudWFsVHlwZSApIHtcblx0XHRcdGNvbC5zVHlwZSA9IGNvbC5fc01hbnVhbFR5cGU7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhIGNvbC5zVHlwZSApIHtcblx0XHRcdC8vIFdpdGggU1NQIHR5cGUgZGV0ZWN0aW9uIGNhbiBiZSB1bnJlbGlhYmxlIGFuZCBlcnJvciBwcm9uZSwgc28gd2UgcHJvdmlkZSBhIHdheVxuXHRcdFx0Ly8gdG8gdHVybiBpdCBvZmYuXG5cdFx0XHRpZiAoISBzZXR0aW5ncy50eXBlRGV0ZWN0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaj0wLCBqZW49dHlwZXMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdHZhciB0eXBlRGV0ZWN0ID0gdHlwZXNbal07XG5cblx0XHRcdFx0Ly8gVGhlcmUgY2FuIGJlIGVpdGhlciBvbmUsIG9yIHRocmVlIHR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9uc1xuXHRcdFx0XHR2YXIgb25lT2YgPSB0eXBlRGV0ZWN0Lm9uZU9mO1xuXHRcdFx0XHR2YXIgYWxsT2YgPSB0eXBlRGV0ZWN0LmFsbE9mIHx8IHR5cGVEZXRlY3Q7XG5cdFx0XHRcdHZhciBpbml0ID0gdHlwZURldGVjdC5pbml0O1xuXHRcdFx0XHR2YXIgb25lID0gZmFsc2U7XG5cblx0XHRcdFx0ZGV0ZWN0ZWRUeXBlID0gbnVsbDtcblxuXHRcdFx0XHQvLyBGYXN0IGRldGVjdCBiYXNlZCBvbiBjb2x1bW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoaW5pdCkge1xuXHRcdFx0XHRcdGRldGVjdGVkVHlwZSA9IF90eXBlUmVzdWx0KHR5cGVEZXRlY3QsIGluaXQoc2V0dGluZ3MsIGNvbCwgaSkpO1xuXG5cdFx0XHRcdFx0aWYgKGRldGVjdGVkVHlwZSkge1xuXHRcdFx0XHRcdFx0Y29sLnNUeXBlID0gZGV0ZWN0ZWRUeXBlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggaz0wLCBrZW49ZGF0YS5sZW5ndGggOyBrPGtlbiA7IGsrKyApIHtcblx0XHRcdFx0XHRpZiAoISBkYXRhW2tdKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBVc2UgYSBjYWNoZSBhcnJheSBzbyB3ZSBvbmx5IG5lZWQgdG8gZ2V0IHRoZSB0eXBlIGRhdGFcblx0XHRcdFx0XHQvLyBmcm9tIHRoZSBmb3JtYXR0ZXIgb25jZSAod2hlbiB1c2luZyBtdWx0aXBsZSBkZXRlY3RvcnMpXG5cdFx0XHRcdFx0aWYgKCBjYWNoZVtrXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0Y2FjaGVba10gPSBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIGssIGksICd0eXBlJyApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgb25lIGRhdGEgcG9pbnQgaW4gdGhlIGNvbHVtbiBuZWVkcyB0byBtYXRjaCB0aGlzIGZ1bmN0aW9uXG5cdFx0XHRcdFx0aWYgKG9uZU9mICYmICEgb25lKSB7XG5cdFx0XHRcdFx0XHRvbmUgPSBfdHlwZVJlc3VsdCh0eXBlRGV0ZWN0LCBvbmVPZiggY2FjaGVba10sIHNldHRpbmdzICkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFsbCBkYXRhIHBvaW50cyBuZWVkIHRvIG1hdGNoIHRoaXMgZnVuY3Rpb25cblx0XHRcdFx0XHRkZXRlY3RlZFR5cGUgPSBfdHlwZVJlc3VsdCh0eXBlRGV0ZWN0LCBhbGxPZiggY2FjaGVba10sIHNldHRpbmdzICkpO1xuXG5cdFx0XHRcdFx0Ly8gSWYgbnVsbCwgdGhlbiB0aGlzIHR5cGUgY2FuJ3QgYXBwbHkgdG8gdGhpcyBjb2x1bW4sIHNvXG5cdFx0XHRcdFx0Ly8gcmF0aGVyIHRoYW4gdGVzdGluZyBhbGwgY2VsbHMsIGJyZWFrIG91dC4gVGhlcmUgaXMgYW5cblx0XHRcdFx0XHQvLyBleGNlcHRpb24gZm9yIHRoZSBsYXN0IHR5cGUgd2hpY2ggaXMgYGh0bWxgLiBXZSBuZWVkIHRvXG5cdFx0XHRcdFx0Ly8gc2NhbiBhbGwgcm93cyBzaW5jZSBpdCBpcyBwb3NzaWJsZSB0byBtaXggc3RyaW5nIGFuZCBIVE1MXG5cdFx0XHRcdFx0Ly8gdHlwZXNcblx0XHRcdFx0XHRpZiAoICEgZGV0ZWN0ZWRUeXBlICYmIGogIT09IHR5cGVzLmxlbmd0aC0zICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhIHNpbmdsZSBtYXRjaCBpcyBuZWVkZWQgZm9yIGh0bWwgdHlwZSBzaW5jZSBpdCBpc1xuXHRcdFx0XHRcdC8vIGJvdHRvbSBvZiB0aGUgcGlsZSBhbmQgdmVyeSBzaW1pbGFyIHRvIHN0cmluZyAtIGJ1dCBpdFxuXHRcdFx0XHRcdC8vIG11c3Qgbm90IGJlIGVtcHR5XG5cdFx0XHRcdFx0aWYgKCBkZXRlY3RlZFR5cGUgPT09ICdodG1sJyAmJiAhIF9lbXB0eShjYWNoZVtrXSkgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIGlzIHZhbGlkIGZvciBhbGwgZGF0YSBwb2ludHMgaW4gdGhlIGNvbHVtbiAtIHVzZSB0aGlzXG5cdFx0XHRcdC8vIHR5cGVcblx0XHRcdFx0aWYgKCAob25lT2YgJiYgb25lICYmIGRldGVjdGVkVHlwZSkgfHwgKCFvbmVPZiAmJiBkZXRlY3RlZFR5cGUpICkge1xuXHRcdFx0XHRcdGNvbC5zVHlwZSA9IGRldGVjdGVkVHlwZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGYWxsIGJhY2sgLSBpZiBubyB0eXBlIHdhcyBkZXRlY3RlZCwgYWx3YXlzIHVzZSBzdHJpbmdcblx0XHRcdGlmICggISBjb2wuc1R5cGUgKSB7XG5cdFx0XHRcdGNvbC5zVHlwZSA9ICdzdHJpbmcnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCBjbGFzcyBuYW1lcyBmb3IgaGVhZGVyIC8gZm9vdGVyIGZvciBhdXRvIHR5cGUgY2xhc3Nlc1xuXHRcdHZhciBhdXRvQ2xhc3MgPSBfZXh0LnR5cGUuY2xhc3NOYW1lW2NvbC5zVHlwZV07XG5cblx0XHRpZiAoYXV0b0NsYXNzKSB7XG5cdFx0XHRfY29sdW1uQXV0b0NsYXNzKHNldHRpbmdzLmFvSGVhZGVyLCBpLCBhdXRvQ2xhc3MpO1xuXHRcdFx0X2NvbHVtbkF1dG9DbGFzcyhzZXR0aW5ncy5hb0Zvb3RlciwgaSwgYXV0b0NsYXNzKTtcblx0XHR9XG5cblx0XHR2YXIgcmVuZGVyZXIgPSBfZXh0LnR5cGUucmVuZGVyW2NvbC5zVHlwZV07XG5cblx0XHQvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiBvbmNlISBUaGVyZSBpcyBubyB3YXkgdG8gcmVtb3ZlXG5cdFx0Ly8gYSByZW5kZXJlci4gQWZ0ZXIgdGhlIGZpcnN0IHRpbWUgdGhlIHJlbmRlcmVyIGhhc1xuXHRcdC8vIGFscmVhZHkgYmVlbiBzZXQgc28gY3JlYXRlVHIgd2lsbCBydW4gdGhlIHJlbmRlcmVyIGl0c2VsZi5cblx0XHRpZiAocmVuZGVyZXIgJiYgISBjb2wuX3JlbmRlcikge1xuXHRcdFx0Y29sLl9yZW5kZXIgPSBEYXRhVGFibGUudXRpbC5nZXQocmVuZGVyZXIpO1xuXG5cdFx0XHRfY29sdW1uQXV0b1JlbmRlcihzZXR0aW5ncywgaSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQXBwbHkgYW4gYXV0byBkZXRlY3RlZCByZW5kZXJlciB0byBkYXRhIHdoaWNoIGRvZXNuJ3QgeWV0IGhhdmVcbiAqIGEgcmVuZGVyZXJcbiAqL1xuZnVuY3Rpb24gX2NvbHVtbkF1dG9SZW5kZXIoc2V0dGluZ3MsIGNvbElkeCkge1xuXHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblxuXHRmb3IgKHZhciBpPTAgOyBpPGRhdGEubGVuZ3RoIDsgaSsrKSB7XG5cdFx0aWYgKGRhdGFbaV0ublRyKSB7XG5cdFx0XHQvLyBXZSBoYXZlIHRvIHVwZGF0ZSB0aGUgZGlzcGxheSBoZXJlIHNpbmNlIHRoZXJlIGlzIG5vXG5cdFx0XHQvLyBpbnZhbGlkYXRpb24gY2hlY2sgZm9yIHRoZSBkYXRhXG5cdFx0XHR2YXIgZGlzcGxheSA9IF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgaSwgY29sSWR4LCAnZGlzcGxheScgKTtcblxuXHRcdFx0ZGF0YVtpXS5kaXNwbGF5RGF0YVtjb2xJZHhdID0gZGlzcGxheTtcblx0XHRcdF9mbldyaXRlQ2VsbChkYXRhW2ldLmFuQ2VsbHNbY29sSWR4XSwgZGlzcGxheSk7XG5cblx0XHRcdC8vIE5vIG5lZWQgdG8gdXBkYXRlIHNvcnQgLyBmaWx0ZXIgZGF0YSBzaW5jZSBpdCBoYXNcblx0XHRcdC8vIGJlZW4gaW52YWxpZGF0ZWQgYW5kIHdpbGwgYmUgcmUtcmVhZCB3aXRoIHRoZVxuXHRcdFx0Ly8gcmVuZGVyZXIgbm93IGFwcGxpZWRcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBBcHBseSBhIGNsYXNzIG5hbWUgdG8gYSBjb2x1bW4ncyBoZWFkZXIgY2VsbHNcbiAqL1xuZnVuY3Rpb24gX2NvbHVtbkF1dG9DbGFzcyhjb250YWluZXIsIGNvbElkeCwgY2xhc3NOYW1lKSB7XG5cdGNvbnRhaW5lci5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcblx0XHRpZiAocm93W2NvbElkeF0gJiYgcm93W2NvbElkeF0udW5pcXVlKSB7XG5cdFx0XHRfYWRkQ2xhc3Mocm93W2NvbElkeF0uY2VsbCwgY2xhc3NOYW1lKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIFRha2UgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyBhbmQgc3RhdGljIGNvbHVtbnMgYXJyYXlzIGFuZCBjYWxjdWxhdGUgaG93XG4gKiB0aGV5IHJlbGF0ZSB0byBjb2x1bW4gaW5kZXhlcy4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgdGhlbiBhcHBseSB0aGVcbiAqIGRlZmluaXRpb24gZm91bmQgZm9yIGEgY29sdW1uIHRvIGEgc3VpdGFibGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7YXJyYXl9IGFvQ29sRGVmcyBUaGUgYW9Db2x1bW5EZWZzIGFycmF5IHRoYXQgaXMgdG8gYmUgYXBwbGllZFxuICogIEBwYXJhbSB7YXJyYXl9IGFvQ29scyBUaGUgYW9Db2x1bW5zIGFycmF5IHRoYXQgZGVmaW5lcyBjb2x1bW5zIGluZGl2aWR1YWxseVxuICogIEBwYXJhbSB7YXJyYXl9IGhlYWRlckxheW91dCBMYXlvdXQgZm9yIGhlYWRlciBhcyBpdCB3YXMgbG9hZGVkXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gLSB0YWtlcyB0d28gcGFyYW1ldGVycywgdGhlIGNhbGN1bGF0ZWRcbiAqICAgIGNvbHVtbiBpbmRleCBhbmQgdGhlIGRlZmluaXRpb24gZm9yIHRoYXQgY29sdW1uLlxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5BcHBseUNvbHVtbkRlZnMoIG9TZXR0aW5ncywgYW9Db2xEZWZzLCBhb0NvbHMsIGhlYWRlckxheW91dCwgZm4gKVxue1xuXHR2YXIgaSwgaUxlbiwgaiwgakxlbiwgaywga0xlbiwgZGVmO1xuXHR2YXIgY29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnM7XG5cblx0aWYgKCBhb0NvbHMgKSB7XG5cdFx0Zm9yICggaT0wLCBpTGVuPWFvQ29scy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoYW9Db2xzW2ldICYmIGFvQ29sc1tpXS5uYW1lKSB7XG5cdFx0XHRcdGNvbHVtbnNbaV0uc05hbWUgPSBhb0NvbHNbaV0ubmFtZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb2x1bW4gZGVmaW5pdGlvbnMgd2l0aCBhVGFyZ2V0c1xuXHRpZiAoIGFvQ29sRGVmcyApXG5cdHtcblx0XHQvKiBMb29wIG92ZXIgdGhlIGRlZmluaXRpb25zIGFycmF5IC0gbG9vcCBpbiByZXZlcnNlIHNvIGZpcnN0IGluc3RhbmNlIGhhcyBwcmlvcml0eSAqL1xuXHRcdGZvciAoIGk9YW9Db2xEZWZzLmxlbmd0aC0xIDsgaT49MCA7IGktLSApXG5cdFx0e1xuXHRcdFx0ZGVmID0gYW9Db2xEZWZzW2ldO1xuXG5cdFx0XHQvKiBFYWNoIGRlZmluaXRpb24gY2FuIHRhcmdldCBtdWx0aXBsZSBjb2x1bW5zLCBhcyBpdCBpcyBhbiBhcnJheSAqL1xuXHRcdFx0dmFyIGFUYXJnZXRzID0gZGVmLnRhcmdldCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdD8gZGVmLnRhcmdldFxuXHRcdFx0XHQ6IGRlZi50YXJnZXRzICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHQ/IGRlZi50YXJnZXRzXG5cdFx0XHRcdFx0OiBkZWYuYVRhcmdldHM7XG5cblx0XHRcdGlmICggISBBcnJheS5pc0FycmF5KCBhVGFyZ2V0cyApIClcblx0XHRcdHtcblx0XHRcdFx0YVRhcmdldHMgPSBbIGFUYXJnZXRzIF07XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGo9MCwgakxlbj1hVGFyZ2V0cy5sZW5ndGggOyBqPGpMZW4gOyBqKysgKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gYVRhcmdldHNbal07XG5cblx0XHRcdFx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJyAmJiB0YXJnZXQgPj0gMCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvKiBBZGQgY29sdW1ucyB0aGF0IHdlIGRvbid0IHlldCBrbm93IGFib3V0ICovXG5cdFx0XHRcdFx0d2hpbGUoIGNvbHVtbnMubGVuZ3RoIDw9IHRhcmdldCApXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0X2ZuQWRkQ29sdW1uKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBJbnRlZ2VyLCBiYXNpYyBpbmRleCAqL1xuXHRcdFx0XHRcdGZuKCB0YXJnZXQsIGRlZiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJyAmJiB0YXJnZXQgPCAwIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdC8qIE5lZ2F0aXZlIGludGVnZXIsIHJpZ2h0IHRvIGxlZnQgY29sdW1uIGNvdW50aW5nICovXG5cdFx0XHRcdFx0Zm4oIGNvbHVtbnMubGVuZ3RoK3RhcmdldCwgZGVmICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAoIGs9MCwga0xlbj1jb2x1bW5zLmxlbmd0aCA7IGs8a0xlbiA7IGsrKyApIHtcblx0XHRcdFx0XHRcdGlmICh0YXJnZXQgPT09ICdfYWxsJykge1xuXHRcdFx0XHRcdFx0XHQvLyBBcHBseSB0byBhbGwgY29sdW1uc1xuXHRcdFx0XHRcdFx0XHRmbiggaywgZGVmICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICh0YXJnZXQuaW5kZXhPZignOm5hbWUnKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ29sdW1uIHNlbGVjdG9yXG5cdFx0XHRcdFx0XHRcdGlmIChjb2x1bW5zW2tdLnNOYW1lID09PSB0YXJnZXQucmVwbGFjZSgnOm5hbWUnLCAnJykpIHtcblx0XHRcdFx0XHRcdFx0XHRmbiggaywgZGVmICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBDZWxsIHNlbGVjdG9yXG5cdFx0XHRcdFx0XHRcdGhlYWRlckxheW91dC5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAocm93W2tdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgY2VsbCA9ICQocm93W2tdLmNlbGwpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBMZWdhY3kgc3VwcG9ydC4gTm90ZSB0aGF0IGl0IG1lYW5zIHRoYXQgd2UgZG9uJ3Qgc3VwcG9ydFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW4gZWxlbWVudCBuYW1lIHNlbGVjdG9yIG9ubHksIHNpbmNlIHRoZXkgYXJlIHRyZWF0ZWQgYXNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGNsYXNzIG5hbWVzIGZvciAxLnggY29tcGF0LlxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRhcmdldC5tYXRjaCgvXlthLXpdW1xcdy1dKiQvaSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gJy4nICsgdGFyZ2V0O1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoY2VsbC5pcyggdGFyZ2V0ICkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4oIGssIGRlZiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU3RhdGljYWxseSBkZWZpbmVkIGNvbHVtbnMgYXJyYXlcblx0aWYgKCBhb0NvbHMgKSB7XG5cdFx0Zm9yICggaT0wLCBpTGVuPWFvQ29scy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRmbiggaSwgYW9Db2xzW2ldICk7XG5cdFx0fVxuXHR9XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIHdpZHRoIGZvciBhIGdpdmVuIHNldCBvZiBjb2x1bW5zXG4gKlxuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHsqfSB0YXJnZXRzIENvbHVtbnMgLSBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIG9yIGFycmF5IG9mIG51bWJlcnNcbiAqIEBwYXJhbSB7Kn0gb3JpZ2luYWwgVXNlIHRoZSBvcmlnaW5hbCB3aWR0aCAodHJ1ZSkgb3IgY2FsY3VsYXRlZCAoZmFsc2UpXG4gKiBAcGFyYW0geyp9IGluY1Zpc2libGUgSW5jbHVkZSB2aXNpYmxlIGNvbHVtbnMgKHRydWUpIG9yIG5vdCAoZmFsc2UpXG4gKiBAcmV0dXJucyBDb21iaW5lZCBDU1MgdmFsdWVcbiAqL1xuZnVuY3Rpb24gX2ZuQ29sdW1uc1N1bVdpZHRoKCBzZXR0aW5ncywgdGFyZ2V0cywgb3JpZ2luYWwsIGluY1Zpc2libGUgKSB7XG5cdGlmICggISBBcnJheS5pc0FycmF5KCB0YXJnZXRzICkgKSB7XG5cdFx0dGFyZ2V0cyA9IF9mbkNvbHVtbnNGcm9tSGVhZGVyKCB0YXJnZXRzICk7XG5cdH1cblxuXHR2YXIgc3VtID0gMDtcblx0dmFyIHVuaXQ7XG5cdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRcblx0Zm9yICggdmFyIGk9MCwgaWVuPXRhcmdldHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0dmFyIGNvbHVtbiA9IGNvbHVtbnNbIHRhcmdldHNbaV0gXTtcblx0XHR2YXIgZGVmaW5lZFdpZHRoID0gb3JpZ2luYWwgP1xuXHRcdFx0Y29sdW1uLnNXaWR0aE9yaWcgOlxuXHRcdFx0Y29sdW1uLnNXaWR0aDtcblxuXHRcdGlmICggISBpbmNWaXNpYmxlICYmIGNvbHVtbi5iVmlzaWJsZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIGRlZmluZWRXaWR0aCA9PT0gbnVsbCB8fCBkZWZpbmVkV2lkdGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiBudWxsOyAvLyBjYW4ndCBkZXRlcm1pbmUgYSBkZWZpbmVkIHdpZHRoIC0gYnJvd3NlciBkZWZpbmVkXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lZFdpZHRoID09PSAnbnVtYmVyJyApIHtcblx0XHRcdHVuaXQgPSAncHgnO1xuXHRcdFx0c3VtICs9IGRlZmluZWRXaWR0aDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgbWF0Y2hlZCA9IGRlZmluZWRXaWR0aC5tYXRjaCgvKFtcXGRcXC5dKykoW15cXGRdKikvKTtcblxuXHRcdFx0aWYgKCBtYXRjaGVkICkge1xuXHRcdFx0XHRzdW0gKz0gbWF0Y2hlZFsxXSAqIDE7XG5cdFx0XHRcdHVuaXQgPSBtYXRjaGVkLmxlbmd0aCA9PT0gMyA/XG5cdFx0XHRcdFx0bWF0Y2hlZFsyXSA6XG5cdFx0XHRcdFx0J3B4Jztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3VtICsgdW5pdDtcbn1cblxuZnVuY3Rpb24gX2ZuQ29sdW1uc0Zyb21IZWFkZXIoIGNlbGwgKVxue1xuXHR2YXIgYXR0ciA9ICQoY2VsbCkuY2xvc2VzdCgnW2RhdGEtZHQtY29sdW1uXScpLmF0dHIoJ2RhdGEtZHQtY29sdW1uJyk7XG5cblx0aWYgKCAhIGF0dHIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0cmV0dXJuIGF0dHIuc3BsaXQoJywnKS5tYXAoIGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdmFsICogMTtcblx0fSApO1xufVxuLyoqXG4gKiBBZGQgYSBkYXRhIGFycmF5IHRvIHRoZSB0YWJsZSwgY3JlYXRpbmcgRE9NIG5vZGUgZXRjLiBUaGlzIGlzIHRoZSBwYXJhbGxlbCB0b1xuICogX2ZuR2F0aGVyRGF0YSwgYnV0IGZvciBhZGRpbmcgcm93cyBmcm9tIGEgSmF2YXNjcmlwdCBzb3VyY2UsIHJhdGhlciB0aGFuIGFcbiAqIERPTSBzb3VyY2UuXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHthcnJheX0gZGF0YSBkYXRhIGFycmF5IHRvIGJlIGFkZGVkXG4gKiAgQHBhcmFtIHtub2RlfSBbdHJdIFRSIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB0YWJsZSAtIG9wdGlvbmFsLiBJZiBub3QgZ2l2ZW4sXG4gKiAgICBEYXRhVGFibGVzIHdpbGwgY3JlYXRlIGEgcm93IGF1dG9tYXRpY2FsbHlcbiAqICBAcGFyYW0ge2FycmF5fSBbdGRzXSBBcnJheSBvZiBURHxUSCBlbGVtZW50cyBmb3IgdGhlIHJvdyAtIG11c3QgYmUgZ2l2ZW5cbiAqICAgIGlmIG5UciBpcy5cbiAqICBAcmV0dXJucyB7aW50fSA+PTAgaWYgc3VjY2Vzc2Z1bCAoaW5kZXggb2YgbmV3IGFvRGF0YSBlbnRyeSksIC0xIGlmIGZhaWxlZFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5BZGREYXRhICggc2V0dGluZ3MsIGRhdGFJbiwgdHIsIHRkcyApXG57XG5cdC8qIENyZWF0ZSB0aGUgb2JqZWN0IGZvciBzdG9yaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgbmV3IHJvdyAqL1xuXHR2YXIgcm93SWR4ID0gc2V0dGluZ3MuYW9EYXRhLmxlbmd0aDtcblx0dmFyIHJvd01vZGVsID0gJC5leHRlbmQoIHRydWUsIHt9LCBEYXRhVGFibGUubW9kZWxzLm9Sb3csIHtcblx0XHRzcmM6IHRyID8gJ2RvbScgOiAnZGF0YScsXG5cdFx0aWR4OiByb3dJZHhcblx0fSApO1xuXG5cdHJvd01vZGVsLl9hRGF0YSA9IGRhdGFJbjtcblx0c2V0dGluZ3MuYW9EYXRhLnB1c2goIHJvd01vZGVsICk7XG5cblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cblx0Zm9yICggdmFyIGk9MCwgaUxlbj1jb2x1bW5zLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApXG5cdHtcblx0XHQvLyBJbnZhbGlkYXRlIHRoZSBjb2x1bW4gdHlwZXMgYXMgdGhlIG5ldyBkYXRhIG5lZWRzIHRvIGJlIHJldmFsaWRhdGVkXG5cdFx0Y29sdW1uc1tpXS5zVHlwZSA9IG51bGw7XG5cdH1cblxuXHQvKiBBZGQgdG8gdGhlIGRpc3BsYXkgYXJyYXkgKi9cblx0c2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnB1c2goIHJvd0lkeCApO1xuXG5cdHZhciBpZCA9IHNldHRpbmdzLnJvd0lkRm4oIGRhdGFJbiApO1xuXHRpZiAoIGlkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0c2V0dGluZ3MuYUlkc1sgaWQgXSA9IHJvd01vZGVsO1xuXHR9XG5cblx0LyogQ3JlYXRlIHRoZSBET00gaW5mb3JtYXRpb24sIG9yIHJlZ2lzdGVyIGl0IGlmIGFscmVhZHkgcHJlc2VudCAqL1xuXHRpZiAoIHRyIHx8ICEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJEZWZlclJlbmRlciApXG5cdHtcblx0XHRfZm5DcmVhdGVUciggc2V0dGluZ3MsIHJvd0lkeCwgdHIsIHRkcyApO1xuXHR9XG5cblx0cmV0dXJuIHJvd0lkeDtcbn1cblxuXG4vKipcbiAqIEFkZCBvbmUgb3IgbW9yZSBUUiBlbGVtZW50cyB0byB0aGUgdGFibGUuIEdlbmVyYWxseSB3ZSdkIGV4cGVjdCB0b1xuICogdXNlIHRoaXMgZm9yIHJlYWRpbmcgZGF0YSBmcm9tIGEgRE9NIHNvdXJjZWQgdGFibGUsIGJ1dCBpdCBjb3VsZCBiZVxuICogdXNlZCBmb3IgYW4gVFIgZWxlbWVudC4gTm90ZSB0aGF0IGlmIGEgVFIgaXMgZ2l2ZW4sIGl0IGlzIHVzZWQgKGkuZS5cbiAqIGl0IGlzIG5vdCBjbG9uZWQpLlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7YXJyYXl8bm9kZXxqUXVlcnl9IHRycyBUaGUgVFIgZWxlbWVudChzKSB0byBhZGQgdG8gdGhlIHRhYmxlXG4gKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBpbmRleGVzIGZvciB0aGUgYWRkZWQgcm93c1xuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5BZGRUciggc2V0dGluZ3MsIHRycyApXG57XG5cdHZhciByb3c7XG5cblx0Ly8gQWxsb3cgYW4gaW5kaXZpZHVhbCBub2RlIHRvIGJlIHBhc3NlZCBpblxuXHRpZiAoICEgKHRycyBpbnN0YW5jZW9mICQpICkge1xuXHRcdHRycyA9ICQodHJzKTtcblx0fVxuXG5cdHJldHVybiB0cnMubWFwKCBmdW5jdGlvbiAoaSwgZWwpIHtcblx0XHRyb3cgPSBfZm5HZXRSb3dFbGVtZW50cyggc2V0dGluZ3MsIGVsICk7XG5cdFx0cmV0dXJuIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cuZGF0YSwgZWwsIHJvdy5jZWxscyApO1xuXHR9ICk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRhdGEgZm9yIGEgZ2l2ZW4gY2VsbCBmcm9tIHRoZSBpbnRlcm5hbCBjYWNoZSwgdGFraW5nIGludG8gYWNjb3VudCBkYXRhIG1hcHBpbmdcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2ludH0gcm93SWR4IGFvRGF0YSByb3cgaWRcbiAqICBAcGFyYW0ge2ludH0gY29sSWR4IENvbHVtbiBpbmRleFxuICogIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGRhdGEgZ2V0IHR5cGUgKCdkaXNwbGF5JywgJ3R5cGUnICdmaWx0ZXJ8c2VhcmNoJyAnc29ydHxvcmRlcicpXG4gKiAgQHJldHVybnMgeyp9IENlbGwgZGF0YVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCB0eXBlIClcbntcblx0aWYgKHR5cGUgPT09ICdzZWFyY2gnKSB7XG5cdFx0dHlwZSA9ICdmaWx0ZXInO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGUgPT09ICdvcmRlcicpIHtcblx0XHR0eXBlID0gJ3NvcnQnO1xuXHR9XG5cblx0dmFyIHJvdyA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdO1xuXG5cdGlmICghIHJvdykge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHR2YXIgZHJhdyAgICAgICAgICAgPSBzZXR0aW5ncy5pRHJhdztcblx0dmFyIGNvbCAgICAgICAgICAgID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XG5cdHZhciByb3dEYXRhICAgICAgICA9IHJvdy5fYURhdGE7XG5cdHZhciBkZWZhdWx0Q29udGVudCA9IGNvbC5zRGVmYXVsdENvbnRlbnQ7XG5cdHZhciBjZWxsRGF0YSAgICAgICA9IGNvbC5mbkdldERhdGEoIHJvd0RhdGEsIHR5cGUsIHtcblx0XHRzZXR0aW5nczogc2V0dGluZ3MsXG5cdFx0cm93OiAgICAgIHJvd0lkeCxcblx0XHRjb2w6ICAgICAgY29sSWR4XG5cdH0gKTtcblxuXHQvLyBBbGxvdyBmb3IgYSBub2RlIGJlaW5nIHJldHVybmVkIGZvciBub24tZGlzcGxheSB0eXBlc1xuXHRpZiAodHlwZSAhPT0gJ2Rpc3BsYXknICYmIGNlbGxEYXRhICYmIHR5cGVvZiBjZWxsRGF0YSA9PT0gJ29iamVjdCcgJiYgY2VsbERhdGEubm9kZU5hbWUpIHtcblx0XHRjZWxsRGF0YSA9IGNlbGxEYXRhLmlubmVySFRNTDtcblx0fVxuXG5cdGlmICggY2VsbERhdGEgPT09IHVuZGVmaW5lZCApIHtcblx0XHRpZiAoIHNldHRpbmdzLmlEcmF3RXJyb3IgIT0gZHJhdyAmJiBkZWZhdWx0Q29udGVudCA9PT0gbnVsbCApIHtcblx0XHRcdF9mbkxvZyggc2V0dGluZ3MsIDAsIFwiUmVxdWVzdGVkIHVua25vd24gcGFyYW1ldGVyIFwiK1xuXHRcdFx0XHQodHlwZW9mIGNvbC5tRGF0YT09J2Z1bmN0aW9uJyA/ICd7ZnVuY3Rpb259JyA6IFwiJ1wiK2NvbC5tRGF0YStcIidcIikrXG5cdFx0XHRcdFwiIGZvciByb3cgXCIrcm93SWR4K1wiLCBjb2x1bW4gXCIrY29sSWR4LCA0ICk7XG5cdFx0XHRzZXR0aW5ncy5pRHJhd0Vycm9yID0gZHJhdztcblx0XHR9XG5cdFx0cmV0dXJuIGRlZmF1bHRDb250ZW50O1xuXHR9XG5cblx0Ly8gV2hlbiB0aGUgZGF0YSBzb3VyY2UgaXMgbnVsbCBhbmQgYSBzcGVjaWZpYyBkYXRhIHR5cGUgaXMgcmVxdWVzdGVkIChpLmUuXG5cdC8vIG5vdCB0aGUgb3JpZ2luYWwgZGF0YSksIHdlIGNhbiB1c2UgZGVmYXVsdCBjb2x1bW4gZGF0YVxuXHRpZiAoIChjZWxsRGF0YSA9PT0gcm93RGF0YSB8fCBjZWxsRGF0YSA9PT0gbnVsbCkgJiYgZGVmYXVsdENvbnRlbnQgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNlbGxEYXRhID0gZGVmYXVsdENvbnRlbnQ7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBjZWxsRGF0YSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHQvLyBJZiB0aGUgZGF0YSBzb3VyY2UgaXMgYSBmdW5jdGlvbiwgdGhlbiB3ZSBydW4gaXQgYW5kIHVzZSB0aGUgcmV0dXJuLFxuXHRcdC8vIGV4ZWN1dGluZyBpbiB0aGUgc2NvcGUgb2YgdGhlIGRhdGEgb2JqZWN0IChmb3IgaW5zdGFuY2VzKVxuXHRcdHJldHVybiBjZWxsRGF0YS5jYWxsKCByb3dEYXRhICk7XG5cdH1cblxuXHRpZiAoIGNlbGxEYXRhID09PSBudWxsICYmIHR5cGUgPT09ICdkaXNwbGF5JyApIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRpZiAoIHR5cGUgPT09ICdmaWx0ZXInICkge1xuXHRcdHZhciBmb21hdHRlcnMgPSBEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoO1xuXG5cdFx0aWYgKCBmb21hdHRlcnNbIGNvbC5zVHlwZSBdICkge1xuXHRcdFx0Y2VsbERhdGEgPSBmb21hdHRlcnNbIGNvbC5zVHlwZSBdKCBjZWxsRGF0YSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjZWxsRGF0YTtcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgdmFsdWUgZm9yIGEgc3BlY2lmaWMgY2VsbCwgaW50byB0aGUgaW50ZXJuYWwgZGF0YSBjYWNoZVxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7aW50fSByb3dJZHggYW9EYXRhIHJvdyBpZFxuICogIEBwYXJhbSB7aW50fSBjb2xJZHggQ29sdW1uIGluZGV4XG4gKiAgQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gc2V0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblNldENlbGxEYXRhKCBzZXR0aW5ncywgcm93SWR4LCBjb2xJZHgsIHZhbCApXG57XG5cdHZhciBjb2wgICAgID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XG5cdHZhciByb3dEYXRhID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF0uX2FEYXRhO1xuXG5cdGNvbC5mblNldERhdGEoIHJvd0RhdGEsIHZhbCwge1xuXHRcdHNldHRpbmdzOiBzZXR0aW5ncyxcblx0XHRyb3c6ICAgICAgcm93SWR4LFxuXHRcdGNvbDogICAgICBjb2xJZHhcblx0fSAgKTtcbn1cblxuLyoqXG4gKiBXcml0ZSBhIHZhbHVlIHRvIGEgY2VsbFxuICogQHBhcmFtIHsqfSB0ZCBDZWxsXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZVxuICovXG5mdW5jdGlvbiBfZm5Xcml0ZUNlbGwodGQsIHZhbClcbntcblx0aWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZU5hbWUpIHtcblx0XHQkKHRkKVxuXHRcdFx0LmVtcHR5KClcblx0XHRcdC5hcHBlbmQodmFsKTtcblx0fVxuXHRlbHNlIHtcblx0XHR0ZC5pbm5lckhUTUwgPSB2YWw7XG5cdH1cbn1cblxuXG4vLyBQcml2YXRlIHZhcmlhYmxlIHRoYXQgaXMgdXNlZCB0byBtYXRjaCBhY3Rpb24gc3ludGF4IGluIHRoZSBkYXRhIHByb3BlcnR5IG9iamVjdFxudmFyIF9fcmVBcnJheSA9IC9cXFsuKj9cXF0kLztcbnZhciBfX3JlRm4gPSAvXFwoXFwpJC87XG5cbi8qKlxuICogU3BsaXQgc3RyaW5nIG9uIHBlcmlvZHMsIHRha2luZyBpbnRvIGFjY291bnQgZXNjYXBlZCBwZXJpb2RzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXRcbiAqIEByZXR1cm4ge2FycmF5fSBTcGxpdCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gX2ZuU3BsaXRPYmpOb3RhdGlvbiggc3RyIClcbntcblx0dmFyIHBhcnRzID0gc3RyLm1hdGNoKC8oXFxcXC58W14uXSkrL2cpIHx8IFsnJ107XG5cblx0cmV0dXJuIHBhcnRzLm1hcCggZnVuY3Rpb24gKCBzICkge1xuXHRcdHJldHVybiBzLnJlcGxhY2UoL1xcXFxcXC4vZywgJy4nKTtcblx0fSApO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQgZGF0YSBmcm9tIGEgc291cmNlIG9iamVjdCwgdGFraW5nXG4gKiBpbnRvIGFjY291bnQgdGhlIGFiaWxpdHkgdG8gdXNlIG5lc3RlZCBvYmplY3RzIGFzIGEgc291cmNlXG4gKiAgQHBhcmFtIHtzdHJpbmd8aW50fGZ1bmN0aW9ufSBtU291cmNlIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIG9iamVjdFxuICogIEByZXR1cm5zIHtmdW5jdGlvbn0gRGF0YSBnZXQgZnVuY3Rpb25cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xudmFyIF9mbkdldE9iamVjdERhdGFGbiA9IERhdGFUYWJsZS51dGlsLmdldDtcblxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2V0IGRhdGEgZnJvbSBhIHNvdXJjZSBvYmplY3QsIHRha2luZ1xuICogaW50byBhY2NvdW50IHRoZSBhYmlsaXR5IHRvIHVzZSBuZXN0ZWQgb2JqZWN0cyBhcyBhIHNvdXJjZVxuICogIEBwYXJhbSB7c3RyaW5nfGludHxmdW5jdGlvbn0gbVNvdXJjZSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSBvYmplY3RcbiAqICBAcmV0dXJucyB7ZnVuY3Rpb259IERhdGEgc2V0IGZ1bmN0aW9uXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbnZhciBfZm5TZXRPYmplY3REYXRhRm4gPSBEYXRhVGFibGUudXRpbC5zZXQ7XG5cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgd2l0aCB0aGUgZnVsbCB0YWJsZSBkYXRhXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIGFycmF5IHthcnJheX0gYURhdGEgTWFzdGVyIGRhdGEgYXJyYXlcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuR2V0RGF0YU1hc3RlciAoIHNldHRpbmdzIClcbntcblx0cmV0dXJuIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyApO1xufVxuXG5cbi8qKlxuICogTnVrZSB0aGUgdGFibGVcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNsZWFyVGFibGUoIHNldHRpbmdzIClcbntcblx0c2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA9IDA7XG5cdHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGggPSAwO1xuXHRzZXR0aW5ncy5haURpc3BsYXkubGVuZ3RoID0gMDtcblx0c2V0dGluZ3MuYUlkcyA9IHt9O1xufVxuXG5cbi8qKlxuICogTWFyayBjYWNoZWQgZGF0YSBhcyBpbnZhbGlkIHN1Y2ggdGhhdCBhIHJlLXJlYWQgb2YgdGhlIGRhdGEgd2lsbCBvY2N1ciB3aGVuXG4gKiB0aGUgY2FjaGVkIGRhdGEgaXMgbmV4dCByZXF1ZXN0ZWQuIEFsc28gdXBkYXRlIGZyb20gdGhlIGRhdGEgc291cmNlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7aW50fSAgICByb3dJZHggICBSb3cgaW5kZXggdG8gaW52YWxpZGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzcmNdICAgIFNvdXJjZSB0byBpbnZhbGlkYXRlIGZyb206IHVuZGVmaW5lZCwgJ2F1dG8nLCAnZG9tJ1xuICogICAgIG9yICdkYXRhJ1xuICogQHBhcmFtIHtpbnR9ICAgIFtjb2xJZHhdIENvbHVtbiBpbmRleCB0byBpbnZhbGlkYXRlLiBJZiB1bmRlZmluZWQgdGhlIHdob2xlXG4gKiAgICAgcm93IHdpbGwgYmUgaW52YWxpZGF0ZWRcbiAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICpcbiAqIEB0b2RvIEZvciB0aGUgbW9kdWxhcmlzYXRpb24gb2YgdjEuMTEgdGhpcyB3aWxsIG5lZWQgdG8gYmVjb21lIGEgY2FsbGJhY2ssIHNvXG4gKiAgIHRoZSBzb3J0IGFuZCBmaWx0ZXIgbWV0aG9kcyBjYW4gc3Vic2NyaWJlIHRvIGl0LiBUaGF0IHdpbGwgcmVxdWlyZWRcbiAqICAgaW5pdGlhbGlzYXRpb24gb3B0aW9ucyBmb3Igc29ydGluZywgd2hpY2ggaXMgd2h5IGl0IGlzIG5vdCBhbHJlYWR5IGJha2VkIGluXG4gKi9cbmZ1bmN0aW9uIF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3dJZHgsIHNyYywgY29sSWR4IClcbntcblx0dmFyIHJvdyA9IHNldHRpbmdzLmFvRGF0YVsgcm93SWR4IF07XG5cdHZhciBpLCBpZW47XG5cblx0Ly8gUmVtb3ZlIHRoZSBjYWNoZWQgZGF0YSBmb3IgdGhlIHJvd1xuXHRyb3cuX2FTb3J0RGF0YSA9IG51bGw7XG5cdHJvdy5fYUZpbHRlckRhdGEgPSBudWxsO1xuXHRyb3cuZGlzcGxheURhdGEgPSBudWxsO1xuXG5cdC8vIEFyZSB3ZSByZWFkaW5nIGxhc3QgZGF0YSBmcm9tIERPTSBvciB0aGUgZGF0YSBvYmplY3Q/XG5cdGlmICggc3JjID09PSAnZG9tJyB8fCAoKCEgc3JjIHx8IHNyYyA9PT0gJ2F1dG8nKSAmJiByb3cuc3JjID09PSAnZG9tJykgKSB7XG5cdFx0Ly8gUmVhZCB0aGUgZGF0YSBmcm9tIHRoZSBET01cblx0XHRyb3cuX2FEYXRhID0gX2ZuR2V0Um93RWxlbWVudHMoXG5cdFx0XHRcdHNldHRpbmdzLCByb3csIGNvbElkeCwgY29sSWR4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByb3cuX2FEYXRhXG5cdFx0XHQpXG5cdFx0XHQuZGF0YTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBSZWFkaW5nIGZyb20gZGF0YSBvYmplY3QsIHVwZGF0ZSB0aGUgRE9NXG5cdFx0dmFyIGNlbGxzID0gcm93LmFuQ2VsbHM7XG5cdFx0dmFyIGRpc3BsYXkgPSBfZm5HZXRSb3dEaXNwbGF5KHNldHRpbmdzLCByb3dJZHgpO1xuXG5cdFx0aWYgKCBjZWxscyApIHtcblx0XHRcdGlmICggY29sSWR4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdF9mbldyaXRlQ2VsbChjZWxsc1tjb2xJZHhdLCBkaXNwbGF5W2NvbElkeF0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZvciAoIGk9MCwgaWVuPWNlbGxzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdF9mbldyaXRlQ2VsbChjZWxsc1tpXSwgZGlzcGxheVtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb2x1bW4gc3BlY2lmaWMgaW52YWxpZGF0aW9uXG5cdHZhciBjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHRpZiAoIGNvbElkeCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdC8vIFR5cGUgLSB0aGUgZGF0YSBtaWdodCBoYXZlIGNoYW5nZWRcblx0XHRjb2xzWyBjb2xJZHggXS5zVHlwZSA9IG51bGw7XG5cblx0XHQvLyBNYXggbGVuZ3RoIHN0cmluZy4gSXRzIGEgZmFpcmx5IGNoZWVwIHJlY2FsY3VsYXRpb24sIHNvIG5vdCB3b3J0aFxuXHRcdC8vIHNvbWV0aGluZyBtb3JlIGNvbXBsaWNhdGVkXG5cdFx0Y29sc1sgY29sSWR4IF0ubWF4TGVuU3RyaW5nID0gbnVsbDtcblx0fVxuXHRlbHNlIHtcblx0XHRmb3IgKCBpPTAsIGllbj1jb2xzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sc1tpXS5zVHlwZSA9IG51bGw7XG5cdFx0XHRjb2xzW2ldLm1heExlblN0cmluZyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIERhdGFUYWJsZXMgc3BlY2lhbCBgRFRfKmAgYXR0cmlidXRlcyBmb3IgdGhlIHJvd1xuXHRcdF9mblJvd0F0dHJpYnV0ZXMoIHNldHRpbmdzLCByb3cgKTtcblx0fVxufVxuXG5cbi8qKlxuICogQnVpbGQgYSBkYXRhIHNvdXJjZSBvYmplY3QgZnJvbSBhbiBIVE1MIHJvdywgcmVhZGluZyB0aGUgY29udGVudHMgb2YgdGhlXG4gKiBjZWxscyB0aGF0IGFyZSBpbiB0aGUgcm93LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHtub2RlfG9iamVjdH0gVFIgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQgZGF0YSBvciBleGlzdGluZyByb3dcbiAqICAgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmUtcmVhZCB0aGUgZGF0YSBmcm9tIHRoZSBjZWxsc1xuICogQHBhcmFtIHtpbnR9IFtjb2xJZHhdIE9wdGlvbmFsIGNvbHVtbiBpbmRleFxuICogQHBhcmFtIHthcnJheXxvYmplY3R9IFtkXSBEYXRhIHNvdXJjZSBvYmplY3QuIElmIGBjb2xJZHhgIGlzIGdpdmVuIHRoZW4gdGhpc1xuICogICBwYXJhbWV0ZXIgc2hvdWxkIGFsc28gYmUgZ2l2ZW4gYW5kIHdpbGwgYmUgdXNlZCB0byB3cml0ZSB0aGUgZGF0YSBpbnRvLlxuICogICBPbmx5IHRoZSBjb2x1bW4gaW4gcXVlc3Rpb24gd2lsbCBiZSB3cml0dGVuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBPYmplY3Qgd2l0aCB0d28gcGFyYW1ldGVyczogYGRhdGFgIHRoZSBkYXRhIHJlYWQsIGluXG4gKiAgIGRvY3VtZW50IG9yZGVyLCBhbmQgYGNlbGxzYCBhbmQgYXJyYXkgb2Ygbm9kZXMgKHRoZXkgY2FuIGJlIHVzZWZ1bCB0byB0aGVcbiAqICAgY2FsbGVyLCBzbyByYXRoZXIgdGhhbiBuZWVkaW5nIGEgc2Vjb25kIHRyYXZlcnNhbCB0byBnZXQgdGhlbSwganVzdCByZXR1cm5cbiAqICAgdGhlbSBmcm9tIGhlcmUpLlxuICogQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkdldFJvd0VsZW1lbnRzKCBzZXR0aW5ncywgcm93LCBjb2xJZHgsIGQgKVxue1xuXHR2YXJcblx0XHR0ZHMgPSBbXSxcblx0XHR0ZCA9IHJvdy5maXJzdENoaWxkLFxuXHRcdG5hbWUsIGNvbCwgaT0wLCBjb250ZW50cyxcblx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdG9iamVjdFJlYWQgPSBzZXR0aW5ncy5fcm93UmVhZE9iamVjdDtcblxuXHQvLyBBbGxvdyB0aGUgZGF0YSBvYmplY3QgdG8gYmUgcGFzc2VkIGluLCBvciBjb25zdHJ1Y3Rcblx0ZCA9IGQgIT09IHVuZGVmaW5lZCA/XG5cdFx0ZCA6XG5cdFx0b2JqZWN0UmVhZCA/XG5cdFx0XHR7fSA6XG5cdFx0XHRbXTtcblxuXHR2YXIgYXR0ciA9IGZ1bmN0aW9uICggc3RyLCB0ZCAgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyApIHtcblx0XHRcdHZhciBpZHggPSBzdHIuaW5kZXhPZignQCcpO1xuXG5cdFx0XHRpZiAoIGlkeCAhPT0gLTEgKSB7XG5cdFx0XHRcdHZhciBhdHRyID0gc3RyLnN1YnN0cmluZyggaWR4KzEgKTtcblx0XHRcdFx0dmFyIHNldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggc3RyICk7XG5cdFx0XHRcdHNldHRlciggZCwgdGQuZ2V0QXR0cmlidXRlKCBhdHRyICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gUmVhZCBkYXRhIGZyb20gYSBjZWxsIGFuZCBzdG9yZSBpbnRvIHRoZSBkYXRhIG9iamVjdFxuXHR2YXIgY2VsbFByb2Nlc3MgPSBmdW5jdGlvbiAoIGNlbGwgKSB7XG5cdFx0aWYgKCBjb2xJZHggPT09IHVuZGVmaW5lZCB8fCBjb2xJZHggPT09IGkgKSB7XG5cdFx0XHRjb2wgPSBjb2x1bW5zW2ldO1xuXHRcdFx0Y29udGVudHMgPSAoY2VsbC5pbm5lckhUTUwpLnRyaW0oKTtcblxuXHRcdFx0aWYgKCBjb2wgJiYgY29sLl9iQXR0clNyYyApIHtcblx0XHRcdFx0dmFyIHNldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggY29sLm1EYXRhLl8gKTtcblx0XHRcdFx0c2V0dGVyKCBkLCBjb250ZW50cyApO1xuXG5cdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS5zb3J0LCBjZWxsICk7XG5cdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS50eXBlLCBjZWxsICk7XG5cdFx0XHRcdGF0dHIoIGNvbC5tRGF0YS5maWx0ZXIsIGNlbGwgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBEZXBlbmRpbmcgb24gdGhlIGBkYXRhYCBvcHRpb24gZm9yIHRoZSBjb2x1bW5zIHRoZSBkYXRhIGNhblxuXHRcdFx0XHQvLyBiZSByZWFkIHRvIGVpdGhlciBhbiBvYmplY3Qgb3IgYW4gYXJyYXkuXG5cdFx0XHRcdGlmICggb2JqZWN0UmVhZCApIHtcblx0XHRcdFx0XHRpZiAoICEgY29sLl9zZXR0ZXIgKSB7XG5cdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgc2V0dGVyIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRjb2wuX3NldHRlciA9IF9mblNldE9iamVjdERhdGFGbiggY29sLm1EYXRhICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbC5fc2V0dGVyKCBkLCBjb250ZW50cyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGRbaV0gPSBjb250ZW50cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGkrKztcblx0fTtcblxuXHRpZiAoIHRkICkge1xuXHRcdC8vIGB0cmAgZWxlbWVudCB3YXMgcGFzc2VkIGluXG5cdFx0d2hpbGUgKCB0ZCApIHtcblx0XHRcdG5hbWUgPSB0ZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG5hbWUgPT0gXCJURFwiIHx8IG5hbWUgPT0gXCJUSFwiICkge1xuXHRcdFx0XHRjZWxsUHJvY2VzcyggdGQgKTtcblx0XHRcdFx0dGRzLnB1c2goIHRkICk7XG5cdFx0XHR9XG5cblx0XHRcdHRkID0gdGQubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEV4aXN0aW5nIHJvdyBvYmplY3QgcGFzc2VkIGluXG5cdFx0dGRzID0gcm93LmFuQ2VsbHM7XG5cblx0XHRmb3IgKCB2YXIgaj0wLCBqZW49dGRzLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0Y2VsbFByb2Nlc3MoIHRkc1tqXSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlYWQgdGhlIElEIGZyb20gdGhlIERPTSBpZiBwcmVzZW50XG5cdHZhciByb3dOb2RlID0gcm93LmZpcnN0Q2hpbGQgPyByb3cgOiByb3cublRyO1xuXG5cdGlmICggcm93Tm9kZSApIHtcblx0XHR2YXIgaWQgPSByb3dOb2RlLmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXG5cdFx0aWYgKCBpZCApIHtcblx0XHRcdF9mblNldE9iamVjdERhdGFGbiggc2V0dGluZ3Mucm93SWQgKSggZCwgaWQgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGRhdGE6IGQsXG5cdFx0Y2VsbHM6IHRkc1xuXHR9O1xufVxuXG4vKipcbiAqIFJlbmRlciBhbmQgY2FjaGUgYSByb3cncyBkaXNwbGF5IGRhdGEgZm9yIHRoZSBjb2x1bW5zLCBpZiByZXF1aXJlZFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIF9mbkdldFJvd0Rpc3BsYXkgKHNldHRpbmdzLCByb3dJZHgpIHtcblx0dmFyIHJvd01vZGFsID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF07XG5cdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXG5cdGlmICghIHJvd01vZGFsLmRpc3BsYXlEYXRhKSB7XG5cdFx0Ly8gTmVlZCB0byByZW5kZXIgYW5kIGNhY2hlXG5cdFx0cm93TW9kYWwuZGlzcGxheURhdGEgPSBbXTtcblx0XG5cdFx0Zm9yICggdmFyIGNvbElkeD0wLCBsZW49Y29sdW1ucy5sZW5ndGggOyBjb2xJZHg8bGVuIDsgY29sSWR4KysgKSB7XG5cdFx0XHRyb3dNb2RhbC5kaXNwbGF5RGF0YS5wdXNoKFxuXHRcdFx0XHRfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCAnZGlzcGxheScgKVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcm93TW9kYWwuZGlzcGxheURhdGE7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFRSIGVsZW1lbnQgKGFuZCBpdCdzIFREIGNoaWxkcmVuKSBmb3IgYSByb3dcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGlSb3cgUm93IHRvIGNvbnNpZGVyXG4gKiAgQHBhcmFtIHtub2RlfSBbblRySW5dIFRSIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB0YWJsZSAtIG9wdGlvbmFsLiBJZiBub3QgZ2l2ZW4sXG4gKiAgICBEYXRhVGFibGVzIHdpbGwgY3JlYXRlIGEgcm93IGF1dG9tYXRpY2FsbHlcbiAqICBAcGFyYW0ge2FycmF5fSBbYW5UZHNdIEFycmF5IG9mIFREfFRIIGVsZW1lbnRzIGZvciB0aGUgcm93IC0gbXVzdCBiZSBnaXZlblxuICogICAgaWYgblRyIGlzLlxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5DcmVhdGVUciAoIG9TZXR0aW5ncywgaVJvdywgblRySW4sIGFuVGRzIClcbntcblx0dmFyXG5cdFx0cm93ID0gb1NldHRpbmdzLmFvRGF0YVtpUm93XSxcblx0XHRyb3dEYXRhID0gcm93Ll9hRGF0YSxcblx0XHRjZWxscyA9IFtdLFxuXHRcdG5UciwgblRkLCBvQ29sLFxuXHRcdGksIGlMZW4sIGNyZWF0ZSxcblx0XHR0ckNsYXNzID0gb1NldHRpbmdzLm9DbGFzc2VzLnRib2R5LnJvdztcblxuXHRpZiAoIHJvdy5uVHIgPT09IG51bGwgKVxuXHR7XG5cdFx0blRyID0gblRySW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcblxuXHRcdHJvdy5uVHIgPSBuVHI7XG5cdFx0cm93LmFuQ2VsbHMgPSBjZWxscztcblxuXHRcdF9hZGRDbGFzcyhuVHIsIHRyQ2xhc3MpO1xuXG5cdFx0LyogVXNlIGEgcHJpdmF0ZSBwcm9wZXJ0eSBvbiB0aGUgbm9kZSB0byBhbGxvdyByZXNlcnZlIG1hcHBpbmcgZnJvbSB0aGUgbm9kZVxuXHRcdCAqIHRvIHRoZSBhb0RhdGEgYXJyYXkgZm9yIGZhc3QgbG9vayB1cFxuXHRcdCAqL1xuXHRcdG5Uci5fRFRfUm93SW5kZXggPSBpUm93O1xuXG5cdFx0LyogU3BlY2lhbCBwYXJhbWV0ZXJzIGNhbiBiZSBnaXZlbiBieSB0aGUgZGF0YSBzb3VyY2UgdG8gYmUgdXNlZCBvbiB0aGUgcm93ICovXG5cdFx0X2ZuUm93QXR0cmlidXRlcyggb1NldHRpbmdzLCByb3cgKTtcblxuXHRcdC8qIFByb2Nlc3MgZWFjaCBjb2x1bW4gKi9cblx0XHRmb3IgKCBpPTAsIGlMZW49b1NldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdG9Db2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2ldO1xuXHRcdFx0Y3JlYXRlID0gblRySW4gJiYgYW5UZHNbaV0gPyBmYWxzZSA6IHRydWU7XG5cblx0XHRcdG5UZCA9IGNyZWF0ZSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIG9Db2wuc0NlbGxUeXBlICkgOiBhblRkc1tpXTtcblxuXHRcdFx0aWYgKCEgblRkKSB7XG5cdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnSW5jb3JyZWN0IGNvbHVtbiBjb3VudCcsIDE4ICk7XG5cdFx0XHR9XG5cblx0XHRcdG5UZC5fRFRfQ2VsbEluZGV4ID0ge1xuXHRcdFx0XHRyb3c6IGlSb3csXG5cdFx0XHRcdGNvbHVtbjogaVxuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0Y2VsbHMucHVzaCggblRkICk7XG5cdFx0XHRcblx0XHRcdHZhciBkaXNwbGF5ID0gX2ZuR2V0Um93RGlzcGxheShvU2V0dGluZ3MsIGlSb3cpO1xuXG5cdFx0XHQvLyBOZWVkIHRvIGNyZWF0ZSB0aGUgSFRNTCBpZiBuZXcsIG9yIGlmIGEgcmVuZGVyaW5nIGZ1bmN0aW9uIGlzIGRlZmluZWRcblx0XHRcdGlmIChcblx0XHRcdFx0Y3JlYXRlIHx8XG5cdFx0XHRcdChcblx0XHRcdFx0XHQob0NvbC5tUmVuZGVyIHx8IG9Db2wubURhdGEgIT09IGkpICYmXG5cdFx0XHRcdFx0KCEkLmlzUGxhaW5PYmplY3Qob0NvbC5tRGF0YSkgfHwgb0NvbC5tRGF0YS5fICE9PSBpKycuZGlzcGxheScpXG5cdFx0XHRcdClcblx0XHRcdCkge1xuXHRcdFx0XHRfZm5Xcml0ZUNlbGwoblRkLCBkaXNwbGF5W2ldKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY29sdW1uIGNsYXNzXG5cdFx0XHRfYWRkQ2xhc3MoblRkLCBvQ29sLnNDbGFzcyk7XG5cblx0XHRcdC8vIFZpc2liaWxpdHkgLSBhZGQgb3IgcmVtb3ZlIGFzIHJlcXVpcmVkXG5cdFx0XHRpZiAoIG9Db2wuYlZpc2libGUgJiYgY3JlYXRlIClcblx0XHRcdHtcblx0XHRcdFx0blRyLmFwcGVuZENoaWxkKCBuVGQgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCAhIG9Db2wuYlZpc2libGUgJiYgISBjcmVhdGUgKVxuXHRcdFx0e1xuXHRcdFx0XHRuVGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggblRkICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggb0NvbC5mbkNyZWF0ZWRDZWxsIClcblx0XHRcdHtcblx0XHRcdFx0b0NvbC5mbkNyZWF0ZWRDZWxsLmNhbGwoIG9TZXR0aW5ncy5vSW5zdGFuY2UsXG5cdFx0XHRcdFx0blRkLCBfZm5HZXRDZWxsRGF0YSggb1NldHRpbmdzLCBpUm93LCBpICksIHJvd0RhdGEsIGlSb3csIGlcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvUm93Q3JlYXRlZENhbGxiYWNrJywgJ3Jvdy1jcmVhdGVkJywgW25Uciwgcm93RGF0YSwgaVJvdywgY2VsbHNdICk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0X2FkZENsYXNzKHJvdy5uVHIsIHRyQ2xhc3MpO1xuXHR9XG59XG5cblxuLyoqXG4gKiBBZGQgYXR0cmlidXRlcyB0byBhIHJvdyBiYXNlZCBvbiB0aGUgc3BlY2lhbCBgRFRfKmAgcGFyYW1ldGVycyBpbiBhIGRhdGFcbiAqIHNvdXJjZSBvYmplY3QuXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtvYmplY3R9IERhdGFUYWJsZXMgcm93IG9iamVjdCBmb3IgdGhlIHJvdyB0byBiZSBtb2RpZmllZFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Sb3dBdHRyaWJ1dGVzKCBzZXR0aW5ncywgcm93IClcbntcblx0dmFyIHRyID0gcm93Lm5Ucjtcblx0dmFyIGRhdGEgPSByb3cuX2FEYXRhO1xuXG5cdGlmICggdHIgKSB7XG5cdFx0dmFyIGlkID0gc2V0dGluZ3Mucm93SWRGbiggZGF0YSApO1xuXG5cdFx0aWYgKCBpZCApIHtcblx0XHRcdHRyLmlkID0gaWQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhLkRUX1Jvd0NsYXNzICkge1xuXHRcdFx0Ly8gUmVtb3ZlIGFueSBjbGFzc2VzIGFkZGVkIGJ5IERUX1Jvd0NsYXNzIGJlZm9yZVxuXHRcdFx0dmFyIGEgPSBkYXRhLkRUX1Jvd0NsYXNzLnNwbGl0KCcgJyk7XG5cdFx0XHRyb3cuX19yb3djID0gcm93Ll9fcm93YyA/XG5cdFx0XHRcdF91bmlxdWUoIHJvdy5fX3Jvd2MuY29uY2F0KCBhICkgKSA6XG5cdFx0XHRcdGE7XG5cblx0XHRcdCQodHIpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggcm93Ll9fcm93Yy5qb2luKCcgJykgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIGRhdGEuRFRfUm93Q2xhc3MgKTtcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEuRFRfUm93QXR0ciApIHtcblx0XHRcdCQodHIpLmF0dHIoIGRhdGEuRFRfUm93QXR0ciApO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YS5EVF9Sb3dEYXRhICkge1xuXHRcdFx0JCh0cikuZGF0YSggZGF0YS5EVF9Sb3dEYXRhICk7XG5cdFx0fVxuXHR9XG59XG5cblxuLyoqXG4gKiBDcmVhdGUgdGhlIEhUTUwgaGVhZGVyIGZvciB0aGUgdGFibGVcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkJ1aWxkSGVhZCggc2V0dGluZ3MsIHNpZGUgKVxue1xuXHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0dmFyIGksIGllbiwgcm93O1xuXHR2YXIgdGFyZ2V0ID0gc2lkZSA9PT0gJ2hlYWRlcidcblx0XHQ/IHNldHRpbmdzLm5USGVhZFxuXHRcdDogc2V0dGluZ3MublRGb290O1xuXHR2YXIgdGl0bGVQcm9wID0gc2lkZSA9PT0gJ2hlYWRlcicgPyAnc1RpdGxlJyA6IHNpZGU7XG5cblx0Ly8gRm9vdGVyIG1pZ2h0IGJlIGRlZmluZWRcblx0aWYgKCEgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gSWYgbm8gY2VsbHMgeWV0IGFuZCB3ZSBoYXZlIGNvbnRlbnQgZm9yIHRoZW0sIHRoZW4gY3JlYXRlXG5cdGlmIChzaWRlID09PSAnaGVhZGVyJyB8fCBfcGx1Y2soc2V0dGluZ3MuYW9Db2x1bW5zLCB0aXRsZVByb3ApLmpvaW4oJycpKSB7XG5cdFx0cm93ID0gJCgndHInLCB0YXJnZXQpO1xuXG5cdFx0Ly8gQWRkIGEgcm93IGlmIG5lZWRlZFxuXHRcdGlmICghIHJvdy5sZW5ndGgpIHtcblx0XHRcdHJvdyA9ICQoJzx0ci8+JykuYXBwZW5kVG8odGFyZ2V0KVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgbnVtYmVyIG9mIGNlbGxzIG5lZWRlZCB0byBtYWtlIHVwIHRvIHRoZSBudW1iZXIgb2YgY29sdW1uc1xuXHRcdGlmIChyb3cubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR2YXIgY2VsbENvdW50ID0gMDtcblx0XHRcdFxuXHRcdFx0JCgndGQsIHRoJywgcm93KS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y2VsbENvdW50ICs9IHRoaXMuY29sU3Bhbjtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKCBpPWNlbGxDb3VudCwgaWVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdCQoJzx0aC8+Jylcblx0XHRcdFx0XHQuaHRtbCggY29sdW1uc1tpXVt0aXRsZVByb3BdIHx8ICcnIClcblx0XHRcdFx0XHQuYXBwZW5kVG8oIHJvdyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBkZXRlY3RlZCA9IF9mbkRldGVjdEhlYWRlciggc2V0dGluZ3MsIHRhcmdldCwgdHJ1ZSApO1xuXG5cdGlmIChzaWRlID09PSAnaGVhZGVyJykge1xuXHRcdHNldHRpbmdzLmFvSGVhZGVyID0gZGV0ZWN0ZWQ7XG5cdFx0JCgndHInLCB0YXJnZXQpLmFkZENsYXNzKGNsYXNzZXMudGhlYWQucm93KTtcblx0fVxuXHRlbHNlIHtcblx0XHRzZXR0aW5ncy5hb0Zvb3RlciA9IGRldGVjdGVkO1xuXHRcdCQoJ3RyJywgdGFyZ2V0KS5hZGRDbGFzcyhjbGFzc2VzLnRmb290LnJvdyk7XG5cdH1cblxuXHQvLyBFdmVyeSBjZWxsIG5lZWRzIHRvIGJlIHBhc3NlZCB0aHJvdWdoIHRoZSByZW5kZXJlclxuXHQkKHRhcmdldCkuY2hpbGRyZW4oJ3RyJykuY2hpbGRyZW4oJ3RoLCB0ZCcpXG5cdFx0LmVhY2goIGZ1bmN0aW9uICgpIHtcblx0XHRcdF9mblJlbmRlcmVyKCBzZXR0aW5ncywgc2lkZSApKFxuXHRcdFx0XHRzZXR0aW5ncywgJCh0aGlzKSwgY2xhc3Nlc1xuXHRcdFx0KTtcblx0XHR9ICk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBsYXlvdXQgc3RydWN0dXJlIGZvciBhIGhlYWRlciBvciBmb290ZXJcbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3NcbiAqIEBwYXJhbSB7Kn0gc291cmNlIFNvdXJjZSBsYXlvdXQgYXJyYXlcbiAqIEBwYXJhbSB7Kn0gaW5jQ29sdW1ucyBXaGF0IGNvbHVtbnMgc2hvdWxkIGJlIGluY2x1ZGVkXG4gKiBAcmV0dXJucyBMYXlvdXQgYXJyYXkgaW4gY29sdW1uIGluZGV4IG9yZGVyXG4gKi9cbmZ1bmN0aW9uIF9mbkhlYWRlckxheW91dCggc2V0dGluZ3MsIHNvdXJjZSwgaW5jQ29sdW1ucyApXG57XG5cdHZhciByb3csIGNvbHVtbiwgY2VsbDtcblx0dmFyIGxvY2FsID0gW107XG5cdHZhciBzdHJ1Y3R1cmUgPSBbXTtcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHZhciBjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoO1xuXHR2YXIgcm93c3BhbiwgY29sc3BhbjtcblxuXHRpZiAoICEgc291cmNlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIERlZmF1bHQgaXMgdG8gd29yayBvbiBvbmx5IHZpc2libGUgY29sdW1uc1xuXHRpZiAoICEgaW5jQ29sdW1ucyApIHtcblx0XHRpbmNDb2x1bW5zID0gX3JhbmdlKGNvbHVtbkNvdW50KVxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdHJldHVybiBjb2x1bW5zW2lkeF0uYlZpc2libGU7XG5cdFx0XHR9KTtcblx0fVxuXG5cdC8vIE1ha2UgYSBjb3B5IG9mIHRoZSBtYXN0ZXIgbGF5b3V0IGFycmF5LCBidXQgd2l0aCBvbmx5IHRoZSBjb2x1bW5zIHdlIHdhbnRcblx0Zm9yICggcm93PTAgOyByb3c8c291cmNlLmxlbmd0aCA7IHJvdysrICkge1xuXHRcdC8vIFJlbW92ZSBhbnkgY29sdW1ucyB3ZSBoYXZlbid0IHNlbGVjdGVkXG5cdFx0bG9jYWxbcm93XSA9IHNvdXJjZVtyb3ddLnNsaWNlKCkuZmlsdGVyKGZ1bmN0aW9uIChjZWxsLCBpKSB7XG5cdFx0XHRyZXR1cm4gaW5jQ29sdW1ucy5pbmNsdWRlcyhpKTtcblx0XHR9KTtcblxuXHRcdC8vIFByZXAgdGhlIHN0cnVjdHVyZSBhcnJheSAtIGl0IG5lZWRzIGFuIGVsZW1lbnQgZm9yIGVhY2ggcm93XG5cdFx0c3RydWN0dXJlLnB1c2goIFtdICk7XG5cdH1cblxuXHRmb3IgKCByb3c9MCA7IHJvdzxsb2NhbC5sZW5ndGggOyByb3crKyApIHtcblx0XHRmb3IgKCBjb2x1bW49MCA7IGNvbHVtbjxsb2NhbFtyb3ddLmxlbmd0aCA7IGNvbHVtbisrICkge1xuXHRcdFx0cm93c3BhbiA9IDE7XG5cdFx0XHRjb2xzcGFuID0gMTtcblxuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBjZWxsIChyb3cvY29sc3BhbikgY292ZXJpbmcgb3VyIHRhcmdldFxuXHRcdFx0Ly8gaW5zZXJ0IHBvaW50LiBJZiB0aGVyZSBpcywgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvLlxuXHRcdFx0aWYgKCBzdHJ1Y3R1cmVbcm93XVtjb2x1bW5dID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGNlbGwgPSBsb2NhbFtyb3ddW2NvbHVtbl0uY2VsbDtcblxuXHRcdFx0XHQvLyBFeHBhbmQgZm9yIHJvd3NwYW5cblx0XHRcdFx0d2hpbGUgKFxuXHRcdFx0XHRcdGxvY2FsW3Jvdytyb3dzcGFuXSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdFx0bG9jYWxbcm93XVtjb2x1bW5dLmNlbGwgPT0gbG9jYWxbcm93K3Jvd3NwYW5dW2NvbHVtbl0uY2VsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRzdHJ1Y3R1cmVbcm93K3Jvd3NwYW5dW2NvbHVtbl0gPSBudWxsO1xuXHRcdFx0XHRcdHJvd3NwYW4rKztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFuZCBmb3IgY29sc3BhblxuXHRcdFx0XHR3aGlsZSAoXG5cdFx0XHRcdFx0bG9jYWxbcm93XVtjb2x1bW4rY29sc3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdGxvY2FsW3Jvd11bY29sdW1uXS5jZWxsID09IGxvY2FsW3Jvd11bY29sdW1uK2NvbHNwYW5dLmNlbGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gV2hpY2ggYWxzbyBuZWVkcyB0byBnbyBvdmVyIHJvd3Ncblx0XHRcdFx0XHRmb3IgKCB2YXIgaz0wIDsgazxyb3dzcGFuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0c3RydWN0dXJlW3JvdytrXVtjb2x1bW4rY29sc3Bhbl0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbHNwYW4rKztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0aXRsZVNwYW4gPSAkKCdzcGFuLmR0LWNvbHVtbi10aXRsZScsIGNlbGwpO1xuXG5cdFx0XHRcdHN0cnVjdHVyZVtyb3ddW2NvbHVtbl0gPSB7XG5cdFx0XHRcdFx0Y2VsbDogY2VsbCxcblx0XHRcdFx0XHRjb2xzcGFuOiBjb2xzcGFuLFxuXHRcdFx0XHRcdHJvd3NwYW46IHJvd3NwYW4sXG5cdFx0XHRcdFx0dGl0bGU6IHRpdGxlU3Bhbi5sZW5ndGhcblx0XHRcdFx0XHRcdD8gdGl0bGVTcGFuLmh0bWwoKVxuXHRcdFx0XHRcdFx0OiAkKGNlbGwpLmh0bWwoKVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHJ1Y3R1cmU7XG59XG5cblxuLyoqXG4gKiBEcmF3IHRoZSBoZWFkZXIgKG9yIGZvb3RlcikgZWxlbWVudCBiYXNlZCBvbiB0aGUgY29sdW1uIHZpc2liaWxpdHkgc3RhdGVzLlxuICpcbiAqICBAcGFyYW0gb2JqZWN0IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSBhcnJheSBhb1NvdXJjZSBMYXlvdXQgYXJyYXkgZnJvbSBfZm5EZXRlY3RIZWFkZXJcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzb3VyY2UgKVxue1xuXHR2YXIgbGF5b3V0ID0gX2ZuSGVhZGVyTGF5b3V0KHNldHRpbmdzLCBzb3VyY2UpO1xuXHR2YXIgdHIsIG47XG5cblx0Zm9yICggdmFyIHJvdz0wIDsgcm93PHNvdXJjZS5sZW5ndGggOyByb3crKyApIHtcblx0XHR0ciA9IHNvdXJjZVtyb3ddLnJvdztcblxuXHRcdC8vIEFsbCBjZWxscyBhcmUgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHNvIGVtcHR5IG91dCB0aGUgcm93XG5cdFx0Ly8gQ2FuJ3QgdXNlICQoKS5lbXB0eSgpIGFzIHRoYXQga2lsbHMgZXZlbnQgaGFuZGxlcnNcblx0XHRpZiAodHIpIHtcblx0XHRcdHdoaWxlKCAobiA9IHRyLmZpcnN0Q2hpbGQpICkge1xuXHRcdFx0XHR0ci5yZW1vdmVDaGlsZCggbiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBjb2x1bW49MCA7IGNvbHVtbjxsYXlvdXRbcm93XS5sZW5ndGggOyBjb2x1bW4rKyApIHtcblx0XHRcdHZhciBwb2ludCA9IGxheW91dFtyb3ddW2NvbHVtbl07XG5cblx0XHRcdGlmIChwb2ludCkge1xuXHRcdFx0XHQkKHBvaW50LmNlbGwpXG5cdFx0XHRcdFx0LmFwcGVuZFRvKHRyKVxuXHRcdFx0XHRcdC5hdHRyKCdyb3dzcGFuJywgcG9pbnQucm93c3Bhbilcblx0XHRcdFx0XHQuYXR0cignY29sc3BhbicsIHBvaW50LmNvbHNwYW4pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5cbi8qKlxuICogSW5zZXJ0IHRoZSByZXF1aXJlZCBUUiBub2RlcyBpbnRvIHRoZSB0YWJsZSBmb3IgZGlzcGxheVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0gYWpheENvbXBsZXRlIHRydWUgYWZ0ZXIgYWpheCBjYWxsIHRvIGNvbXBsZXRlIHJlbmRlcmluZ1xuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5EcmF3KCBvU2V0dGluZ3MsIGFqYXhDb21wbGV0ZSApXG57XG5cdC8vIEFsbG93IGZvciBzdGF0ZSBzYXZpbmcgYW5kIGEgY3VzdG9tIHN0YXJ0IHBvc2l0aW9uXG5cdF9mblN0YXJ0KCBvU2V0dGluZ3MgKTtcblxuXHQvKiBQcm92aWRlIGEgcHJlLWNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgZHJhdyBpcyBmYWxzZSBpcyByZXR1cm5lZCAqL1xuXHR2YXIgYVByZURyYXcgPSBfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvUHJlRHJhd0NhbGxiYWNrJywgJ3ByZURyYXcnLCBbb1NldHRpbmdzXSApO1xuXHRpZiAoIGFQcmVEcmF3LmluZGV4T2YoZmFsc2UpICE9PSAtMSApXG5cdHtcblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggb1NldHRpbmdzLCBmYWxzZSApO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBhblJvd3MgPSBbXTtcblx0dmFyIGlSb3dDb3VudCA9IDA7XG5cdHZhciBiU2VydmVyU2lkZSA9IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09ICdzc3AnO1xuXHR2YXIgYWlEaXNwbGF5ID0gb1NldHRpbmdzLmFpRGlzcGxheTtcblx0dmFyIGlEaXNwbGF5U3RhcnQgPSBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQ7XG5cdHZhciBpRGlzcGxheUVuZCA9IG9TZXR0aW5ncy5mbkRpc3BsYXlFbmQoKTtcblx0dmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXHR2YXIgYm9keSA9ICQob1NldHRpbmdzLm5UQm9keSk7XG5cblx0b1NldHRpbmdzLmJEcmF3aW5nID0gdHJ1ZTtcblxuXHQvKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGRyYXcgaW50ZXJjZXB0ICovXG5cdGlmICggb1NldHRpbmdzLmRlZmVyTG9hZGluZyApXG5cdHtcblx0XHRvU2V0dGluZ3MuZGVmZXJMb2FkaW5nID0gZmFsc2U7XG5cdFx0b1NldHRpbmdzLmlEcmF3Kys7XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIG9TZXR0aW5ncywgZmFsc2UgKTtcblx0fVxuXHRlbHNlIGlmICggIWJTZXJ2ZXJTaWRlIClcblx0e1xuXHRcdG9TZXR0aW5ncy5pRHJhdysrO1xuXHR9XG5cdGVsc2UgaWYgKCAhb1NldHRpbmdzLmJEZXN0cm95aW5nICYmICFhamF4Q29tcGxldGUpXG5cdHtcblx0XHQvLyBTaG93IGxvYWRpbmcgbWVzc2FnZSBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuXHRcdGlmIChvU2V0dGluZ3MuaURyYXcgPT09IDApIHtcblx0XHRcdGJvZHkuZW1wdHkoKS5hcHBlbmQoX2VtcHR5Um93KG9TZXR0aW5ncykpO1xuXHRcdH1cblxuXHRcdF9mbkFqYXhVcGRhdGUoIG9TZXR0aW5ncyApO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggYWlEaXNwbGF5Lmxlbmd0aCAhPT0gMCApXG5cdHtcblx0XHR2YXIgaVN0YXJ0ID0gYlNlcnZlclNpZGUgPyAwIDogaURpc3BsYXlTdGFydDtcblx0XHR2YXIgaUVuZCA9IGJTZXJ2ZXJTaWRlID8gb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggOiBpRGlzcGxheUVuZDtcblxuXHRcdGZvciAoIHZhciBqPWlTdGFydCA7IGo8aUVuZCA7IGorKyApXG5cdFx0e1xuXHRcdFx0dmFyIGlEYXRhSW5kZXggPSBhaURpc3BsYXlbal07XG5cdFx0XHR2YXIgYW9EYXRhID0gb1NldHRpbmdzLmFvRGF0YVsgaURhdGFJbmRleCBdO1xuXHRcdFx0aWYgKCBhb0RhdGEublRyID09PSBudWxsIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuQ3JlYXRlVHIoIG9TZXR0aW5ncywgaURhdGFJbmRleCApO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgblJvdyA9IGFvRGF0YS5uVHI7XG5cblx0XHRcdC8vIEFkZCB2YXJpb3VzIGNsYXNzZXMgYXMgbmVlZGVkXG5cdFx0XHRmb3IgKHZhciBpPTAgOyBpPGNvbHVtbnMubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb2wgPSBjb2x1bW5zW2ldO1xuXHRcdFx0XHR2YXIgdGQgPSBhb0RhdGEuYW5DZWxsc1tpXTtcblxuXHRcdFx0XHRfYWRkQ2xhc3ModGQsIF9leHQudHlwZS5jbGFzc05hbWVbY29sLnNUeXBlXSk7IC8vIGF1dG8gY2xhc3Ncblx0XHRcdFx0X2FkZENsYXNzKHRkLCBvU2V0dGluZ3Mub0NsYXNzZXMudGJvZHkuY2VsbCk7IC8vIGFsbCBjZWxsc1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSb3cgY2FsbGJhY2sgZnVuY3Rpb25zIC0gbWlnaHQgd2FudCB0byBtYW5pcHVsYXRlIHRoZSByb3dcblx0XHRcdC8vIGlSb3dDb3VudCBhbmQgaiBhcmUgbm90IGN1cnJlbnRseSBkb2N1bWVudGVkLiBBcmUgdGhleSBhdCBhbGxcblx0XHRcdC8vIHVzZWZ1bD9cblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCAnYW9Sb3dDYWxsYmFjaycsIG51bGwsXG5cdFx0XHRcdFtuUm93LCBhb0RhdGEuX2FEYXRhLCBpUm93Q291bnQsIGosIGlEYXRhSW5kZXhdICk7XG5cblx0XHRcdGFuUm93cy5wdXNoKCBuUm93ICk7XG5cdFx0XHRpUm93Q291bnQrKztcblx0XHR9XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0YW5Sb3dzWyAwIF0gPSBfZW1wdHlSb3cob1NldHRpbmdzKTtcblx0fVxuXG5cdC8qIEhlYWRlciBhbmQgZm9vdGVyIGNhbGxiYWNrcyAqL1xuXHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvSGVhZGVyQ2FsbGJhY2snLCAnaGVhZGVyJywgWyAkKG9TZXR0aW5ncy5uVEhlYWQpLmNoaWxkcmVuKCd0cicpWzBdLFxuXHRcdF9mbkdldERhdGFNYXN0ZXIoIG9TZXR0aW5ncyApLCBpRGlzcGxheVN0YXJ0LCBpRGlzcGxheUVuZCwgYWlEaXNwbGF5IF0gKTtcblxuXHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvRm9vdGVyQ2FsbGJhY2snLCAnZm9vdGVyJywgWyAkKG9TZXR0aW5ncy5uVEZvb3QpLmNoaWxkcmVuKCd0cicpWzBdLFxuXHRcdF9mbkdldERhdGFNYXN0ZXIoIG9TZXR0aW5ncyApLCBpRGlzcGxheVN0YXJ0LCBpRGlzcGxheUVuZCwgYWlEaXNwbGF5IF0gKTtcblxuXHQvLyByZXBsYWNlQ2hpbGRyZW4gaXMgZmFzdGVyLCBidXQgb25seSBiZWNhbWUgd2lkZXNwcmVhZCBpbiAyMDIwLFxuXHQvLyBzbyBhIGZhbGwgYmFjayBpbiBqUXVlcnkgaXMgcHJvdmlkZWQgZm9yIG9sZGVyIGJyb3dzZXJzLlxuXHRpZiAoYm9keVswXS5yZXBsYWNlQ2hpbGRyZW4pIHtcblx0XHRib2R5WzBdLnJlcGxhY2VDaGlsZHJlbi5hcHBseShib2R5WzBdLCBhblJvd3MpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGJvZHkuY2hpbGRyZW4oKS5kZXRhY2goKTtcblx0XHRib2R5LmFwcGVuZCggJChhblJvd3MpICk7XG5cdH1cblxuXHQvLyBFbXB0eSB0YWJsZSBuZWVkcyBhIHNwZWNpZmljIGNsYXNzXG5cdCQob1NldHRpbmdzLm5UYWJsZVdyYXBwZXIpLnRvZ2dsZUNsYXNzKCdkdC1lbXB0eS1mb290ZXInLCAkKCd0cicsIG9TZXR0aW5ncy5uVEZvb3QpLmxlbmd0aCA9PT0gMCk7XG5cblx0LyogQ2FsbCBhbGwgcmVxdWlyZWQgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgZW5kIG9mIGEgZHJhdyAqL1xuXHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgJ2RyYXcnLCBbb1NldHRpbmdzXSwgdHJ1ZSApO1xuXG5cdC8qIERyYXcgaXMgY29tcGxldGUsIHNvcnRpbmcgYW5kIGZpbHRlcmluZyBtdXN0IGJlIGFzIHdlbGwgKi9cblx0b1NldHRpbmdzLmJTb3J0ZWQgPSBmYWxzZTtcblx0b1NldHRpbmdzLmJGaWx0ZXJlZCA9IGZhbHNlO1xuXHRvU2V0dGluZ3MuYkRyYXdpbmcgPSBmYWxzZTtcbn1cblxuXG4vKipcbiAqIFJlZHJhdyB0aGUgdGFibGUgLSB0YWtpbmcgYWNjb3VudCBvZiB0aGUgdmFyaW91cyBmZWF0dXJlcyB3aGljaCBhcmUgZW5hYmxlZFxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2Jvb2xlYW59IFtob2xkUG9zaXRpb25dIEtlZXAgdGhlIGN1cnJlbnQgcGFnaW5nIHBvc2l0aW9uLiBCeSBkZWZhdWx0XG4gKiAgICB0aGUgcGFnaW5nIGlzIHJlc2V0IHRvIHRoZSBmaXJzdCBwYWdlXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblJlRHJhdyggc2V0dGluZ3MsIGhvbGRQb3NpdGlvbiwgcmVjb21wdXRlIClcbntcblx0dmFyXG5cdFx0ZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXMsXG5cdFx0c29ydCAgICAgPSBmZWF0dXJlcy5iU29ydCxcblx0XHRmaWx0ZXIgICA9IGZlYXR1cmVzLmJGaWx0ZXI7XG5cblx0aWYgKHJlY29tcHV0ZSA9PT0gdW5kZWZpbmVkIHx8IHJlY29tcHV0ZSA9PT0gdHJ1ZSkge1xuXHRcdC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cblx0XHRfZm5Db2x1bW5UeXBlcyggc2V0dGluZ3MgKTtcblxuXHRcdGlmICggc29ydCApIHtcblx0XHRcdF9mblNvcnQoIHNldHRpbmdzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBmaWx0ZXIgKSB7XG5cdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE5vIGZpbHRlcmluZywgc28gd2Ugd2FudCB0byBqdXN0IHVzZSB0aGUgZGlzcGxheSBtYXN0ZXJcblx0XHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdH1cblx0fVxuXG5cdGlmICggaG9sZFBvc2l0aW9uICE9PSB0cnVlICkge1xuXHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gMDtcblx0fVxuXG5cdC8vIExldCBhbnkgbW9kdWxlcyBrbm93IGFib3V0IHRoZSBkcmF3IGhvbGQgcG9zaXRpb24gc3RhdGUgKHVzZWQgYnlcblx0Ly8gc2Nyb2xsaW5nIGludGVybmFsbHkpXG5cdHNldHRpbmdzLl9kcmF3SG9sZCA9IGhvbGRQb3NpdGlvbjtcblxuXHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXG5cdHNldHRpbmdzLl9kcmF3SG9sZCA9IGZhbHNlO1xufVxuXG5cbi8qXG4gKiBUYWJsZSBpcyBlbXB0eSAtIGNyZWF0ZSBhIHJvdyB3aXRoIGFuIGVtcHR5IG1lc3NhZ2UgaW4gaXRcbiAqL1xuZnVuY3Rpb24gX2VtcHR5Um93ICggc2V0dGluZ3MgKSB7XG5cdHZhciBvTGFuZyA9IHNldHRpbmdzLm9MYW5ndWFnZTtcblx0dmFyIHplcm8gPSBvTGFuZy5zWmVyb1JlY29yZHM7XG5cdHZhciBkYXRhU3JjID0gX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKTtcblxuXHQvLyBNYWtlIHVzZSBvZiB0aGUgZmFjdCB0aGF0IHNldHRpbmdzLmpzb24gaXMgb25seSBzZXQgb25jZSB0aGUgaW5pdGlhbCBkYXRhIGhhc1xuXHQvLyBiZWVuIGxvYWRlZC4gU2hvdyBsb2FkaW5nIHdoZW4gdGhhdCBpc24ndCB0aGUgY2FzZVxuXHRpZiAoKGRhdGFTcmMgPT09ICdzc3AnIHx8IGRhdGFTcmMgPT09ICdhamF4JykgJiYgISBzZXR0aW5ncy5qc29uKSB7XG5cdFx0emVybyA9IG9MYW5nLnNMb2FkaW5nUmVjb3Jkcztcblx0fVxuXHRlbHNlIGlmICggb0xhbmcuc0VtcHR5VGFibGUgJiYgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSA9PT0gMCApXG5cdHtcblx0XHR6ZXJvID0gb0xhbmcuc0VtcHR5VGFibGU7XG5cdH1cblxuXHRyZXR1cm4gJCggJzx0ci8+JyApXG5cdFx0LmFwcGVuZCggJCgnPHRkIC8+Jywge1xuXHRcdFx0J2NvbFNwYW4nOiBfZm5WaXNibGVDb2x1bW5zKCBzZXR0aW5ncyApLFxuXHRcdFx0J2NsYXNzJzogICBzZXR0aW5ncy5vQ2xhc3Nlcy5lbXB0eS5yb3dcblx0XHR9ICkuaHRtbCggemVybyApIClbMF07XG59XG5cblxuLyoqXG4gKiBFeHBhbmQgdGhlIGxheW91dCBpdGVtcyBpbnRvIGFuIG9iamVjdCBmb3IgdGhlIHJlbmRlcmluZyBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBfbGF5b3V0SXRlbXMgKHJvdywgYWxpZ24sIGl0ZW1zKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheShpdGVtcykpIHtcblx0XHRmb3IgKHZhciBpPTAgOyBpPGl0ZW1zLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0X2xheW91dEl0ZW1zKHJvdywgYWxpZ24sIGl0ZW1zW2ldKTtcblx0XHR9XG5cblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgcm93Q2VsbCA9IHJvd1thbGlnbl07XG5cblx0Ly8gSWYgaXQgaXMgYW4gb2JqZWN0LCB0aGVuIHRoZXJlIGNhbiBiZSBtdWx0aXBsZSBmZWF0dXJlcyBjb250YWluZWQgaW4gaXRcblx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIGl0ZW1zICkgKSB7XG5cdFx0Ly8gQSBmZWF0dXJlIHBsdWdpbiBjYW5ub3QgYmUgbmFtZWQgXCJmZWF0dXJlc1wiIGR1ZSB0byB0aGlzIGNoZWNrXG5cdFx0aWYgKGl0ZW1zLmZlYXR1cmVzKSB7XG5cdFx0XHRpZiAoaXRlbXMucm93SWQpIHtcblx0XHRcdFx0cm93LmlkID0gaXRlbXMucm93SWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXRlbXMucm93Q2xhc3MpIHtcblx0XHRcdFx0cm93LmNsYXNzTmFtZSA9IGl0ZW1zLnJvd0NsYXNzO1xuXHRcdFx0fVxuXG5cdFx0XHRyb3dDZWxsLmlkID0gaXRlbXMuaWQ7XG5cdFx0XHRyb3dDZWxsLmNsYXNzTmFtZSA9IGl0ZW1zLmNsYXNzTmFtZTtcblxuXHRcdFx0X2xheW91dEl0ZW1zKHJvdywgYWxpZ24sIGl0ZW1zLmZlYXR1cmVzKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRPYmplY3Qua2V5cyhpdGVtcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0cm93Q2VsbC5jb250ZW50cy5wdXNoKCB7XG5cdFx0XHRcdFx0ZmVhdHVyZToga2V5LFxuXHRcdFx0XHRcdG9wdHM6IGl0ZW1zW2tleV1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0cm93Q2VsbC5jb250ZW50cy5wdXNoKGl0ZW1zKTtcblx0fVxufVxuXG4vKipcbiAqIEZpbmQsIG9yIGNyZWF0ZSBhIGxheW91dCByb3dcbiAqL1xuZnVuY3Rpb24gX2xheW91dEdldFJvdyhyb3dzLCByb3dOdW0sIGFsaWduKSB7XG5cdHZhciByb3c7XG5cblx0Ly8gRmluZCBleGlzdGluZyByb3dzXG5cdGZvciAodmFyIGk9MDsgaTxyb3dzLmxlbmd0aDsgaSsrKSB7XG5cdFx0cm93ID0gcm93c1tpXTtcblxuXHRcdGlmIChyb3cucm93TnVtID09PSByb3dOdW0pIHtcblx0XHRcdC8vIGZ1bGwgaXMgb24gaXRzIG93biwgYnV0IHN0YXJ0IGFuZCBlbmQgc2hhcmUgYSByb3dcblx0XHRcdGlmIChcblx0XHRcdFx0KGFsaWduID09PSAnZnVsbCcgJiYgcm93LmZ1bGwpIHx8XG5cdFx0XHRcdCgoYWxpZ24gPT09ICdzdGFydCcgfHwgYWxpZ24gPT09ICdlbmQnKSAmJiAocm93LnN0YXJ0IHx8IHJvdy5lbmQpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmICghIHJvd1thbGlnbl0pIHtcblx0XHRcdFx0XHRyb3dbYWxpZ25dID0ge1xuXHRcdFx0XHRcdFx0Y29udGVudHM6IFtdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByb3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgd2UgZ2V0IHRoaXMgZmFyLCB0aGVuIHRoZXJlIHdhcyBubyBtYXRjaCwgY3JlYXRlIGEgbmV3IHJvd1xuXHRyb3cgPSB7XG5cdFx0cm93TnVtOiByb3dOdW1cdFxuXHR9O1xuXG5cdHJvd1thbGlnbl0gPSB7XG5cdFx0Y29udGVudHM6IFtdXG5cdH07XG5cblx0cm93cy5wdXNoKHJvdyk7XG5cblx0cmV0dXJuIHJvdztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgYGxheW91dGAgb2JqZWN0IGdpdmVuIGJ5IGEgdXNlciB0byB0aGUgb2JqZWN0IHN0cnVjdHVyZSBuZWVkZWRcbiAqIGZvciB0aGUgcmVuZGVyZXIuIFRoaXMgaXMgZG9uZSB0d2ljZSwgb25jZSBmb3IgYWJvdmUgYW5kIG9uY2UgZm9yIGJlbG93XG4gKiB0aGUgdGFibGUuIE9yZGVyaW5nIG11c3QgYWxzbyBiZSBjb25zaWRlcmVkLlxuICpcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gbGF5b3V0IExheW91dCBvYmplY3QgdG8gY29udmVydFxuICogQHBhcmFtIHtzdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGJvdHRvbWBcbiAqIEByZXR1cm5zIENvbnZlcnRlZCBhcnJheSBzdHJ1Y3R1cmUgLSBvbmUgaXRlbSBmb3IgZWFjaCByb3cuXG4gKi9cbmZ1bmN0aW9uIF9sYXlvdXRBcnJheSAoIHNldHRpbmdzLCBsYXlvdXQsIHNpZGUgKSB7XG5cdHZhciByb3dzID0gW107XG5cdFxuXHQvLyBTcGxpdCBvdXQgaW50byBhbiBhcnJheVxuXHQkLmVhY2goIGxheW91dCwgZnVuY3Rpb24gKCBwb3MsIGl0ZW1zICkge1xuXHRcdGlmIChpdGVtcyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBwYXJ0cyA9IHBvcy5tYXRjaCgvXihbYS16XSspKFswLTldKikoW0EtWmEtel0qKSQvKTtcblx0XHR2YXIgcm93TnVtID0gcGFydHNbMl1cblx0XHRcdD8gcGFydHNbMl0gKiAxXG5cdFx0XHQ6IDA7XG5cdFx0dmFyIGFsaWduID0gcGFydHNbM11cblx0XHRcdD8gcGFydHNbM10udG9Mb3dlckNhc2UoKVxuXHRcdFx0OiAnZnVsbCc7XG5cblx0XHQvLyBGaWx0ZXIgb3V0IHRoZSBzaWRlIHdlIGFyZW4ndCBpbnRlcmVzdGVkIGluXG5cdFx0aWYgKHBhcnRzWzFdICE9PSBzaWRlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IG9yIGNyZWF0ZSB0aGUgcm93IHdlIHNob3VsZCBhdHRhY2ggdG9cblx0XHR2YXIgcm93ID0gX2xheW91dEdldFJvdyhyb3dzLCByb3dOdW0sIGFsaWduKTtcblxuXHRcdF9sYXlvdXRJdGVtcyhyb3csIGFsaWduLCBpdGVtcyk7XG5cdH0pO1xuXG5cdC8vIE9yZGVyIGJ5IGl0ZW0gaWRlbnRpZmllclxuXHRyb3dzLnNvcnQoIGZ1bmN0aW9uICggYSwgYiApIHtcblx0XHR2YXIgb3JkZXIxID0gYS5yb3dOdW07XG5cdFx0dmFyIG9yZGVyMiA9IGIucm93TnVtO1xuXG5cdFx0Ly8gSWYgYm90aCBpbiB0aGUgc2FtZSByb3csIHRoZW4gdGhlIHJvdyB3aXRoIGBmdWxsYCBjb21lcyBmaXJzdFxuXHRcdGlmIChvcmRlcjEgPT09IG9yZGVyMikge1xuXHRcdFx0dmFyIHJldCA9IGEuZnVsbCAmJiAhIGIuZnVsbCA/IC0xIDogMTtcblxuXHRcdFx0cmV0dXJuIHNpZGUgPT09ICdib3R0b20nXG5cdFx0XHRcdD8gcmV0ICogLTFcblx0XHRcdFx0OiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9yZGVyMiAtIG9yZGVyMTtcblx0fSApO1xuXG5cdC8vIEludmVydCBmb3IgYmVsb3cgdGhlIHRhYmxlXG5cdGlmICggc2lkZSA9PT0gJ2JvdHRvbScgKSB7XG5cdFx0cm93cy5yZXZlcnNlKCk7XG5cdH1cblxuXHRmb3IgKHZhciByb3cgPSAwOyByb3c8cm93cy5sZW5ndGg7IHJvdysrKSB7XG5cdFx0ZGVsZXRlIHJvd3Nbcm93XS5yb3dOdW07XG5cblx0XHRfbGF5b3V0UmVzb2x2ZShzZXR0aW5ncywgcm93c1tyb3ddKTtcblx0fVxuXG5cdHJldHVybiByb3dzO1xufVxuXG5cbi8qKlxuICogQ29udmVydCB0aGUgY29udGVudHMgb2YgYSByb3cncyBsYXlvdXQgb2JqZWN0IHRvIG5vZGVzIHRoYXQgY2FuIGJlIGluc2VydGVkXG4gKiBpbnRvIHRoZSBkb2N1bWVudCBieSBhIHJlbmRlcmVyLiBFeGVjdXRlIGZ1bmN0aW9ucywgbG9vayB1cCBwbHVnLWlucywgZXRjLlxuICpcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gcm93IExheW91dCBvYmplY3QgZm9yIHRoaXMgcm93XG4gKi9cbmZ1bmN0aW9uIF9sYXlvdXRSZXNvbHZlKCBzZXR0aW5ncywgcm93ICkge1xuXHR2YXIgZ2V0RmVhdHVyZSA9IGZ1bmN0aW9uIChmZWF0dXJlLCBvcHRzKSB7XG5cdFx0aWYgKCAhIF9leHQuZmVhdHVyZXNbIGZlYXR1cmUgXSApIHtcblx0XHRcdF9mbkxvZyggc2V0dGluZ3MsIDAsICdVbmtub3duIGZlYXR1cmU6ICcrIGZlYXR1cmUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gX2V4dC5mZWF0dXJlc1sgZmVhdHVyZSBdLmFwcGx5KCB0aGlzLCBbc2V0dGluZ3MsIG9wdHNdICk7XG5cdH07XG5cblx0dmFyIHJlc29sdmUgPSBmdW5jdGlvbiAoIGl0ZW0gKSB7XG5cdFx0aWYgKCEgcm93WyBpdGVtIF0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbGluZSA9IHJvd1sgaXRlbSBdLmNvbnRlbnRzO1xuXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWxpbmUubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoICEgbGluZVtpXSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZW9mIGxpbmVbaV0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRsaW5lW2ldID0gZ2V0RmVhdHVyZSggbGluZVtpXSwgbnVsbCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdChsaW5lW2ldKSApIHtcblx0XHRcdFx0Ly8gSWYgaXQncyBhbiBvYmplY3QsIGl0IGp1c3QgaGFzIGZlYXR1cmUgYW5kIG9wdHMgcHJvcGVydGllcyBmcm9tXG5cdFx0XHRcdC8vIHRoZSB0cmFuc2Zvcm0gaW4gX2xheW91dEFycmF5XG5cdFx0XHRcdGxpbmVbaV0gPSBnZXRGZWF0dXJlKGxpbmVbaV0uZmVhdHVyZSwgbGluZVtpXS5vcHRzKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgbGluZVtpXS5ub2RlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRsaW5lW2ldID0gbGluZVtpXS5ub2RlKCBzZXR0aW5ncyApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiBsaW5lW2ldID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHR2YXIgaW5zdCA9IGxpbmVbaV0oIHNldHRpbmdzICk7XG5cblx0XHRcdFx0bGluZVtpXSA9IHR5cGVvZiBpbnN0Lm5vZGUgPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHRcdGluc3Qubm9kZSgpIDpcblx0XHRcdFx0XHRpbnN0O1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRyZXNvbHZlKCdzdGFydCcpO1xuXHRyZXNvbHZlKCdlbmQnKTtcblx0cmVzb2x2ZSgnZnVsbCcpO1xufVxuXG5cbi8qKlxuICogQWRkIHRoZSBvcHRpb25zIHRvIHRoZSBwYWdlIEhUTUwgZm9yIHRoZSB0YWJsZVxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5BZGRPcHRpb25zSHRtbCAoIHNldHRpbmdzIClcbntcblx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0dmFyIHRhYmxlID0gJChzZXR0aW5ncy5uVGFibGUpO1xuXG5cdC8vIFdyYXBwZXIgZGl2IGFyb3VuZCBldmVyeXRoaW5nIERhdGFUYWJsZXMgY29udHJvbHNcblx0dmFyIGluc2VydCA9ICQoJzxkaXYvPicpXG5cdFx0LmF0dHIoe1xuXHRcdFx0aWQ6ICAgICAgc2V0dGluZ3Muc1RhYmxlSWQrJ193cmFwcGVyJyxcblx0XHRcdCdjbGFzcyc6IGNsYXNzZXMuY29udGFpbmVyXG5cdFx0fSlcblx0XHQuaW5zZXJ0QmVmb3JlKHRhYmxlKTtcblxuXHRzZXR0aW5ncy5uVGFibGVXcmFwcGVyID0gaW5zZXJ0WzBdO1xuXG5cdGlmIChzZXR0aW5ncy5zRG9tKSB7XG5cdFx0Ly8gTGVnYWN5XG5cdFx0X2ZuTGF5b3V0RG9tKHNldHRpbmdzLCBzZXR0aW5ncy5zRG9tLCBpbnNlcnQpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHZhciB0b3AgPSBfbGF5b3V0QXJyYXkoIHNldHRpbmdzLCBzZXR0aW5ncy5sYXlvdXQsICd0b3AnICk7XG5cdFx0dmFyIGJvdHRvbSA9IF9sYXlvdXRBcnJheSggc2V0dGluZ3MsIHNldHRpbmdzLmxheW91dCwgJ2JvdHRvbScgKTtcblx0XHR2YXIgcmVuZGVyZXIgPSBfZm5SZW5kZXJlciggc2V0dGluZ3MsICdsYXlvdXQnICk7XG5cdFxuXHRcdC8vIEV2ZXJ5dGhpbmcgYWJvdmUgLSB0aGUgcmVuZGVyZXIgd2lsbCBhY3R1YWxseSBpbnNlcnQgdGhlIGNvbnRlbnRzIGludG8gdGhlIGRvY3VtZW50XG5cdFx0dG9wLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHJlbmRlcmVyKCBzZXR0aW5ncywgaW5zZXJ0LCBpdGVtICk7XG5cdFx0fSk7XG5cblx0XHQvLyBUaGUgdGFibGUgLSBhbHdheXMgdGhlIGNlbnRlciBvZiBhdHRlbnRpb25cblx0XHRyZW5kZXJlciggc2V0dGluZ3MsIGluc2VydCwge1xuXHRcdFx0ZnVsbDoge1xuXHRcdFx0XHR0YWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29udGVudHM6IFsgX2ZuRmVhdHVyZUh0bWxUYWJsZShzZXR0aW5ncykgXVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIEV2ZXJ5dGhpbmcgYmVsb3dcblx0XHRib3R0b20uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0cmVuZGVyZXIoIHNldHRpbmdzLCBpbnNlcnQsIGl0ZW0gKTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIFByb2Nlc3NpbmcgZmxvYXRzIG9uIHRvcCwgc28gaXQgaXNuJ3QgYW4gaW5zZXJ0ZWQgZmVhdHVyZVxuXHRfcHJvY2Vzc2luZ0h0bWwoIHNldHRpbmdzICk7XG59XG5cbi8qKlxuICogRHJhdyB0aGUgdGFibGUgd2l0aCB0aGUgbGVnYWN5IERPTSBwcm9wZXJ0eVxuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEVCBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gZG9tIERPTSBzdHJpbmdcbiAqIEBwYXJhbSB7Kn0gaW5zZXJ0IEluc2VydCBwb2ludFxuICovXG5mdW5jdGlvbiBfZm5MYXlvdXREb20oIHNldHRpbmdzLCBkb20sIGluc2VydCApXG57XG5cdHZhciBwYXJ0cyA9IGRvbS5tYXRjaCgvKFwiLio/XCIpfCgnLio/Jyl8Li9nKTtcblx0dmFyIGZlYXR1cmVOb2RlLCBvcHRpb24sIG5ld05vZGUsIG5leHQsIGF0dHI7XG5cblx0Zm9yICggdmFyIGk9MCA7IGk8cGFydHMubGVuZ3RoIDsgaSsrICkge1xuXHRcdGZlYXR1cmVOb2RlID0gbnVsbDtcblx0XHRvcHRpb24gPSBwYXJ0c1tpXTtcblxuXHRcdGlmICggb3B0aW9uID09ICc8JyApIHtcblx0XHRcdC8vIE5ldyBjb250YWluZXIgZGl2XG5cdFx0XHRuZXdOb2RlID0gJCgnPGRpdi8+Jyk7XG5cblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgYXBwZW5kIGFuIGlkIGFuZC9vciBhIGNsYXNzIG5hbWUgdG8gdGhlIGNvbnRhaW5lclxuXHRcdFx0bmV4dCA9IHBhcnRzW2krMV07XG5cblx0XHRcdGlmICggbmV4dFswXSA9PSBcIidcIiB8fCBuZXh0WzBdID09ICdcIicgKSB7XG5cdFx0XHRcdGF0dHIgPSBuZXh0LnJlcGxhY2UoL1snXCJdL2csICcnKTtcblxuXHRcdFx0XHR2YXIgaWQgPSAnJywgY2xhc3NOYW1lO1xuXG5cdFx0XHRcdC8qIFRoZSBhdHRyaWJ1dGUgY2FuIGJlIGluIHRoZSBmb3JtYXQgb2YgXCIjaWQuY2xhc3NcIiwgXCIjaWRcIiBvciBcImNsYXNzXCIgVGhpcyBsb2dpY1xuXHRcdFx0XHQgKiBicmVha3MgdGhlIHN0cmluZyBpbnRvIHBhcnRzIGFuZCBhcHBsaWVzIHRoZW0gYXMgbmVlZGVkXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHRpZiAoIGF0dHIuaW5kZXhPZignLicpICE9IC0xICkge1xuXHRcdFx0XHRcdHZhciBzcGxpdCA9IGF0dHIuc3BsaXQoJy4nKTtcblxuXHRcdFx0XHRcdGlkID0gc3BsaXRbMF07XG5cdFx0XHRcdFx0Y2xhc3NOYW1lID0gc3BsaXRbMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJbMF0gPT0gXCIjXCIgKSB7XG5cdFx0XHRcdFx0aWQgPSBhdHRyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNsYXNzTmFtZSA9IGF0dHI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuZXdOb2RlXG5cdFx0XHRcdFx0LmF0dHIoJ2lkJywgaWQuc3Vic3RyaW5nKDEpKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyhjbGFzc05hbWUpO1xuXG5cdFx0XHRcdGkrKzsgLy8gTW92ZSBhbG9uZyB0aGUgcG9zaXRpb24gYXJyYXlcblx0XHRcdH1cblxuXHRcdFx0aW5zZXJ0LmFwcGVuZCggbmV3Tm9kZSApO1xuXHRcdFx0aW5zZXJ0ID0gbmV3Tm9kZTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9wdGlvbiA9PSAnPicgKSB7XG5cdFx0XHQvLyBFbmQgY29udGFpbmVyIGRpdlxuXHRcdFx0aW5zZXJ0ID0gaW5zZXJ0LnBhcmVudCgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggb3B0aW9uID09ICd0JyApIHtcblx0XHRcdC8vIFRhYmxlXG5cdFx0XHRmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sVGFibGUoIHNldHRpbmdzICk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHREYXRhVGFibGUuZXh0LmZlYXR1cmUuZm9yRWFjaChmdW5jdGlvbihmZWF0dXJlKSB7XG5cdFx0XHRcdGlmICggb3B0aW9uID09IGZlYXR1cmUuY0ZlYXR1cmUgKSB7XG5cdFx0XHRcdFx0ZmVhdHVyZU5vZGUgPSBmZWF0dXJlLmZuSW5pdCggc2V0dGluZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRvIHRoZSBkaXNwbGF5XG5cdFx0aWYgKCBmZWF0dXJlTm9kZSApIHtcblx0XHRcdGluc2VydC5hcHBlbmQoIGZlYXR1cmVOb2RlICk7XG5cdFx0fVxuXHR9XG59XG5cblxuLyoqXG4gKiBVc2UgdGhlIERPTSBzb3VyY2UgdG8gY3JlYXRlIHVwIGFuIGFycmF5IG9mIGhlYWRlciBjZWxscy4gVGhlIGlkZWEgaGVyZSBpcyB0b1xuICogY3JlYXRlIGEgbGF5b3V0IGdyaWQgKGFycmF5KSBvZiByb3dzIHggY29sdW1ucywgd2hpY2ggY29udGFpbnMgYSByZWZlcmVuY2VcbiAqIHRvIHRoZSBjZWxsIHRoYXQgdGhhdCBwb2ludCBpbiB0aGUgZ3JpZCAocmVnYXJkbGVzcyBvZiBjb2wvcm93c3BhbiksIHN1Y2ggdGhhdFxuICogYW55IGNvbHVtbiAvIHJvdyBjb3VsZCBiZSByZW1vdmVkIGFuZCB0aGUgbmV3IGdyaWQgY29uc3RydWN0ZWRcbiAqICBAcGFyYW0ge25vZGV9IHRoZWFkIFRoZSBoZWFkZXIvZm9vdGVyIGVsZW1lbnQgZm9yIHRoZSB0YWJsZVxuICogIEByZXR1cm5zIHthcnJheX0gQ2FsY3VsYXRlZCBsYXlvdXQgYXJyYXlcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuRGV0ZWN0SGVhZGVyICggc2V0dGluZ3MsIHRoZWFkLCB3cml0ZSApXG57XG5cdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHR2YXIgcm93cyA9ICQodGhlYWQpLmNoaWxkcmVuKCd0cicpO1xuXHR2YXIgcm93LCBjZWxsO1xuXHR2YXIgaSwgaywgbCwgaUxlbiwgc2hpZnRlZCwgY29sdW1uLCBjb2xzcGFuLCByb3dzcGFuO1xuXHR2YXIgdGl0bGVSb3cgPSBzZXR0aW5ncy50aXRsZVJvdztcblx0dmFyIGlzSGVhZGVyID0gdGhlYWQgJiYgdGhlYWQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RoZWFkJztcblx0dmFyIGxheW91dCA9IFtdO1xuXHR2YXIgdW5pcXVlO1xuXHR2YXIgc2hpZnQgPSBmdW5jdGlvbiAoIGEsIGksIGogKSB7XG5cdFx0dmFyIGsgPSBhW2ldO1xuXHRcdHdoaWxlICgga1tqXSApIHtcblx0XHRcdGorKztcblx0XHR9XG5cdFx0cmV0dXJuIGo7XG5cdH07XG5cblx0Ly8gV2Uga25vdyBob3cgbWFueSByb3dzIHRoZXJlIGFyZSBpbiB0aGUgbGF5b3V0IC0gc28gcHJlcCBpdFxuXHRmb3IgKCBpPTAsIGlMZW49cm93cy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0bGF5b3V0LnB1c2goIFtdICk7XG5cdH1cblxuXHRmb3IgKCBpPTAsIGlMZW49cm93cy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0cm93ID0gcm93c1tpXTtcblx0XHRjb2x1bW4gPSAwO1xuXG5cdFx0Ly8gRm9yIGV2ZXJ5IGNlbGwgaW4gdGhlIHJvdy4uXG5cdFx0Y2VsbCA9IHJvdy5maXJzdENoaWxkO1xuXHRcdHdoaWxlICggY2VsbCApIHtcblx0XHRcdGlmIChcblx0XHRcdFx0Y2VsbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09ICdURCcgfHxcblx0XHRcdFx0Y2VsbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09ICdUSCdcblx0XHRcdCkge1xuXHRcdFx0XHR2YXIgY29scyA9IFtdO1xuXHRcdFx0XHR2YXIganFDZWxsID0gJChjZWxsKTtcblxuXHRcdFx0XHQvLyBHZXQgdGhlIGNvbCBhbmQgcm93c3BhbiBhdHRyaWJ1dGVzIGZyb20gdGhlIERPTSBhbmQgc2FuaXRpc2UgdGhlbVxuXHRcdFx0XHRjb2xzcGFuID0gY2VsbC5nZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nKSAqIDE7XG5cdFx0XHRcdHJvd3NwYW4gPSBjZWxsLmdldEF0dHJpYnV0ZSgncm93c3BhbicpICogMTtcblx0XHRcdFx0Y29sc3BhbiA9ICghY29sc3BhbiB8fCBjb2xzcGFuPT09MCB8fCBjb2xzcGFuPT09MSkgPyAxIDogY29sc3Bhbjtcblx0XHRcdFx0cm93c3BhbiA9ICghcm93c3BhbiB8fCByb3dzcGFuPT09MCB8fCByb3dzcGFuPT09MSkgPyAxIDogcm93c3BhbjtcblxuXHRcdFx0XHQvLyBUaGVyZSBtaWdodCBiZSBjb2xzcGFuIGNlbGxzIGFscmVhZHkgaW4gdGhpcyByb3csIHNvIHNoaWZ0IG91ciB0YXJnZXRcblx0XHRcdFx0Ly8gYWNjb3JkaW5nbHlcblx0XHRcdFx0c2hpZnRlZCA9IHNoaWZ0KCBsYXlvdXQsIGksIGNvbHVtbiApO1xuXG5cdFx0XHRcdC8vIENhY2hlIGNhbGN1bGF0aW9uIGZvciB1bmlxdWUgY29sdW1uc1xuXHRcdFx0XHR1bmlxdWUgPSBjb2xzcGFuID09PSAxID9cblx0XHRcdFx0XHR0cnVlIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFBlcmZvcm0gaGVhZGVyIHNldHVwXG5cdFx0XHRcdGlmICggd3JpdGUgKSB7XG5cdFx0XHRcdFx0aWYgKHVuaXF1ZSkge1xuXHRcdFx0XHRcdFx0Ly8gQWxsb3cgY29sdW1uIG9wdGlvbnMgdG8gYmUgc2V0IGZyb20gSFRNTCBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRfZm5Db2x1bW5PcHRpb25zKCBzZXR0aW5ncywgc2hpZnRlZCwganFDZWxsLmRhdGEoKSApO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHdpZHRoIGZvciB0aGUgY29sdW1uLiBUaGlzIGNhbiBiZSBkZWZpbmVkIGZyb20gdGhlXG5cdFx0XHRcdFx0XHQvLyB3aWR0aCBhdHRyaWJ1dGUsIHN0eWxlIGF0dHJpYnV0ZSBvciBgY29sdW1ucy53aWR0aGAgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YXIgY29sdW1uRGVmID0gY29sdW1uc1tzaGlmdGVkXTtcblx0XHRcdFx0XHRcdHZhciB3aWR0aCA9IGNlbGwuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIHx8IG51bGw7XG5cdFx0XHRcdFx0XHR2YXIgdCA9IGNlbGwuc3R5bGUud2lkdGgubWF0Y2goL3dpZHRoOlxccyooXFxkK1tweGVtJV0rKS8pO1xuXHRcdFx0XHRcdFx0aWYgKCB0ICkge1xuXHRcdFx0XHRcdFx0XHR3aWR0aCA9IHRbMV07XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbHVtbkRlZi5zV2lkdGhPcmlnID0gY29sdW1uRGVmLnNXaWR0aCB8fCB3aWR0aDtcblxuXHRcdFx0XHRcdFx0aWYgKGlzSGVhZGVyKSB7XG5cdFx0XHRcdFx0XHRcdC8vIENvbHVtbiB0aXRsZSBoYW5kbGluZyAtIGNhbiBiZSB1c2VyIHNldCwgb3IgcmVhZCBmcm9tIHRoZSBET01cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBoYXBwZW5zIGJlZm9yZSB0aGUgcmVuZGVyLCBzbyB0aGUgb3JpZ2luYWwgaXMgc3RpbGwgaW4gcGxhY2Vcblx0XHRcdFx0XHRcdFx0aWYgKCBjb2x1bW5EZWYuc1RpdGxlICE9PSBudWxsICYmICEgY29sdW1uRGVmLmF1dG9UaXRsZSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0XHQodGl0bGVSb3cgPT09IHRydWUgJiYgaSA9PT0gMCkgfHwgLy8gdG9wIHJvd1xuXHRcdFx0XHRcdFx0XHRcdFx0KHRpdGxlUm93ID09PSBmYWxzZSAmJiBpID09PSByb3dzLmxlbmd0aCAtMSkgfHwgLy8gYm90dG9tIHJvd1xuXHRcdFx0XHRcdFx0XHRcdFx0KHRpdGxlUm93ID09PSBpKSB8fCAvLyBzcGVjaWZpYyByb3dcblx0XHRcdFx0XHRcdFx0XHRcdCh0aXRsZVJvdyA9PT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNlbGwuaW5uZXJIVE1MID0gY29sdW1uRGVmLnNUaXRsZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoISBjb2x1bW5EZWYuc1RpdGxlICYmIHVuaXF1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbHVtbkRlZi5zVGl0bGUgPSBfc3RyaXBIdG1sKGNlbGwuaW5uZXJIVE1MKTtcblx0XHRcdFx0XHRcdFx0XHRjb2x1bW5EZWYuYXV0b1RpdGxlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIEZvb3RlciBzcGVjaWZpYyBvcGVyYXRpb25zXG5cdFx0XHRcdFx0XHRcdGlmIChjb2x1bW5EZWYuZm9vdGVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2VsbC5pbm5lckhUTUwgPSBjb2x1bW5EZWYuZm9vdGVyO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEZhbGwgYmFjayB0byB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUgb24gdGhlIHRhYmxlIGhlYWRlciBpZiBubyBhcmlhVGl0bGUgaXNcblx0XHRcdFx0XHRcdC8vIHByb3ZpZGVkLlxuXHRcdFx0XHRcdFx0aWYgKCEgY29sdW1uRGVmLmFyaWFUaXRsZSkge1xuXHRcdFx0XHRcdFx0XHRjb2x1bW5EZWYuYXJpYVRpdGxlID0ganFDZWxsLmF0dHIoXCJhcmlhLWxhYmVsXCIpIHx8IGNvbHVtbkRlZi5zVGl0bGU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIENvbHVtbiBzcGVjaWZpYyBjbGFzcyBuYW1lc1xuXHRcdFx0XHRcdFx0aWYgKCBjb2x1bW5EZWYuY2xhc3NOYW1lICkge1xuXHRcdFx0XHRcdFx0XHRqcUNlbGwuYWRkQ2xhc3MoIGNvbHVtbkRlZi5jbGFzc05hbWUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBXcmFwIHRoZSBjb2x1bW4gdGl0bGUgc28gd2UgY2FuIHdyaXRlIHRvIGl0IGluIGZ1dHVyZVxuXHRcdFx0XHRcdGlmICggJCgnc3Bhbi5kdC1jb2x1bW4tdGl0bGUnLCBjZWxsKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdCQoJzxzcGFuPicpXG5cdFx0XHRcdFx0XHRcdC5hZGRDbGFzcygnZHQtY29sdW1uLXRpdGxlJylcblx0XHRcdFx0XHRcdFx0LmFwcGVuZChjZWxsLmNoaWxkTm9kZXMpXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmRUbyhjZWxsKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRzZXR0aW5ncy5vcmRlckluZGljYXRvcnMgJiZcblx0XHRcdFx0XHRcdGlzSGVhZGVyICYmXG5cdFx0XHRcdFx0XHRqcUNlbGwuZmlsdGVyKCc6bm90KFtkYXRhLWR0LW9yZGVyPWRpc2FibGVdKScpLmxlbmd0aCAhPT0gMCAmJlxuXHRcdFx0XHRcdFx0anFDZWxsLnBhcmVudCgnOm5vdChbZGF0YS1kdC1vcmRlcj1kaXNhYmxlXSknKS5sZW5ndGggIT09IDAgJiZcblx0XHRcdFx0XHRcdCQoJ3NwYW4uZHQtY29sdW1uLW9yZGVyJywgY2VsbCkubGVuZ3RoID09PSAwXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHQkKCc8c3Bhbj4nKVxuXHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3MoJ2R0LWNvbHVtbi1vcmRlcicpXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmRUbyhjZWxsKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIHdyYXAgdGhlIGVsZW1lbnRzIGluIHRoZSBoZWFkZXIgaW4gYW5vdGhlciBlbGVtZW50IHRvIHVzZSBmbGV4Ym94XG5cdFx0XHRcdFx0Ly8gbGF5b3V0IGZvciB0aG9zZSBlbGVtZW50c1xuXHRcdFx0XHRcdHZhciBoZWFkZXJGb290ZXIgPSBpc0hlYWRlciA/ICdoZWFkZXInIDogJ2Zvb3Rlcic7XG5cblx0XHRcdFx0XHRpZiAoICQoJ3NwYW4uZHQtY29sdW1uLScgKyBoZWFkZXJGb290ZXIsIGNlbGwpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0JCgnPGRpdj4nKVxuXHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3MoJ2R0LWNvbHVtbi0nICsgaGVhZGVyRm9vdGVyKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kKGNlbGwuY2hpbGROb2Rlcylcblx0XHRcdFx0XHRcdFx0LmFwcGVuZFRvKGNlbGwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGNvbCAvIHJvd3NwYW4sIGNvcHkgdGhlIGluZm9ybWF0aW9uIGludG8gdGhlIGxheW91dCBncmlkXG5cdFx0XHRcdGZvciAoIGw9MCA7IGw8Y29sc3BhbiA7IGwrKyApIHtcblx0XHRcdFx0XHRmb3IgKCBrPTAgOyBrPHJvd3NwYW4gOyBrKysgKSB7XG5cdFx0XHRcdFx0XHRsYXlvdXRbaStrXVtzaGlmdGVkK2xdID0ge1xuXHRcdFx0XHRcdFx0XHRjZWxsOiBjZWxsLFxuXHRcdFx0XHRcdFx0XHR1bmlxdWU6IHVuaXF1ZVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0bGF5b3V0W2kra10ucm93ID0gcm93O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbHMucHVzaCggc2hpZnRlZCtsICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBc3NpZ24gYW4gYXR0cmlidXRlIHNvIHNwYW5uaW5nIGNlbGxzIGNhbiBzdGlsbCBiZSBpZGVudGlmaWVkXG5cdFx0XHRcdC8vIGFzIGJlbG9uZ2luZyB0byBhIGNvbHVtblxuXHRcdFx0XHRjZWxsLnNldEF0dHJpYnV0ZSgnZGF0YS1kdC1jb2x1bW4nLCBfdW5pcXVlKGNvbHMpLmpvaW4oJywnKSk7XG5cdFx0XHR9XG5cblx0XHRcdGNlbGwgPSBjZWxsLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBsYXlvdXQ7XG59XG5cbi8qKlxuICogU2V0IHRoZSBzdGFydCBwb3NpdGlvbiBmb3IgZHJhd1xuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gX2ZuU3RhcnQoIG9TZXR0aW5ncyApXG57XG5cdHZhciBiU2VydmVyU2lkZSA9IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09ICdzc3AnO1xuXHR2YXIgaUluaXREaXNwbGF5U3RhcnQgPSBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQ7XG5cblx0Ly8gQ2hlY2sgYW5kIHNlZSBpZiB3ZSBoYXZlIGFuIGluaXRpYWwgZHJhdyBwb3NpdGlvbiBmcm9tIHN0YXRlIHNhdmluZ1xuXHRpZiAoIGlJbml0RGlzcGxheVN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgaUluaXREaXNwbGF5U3RhcnQgIT09IC0xIClcblx0e1xuXHRcdG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IGJTZXJ2ZXJTaWRlID9cblx0XHRcdGlJbml0RGlzcGxheVN0YXJ0IDpcblx0XHRcdGlJbml0RGlzcGxheVN0YXJ0ID49IG9TZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCkgP1xuXHRcdFx0XHQwIDpcblx0XHRcdFx0aUluaXREaXNwbGF5U3RhcnQ7XG5cblx0XHRvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSAtMTtcblx0fVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBBamF4IGNhbGwgYmFzZWQgb24gdGhlIHRhYmxlJ3Mgc2V0dGluZ3MsIHRha2luZyBpbnRvIGFjY291bnQgdGhhdFxuICogcGFyYW1ldGVycyBjYW4gaGF2ZSBtdWx0aXBsZSBmb3JtcywgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgRGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIsIHJlcXVpcmVkIGJ5XG4gKiAgICAgRGF0YVRhYmxlcyAtIG1heSBiZSBhdWdtZW50ZWQgYnkgZGV2ZWxvcGVyIGNhbGxiYWNrc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIHdoZW4gZGF0YSBpcyBvYnRhaW5lZFxuICovXG5mdW5jdGlvbiBfZm5CdWlsZEFqYXgoIG9TZXR0aW5ncywgZGF0YSwgZm4gKVxue1xuXHR2YXIgYWpheERhdGE7XG5cdHZhciBhamF4ID0gb1NldHRpbmdzLmFqYXg7XG5cdHZhciBpbnN0YW5jZSA9IG9TZXR0aW5ncy5vSW5zdGFuY2U7XG5cdHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgganNvbiApIHtcblx0XHR2YXIgc3RhdHVzID0gb1NldHRpbmdzLmpxWEhSXG5cdFx0XHQ/IG9TZXR0aW5ncy5qcVhIUi5zdGF0dXNcblx0XHRcdDogbnVsbDtcblxuXHRcdGlmICgganNvbiA9PT0gbnVsbCB8fCAodHlwZW9mIHN0YXR1cyA9PT0gJ251bWJlcicgJiYgc3RhdHVzID09IDIwNCApICkge1xuXHRcdFx0anNvbiA9IHt9O1xuXHRcdFx0X2ZuQWpheERhdGFTcmMoIG9TZXR0aW5ncywganNvbiwgW10gKTtcblx0XHR9XG5cblx0XHR2YXIgZXJyb3IgPSBqc29uLmVycm9yIHx8IGpzb24uc0Vycm9yO1xuXHRcdGlmICggZXJyb3IgKSB7XG5cdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgZXJyb3IgKTtcblx0XHR9XG5cblx0XHQvLyBNaWNyb3NvZnQgb2Z0ZW4gd3JhcCBKU09OIGFzIGEgc3RyaW5nIGluIGFub3RoZXIgSlNPTiBvYmplY3Rcblx0XHQvLyBMZXQncyBoYW5kbGUgdGhhdCBhdXRvbWF0aWNhbGx5XG5cdFx0aWYgKGpzb24uZCAmJiB0eXBlb2YganNvbi5kID09PSAnc3RyaW5nJykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0anNvbiA9IEpTT04ucGFyc2UoanNvbi5kKTtcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIG5vb3Bcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvU2V0dGluZ3MuanNvbiA9IGpzb247XG5cblx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3hocicsIFtvU2V0dGluZ3MsIGpzb24sIG9TZXR0aW5ncy5qcVhIUl0sIHRydWUgKTtcblx0XHRmbigganNvbiApO1xuXHR9O1xuXG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCBhamF4ICkgJiYgYWpheC5kYXRhIClcblx0e1xuXHRcdGFqYXhEYXRhID0gYWpheC5kYXRhO1xuXG5cdFx0dmFyIG5ld0RhdGEgPSB0eXBlb2YgYWpheERhdGEgPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0YWpheERhdGEoIGRhdGEsIG9TZXR0aW5ncyApIDogIC8vIGZuIGNhbiBtYW5pcHVsYXRlIGRhdGEgb3IgcmV0dXJuXG5cdFx0XHRhamF4RGF0YTsgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gb2JqZWN0IG9iamVjdCBvciBhcnJheSB0byBtZXJnZVxuXG5cdFx0Ly8gSWYgdGhlIGZ1bmN0aW9uIHJldHVybmVkIHNvbWV0aGluZywgdXNlIHRoYXQgYWxvbmVcblx0XHRkYXRhID0gdHlwZW9mIGFqYXhEYXRhID09PSAnZnVuY3Rpb24nICYmIG5ld0RhdGEgP1xuXHRcdFx0bmV3RGF0YSA6XG5cdFx0XHQkLmV4dGVuZCggdHJ1ZSwgZGF0YSwgbmV3RGF0YSApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBkYXRhIHByb3BlcnR5IGFzIHdlJ3ZlIHJlc29sdmVkIGl0IGFscmVhZHkgYW5kIGRvbid0IHdhbnRcblx0XHQvLyBqUXVlcnkgdG8gZG8gaXQgYWdhaW4gKGl0IGlzIHJlc3RvcmVkIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uKVxuXHRcdGRlbGV0ZSBhamF4LmRhdGE7XG5cdH1cblxuXHR2YXIgYmFzZUFqYXggPSB7XG5cdFx0XCJ1cmxcIjogdHlwZW9mIGFqYXggPT09ICdzdHJpbmcnID9cblx0XHRcdGFqYXggOlxuXHRcdFx0JycsXG5cdFx0XCJkYXRhXCI6IGRhdGEsXG5cdFx0XCJzdWNjZXNzXCI6IGNhbGxiYWNrLFxuXHRcdFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXG5cdFx0XCJjYWNoZVwiOiBmYWxzZSxcblx0XHRcInR5cGVcIjogb1NldHRpbmdzLnNTZXJ2ZXJNZXRob2QsXG5cdFx0XCJlcnJvclwiOiBmdW5jdGlvbiAoeGhyLCBlcnJvcikge1xuXHRcdFx0dmFyIHJldCA9IF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAneGhyJywgW29TZXR0aW5ncywgbnVsbCwgb1NldHRpbmdzLmpxWEhSXSwgdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHJldC5pbmRleE9mKHRydWUpID09PSAtMSApIHtcblx0XHRcdFx0aWYgKCBlcnJvciA9PSBcInBhcnNlcmVycm9yXCIgKSB7XG5cdFx0XHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsICdJbnZhbGlkIEpTT04gcmVzcG9uc2UnLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnQWpheCBlcnJvcicsIDcgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggb1NldHRpbmdzLCBmYWxzZSApO1xuXHRcdH1cblx0fTtcblxuXHQvLyBJZiBgYWpheGAgb3B0aW9uIGlzIGFuIG9iamVjdCwgZXh0ZW5kIGFuZCBvdmVycmlkZSBvdXIgZGVmYXVsdCBiYXNlXG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCBhamF4ICkgKSB7XG5cdFx0JC5leHRlbmQoIGJhc2VBamF4LCBhamF4IClcblx0fVxuXG5cdC8vIFN0b3JlIHRoZSBkYXRhIHN1Ym1pdHRlZCBmb3IgdGhlIEFQSVxuXHRvU2V0dGluZ3Mub0FqYXhEYXRhID0gZGF0YTtcblxuXHQvLyBBbGxvdyBwbHVnLWlucyBhbmQgZXh0ZXJuYWwgcHJvY2Vzc2VzIHRvIG1vZGlmeSB0aGUgZGF0YVxuXHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3ByZVhocicsIFtvU2V0dGluZ3MsIGRhdGEsIGJhc2VBamF4XSwgdHJ1ZSApO1xuXG5cdC8vIEN1c3RvbSBBamF4IG9wdGlvbiB0byBzdWJtaXQgdGhlIHBhcmFtZXRlcnMgYXMgYSBKU09OIHN0cmluZ1xuXHRpZiAoYmFzZUFqYXguc3VibWl0QXMgPT09ICdqc29uJyAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcpIHtcblx0XHRiYXNlQWpheC5kYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG5cdH1cblxuXHRpZiAoIHR5cGVvZiBhamF4ID09PSAnZnVuY3Rpb24nIClcblx0e1xuXHRcdC8vIElzIGEgZnVuY3Rpb24gLSBsZXQgdGhlIGNhbGxlciBkZWZpbmUgd2hhdCBuZWVkcyB0byBiZSBkb25lXG5cdFx0b1NldHRpbmdzLmpxWEhSID0gYWpheC5jYWxsKCBpbnN0YW5jZSwgZGF0YSwgY2FsbGJhY2ssIG9TZXR0aW5ncyApO1xuXHR9XG5cdGVsc2UgaWYgKGFqYXgudXJsID09PSAnJykge1xuXHRcdC8vIE5vIHVybCwgc28gZG9uJ3QgbG9hZCBhbnkgZGF0YS4gSnVzdCBhcHBseSBhbiBlbXB0eSBkYXRhIGFycmF5XG5cdFx0Ly8gdG8gdGhlIG9iamVjdCBmb3IgdGhlIGNhbGxiYWNrLlxuXHRcdHZhciBlbXB0eSA9IHt9O1xuXG5cdFx0RGF0YVRhYmxlLnV0aWwuc2V0KGFqYXguZGF0YVNyYykoZW1wdHksIFtdKTtcblx0XHRjYWxsYmFjayhlbXB0eSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gT2JqZWN0IHRvIGV4dGVuZCB0aGUgYmFzZSBzZXR0aW5nc1xuXHRcdG9TZXR0aW5ncy5qcVhIUiA9ICQuYWpheCggYmFzZUFqYXggKTtcblx0fVxuXG5cdC8vIFJlc3RvcmUgZm9yIG5leHQgdGltZSBhcm91bmRcblx0aWYgKCBhamF4RGF0YSApIHtcblx0XHRhamF4LmRhdGEgPSBhamF4RGF0YTtcblx0fVxufVxuXG5cbi8qKlxuICogVXBkYXRlIHRoZSB0YWJsZSB1c2luZyBhbiBBamF4IGNhbGxcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcmV0dXJucyB7Ym9vbGVhbn0gQmxvY2sgdGhlIHRhYmxlIGRyYXdpbmcgb3Igbm90XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkFqYXhVcGRhdGUoIHNldHRpbmdzIClcbntcblx0c2V0dGluZ3MuaURyYXcrKztcblx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cblx0X2ZuQnVpbGRBamF4KFxuXHRcdHNldHRpbmdzLFxuXHRcdF9mbkFqYXhQYXJhbWV0ZXJzKCBzZXR0aW5ncyApLFxuXHRcdGZ1bmN0aW9uKGpzb24pIHtcblx0XHRcdF9mbkFqYXhVcGRhdGVEcmF3KCBzZXR0aW5ncywganNvbiApO1xuXHRcdH1cblx0KTtcbn1cblxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBwYXJhbWV0ZXJzIGluIGFuIG9iamVjdCBuZWVkZWQgZm9yIGEgc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuICogcmVxdWVzdC5cbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHJldHVybnMge2Jvb2x9IGJsb2NrIHRoZSB0YWJsZSBkcmF3aW5nIG9yIG5vdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5BamF4UGFyYW1ldGVycyggc2V0dGluZ3MgKVxue1xuXHR2YXJcblx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxuXHRcdHByZVNlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCxcblx0XHRwcmVDb2xTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHMsXG5cdFx0Y29sRGF0YSA9IGZ1bmN0aW9uICggaWR4LCBwcm9wICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBjb2x1bW5zW2lkeF1bcHJvcF0gPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHQnZnVuY3Rpb24nIDpcblx0XHRcdFx0Y29sdW1uc1tpZHhdW3Byb3BdO1xuXHRcdH07XG5cblx0cmV0dXJuIHtcblx0XHRkcmF3OiBzZXR0aW5ncy5pRHJhdyxcblx0XHRjb2x1bW5zOiBjb2x1bW5zLm1hcCggZnVuY3Rpb24gKCBjb2x1bW4sIGkgKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBjb2xEYXRhKGksICdtRGF0YScpLFxuXHRcdFx0XHRuYW1lOiBjb2x1bW4uc05hbWUsXG5cdFx0XHRcdHNlYXJjaGFibGU6IGNvbHVtbi5iU2VhcmNoYWJsZSxcblx0XHRcdFx0b3JkZXJhYmxlOiBjb2x1bW4uYlNvcnRhYmxlLFxuXHRcdFx0XHRzZWFyY2g6IHtcblx0XHRcdFx0XHR2YWx1ZTogcHJlQ29sU2VhcmNoW2ldLnNlYXJjaCxcblx0XHRcdFx0XHRyZWdleDogcHJlQ29sU2VhcmNoW2ldLnJlZ2V4LFxuXHRcdFx0XHRcdGZpeGVkOiBPYmplY3Qua2V5cyhjb2x1bW4uc2VhcmNoRml4ZWQpLm1hcCggZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRcdFx0dGVybTogY29sdW1uLnNlYXJjaEZpeGVkW25hbWVdLnRvU3RyaW5nKClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0gKSxcblx0XHRvcmRlcjogX2ZuU29ydEZsYXR0ZW4oIHNldHRpbmdzICkubWFwKCBmdW5jdGlvbiAoIHZhbCApIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNvbHVtbjogdmFsLmNvbCxcblx0XHRcdFx0ZGlyOiB2YWwuZGlyLFxuXHRcdFx0XHRuYW1lOiBjb2xEYXRhKHZhbC5jb2wsICdzTmFtZScpXG5cdFx0XHR9O1xuXHRcdH0gKSxcblx0XHRzdGFydDogc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0bGVuZ3RoOiBmZWF0dXJlcy5iUGFnaW5hdGUgP1xuXHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIDpcblx0XHRcdC0xLFxuXHRcdHNlYXJjaDoge1xuXHRcdFx0dmFsdWU6IHByZVNlYXJjaC5zZWFyY2gsXG5cdFx0XHRyZWdleDogcHJlU2VhcmNoLnJlZ2V4LFxuXHRcdFx0Zml4ZWQ6IE9iamVjdC5rZXlzKHNldHRpbmdzLnNlYXJjaEZpeGVkKS5tYXAoIGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0XHRcdHRlcm06IHNldHRpbmdzLnNlYXJjaEZpeGVkW25hbWVdLnRvU3RyaW5nKClcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9XG5cdH07XG59XG5cblxuLyoqXG4gKiBEYXRhIHRoZSBkYXRhIGZyb20gdGhlIHNlcnZlciAobnVraW5nIHRoZSBvbGQpIGFuZCByZWRyYXcgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIGpzb24gZGF0YSByZXR1cm4gZnJvbSB0aGUgc2VydmVyLlxuICogIEBwYXJhbSB7c3RyaW5nfSBqc29uLnNFY2hvIFRyYWNraW5nIGZsYWcgZm9yIERhdGFUYWJsZXMgdG8gbWF0Y2ggcmVxdWVzdHNcbiAqICBAcGFyYW0ge2ludH0ganNvbi5pVG90YWxSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgbm90IGFjY291bnRpbmcgZm9yIGZpbHRlcmluZ1xuICogIEBwYXJhbSB7aW50fSBqc29uLmlUb3RhbERpc3BsYXlSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgYWNjb3VudGluZyBmb3IgZmlsdGVyaW5nXG4gKiAgQHBhcmFtIHthcnJheX0ganNvbi5hYURhdGEgVGhlIGRhdGEgdG8gZGlzcGxheSBvbiB0aGlzIHBhZ2VcbiAqICBAcGFyYW0ge3N0cmluZ30gW2pzb24uc0NvbHVtbnNdIENvbHVtbiBvcmRlcmluZyAoc05hbWUsIGNvbW1hIHNlcGFyYXRlZClcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWpheFVwZGF0ZURyYXcgKCBzZXR0aW5ncywganNvbiApXG57XG5cdHZhciBkYXRhID0gX2ZuQWpheERhdGFTcmMoc2V0dGluZ3MsIGpzb24pO1xuXHR2YXIgZHJhdyA9IF9mbkFqYXhEYXRhU3JjUGFyYW0oc2V0dGluZ3MsICdkcmF3JywganNvbik7XG5cdHZhciByZWNvcmRzVG90YWwgPSBfZm5BamF4RGF0YVNyY1BhcmFtKHNldHRpbmdzLCAncmVjb3Jkc1RvdGFsJywganNvbik7XG5cdHZhciByZWNvcmRzRmlsdGVyZWQgPSBfZm5BamF4RGF0YVNyY1BhcmFtKHNldHRpbmdzLCAncmVjb3Jkc0ZpbHRlcmVkJywganNvbik7XG5cblx0aWYgKCBkcmF3ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gUHJvdGVjdCBhZ2FpbnN0IG91dCBvZiBzZXF1ZW5jZSByZXR1cm5zXG5cdFx0aWYgKCBkcmF3KjEgPCBzZXR0aW5ncy5pRHJhdyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0c2V0dGluZ3MuaURyYXcgPSBkcmF3ICogMTtcblx0fVxuXG5cdC8vIE5vIGRhdGEgaW4gcmV0dXJuZWQgb2JqZWN0LCBzbyByYXRoZXIgdGhhbiBhbiBhcnJheSwgd2Ugc2hvdyBhbiBlbXB0eSB0YWJsZVxuXHRpZiAoICEgZGF0YSApIHtcblx0XHRkYXRhID0gW107XG5cdH1cblxuXHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHRzZXR0aW5ncy5faVJlY29yZHNUb3RhbCAgID0gcGFyc2VJbnQocmVjb3Jkc1RvdGFsLCAxMCk7XG5cdHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSBwYXJzZUludChyZWNvcmRzRmlsdGVyZWQsIDEwKTtcblxuXHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgZGF0YVtpXSApO1xuXHR9XG5cdHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXG5cdF9mbkNvbHVtblR5cGVzKHNldHRpbmdzKTtcblx0X2ZuRHJhdyggc2V0dGluZ3MsIHRydWUgKTtcblx0X2ZuSW5pdENvbXBsZXRlKCBzZXR0aW5ncyApO1xuXHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIGZhbHNlICk7XG59XG5cblxuLyoqXG4gKiBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgSlNPTiBkYXRhIHNvdXJjZSB0byB1c2UgZm9yIGRyYXdpbmcgYSB0YWJsZS4gVXNpbmdcbiAqIGBfZm5HZXRPYmplY3REYXRhRm5gIGFsbG93cyB0aGUgZGF0YSB0byBiZSBzb3VyY2VkIGZyb20gYSBwcm9wZXJ0eSBvZiB0aGVcbiAqIHNvdXJjZSBvYmplY3QsIG9yIGZyb20gYSBwcm9jZXNzaW5nIGZ1bmN0aW9uLlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSAge29iamVjdH0ganNvbiBEYXRhIHNvdXJjZSBvYmplY3QgLyBhcnJheSBmcm9tIHRoZSBzZXJ2ZXJcbiAqICBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgZGF0YSB0byB1c2VcbiAqL1xuZnVuY3Rpb24gX2ZuQWpheERhdGFTcmMgKCBzZXR0aW5ncywganNvbiwgd3JpdGUgKVxue1xuXHR2YXIgZGF0YVByb3AgPSAnZGF0YSc7XG5cblx0aWYgKCQuaXNQbGFpbk9iamVjdCggc2V0dGluZ3MuYWpheCApICYmIHNldHRpbmdzLmFqYXguZGF0YVNyYyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gQ291bGQgaW4gaW5zaWRlIGEgYGRhdGFTcmNgIG9iamVjdCwgb3Igbm90IVxuXHRcdHZhciBkYXRhU3JjID0gc2V0dGluZ3MuYWpheC5kYXRhU3JjO1xuXG5cdFx0Ly8gc3RyaW5nLCBmdW5jdGlvbiBhbmQgb2JqZWN0IGFyZSB2YWxpZCB0eXBlc1xuXHRcdGlmICh0eXBlb2YgZGF0YVNyYyA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGRhdGFTcmMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGRhdGFQcm9wID0gZGF0YVNyYztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoZGF0YVNyYy5kYXRhICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGRhdGFQcm9wID0gZGF0YVNyYy5kYXRhO1xuXHRcdH1cblx0fVxuXG5cdGlmICggISB3cml0ZSApIHtcblx0XHRpZiAoIGRhdGFQcm9wID09PSAnZGF0YScgKSB7XG5cdFx0XHQvLyBJZiB0aGUgZGVmYXVsdCwgdGhlbiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnQgdGhlIG9sZCBzdHlsZSwgYW5kIHNhZmVseSBpZ25vcmVcblx0XHRcdC8vIGl0IGlmIHBvc3NpYmxlXG5cdFx0XHRyZXR1cm4ganNvbi5hYURhdGEgfHwganNvbltkYXRhUHJvcF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGFQcm9wICE9PSBcIlwiID9cblx0XHRcdF9mbkdldE9iamVjdERhdGFGbiggZGF0YVByb3AgKSgganNvbiApIDpcblx0XHRcdGpzb247XG5cdH1cblx0XG5cdC8vIHNldFxuXHRfZm5TZXRPYmplY3REYXRhRm4oIGRhdGFQcm9wICkoIGpzb24sIHdyaXRlICk7XG59XG5cbi8qKlxuICogVmVyeSBzaW1pbGFyIHRvIF9mbkFqYXhEYXRhU3JjLCBidXQgZm9yIHRoZSBvdGhlciBTU1AgcHJvcGVydGllc1xuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHsqfSBwYXJhbSBUYXJnZXQgcGFyYW1ldGVyXG4gKiBAcGFyYW0geyp9IGpzb24gSlNPTiBkYXRhXG4gKiBAcmV0dXJucyBSZXNvbHZlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBfZm5BamF4RGF0YVNyY1BhcmFtIChzZXR0aW5ncywgcGFyYW0sIGpzb24pIHtcblx0dmFyIGRhdGFTcmMgPSAkLmlzUGxhaW5PYmplY3QoIHNldHRpbmdzLmFqYXggKVxuXHRcdD8gc2V0dGluZ3MuYWpheC5kYXRhU3JjXG5cdFx0OiBudWxsO1xuXG5cdGlmIChkYXRhU3JjICYmIGRhdGFTcmNbcGFyYW1dKSB7XG5cdFx0Ly8gR2V0IGZyb20gY3VzdG9tIGxvY2F0aW9uXG5cdFx0cmV0dXJuIF9mbkdldE9iamVjdERhdGFGbiggZGF0YVNyY1twYXJhbV0gKSgganNvbiApO1xuXHR9XG5cblx0Ly8gZWxzZSAtIERlZmF1bHQgYmVoYXZpb3VyXG5cdHZhciBvbGQgPSAnJztcblxuXHQvLyBMZWdhY3kgc3VwcG9ydFxuXHRpZiAocGFyYW0gPT09ICdkcmF3Jykge1xuXHRcdG9sZCA9ICdzRWNobyc7XG5cdH1cblx0ZWxzZSBpZiAocGFyYW0gPT09ICdyZWNvcmRzVG90YWwnKSB7XG5cdFx0b2xkID0gJ2lUb3RhbFJlY29yZHMnO1xuXHR9XG5cdGVsc2UgaWYgKHBhcmFtID09PSAncmVjb3Jkc0ZpbHRlcmVkJykge1xuXHRcdG9sZCA9ICdpVG90YWxEaXNwbGF5UmVjb3Jkcyc7XG5cdH1cblxuXHRyZXR1cm4ganNvbltvbGRdICE9PSB1bmRlZmluZWRcblx0XHQ/IGpzb25bb2xkXVxuXHRcdDoganNvbltwYXJhbV07XG59XG5cblxuLyoqXG4gKiBGaWx0ZXIgdGhlIHRhYmxlIHVzaW5nIGJvdGggdGhlIGdsb2JhbCBmaWx0ZXIgYW5kIGNvbHVtbiBiYXNlZCBmaWx0ZXJpbmdcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0gaW5wdXQgc2VhcmNoIGluZm9ybWF0aW9uXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZpbHRlckNvbXBsZXRlICggc2V0dGluZ3MsIGlucHV0IClcbntcblx0dmFyIGNvbHVtbnNTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cblx0Ly8gSW4gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBhbGwgZmlsdGVyaW5nIGlzIGRvbmUgYnkgdGhlIHNlcnZlciwgc28gbm8gcG9pbnQgaGFuZ2luZyBhcm91bmQgaGVyZVxuXHRpZiAoIF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgIT0gJ3NzcCcgKVxuXHR7XG5cdFx0Ly8gQ2hlY2sgaWYgYW55IG9mIHRoZSByb3dzIHdlcmUgaW52YWxpZGF0ZWRcblx0XHRfZm5GaWx0ZXJEYXRhKCBzZXR0aW5ncyApO1xuXG5cdFx0Ly8gU3RhcnQgZnJvbSB0aGUgZnVsbCBkYXRhIHNldFxuXHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXG5cdFx0Ly8gR2xvYmFsIGZpbHRlciBmaXJzdFxuXHRcdF9mbkZpbHRlciggc2V0dGluZ3MuYWlEaXNwbGF5LCBzZXR0aW5ncywgaW5wdXQuc2VhcmNoLCBpbnB1dCApO1xuXG5cdFx0JC5lYWNoKHNldHRpbmdzLnNlYXJjaEZpeGVkLCBmdW5jdGlvbiAobmFtZSwgdGVybSkge1xuXHRcdFx0X2ZuRmlsdGVyKHNldHRpbmdzLmFpRGlzcGxheSwgc2V0dGluZ3MsIHRlcm0sIHt9KTtcblx0XHR9KTtcblxuXHRcdC8vIFRoZW4gaW5kaXZpZHVhbCBjb2x1bW4gZmlsdGVyc1xuXHRcdGZvciAoIHZhciBpPTAgOyBpPGNvbHVtbnNTZWFyY2gubGVuZ3RoIDsgaSsrIClcblx0XHR7XG5cdFx0XHR2YXIgY29sID0gY29sdW1uc1NlYXJjaFtpXTtcblxuXHRcdFx0X2ZuRmlsdGVyKFxuXHRcdFx0XHRzZXR0aW5ncy5haURpc3BsYXksXG5cdFx0XHRcdHNldHRpbmdzLFxuXHRcdFx0XHRjb2wuc2VhcmNoLFxuXHRcdFx0XHRjb2wsXG5cdFx0XHRcdGlcblx0XHRcdCk7XG5cblx0XHRcdCQuZWFjaChzZXR0aW5ncy5hb0NvbHVtbnNbaV0uc2VhcmNoRml4ZWQsIGZ1bmN0aW9uIChuYW1lLCB0ZXJtKSB7XG5cdFx0XHRcdF9mbkZpbHRlcihzZXR0aW5ncy5haURpc3BsYXksIHNldHRpbmdzLCB0ZXJtLCB7fSwgaSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBBbmQgZmluYWxseSBnbG9iYWwgZmlsdGVyaW5nXG5cdFx0X2ZuRmlsdGVyQ3VzdG9tKCBzZXR0aW5ncyApO1xuXHR9XG5cblx0Ly8gVGVsbCB0aGUgZHJhdyBmdW5jdGlvbiB3ZSBoYXZlIGJlZW4gZmlsdGVyaW5nXG5cdHNldHRpbmdzLmJGaWx0ZXJlZCA9IHRydWU7XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3NlYXJjaCcsIFtzZXR0aW5nc10gKTtcbn1cblxuXG4vKipcbiAqIEFwcGx5IGN1c3RvbSBmaWx0ZXJpbmcgZnVuY3Rpb25zXG4gKiBcbiAqIFRoaXMgaXMgbGVnYWN5IG5vdyB0aGF0IHdlIGhhdmUgbmFtZWQgZnVuY3Rpb25zLCBidXQgaXQgaXMgd2lkZWx5IHVzZWRcbiAqIGZyb20gMS54LCBzbyBpdCBpcyBub3QgeWV0IGRlcHJlY2F0ZWQuXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5GaWx0ZXJDdXN0b20oIHNldHRpbmdzIClcbntcblx0dmFyIGZpbHRlcnMgPSBEYXRhVGFibGUuZXh0LnNlYXJjaDtcblx0dmFyIGRpc3BsYXlSb3dzID0gc2V0dGluZ3MuYWlEaXNwbGF5O1xuXHR2YXIgcm93LCByb3dJZHg7XG5cblx0Zm9yICggdmFyIGk9MCwgaWVuPWZpbHRlcnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0dmFyIHJvd3MgPSBbXTtcblxuXHRcdC8vIExvb3Agb3ZlciBlYWNoIHJvdyBhbmQgc2VlIGlmIGl0IHNob3VsZCBiZSBpbmNsdWRlZFxuXHRcdGZvciAoIHZhciBqPTAsIGplbj1kaXNwbGF5Um93cy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdHJvd0lkeCA9IGRpc3BsYXlSb3dzWyBqIF07XG5cdFx0XHRyb3cgPSBzZXR0aW5ncy5hb0RhdGFbIHJvd0lkeCBdO1xuXG5cdFx0XHRpZiAoIGZpbHRlcnNbaV0oIHNldHRpbmdzLCByb3cuX2FGaWx0ZXJEYXRhLCByb3dJZHgsIHJvdy5fYURhdGEsIGogKSApIHtcblx0XHRcdFx0cm93cy5wdXNoKCByb3dJZHggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTbyB0aGUgYXJyYXkgcmVmZXJlbmNlIGRvZXNuJ3QgYnJlYWsgc2V0IHRoZSByZXN1bHRzIGludG8gdGhlXG5cdFx0Ly8gZXhpc3RpbmcgYXJyYXlcblx0XHRkaXNwbGF5Um93cy5sZW5ndGggPSAwO1xuXHRcdF9mbkFycmF5QXBwbHkoZGlzcGxheVJvd3MsIHJvd3MpO1xuXHR9XG59XG5cblxuLyoqXG4gKiBGaWx0ZXIgdGhlIGRhdGEgdGFibGUgYmFzZWQgb24gdXNlciBpbnB1dCBhbmQgZHJhdyB0aGUgdGFibGVcbiAqL1xuZnVuY3Rpb24gX2ZuRmlsdGVyKCBzZWFyY2hSb3dzLCBzZXR0aW5ncywgaW5wdXQsIG9wdGlvbnMsIGNvbHVtbiApXG57XG5cdGlmICggaW5wdXQgPT09ICcnICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBpID0gMDtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHQvLyBTZWFyY2ggdGVybSBjYW4gYmUgYSBmdW5jdGlvbiwgcmVnZXggb3Igc3RyaW5nIC0gaWYgYSBzdHJpbmcgd2UgYXBwbHkgb3VyXG5cdC8vIHNtYXJ0IGZpbHRlcmluZyByZWdleCAoYXNzdW1pbmcgdGhlIG9wdGlvbnMgcmVxdWlyZSB0aGF0KVxuXHR2YXIgc2VhcmNoRnVuYyA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/IGlucHV0IDogbnVsbDtcblx0dmFyIHJwU2VhcmNoID0gaW5wdXQgaW5zdGFuY2VvZiBSZWdFeHBcblx0XHQ/IGlucHV0XG5cdFx0OiBzZWFyY2hGdW5jXG5cdFx0XHQ/IG51bGxcblx0XHRcdDogX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKCBpbnB1dCwgb3B0aW9ucyApO1xuXG5cdC8vIFRoZW4gZm9yIGVhY2ggcm93LCBkb2VzIHRoZSB0ZXN0IHBhc3MuIElmIG5vdCwgbG9wIHRoZSByb3cgZnJvbSB0aGUgYXJyYXlcblx0Zm9yIChpPTAgOyBpPHNlYXJjaFJvd3MubGVuZ3RoIDsgaSsrKSB7XG5cdFx0dmFyIHJvdyA9IHNldHRpbmdzLmFvRGF0YVsgc2VhcmNoUm93c1tpXSBdO1xuXHRcdHZhciBkYXRhID0gY29sdW1uID09PSB1bmRlZmluZWRcblx0XHRcdD8gcm93Ll9zRmlsdGVyUm93XG5cdFx0XHQ6IHJvdy5fYUZpbHRlckRhdGFbIGNvbHVtbiBdO1xuXG5cdFx0aWYgKCAoc2VhcmNoRnVuYyAmJiBzZWFyY2hGdW5jKGRhdGEsIHJvdy5fYURhdGEsIHNlYXJjaFJvd3NbaV0sIGNvbHVtbikpIHx8IChycFNlYXJjaCAmJiBycFNlYXJjaC50ZXN0KGRhdGEpKSApIHtcblx0XHRcdG1hdGNoZWQucHVzaChzZWFyY2hSb3dzW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBNdXRhdGUgdGhlIHNlYXJjaFJvd3MgYXJyYXlcblx0c2VhcmNoUm93cy5sZW5ndGggPSBtYXRjaGVkLmxlbmd0aDtcblxuXHRmb3IgKGk9MCA7IGk8bWF0Y2hlZC5sZW5ndGggOyBpKyspIHtcblx0XHRzZWFyY2hSb3dzW2ldID0gbWF0Y2hlZFtpXTtcblx0fVxufVxuXG5cbi8qKlxuICogQnVpbGQgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IHN1aXRhYmxlIGZvciBzZWFyY2hpbmcgYSB0YWJsZVxuICogIEBwYXJhbSB7c3RyaW5nfSBzU2VhcmNoIHN0cmluZyB0byBzZWFyY2ggZm9yXG4gKiAgQHBhcmFtIHtib29sfSBiUmVnZXggdHJlYXQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG4gKiAgQHBhcmFtIHtib29sfSBiU21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XG4gKiAgQHBhcmFtIHtib29sfSBiQ2FzZUluc2Vuc2l0aXZlIERvIGNhc2UgaW5zZW5zaXRpdmUgbWF0Y2hpbmcgb3Igbm90XG4gKiAgQHJldHVybnMge1JlZ0V4cH0gY29uc3RydWN0ZWQgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZpbHRlckNyZWF0ZVNlYXJjaCggc2VhcmNoLCBpbk9wdHMgKVxue1xuXHR2YXIgbm90ID0gW107XG5cdHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIHtcblx0XHRib3VuZGFyeTogZmFsc2UsXG5cdFx0Y2FzZUluc2Vuc2l0aXZlOiB0cnVlLFxuXHRcdGV4YWN0OiBmYWxzZSxcblx0XHRyZWdleDogZmFsc2UsXG5cdFx0c21hcnQ6IHRydWVcblx0fSwgaW5PcHRzKTtcblxuXHRpZiAodHlwZW9mIHNlYXJjaCAhPT0gJ3N0cmluZycpIHtcblx0XHRzZWFyY2ggPSBzZWFyY2gudG9TdHJpbmcoKTtcblx0fVxuXG5cdC8vIFJlbW92ZSBkaWFjcml0aWNzIGlmIG5vcm1hbGl6ZSBpcyBzZXQgdXAgdG8gZG8gc29cblx0c2VhcmNoID0gX25vcm1hbGl6ZShzZWFyY2gpO1xuXG5cdGlmIChvcHRpb25zLmV4YWN0KSB7XG5cdFx0cmV0dXJuIG5ldyBSZWdFeHAoXG5cdFx0XHQnXicrX2ZuRXNjYXBlUmVnZXgoc2VhcmNoKSsnJCcsXG5cdFx0XHRvcHRpb25zLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6ICcnXG5cdFx0KTtcblx0fVxuXG5cdHNlYXJjaCA9IG9wdGlvbnMucmVnZXggP1xuXHRcdHNlYXJjaCA6XG5cdFx0X2ZuRXNjYXBlUmVnZXgoIHNlYXJjaCApO1xuXHRcblx0aWYgKCBvcHRpb25zLnNtYXJ0ICkge1xuXHRcdC8qIEZvciBzbWFydCBmaWx0ZXJpbmcgd2Ugd2FudCB0byBhbGxvdyB0aGUgc2VhcmNoIHRvIHdvcmsgcmVnYXJkbGVzcyBvZlxuXHRcdCAqIHdvcmQgb3JkZXIuIFdlIGFsc28gd2FudCBkb3VibGUgcXVvdGVkIHRleHQgdG8gYmUgcHJlc2VydmVkLCBzbyB3b3JkXG5cdFx0ICogb3JkZXIgaXMgaW1wb3J0YW50IC0gYSBsYSBnb29nbGUuIEFuZCBhIG5lZ2F0aXZlIGxvb2sgYXJvdW5kIGZvclxuXHRcdCAqIGZpbmRpbmcgcm93cyB3aGljaCBkb24ndCBjb250YWluIGEgZ2l2ZW4gc3RyaW5nLlxuXHRcdCAqIFxuXHRcdCAqIFNvIHRoaXMgaXMgdGhlIHNvcnQgb2YgdGhpbmcgd2Ugd2FudCB0byBnZW5lcmF0ZTpcblx0XHQgKiBcblx0XHQgKiBeKD89Lio/XFxib25lXFxiKSg/PS4qP1xcYnR3byB0aHJlZVxcYikoPz0uKj9cXGJmb3VyXFxiKS4qJFxuXHRcdCAqL1xuXHRcdHZhciBwYXJ0cyA9IHNlYXJjaC5tYXRjaCggLyE/W1wiXFx1MjAxQ11bXlwiXFx1MjAxRF0rW1wiXFx1MjAxRF18W14gXSsvZyApIHx8IFsnJ107XG5cdFx0dmFyIGEgPSBwYXJ0cy5tYXAoIGZ1bmN0aW9uICggd29yZCApIHtcblx0XHRcdHZhciBuZWdhdGl2ZSA9IGZhbHNlO1xuXHRcdFx0dmFyIG07XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBpdCBpcyBhIFwiZG9lcyBub3QgaW5jbHVkZVwiXG5cdFx0XHRpZiAoIHdvcmQuY2hhckF0KDApID09PSAnIScgKSB7XG5cdFx0XHRcdG5lZ2F0aXZlID0gdHJ1ZTtcblx0XHRcdFx0d29yZCA9IHdvcmQuc3Vic3RyaW5nKDEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdHJpcCB0aGUgcXVvdGVzIGZyb20gYXJvdW5kIG1hdGNoZWQgcGhyYXNlc1xuXHRcdFx0aWYgKCB3b3JkLmNoYXJBdCgwKSA9PT0gJ1wiJyApIHtcblx0XHRcdFx0bSA9IHdvcmQubWF0Y2goIC9eXCIoLiopXCIkLyApO1xuXHRcdFx0XHR3b3JkID0gbSA/IG1bMV0gOiB3b3JkO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHdvcmQuY2hhckF0KDApID09PSAnXFx1MjAxQycgKSB7XG5cdFx0XHRcdC8vIFNtYXJ0IHF1b3RlIG1hdGNoIChpUGhvbmUgdXNlcnMpXG5cdFx0XHRcdG0gPSB3b3JkLm1hdGNoKCAvXlxcdTIwMUMoLiopXFx1MjAxRCQvICk7XG5cdFx0XHRcdHdvcmQgPSBtID8gbVsxXSA6IHdvcmQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBvdXIgXCJub3RcIiBjYXNlLCB3ZSBuZWVkIHRvIG1vZGlmeSB0aGUgc3RyaW5nIHRoYXQgaXNcblx0XHRcdC8vIGFsbG93ZWQgdG8gbWF0Y2ggYXQgdGhlIGVuZCBvZiB0aGUgZXhwcmVzc2lvbi5cblx0XHRcdGlmIChuZWdhdGl2ZSkge1xuXHRcdFx0XHRpZiAod29yZC5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0bm90LnB1c2goJyg/IScrd29yZCsnKScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0d29yZCA9ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gd29yZC5yZXBsYWNlKC9cIi9nLCAnJyk7XG5cdFx0fSApO1xuXG5cdFx0dmFyIG1hdGNoID0gbm90Lmxlbmd0aFxuXHRcdFx0PyBub3Quam9pbignJylcblx0XHRcdDogJyc7XG5cblx0XHR2YXIgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5XG5cdFx0XHQ/ICdcXFxcYidcblx0XHRcdDogJyc7XG5cblx0XHRzZWFyY2ggPSAnXig/PS4qPycrYm91bmRhcnkrYS5qb2luKCAnKSg/PS4qPycrYm91bmRhcnkgKSsnKSgnK21hdGNoKycuKSokJztcblx0fVxuXG5cdHJldHVybiBuZXcgUmVnRXhwKCBzZWFyY2gsIG9wdGlvbnMuY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogJycgKTtcbn1cblxuXG4vKipcbiAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cbiAqICBAcGFyYW0ge3N0cmluZ30gc1ZhbCBzdHJpbmcgdG8gZXNjYXBlXG4gKiAgQHJldHVybnMge3N0cmluZ30gZXNjYXBlZCBzdHJpbmdcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xudmFyIF9mbkVzY2FwZVJlZ2V4ID0gRGF0YVRhYmxlLnV0aWwuZXNjYXBlUmVnZXg7XG5cbnZhciBfX2ZpbHRlcl9kaXYgPSAkKCc8ZGl2PicpWzBdO1xudmFyIF9fZmlsdGVyX2Rpdl90ZXh0Q29udGVudCA9IF9fZmlsdGVyX2Rpdi50ZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkO1xuXG4vLyBVcGRhdGUgdGhlIGZpbHRlcmluZyBkYXRhIGZvciBlYWNoIHJvdyBpZiBuZWVkZWQgKGJ5IGludmFsaWRhdGlvbiBvciBmaXJzdCBydW4pXG5mdW5jdGlvbiBfZm5GaWx0ZXJEYXRhICggc2V0dGluZ3MgKVxue1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdHZhciBjb2x1bW47XG5cdHZhciBqLCBqZW4sIGZpbHRlckRhdGEsIGNlbGxEYXRhLCByb3c7XG5cdHZhciB3YXNJbnZhbGlkYXRlZCA9IGZhbHNlO1xuXG5cdGZvciAoIHZhciByb3dJZHg9MCA7IHJvd0lkeDxkYXRhLmxlbmd0aCA7IHJvd0lkeCsrICkge1xuXHRcdGlmICghIGRhdGFbcm93SWR4XSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0cm93ID0gZGF0YVtyb3dJZHhdO1xuXG5cdFx0aWYgKCAhIHJvdy5fYUZpbHRlckRhdGEgKSB7XG5cdFx0XHRmaWx0ZXJEYXRhID0gW107XG5cblx0XHRcdGZvciAoIGo9MCwgamVuPWNvbHVtbnMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdGNvbHVtbiA9IGNvbHVtbnNbal07XG5cblx0XHRcdFx0aWYgKCBjb2x1bW4uYlNlYXJjaGFibGUgKSB7XG5cdFx0XHRcdFx0Y2VsbERhdGEgPSBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgaiwgJ2ZpbHRlcicgKTtcblxuXHRcdFx0XHRcdC8vIFNlYXJjaCBpbiBEYXRhVGFibGVzIGlzIHN0cmluZyBiYXNlZFxuXHRcdFx0XHRcdGlmICggY2VsbERhdGEgPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRjZWxsRGF0YSA9ICcnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdHlwZW9mIGNlbGxEYXRhICE9PSAnc3RyaW5nJyAmJiBjZWxsRGF0YS50b1N0cmluZyApIHtcblx0XHRcdFx0XHRcdGNlbGxEYXRhID0gY2VsbERhdGEudG9TdHJpbmcoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2VsbERhdGEgPSAnJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIGl0IGxvb2tzIGxpa2UgdGhlcmUgaXMgYW4gSFRNTCBlbnRpdHkgaW4gdGhlIHN0cmluZyxcblx0XHRcdFx0Ly8gYXR0ZW1wdCB0byBkZWNvZGUgaXQgc28gc29ydGluZyB3b3JrcyBhcyBleHBlY3RlZC4gTm90ZSB0aGF0XG5cdFx0XHRcdC8vIHdlIGNvdWxkIHVzZSBhIHNpbmdsZSBsaW5lIG9mIGpRdWVyeSB0byBkbyB0aGlzLCBidXQgdGhlIERPTVxuXHRcdFx0XHQvLyBtZXRob2QgdXNlZCBoZXJlIGlzIG11Y2ggZmFzdGVyIGh0dHBzOi8vanNwZXJmLmNvbS9odG1sLWRlY29kZVxuXHRcdFx0XHRpZiAoIGNlbGxEYXRhLmluZGV4T2YgJiYgY2VsbERhdGEuaW5kZXhPZignJicpICE9PSAtMSApIHtcblx0XHRcdFx0XHRfX2ZpbHRlcl9kaXYuaW5uZXJIVE1MID0gY2VsbERhdGE7XG5cdFx0XHRcdFx0Y2VsbERhdGEgPSBfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQgP1xuXHRcdFx0XHRcdFx0X19maWx0ZXJfZGl2LnRleHRDb250ZW50IDpcblx0XHRcdFx0XHRcdF9fZmlsdGVyX2Rpdi5pbm5lclRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNlbGxEYXRhLnJlcGxhY2UgKSB7XG5cdFx0XHRcdFx0Y2VsbERhdGEgPSBjZWxsRGF0YS5yZXBsYWNlKC9bXFxyXFxuXFx1MjAyOF0vZywgJycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmlsdGVyRGF0YS5wdXNoKCBjZWxsRGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyb3cuX2FGaWx0ZXJEYXRhID0gZmlsdGVyRGF0YTtcblx0XHRcdHJvdy5fc0ZpbHRlclJvdyA9IGZpbHRlckRhdGEuam9pbignICAnKTtcblx0XHRcdHdhc0ludmFsaWRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gd2FzSW52YWxpZGF0ZWQ7XG59XG5cblxuLyoqXG4gKiBEcmF3IHRoZSB0YWJsZSBmb3IgdGhlIGZpcnN0IHRpbWUsIGFkZGluZyBhbGwgcmVxdWlyZWQgZmVhdHVyZXNcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuSW5pdGlhbGlzZSAoIHNldHRpbmdzIClcbntcblx0dmFyIGk7XG5cdHZhciBpbml0ID0gc2V0dGluZ3Mub0luaXQ7XG5cdHZhciBkZWZlckxvYWRpbmcgPSBzZXR0aW5ncy5kZWZlckxvYWRpbmc7XG5cdHZhciBkYXRhU3JjID0gX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKTtcblxuXHQvLyBFbnN1cmUgdGhhdCB0aGUgdGFibGUgZGF0YSBpcyBmdWxseSBpbml0aWFsaXNlZFxuXHRpZiAoICEgc2V0dGluZ3MuYkluaXRpYWxpc2VkICkge1xuXHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCl7IF9mbkluaXRpYWxpc2UoIHNldHRpbmdzICk7IH0sIDIwMCApO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIEJ1aWxkIHRoZSBoZWFkZXIgLyBmb290ZXIgZm9yIHRoZSB0YWJsZVxuXHRfZm5CdWlsZEhlYWQoIHNldHRpbmdzLCAnaGVhZGVyJyApO1xuXHRfZm5CdWlsZEhlYWQoIHNldHRpbmdzLCAnZm9vdGVyJyApO1xuXG5cdC8vIExvYWQgdGhlIHRhYmxlJ3Mgc3RhdGUgKGlmIG5lZWRlZCkgYW5kIHRoZW4gcmVuZGVyIGFyb3VuZCBpdCBhbmQgZHJhd1xuXHRfZm5Mb2FkU3RhdGUoIHNldHRpbmdzLCBpbml0LCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGhlbiBkcmF3IHRoZSBoZWFkZXIgLyBmb290ZXJcblx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvSGVhZGVyICk7XG5cdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0Zvb3RlciApO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIHBhZ2luZyBzdGFydCBwb2ludCwgYXMgdGhlIGZpcnN0IHJlZHJhdyB3aWxsIHJlc2V0IGl0XG5cdFx0dmFyIGlBamF4U3RhcnQgPSBzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydFxuXG5cdFx0Ly8gTG9jYWwgZGF0YSBsb2FkXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlcmUgaXMgZGF0YSBwYXNzaW5nIGludG8gdGhlIGNvbnN0cnVjdG9yXG5cdFx0aWYgKCBpbml0LmFhRGF0YSApIHtcblx0XHRcdGZvciAoIGk9MCA7IGk8aW5pdC5hYURhdGEubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgaW5pdC5hYURhdGFbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggZGVmZXJMb2FkaW5nIHx8IGRhdGFTcmMgPT0gJ2RvbScgKSB7XG5cdFx0XHQvLyBHcmFiIHRoZSBkYXRhIGZyb20gdGhlIHBhZ2Vcblx0XHRcdF9mbkFkZFRyKCBzZXR0aW5ncywgJChzZXR0aW5ncy5uVEJvZHkpLmNoaWxkcmVuKCd0cicpICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyIG5vdCB5ZXQgYXBwbGllZCAtIGNvcHkgdGhlIGRpc3BsYXkgbWFzdGVyXG5cdFx0c2V0dGluZ3MuYWlEaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cblx0XHQvLyBFbmFibGUgZmVhdHVyZXNcblx0XHRfZm5BZGRPcHRpb25zSHRtbCggc2V0dGluZ3MgKTtcblx0XHRfZm5Tb3J0SW5pdCggc2V0dGluZ3MgKTtcblxuXHRcdF9jb2xHcm91cCggc2V0dGluZ3MgKTtcblxuXHRcdC8qIE9rYXkgdG8gc2hvdyB0aGF0IHNvbWV0aGluZyBpcyBnb2luZyBvbiBub3cgKi9cblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIHRydWUgKTtcblxuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwcmVJbml0JywgW3NldHRpbmdzXSwgdHJ1ZSApO1xuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgZGVmYXVsdCBzb3J0aW5nIHJlcXVpcmVkIC0gbGV0J3MgZG8gaXQuIFRoZSBzb3J0IGZ1bmN0aW9uXG5cdFx0Ly8gd2lsbCBkbyB0aGUgZHJhd2luZyBmb3IgdXMuIE90aGVyd2lzZSB3ZSBkcmF3IHRoZSB0YWJsZSByZWdhcmRsZXNzIG9mIHRoZVxuXHRcdC8vIEFqYXggc291cmNlIC0gdGhpcyBhbGxvd3MgdGhlIHRhYmxlIHRvIGxvb2sgaW5pdGlhbGlzZWQgZm9yIEFqYXggc291cmNpbmdcblx0XHQvLyBkYXRhIChzaG93ICdsb2FkaW5nJyBtZXNzYWdlIHBvc3NpYmx5KVxuXHRcdF9mblJlRHJhdyggc2V0dGluZ3MgKTtcblxuXHRcdC8vIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgaW5pdCBjb21wbGV0ZSBpcyBkb25lIGJ5IF9mbkFqYXhVcGRhdGVEcmF3XG5cdFx0aWYgKCBkYXRhU3JjICE9ICdzc3AnIHx8IGRlZmVyTG9hZGluZyApIHtcblx0XHRcdC8vIGlmIHRoZXJlIGlzIGFuIGFqYXggc291cmNlIGxvYWQgdGhlIGRhdGFcblx0XHRcdGlmICggZGF0YVNyYyA9PSAnYWpheCcgKSB7XG5cdFx0XHRcdF9mbkJ1aWxkQWpheCggc2V0dGluZ3MsIHt9LCBmdW5jdGlvbihqc29uKSB7XG5cdFx0XHRcdFx0dmFyIGFEYXRhID0gX2ZuQWpheERhdGFTcmMoIHNldHRpbmdzLCBqc29uICk7XG5cblx0XHRcdFx0XHQvLyBHb3QgdGhlIGRhdGEgLSBhZGQgaXQgdG8gdGhlIHRhYmxlXG5cdFx0XHRcdFx0Zm9yICggaT0wIDsgaTxhRGF0YS5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgYURhdGFbaV0gKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSZXNldCB0aGUgaW5pdCBkaXNwbGF5IGZvciBjb29raWUgc2F2aW5nLiBXZSd2ZSBhbHJlYWR5IGRvbmVcblx0XHRcdFx0XHQvLyBhIGZpbHRlciwgYW5kIHRoZXJlZm9yZSBjbGVhcmVkIGl0IGJlZm9yZS4gU28gd2UgbmVlZCB0byBtYWtlXG5cdFx0XHRcdFx0Ly8gaXQgYXBwZWFyICdmcmVzaCdcblx0XHRcdFx0XHRzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IGlBamF4U3RhcnQ7XG5cblx0XHRcdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzICk7XG5cdFx0XHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xuXHRcdFx0XHRcdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MgKTtcblx0XHRcdFx0fSwgc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRfZm5Jbml0Q29tcGxldGUoIHNldHRpbmdzICk7XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuXG4vKipcbiAqIERyYXcgdGhlIHRhYmxlIGZvciB0aGUgZmlyc3QgdGltZSwgYWRkaW5nIGFsbCByZXF1aXJlZCBmZWF0dXJlc1xuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Jbml0Q29tcGxldGUgKCBzZXR0aW5ncyApXG57XG5cdGlmIChzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBhcmdzID0gW3NldHRpbmdzLCBzZXR0aW5ncy5qc29uXTtcblxuXHRzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSA9IHRydWU7XG5cblx0Ly8gVGFibGUgaXMgZnVsbHkgc2V0IHVwIGFuZCB3ZSBoYXZlIGRhdGEsIHNvIGNhbGN1bGF0ZSB0aGVcblx0Ly8gY29sdW1uIHdpZHRoc1xuXHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgJ3BsdWdpbi1pbml0JywgYXJncywgdHJ1ZSApO1xuXHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAnaW5pdCcsIGFyZ3MsIHRydWUgKTtcbn1cblxuZnVuY3Rpb24gX2ZuTGVuZ3RoQ2hhbmdlICggc2V0dGluZ3MsIHZhbCApXG57XG5cdHZhciBsZW4gPSBwYXJzZUludCggdmFsLCAxMCApO1xuXHRzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggPSBsZW47XG5cblx0X2ZuTGVuZ3RoT3ZlcmZsb3coIHNldHRpbmdzICk7XG5cblx0Ly8gRmlyZSBsZW5ndGggY2hhbmdlIGV2ZW50XG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdsZW5ndGgnLCBbc2V0dGluZ3MsIGxlbl0gKTtcbn1cblxuLyoqXG4gKiBBbHRlciB0aGUgZGlzcGxheSBzZXR0aW5ncyB0byBjaGFuZ2UgdGhlIHBhZ2VcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge3N0cmluZ3xpbnR9IGFjdGlvbiBQYWdpbmcgYWN0aW9uIHRvIHRha2U6IFwiZmlyc3RcIiwgXCJwcmV2aW91c1wiLFxuICogICAgXCJuZXh0XCIgb3IgXCJsYXN0XCIgb3IgcGFnZSBudW1iZXIgdG8ganVtcCB0byAoaW50ZWdlcilcbiAqICBAcGFyYW0gW2Jvb2xdIHJlZHJhdyBBdXRvbWF0aWNhbGx5IGRyYXcgdGhlIHVwZGF0ZSBvciBub3RcbiAqICBAcmV0dXJucyB7Ym9vbH0gdHJ1ZSBwYWdlIGhhcyBjaGFuZ2VkLCBmYWxzZSAtIG5vIGNoYW5nZVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5QYWdlQ2hhbmdlICggc2V0dGluZ3MsIGFjdGlvbiwgcmVkcmF3IClcbntcblx0dmFyXG5cdFx0c3RhcnQgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0bGVuICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdHJlY29yZHMgICA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKTtcblxuXHRpZiAoIHJlY29yZHMgPT09IDAgfHwgbGVuID09PSAtMSApXG5cdHtcblx0XHRzdGFydCA9IDA7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBhY3Rpb24gPT09IFwibnVtYmVyXCIgKVxuXHR7XG5cdFx0c3RhcnQgPSBhY3Rpb24gKiBsZW47XG5cblx0XHRpZiAoIHN0YXJ0ID4gcmVjb3JkcyApXG5cdFx0e1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggYWN0aW9uID09IFwiZmlyc3RcIiApXG5cdHtcblx0XHRzdGFydCA9IDA7XG5cdH1cblx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcInByZXZpb3VzXCIgKVxuXHR7XG5cdFx0c3RhcnQgPSBsZW4gPj0gMCA/XG5cdFx0XHRzdGFydCAtIGxlbiA6XG5cdFx0XHQwO1xuXG5cdFx0aWYgKCBzdGFydCA8IDAgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcIm5leHRcIiApXG5cdHtcblx0XHRpZiAoIHN0YXJ0ICsgbGVuIDwgcmVjb3JkcyApXG5cdFx0e1xuXHRcdFx0c3RhcnQgKz0gbGVuO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggYWN0aW9uID09IFwibGFzdFwiIClcblx0e1xuXHRcdHN0YXJ0ID0gTWF0aC5mbG9vciggKHJlY29yZHMtMSkgLyBsZW4pICogbGVuO1xuXHR9XG5cdGVsc2UgaWYgKCBhY3Rpb24gPT09ICdlbGxpcHNpcycgKVxuXHR7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdF9mbkxvZyggc2V0dGluZ3MsIDAsIFwiVW5rbm93biBwYWdpbmcgYWN0aW9uOiBcIithY3Rpb24sIDUgKTtcblx0fVxuXG5cdHZhciBjaGFuZ2VkID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgIT09IHN0YXJ0O1xuXHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xuXG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsIGNoYW5nZWQgPyAncGFnZScgOiAncGFnZS1uYycsIFtzZXR0aW5nc10gKTtcblxuXHRpZiAoIGNoYW5nZWQgJiYgcmVkcmF3ICkge1xuXHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdH1cblxuXHRyZXR1cm4gY2hhbmdlZDtcbn1cblxuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB0aGUgcHJvY2Vzc2luZyBub2RlXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIF9wcm9jZXNzaW5nSHRtbCAoIHNldHRpbmdzIClcbntcblx0dmFyIHRhYmxlID0gc2V0dGluZ3MublRhYmxlO1xuXHR2YXIgc2Nyb2xsaW5nID0gc2V0dGluZ3Mub1Njcm9sbC5zWCAhPT0gJycgfHwgc2V0dGluZ3Mub1Njcm9sbC5zWSAhPT0gJyc7XG5cblx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlByb2Nlc3NpbmcgKSB7XG5cdFx0dmFyIG4gPSAkKCc8ZGl2Lz4nLCB7XG5cdFx0XHRcdCdpZCc6IHNldHRpbmdzLnNUYWJsZUlkICsgJ19wcm9jZXNzaW5nJyxcblx0XHRcdFx0J2NsYXNzJzogc2V0dGluZ3Mub0NsYXNzZXMucHJvY2Vzc2luZy5jb250YWluZXIsXG5cdFx0XHRcdCdyb2xlJzogJ3N0YXR1cydcblx0XHRcdH0gKVxuXHRcdFx0Lmh0bWwoIHNldHRpbmdzLm9MYW5ndWFnZS5zUHJvY2Vzc2luZyApXG5cdFx0XHQuYXBwZW5kKCc8ZGl2PjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PjxkaXY+PC9kaXY+PC9kaXY+Jyk7XG5cblx0XHQvLyBEaWZmZXJlbnQgcG9zaXRpb25pbmcgZGVwZW5kaW5nIG9uIGlmIHNjcm9sbGluZyBpcyBlbmFibGVkIG9yIG5vdFxuXHRcdGlmIChzY3JvbGxpbmcpIHtcblx0XHRcdG4ucHJlcGVuZFRvKCAkKCdkaXYuZHQtc2Nyb2xsJywgc2V0dGluZ3MublRhYmxlV3JhcHBlcikgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRuLmluc2VydEJlZm9yZSggdGFibGUgKTtcblx0XHR9XG5cblx0XHQkKHRhYmxlKS5vbiggJ3Byb2Nlc3NpbmcuZHQuRFQnLCBmdW5jdGlvbiAoZSwgcywgc2hvdykge1xuXHRcdFx0bi5jc3MoICdkaXNwbGF5Jywgc2hvdyA/ICdibG9jaycgOiAnbm9uZScgKTtcblx0XHR9ICk7XG5cdH1cbn1cblxuXG4vKipcbiAqIERpc3BsYXkgb3IgaGlkZSB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3JcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2Jvb2x9IHNob3cgU2hvdyB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3IgKHRydWUpIG9yIG5vdCAoZmFsc2UpXG4gKi9cbmZ1bmN0aW9uIF9mblByb2Nlc3NpbmdEaXNwbGF5ICggc2V0dGluZ3MsIHNob3cgKVxue1xuXHQvLyBJZ25vcmUgY2FzZXMgd2hlbiB3ZSBhcmUgc3RpbGwgcmVkcmF3aW5nXG5cdGlmIChzZXR0aW5ncy5iRHJhd2luZyAmJiBzaG93ID09PSBmYWxzZSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwcm9jZXNzaW5nJywgW3NldHRpbmdzLCBzaG93XSApO1xufVxuXG4vKipcbiAqIFNob3cgdGhlIHByb2Nlc3NpbmcgZWxlbWVudCBpZiBhbiBhY3Rpb24gdGFrZXMgbG9uZ2VyIHRoYW4gYSBnaXZlbiB0aW1lXG4gKlxuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHsqfSBlbmFibGUgRG8gKHRydWUpIG9yIG5vdCAoZmFsc2UpIGFzeW5jIHByb2Nlc3NpbmcgKGxvY2FsIGZlYXR1cmUgZW5hYmxlbWVudClcbiAqIEBwYXJhbSB7Kn0gcnVuIEZ1bmN0aW9uIHRvIHJ1blxuICovXG5mdW5jdGlvbiBfZm5Qcm9jZXNzaW5nUnVuKCBzZXR0aW5ncywgZW5hYmxlLCBydW4gKSB7XG5cdGlmICghIGVuYWJsZSkge1xuXHRcdC8vIEltbWVkaWF0ZSBleGVjdXRpb24sIHN5bmNocm9ub3VzXG5cdFx0cnVuKCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIHRydWUpO1xuXHRcdFxuXHRcdC8vIEFsbG93IHRoZSBwcm9jZXNzaW5nIGRpc3BsYXkgdG8gc2hvdyBpZiBuZWVkZWRcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHJ1bigpO1xuXG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgZmFsc2UpO1xuXHRcdH0sIDApO1xuXHR9XG59XG4vKipcbiAqIEFkZCBhbnkgY29udHJvbCBlbGVtZW50cyBmb3IgdGhlIHRhYmxlIC0gc3BlY2lmaWNhbGx5IHNjcm9sbGluZ1xuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtub2RlfSBOb2RlIHRvIGFkZCB0byB0aGUgRE9NXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sVGFibGUgKCBzZXR0aW5ncyApXG57XG5cdHZhciB0YWJsZSA9ICQoc2V0dGluZ3MublRhYmxlKTtcblxuXHQvLyBTY3JvbGxpbmcgZnJvbSBoZXJlIG9uIGluXG5cdHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuXG5cdGlmICggc2Nyb2xsLnNYID09PSAnJyAmJiBzY3JvbGwuc1kgPT09ICcnICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5uVGFibGU7XG5cdH1cblxuXHR2YXIgc2Nyb2xsWCA9IHNjcm9sbC5zWDtcblx0dmFyIHNjcm9sbFkgPSBzY3JvbGwuc1k7XG5cdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXMuc2Nyb2xsaW5nO1xuXHR2YXIgY2FwdGlvbiA9IHNldHRpbmdzLmNhcHRpb25Ob2RlO1xuXHR2YXIgY2FwdGlvblNpZGUgPSBjYXB0aW9uID8gY2FwdGlvbi5fY2FwdGlvblNpZGUgOiBudWxsO1xuXHR2YXIgaGVhZGVyQ2xvbmUgPSAkKCB0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpICk7XG5cdHZhciBmb290ZXJDbG9uZSA9ICQoIHRhYmxlWzBdLmNsb25lTm9kZShmYWxzZSkgKTtcblx0dmFyIGZvb3RlciA9IHRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpO1xuXHR2YXIgX2RpdiA9ICc8ZGl2Lz4nO1xuXHR2YXIgc2l6ZSA9IGZ1bmN0aW9uICggcyApIHtcblx0XHRyZXR1cm4gIXMgPyBudWxsIDogX2ZuU3RyaW5nVG9Dc3MoIHMgKTtcblx0fTtcblxuXHRpZiAoICEgZm9vdGVyLmxlbmd0aCApIHtcblx0XHRmb290ZXIgPSBudWxsO1xuXHR9XG5cblx0Lypcblx0ICogVGhlIEhUTUwgc3RydWN0dXJlIHRoYXQgd2Ugd2FudCB0byBnZW5lcmF0ZSBpbiB0aGlzIGZ1bmN0aW9uIGlzOlxuXHQgKiAgZGl2IC0gc2Nyb2xsZXJcblx0ICogICAgZGl2IC0gc2Nyb2xsIGhlYWRcblx0ICogICAgICBkaXYgLSBzY3JvbGwgaGVhZCBpbm5lclxuXHQgKiAgICAgICAgdGFibGUgLSBzY3JvbGwgaGVhZCB0YWJsZVxuXHQgKiAgICAgICAgICB0aGVhZCAtIHRoZWFkXG5cdCAqICAgIGRpdiAtIHNjcm9sbCBib2R5XG5cdCAqICAgICAgdGFibGUgLSB0YWJsZSAobWFzdGVyIHRhYmxlKVxuXHQgKiAgICAgICAgdGhlYWQgLSB0aGVhZCBjbG9uZSBmb3Igc2l6aW5nXG5cdCAqICAgICAgICB0Ym9keSAtIHRib2R5XG5cdCAqICAgIGRpdiAtIHNjcm9sbCBmb290XG5cdCAqICAgICAgZGl2IC0gc2Nyb2xsIGZvb3QgaW5uZXJcblx0ICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGZvb3QgdGFibGVcblx0ICogICAgICAgICAgdGZvb3QgLSB0Zm9vdFxuXHQgKi9cblx0dmFyIHNjcm9sbGVyID0gJCggX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLmNvbnRhaW5lciB9IClcblx0XHQuYXBwZW5kKFxuXHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuaGVhZGVyLnNlbGYgfSApXG5cdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdFx0cG9zaXRpb246ICdyZWxhdGl2ZScsXG5cdFx0XHRcdFx0Ym9yZGVyOiAwLFxuXHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5oZWFkZXIuaW5uZXIgfSApXG5cdFx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRcdCdib3gtc2l6aW5nJzogJ2NvbnRlbnQtYm94Jyxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHNjcm9sbC5zWElubmVyIHx8ICcxMDAlJ1xuXHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRoZWFkZXJDbG9uZVxuXHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVBdHRyKCdpZCcpXG5cdFx0XHRcdFx0XHRcdFx0LmNzcyggJ21hcmdpbi1sZWZ0JywgMCApXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZCggY2FwdGlvblNpZGUgPT09ICd0b3AnID8gY2FwdGlvbiA6IG51bGwgKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHR0YWJsZS5jaGlsZHJlbigndGhlYWQnKVxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0KVxuXHRcdClcblx0XHQuYXBwZW5kKFxuXHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuYm9keSB9IClcblx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuXHRcdFx0XHRcdG92ZXJmbG93OiAnYXV0bycsXG5cdFx0XHRcdFx0d2lkdGg6IHNpemUoIHNjcm9sbFggKVxuXHRcdFx0XHR9IClcblx0XHRcdFx0LmFwcGVuZCggdGFibGUgKVxuXHRcdCk7XG5cblx0aWYgKCBmb290ZXIgKSB7XG5cdFx0c2Nyb2xsZXIuYXBwZW5kKFxuXHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuZm9vdGVyLnNlbGYgfSApXG5cdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdFx0Ym9yZGVyOiAwLFxuXHRcdFx0XHRcdHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xuXHRcdFx0XHR9IClcblx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHQkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5mb290ZXIuaW5uZXIgfSApXG5cdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRmb290ZXJDbG9uZVxuXHRcdFx0XHRcdFx0XHRcdC5yZW1vdmVBdHRyKCdpZCcpXG5cdFx0XHRcdFx0XHRcdFx0LmNzcyggJ21hcmdpbi1sZWZ0JywgMCApXG5cdFx0XHRcdFx0XHRcdFx0LmFwcGVuZCggY2FwdGlvblNpZGUgPT09ICdib3R0b20nID8gY2FwdGlvbiA6IG51bGwgKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHR0YWJsZS5jaGlsZHJlbigndGZvb3QnKVxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0KVxuXHRcdCk7XG5cdH1cblxuXHR2YXIgY2hpbGRyZW4gPSBzY3JvbGxlci5jaGlsZHJlbigpO1xuXHR2YXIgc2Nyb2xsSGVhZCA9IGNoaWxkcmVuWzBdO1xuXHR2YXIgc2Nyb2xsQm9keSA9IGNoaWxkcmVuWzFdO1xuXHR2YXIgc2Nyb2xsRm9vdCA9IGZvb3RlciA/IGNoaWxkcmVuWzJdIDogbnVsbDtcblxuXHQvLyBXaGVuIHRoZSBib2R5IGlzIHNjcm9sbGVkLCB0aGVuIHdlIGFsc28gd2FudCB0byBzY3JvbGwgdGhlIGhlYWRlcnNcblx0JChzY3JvbGxCb2R5KS5vbiggJ3Njcm9sbC5EVCcsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdDtcblxuXHRcdHNjcm9sbEhlYWQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cblx0XHRpZiAoIGZvb3RlciApIHtcblx0XHRcdHNjcm9sbEZvb3Quc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cdFx0fVxuXHR9ICk7XG5cblx0Ly8gV2hlbiBmb2N1cyBpcyBwdXQgb24gdGhlIGhlYWRlciBjZWxscywgd2UgbWlnaHQgbmVlZCB0byBzY3JvbGwgdGhlIGJvZHlcblx0JCgndGgsIHRkJywgc2Nyb2xsSGVhZCkub24oJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzY3JvbGxMZWZ0ID0gc2Nyb2xsSGVhZC5zY3JvbGxMZWZ0O1xuXG5cdFx0c2Nyb2xsQm9keS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblxuXHRcdGlmICggZm9vdGVyICkge1xuXHRcdFx0c2Nyb2xsQm9keS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblx0XHR9XG5cdH0pO1xuXG5cdCQoc2Nyb2xsQm9keSkuY3NzKCdtYXgtaGVpZ2h0Jywgc2Nyb2xsWSk7XG5cdGlmICghIHNjcm9sbC5iQ29sbGFwc2UpIHtcblx0XHQkKHNjcm9sbEJvZHkpLmNzcygnaGVpZ2h0Jywgc2Nyb2xsWSk7XG5cdH1cblxuXHRzZXR0aW5ncy5uU2Nyb2xsSGVhZCA9IHNjcm9sbEhlYWQ7XG5cdHNldHRpbmdzLm5TY3JvbGxCb2R5ID0gc2Nyb2xsQm9keTtcblx0c2V0dGluZ3MublNjcm9sbEZvb3QgPSBzY3JvbGxGb290O1xuXG5cdC8vIE9uIHJlZHJhdyAtIGFsaWduIGNvbHVtbnNcblx0c2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaChfZm5TY3JvbGxEcmF3KTtcblxuXHRyZXR1cm4gc2Nyb2xsZXJbMF07XG59XG5cblxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgaGVhZGVyLCBmb290ZXIgYW5kIGJvZHkgdGFibGVzIGZvciByZXNpemluZyAtIGkuZS4gY29sdW1uXG4gKiBhbGlnbm1lbnQuXG4gKlxuICogV2VsY29tZSB0byB0aGUgbW9zdCBob3JyaWJsZSBmdW5jdGlvbiBEYXRhVGFibGVzLiBUaGUgcHJvY2VzcyB0aGF0IHRoaXNcbiAqIGZ1bmN0aW9uIGZvbGxvd3MgaXMgYmFzaWNhbGx5OlxuICogICAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxuICogICAyLiBDb3JyZWN0IGNvbGdyb3VwID4gY29sIHZhbHVlcyBpZiBuZWVkZWRcbiAqICAgMy4gQ29weSBjb2xncm91cCA+IGNvbCBvdmVyIHRvIGhlYWRlciBhbmQgZm9vdGVyXG4gKiAgIDQuIENsZWFuIHVwXG4gKlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5TY3JvbGxEcmF3ICggc2V0dGluZ3MgKVxue1xuXHQvLyBHaXZlbiB0aGF0IHRoaXMgaXMgc3VjaCBhIG1vbnN0ZXIgZnVuY3Rpb24sIGEgbG90IG9mIHZhcmlhYmxlcyBhcmUgdXNlXG5cdC8vIHRvIHRyeSBhbmQga2VlcCB0aGUgbWluaW1pc2VkIHNpemUgYXMgc21hbGwgYXMgcG9zc2libGVcblx0dmFyXG5cdFx0c2Nyb2xsICAgICAgICAgPSBzZXR0aW5ncy5vU2Nyb2xsLFxuXHRcdGJhcldpZHRoICAgICAgID0gc2Nyb2xsLmlCYXJXaWR0aCxcblx0XHRkaXZIZWFkZXIgICAgICA9ICQoc2V0dGluZ3MublNjcm9sbEhlYWQpLFxuXHRcdGRpdkhlYWRlcklubmVyID0gZGl2SGVhZGVyLmNoaWxkcmVuKCdkaXYnKSxcblx0XHRkaXZIZWFkZXJUYWJsZSA9IGRpdkhlYWRlcklubmVyLmNoaWxkcmVuKCd0YWJsZScpLFxuXHRcdGRpdkJvZHlFbCAgICAgID0gc2V0dGluZ3MublNjcm9sbEJvZHksXG5cdFx0ZGl2Qm9keSAgICAgICAgPSAkKGRpdkJvZHlFbCksXG5cdFx0ZGl2Rm9vdGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxGb290KSxcblx0XHRkaXZGb290ZXJJbm5lciA9IGRpdkZvb3Rlci5jaGlsZHJlbignZGl2JyksXG5cdFx0ZGl2Rm9vdGVyVGFibGUgPSBkaXZGb290ZXJJbm5lci5jaGlsZHJlbigndGFibGUnKSxcblx0XHRoZWFkZXIgICAgICAgICA9ICQoc2V0dGluZ3MublRIZWFkKSxcblx0XHR0YWJsZSAgICAgICAgICA9ICQoc2V0dGluZ3MublRhYmxlKSxcblx0XHRmb290ZXIgICAgICAgICA9IHNldHRpbmdzLm5URm9vdCAmJiAkKCd0aCwgdGQnLCBzZXR0aW5ncy5uVEZvb3QpLmxlbmd0aCA/ICQoc2V0dGluZ3MublRGb290KSA6IG51bGwsXG5cdFx0YnJvd3NlciAgICAgICAgPSBzZXR0aW5ncy5vQnJvd3Nlcixcblx0XHRoZWFkZXJDb3B5LCBmb290ZXJDb3B5O1xuXG5cdC8vIElmIHRoZSBzY3JvbGxiYXIgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCBmcm9tIHRoZSBsYXN0IGRyYXcsIHdlIG5lZWQgdG9cblx0Ly8gYWRqdXN0IHRoZSBjb2x1bW4gc2l6ZXMgYXMgdGhlIHRhYmxlIHdpZHRoIHdpbGwgaGF2ZSBjaGFuZ2VkIHRvIGFjY291bnRcblx0Ly8gZm9yIHRoZSBzY3JvbGxiYXJcblx0dmFyIHNjcm9sbEJhclZpcyA9IGRpdkJvZHlFbC5zY3JvbGxIZWlnaHQgPiBkaXZCb2R5RWwuY2xpZW50SGVpZ2h0O1xuXHRcblx0aWYgKCBzZXR0aW5ncy5zY3JvbGxCYXJWaXMgIT09IHNjcm9sbEJhclZpcyAmJiBzZXR0aW5ncy5zY3JvbGxCYXJWaXMgIT09IHVuZGVmaW5lZCApIHtcblx0XHRzZXR0aW5ncy5zY3JvbGxCYXJWaXMgPSBzY3JvbGxCYXJWaXM7XG5cdFx0X2ZuQWRqdXN0Q29sdW1uU2l6aW5nKCBzZXR0aW5ncyApO1xuXHRcdHJldHVybjsgLy8gYWRqdXN0IGNvbHVtbiBzaXppbmcgd2lsbCBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW5cblx0fVxuXHRlbHNlIHtcblx0XHRzZXR0aW5ncy5zY3JvbGxCYXJWaXMgPSBzY3JvbGxCYXJWaXM7XG5cdH1cblxuXHQvLyAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxuXHQvLyBSZW1vdmUgdGhlIG9sZCBtaW5pbWlzZWQgdGhlYWQgYW5kIHRmb290IGVsZW1lbnRzIGluIHRoZSBpbm5lciB0YWJsZVxuXHR0YWJsZS5jaGlsZHJlbigndGhlYWQsIHRmb290JykucmVtb3ZlKCk7XG5cblx0Ly8gQ2xvbmUgdGhlIGN1cnJlbnQgaGVhZGVyIGFuZCBmb290ZXIgZWxlbWVudHMgYW5kIHRoZW4gcGxhY2UgaXQgaW50byB0aGUgaW5uZXIgdGFibGVcblx0aGVhZGVyQ29weSA9IGhlYWRlci5jbG9uZSgpLnByZXBlbmRUbyggdGFibGUgKTtcblx0aGVhZGVyQ29weS5maW5kKCd0aCwgdGQnKS5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuXHRoZWFkZXJDb3B5LmZpbmQoJ1tpZF0nKS5yZW1vdmVBdHRyKCdpZCcpO1xuXG5cdGlmICggZm9vdGVyICkge1xuXHRcdGZvb3RlckNvcHkgPSBmb290ZXIuY2xvbmUoKS5wcmVwZW5kVG8oIHRhYmxlICk7XG5cdFx0Zm9vdGVyQ29weS5maW5kKCdbaWRdJykucmVtb3ZlQXR0cignaWQnKTtcblx0fVxuXG5cdC8vIDIuIENvcnJlY3QgY29sZ3JvdXAgPiBjb2wgdmFsdWVzIGlmIG5lZWRlZFxuXHQvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBjZWxsIHNpemVzIGFyZSBzbWFsbGVyIHRoYW4gdGhlIGNvbnRlbnQsIHNvIHdlIG5lZWQgdG9cblx0Ly8gY29ycmVjdCBjb2xncm91cD5jb2wgZm9yIHN1Y2ggY2FzZXMuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgYXV0byB3aWR0aCBkZXRlY3Rpb25cblx0Ly8gdXNlcyBhIGNlbGwgd2hpY2ggaGFzIGEgbG9uZ2VyIHN0cmluZywgYnV0IGlzbid0IHRoZSB3aWRlc3QhIEZvciBleGFtcGxlIFxuXHQvLyBcIkNoaWVmIEV4ZWN1dGl2ZSBPZmZpY2VyIChDRU8pXCIgaXMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIHRoZSBkZW1vLCBidXRcblx0Ly8gXCJTeXN0ZW1zIEFkbWluaXN0cmF0b3JcIiBpcyBhY3R1YWxseSB0aGUgd2lkZXN0IHN0cmluZyBzaW5jZSBpdCBkb2Vzbid0IGNvbGxhcHNlLlxuXHQvLyBOb3RlIHRoZSB1c2Ugb2YgdHJhbnNsYXRpbmcgaW50byBhIGNvbHVtbiBpbmRleCB0byBnZXQgdGhlIGBjb2xgIGVsZW1lbnQuIFRoaXNcblx0Ly8gaXMgYmVjYXVzZSBvZiBSZXNwb25zaXZlIHdoaWNoIG1pZ2h0IHJlbW92ZSBgY29sYCBlbGVtZW50cywga25vY2tpbmcgdGhlIGFsaWdubWVudFxuXHQvLyBvZiB0aGUgaW5kZXhlcyBvdXQuXG5cdGlmIChzZXR0aW5ncy5haURpc3BsYXkubGVuZ3RoKSB7XG5cdFx0Ly8gR2V0IHRoZSBjb2x1bW4gc2l6ZXMgZnJvbSB0aGUgZmlyc3Qgcm93IGluIHRoZSB0YWJsZS4gVGhpcyBzaG91bGQgcmVhbGx5IGJlIGFcblx0XHQvLyBbXS5maW5kLCBidXQgaXQgd2Fzbid0IHN1cHBvcnRlZCBpbiBDaHJvbWUgdW50aWwgU2VwdCAyMDE1LCBhbmQgRFQgaGFzIDEwIHllYXJcblx0XHQvLyBicm93c2VyIHN1cHBvcnRcblx0XHR2YXIgZmlyc3RUciA9IG51bGw7XG5cdFx0dmFyIHN0YXJ0ID0gX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSAhPT0gJ3NzcCdcblx0XHRcdD8gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnRcblx0XHRcdDogMDtcblxuXHRcdGZvciAoaT1zdGFydCA7IGk8c3RhcnQgKyBzZXR0aW5ncy5haURpc3BsYXkubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHR2YXIgaWR4ID0gc2V0dGluZ3MuYWlEaXNwbGF5W2ldO1xuXHRcdFx0dmFyIHRyID0gc2V0dGluZ3MuYW9EYXRhW2lkeF0ublRyO1xuXG5cdFx0XHRpZiAodHIpIHtcblx0XHRcdFx0Zmlyc3RUciA9IHRyO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZmlyc3RUcikge1xuXHRcdFx0dmFyIGNvbFNpemVzID0gJChmaXJzdFRyKS5jaGlsZHJlbigndGgsIHRkJykubWFwKGZ1bmN0aW9uICh2aXMpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRpZHg6IF9mblZpc2libGVUb0NvbHVtbkluZGV4KHNldHRpbmdzLCB2aXMpLFxuXHRcdFx0XHRcdHdpZHRoOiAkKHRoaXMpLm91dGVyV2lkdGgoKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIENoZWNrIGFnYWluc3Qgd2hhdCB0aGUgY29sZ3JvdXAgPiBjb2wgaXMgc2V0IHRvIGFuZCBjb3JyZWN0IGlmIG5lZWRlZFxuXHRcdFx0Zm9yICh2YXIgaT0wIDsgaTxjb2xTaXplcy5sZW5ndGggOyBpKyspIHtcblx0XHRcdFx0dmFyIGNvbEVsID0gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2xTaXplc1tpXS5pZHggXS5jb2xFbFswXTtcblx0XHRcdFx0dmFyIGNvbFdpZHRoID0gY29sRWwuc3R5bGUud2lkdGgucmVwbGFjZSgncHgnLCAnJyk7XG5cblx0XHRcdFx0aWYgKGNvbFdpZHRoICE9PSBjb2xTaXplc1tpXS53aWR0aCkge1xuXHRcdFx0XHRcdGNvbEVsLnN0eWxlLndpZHRoID0gY29sU2l6ZXNbaV0ud2lkdGggKyAncHgnO1xuXG5cdFx0XHRcdFx0aWYgKHNjcm9sbC5zWCkge1xuXHRcdFx0XHRcdFx0Y29sRWwuc3R5bGUubWluV2lkdGggPSBjb2xTaXplc1tpXS53aWR0aCArICdweCc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMy4gQ29weSB0aGUgY29sZ3JvdXAgb3ZlciB0byB0aGUgaGVhZGVyIGFuZCBmb290ZXJcblx0ZGl2SGVhZGVyVGFibGVcblx0XHQuZmluZCgnY29sZ3JvdXAnKVxuXHRcdC5yZW1vdmUoKTtcblxuXHRkaXZIZWFkZXJUYWJsZS5hcHBlbmQoc2V0dGluZ3MuY29sZ3JvdXAuY2xvbmUoKSk7XG5cblx0aWYgKCBmb290ZXIgKSB7XG5cdFx0ZGl2Rm9vdGVyVGFibGVcblx0XHRcdC5maW5kKCdjb2xncm91cCcpXG5cdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRkaXZGb290ZXJUYWJsZS5hcHBlbmQoc2V0dGluZ3MuY29sZ3JvdXAuY2xvbmUoKSk7XG5cdH1cblxuXHQvLyBcIkhpZGVcIiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGhhdCB3ZSB1c2VkIGZvciB0aGUgc2l6aW5nLiBXZSBuZWVkIHRvIGtlZXBcblx0Ly8gdGhlIGNvbnRlbnQgb2YgdGhlIGNlbGwgc28gdGhhdCB0aGUgd2lkdGggYXBwbGllZCB0byB0aGUgaGVhZGVyIGFuZCBib2R5XG5cdC8vIGJvdGggbWF0Y2gsIGJ1dCB3ZSB3YW50IHRvIGhpZGUgaXQgY29tcGxldGVseS5cblx0JCgndGgsIHRkJywgaGVhZGVyQ29weSkuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0JCh0aGlzLmNoaWxkTm9kZXMpLndyYXBBbGwoJzxkaXYgY2xhc3M9XCJkdC1zY3JvbGwtc2l6aW5nXCI+Jyk7XG5cdH0pO1xuXG5cdGlmICggZm9vdGVyICkge1xuXHRcdCQoJ3RoLCB0ZCcsIGZvb3RlckNvcHkpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0JCh0aGlzLmNoaWxkTm9kZXMpLndyYXBBbGwoJzxkaXYgY2xhc3M9XCJkdC1zY3JvbGwtc2l6aW5nXCI+Jyk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyA0LiBDbGVhbiB1cFxuXHQvLyBGaWd1cmUgb3V0IGlmIHRoZXJlIGFyZSBzY3JvbGxiYXIgcHJlc2VudCAtIGlmIHNvIHRoZW4gd2UgbmVlZCBhIHRoZSBoZWFkZXIgYW5kIGZvb3RlciB0b1xuXHQvLyBwcm92aWRlIGEgYml0IG1vcmUgc3BhY2UgdG8gYWxsb3cgXCJvdmVyZmxvd1wiIHNjcm9sbGluZyAoaS5lLiBwYXN0IHRoZSBzY3JvbGxiYXIpXG5cdHZhciBpc1Njcm9sbGluZyA9IE1hdGguZmxvb3IodGFibGUuaGVpZ2h0KCkpID4gZGl2Qm9keUVsLmNsaWVudEhlaWdodCB8fCBkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCI7XG5cdHZhciBwYWRkaW5nU2lkZSA9ICdwYWRkaW5nJyArIChicm93c2VyLmJTY3JvbGxiYXJMZWZ0ID8gJ0xlZnQnIDogJ1JpZ2h0JyApO1xuXG5cdC8vIFNldCB0aGUgd2lkdGgncyBvZiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGFibGVzXG5cdHZhciBvdXRlcldpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuXG5cdGRpdkhlYWRlclRhYmxlLmNzcygnd2lkdGgnLCBfZm5TdHJpbmdUb0Nzcyggb3V0ZXJXaWR0aCApKTtcblx0ZGl2SGVhZGVySW5uZXJcblx0XHQuY3NzKCd3aWR0aCcsIF9mblN0cmluZ1RvQ3NzKCBvdXRlcldpZHRoICkpXG5cdFx0LmNzcyhwYWRkaW5nU2lkZSwgaXNTY3JvbGxpbmcgPyBiYXJXaWR0aCtcInB4XCIgOiBcIjBweFwiKTtcblxuXHRpZiAoIGZvb3RlciApIHtcblx0XHRkaXZGb290ZXJUYWJsZS5jc3MoJ3dpZHRoJywgX2ZuU3RyaW5nVG9Dc3MoIG91dGVyV2lkdGggKSk7XG5cdFx0ZGl2Rm9vdGVySW5uZXJcblx0XHRcdC5jc3MoJ3dpZHRoJywgX2ZuU3RyaW5nVG9Dc3MoIG91dGVyV2lkdGggKSlcblx0XHRcdC5jc3MocGFkZGluZ1NpZGUsIGlzU2Nyb2xsaW5nID8gYmFyV2lkdGgrXCJweFwiIDogXCIwcHhcIik7XG5cdH1cblxuXHQvLyBDb3JyZWN0IERPTSBvcmRlcmluZyBmb3IgY29sZ3JvdXAgLSBjb21lcyBiZWZvcmUgdGhlIHRoZWFkXG5cdHRhYmxlLmNoaWxkcmVuKCdjb2xncm91cCcpLnByZXBlbmRUbyh0YWJsZSk7XG5cblx0Ly8gQWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyIGluIGNhc2Ugd2UgbG9vc2UgdGhlIHktc2Nyb2xsYmFyXG5cdGRpdkJvZHkudHJpZ2dlcignc2Nyb2xsJyk7XG5cblx0Ly8gSWYgc29ydGluZyBvciBmaWx0ZXJpbmcgaGFzIG9jY3VycmVkLCBqdW1wIHRoZSBzY3JvbGxpbmcgYmFjayB0byB0aGUgdG9wXG5cdC8vIG9ubHkgaWYgd2UgYXJlbid0IGhvbGRpbmcgdGhlIHBvc2l0aW9uXG5cdGlmICggKHNldHRpbmdzLmJTb3J0ZWQgfHwgc2V0dGluZ3MuYkZpbHRlcmVkKSAmJiAhIHNldHRpbmdzLl9kcmF3SG9sZCApIHtcblx0XHRkaXZCb2R5RWwuc2Nyb2xsVG9wID0gMDtcblx0fVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgd2lkdGggb2YgY29sdW1ucyBmb3IgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyAoIHNldHRpbmdzIClcbntcblx0Ly8gTm90IGludGVyZXN0ZWQgaW4gZG9pbmcgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uIGlmIGF1dG8td2lkdGggaXMgZGlzYWJsZWRcblx0aWYgKCEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJBdXRvV2lkdGgpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXJcblx0XHR0YWJsZSA9IHNldHRpbmdzLm5UYWJsZSxcblx0XHRjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGwsXG5cdFx0c2Nyb2xsWSA9IHNjcm9sbC5zWSxcblx0XHRzY3JvbGxYID0gc2Nyb2xsLnNYLFxuXHRcdHNjcm9sbFhJbm5lciA9IHNjcm9sbC5zWElubmVyLFxuXHRcdHZpc2libGVDb2x1bW5zID0gX2ZuR2V0Q29sdW1ucyggc2V0dGluZ3MsICdiVmlzaWJsZScgKSxcblx0XHR0YWJsZVdpZHRoQXR0ciA9IHRhYmxlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSwgLy8gZnJvbSBET00gZWxlbWVudFxuXHRcdHRhYmxlQ29udGFpbmVyID0gdGFibGUucGFyZW50Tm9kZSxcblx0XHRpLCBjb2x1bW4sIGNvbHVtbklkeDtcblx0XHRcblx0dmFyIHN0eWxlV2lkdGggPSB0YWJsZS5zdHlsZS53aWR0aDtcblx0dmFyIGNvbnRhaW5lcldpZHRoID0gX2ZuV3JhcHBlcldpZHRoKHNldHRpbmdzKTtcblxuXHQvLyBEb24ndCByZS1ydW4gZm9yIHRoZSBzYW1lIHdpZHRoIGFzIHRoZSBsYXN0IHRpbWVcblx0aWYgKGNvbnRhaW5lcldpZHRoID09PSBzZXR0aW5ncy5jb250YWluZXJXaWR0aCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHNldHRpbmdzLmNvbnRhaW5lcldpZHRoID0gY29udGFpbmVyV2lkdGg7XG5cblx0Ly8gSWYgdGhlcmUgaXMgbm8gd2lkdGggYXBwbGllZCBhcyBhIENTUyBzdHlsZSBvciBhcyBhbiBhdHRyaWJ1dGUsIHdlIGFzc3VtZSB0aGF0XG5cdC8vIHRoZSB3aWR0aCBpcyBpbnRlbmRlZCB0byBiZSAxMDAlLCB3aGljaCBpcyB1c3VhbGx5IGlzIGluIENTUywgYnV0IGl0IGlzIHZlcnlcblx0Ly8gZGlmZmljdWx0IHRvIGNvcnJlY3RseSBwYXJzZSB0aGUgcnVsZXMgdG8gZ2V0IHRoZSBmaW5hbCByZXN1bHQuXG5cdGlmICggISBzdHlsZVdpZHRoICYmICEgdGFibGVXaWR0aEF0dHIpIHtcblx0XHR0YWJsZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcblx0XHRzdHlsZVdpZHRoID0gJzEwMCUnO1xuXHR9XG5cblx0aWYgKCBzdHlsZVdpZHRoICYmIHN0eWxlV2lkdGguaW5kZXhPZignJScpICE9PSAtMSApIHtcblx0XHR0YWJsZVdpZHRoQXR0ciA9IHN0eWxlV2lkdGg7XG5cdH1cblxuXHQvLyBMZXQgcGx1Zy1pbnMga25vdyB0aGF0IHdlIGFyZSBkb2luZyBhIHJlY2FsYywgaW4gY2FzZSB0aGV5IGhhdmUgY2hhbmdlZCBhbnkgb2YgdGhlXG5cdC8vIHZpc2libGUgY29sdW1ucyB0aGVpciBvd24gd2F5IChlLmcuIFJlc3BvbnNpdmUgdXNlcyBkaXNwbGF5Om5vbmUpLlxuXHRfZm5DYWxsYmFja0ZpcmUoXG5cdFx0c2V0dGluZ3MsXG5cdFx0bnVsbCxcblx0XHQnY29sdW1uLWNhbGMnLFxuXHRcdHt2aXNpYmxlOiB2aXNpYmxlQ29sdW1uc30sXG5cdFx0ZmFsc2Vcblx0KTtcblxuXHQvLyBDb25zdHJ1Y3QgYSBzaW5nbGUgcm93LCB3b3JzdCBjYXNlLCB0YWJsZSB3aXRoIHRoZSB3aWRlc3Rcblx0Ly8gbm9kZSBpbiB0aGUgZGF0YSwgYXNzaWduIGFueSB1c2VyIGRlZmluZWQgd2lkdGhzLCB0aGVuIGluc2VydCBpdCBpbnRvXG5cdC8vIHRoZSBET00gYW5kIGFsbG93IHRoZSBicm93c2VyIHRvIGRvIGFsbCB0aGUgaGFyZCB3b3JrIG9mIGNhbGN1bGF0aW5nXG5cdC8vIHRhYmxlIHdpZHRoc1xuXHR2YXIgdG1wVGFibGUgPSAkKHRhYmxlLmNsb25lTm9kZSgpKVxuXHRcdC5jc3MoICd2aXNpYmlsaXR5JywgJ2hpZGRlbicgKVxuXHRcdC5yZW1vdmVBdHRyKCAnaWQnICk7XG5cblx0Ly8gQ2xlYW4gdXAgdGhlIHRhYmxlIGJvZHlcblx0dG1wVGFibGUuYXBwZW5kKCc8dGJvZHk+Jylcblx0dmFyIHRyID0gJCgnPHRyLz4nKS5hcHBlbmRUbyggdG1wVGFibGUuZmluZCgndGJvZHknKSApO1xuXG5cdC8vIENsb25lIHRoZSB0YWJsZSBoZWFkZXIgYW5kIGZvb3RlciAtIHdlIGNhbid0IHVzZSB0aGUgaGVhZGVyIC8gZm9vdGVyXG5cdC8vIGZyb20gdGhlIGNsb25lZCB0YWJsZSwgc2luY2UgaWYgc2Nyb2xsaW5nIGlzIGFjdGl2ZSwgdGhlIHRhYmxlJ3Ncblx0Ly8gcmVhbCBoZWFkZXIgYW5kIGZvb3RlciBhcmUgY29udGFpbmVkIGluIGRpZmZlcmVudCB0YWJsZSB0YWdzXG5cdHRtcFRhYmxlXG5cdFx0LmFwcGVuZCggJChzZXR0aW5ncy5uVEhlYWQpLmNsb25lKCkgKVxuXHRcdC5hcHBlbmQoICQoc2V0dGluZ3MublRGb290KS5jbG9uZSgpICk7XG5cblx0Ly8gUmVtb3ZlIGFueSBhc3NpZ25lZCB3aWR0aHMgZnJvbSB0aGUgZm9vdGVyIChmcm9tIHNjcm9sbGluZylcblx0dG1wVGFibGUuZmluZCgndGZvb3QgdGgsIHRmb290IHRkJykuY3NzKCd3aWR0aCcsICcnKTtcblxuXHQvLyBBcHBseSBjdXN0b20gc2l6aW5nIHRvIHRoZSBjbG9uZWQgaGVhZGVyXG5cdHRtcFRhYmxlLmZpbmQoJ3RoZWFkIHRoLCB0aGVhZCB0ZCcpLmVhY2goIGZ1bmN0aW9uICgpIHtcblx0XHQvLyBHZXQgdGhlIGB3aWR0aGAgZnJvbSB0aGUgaGVhZGVyIGxheW91dFxuXHRcdHZhciB3aWR0aCA9IF9mbkNvbHVtbnNTdW1XaWR0aCggc2V0dGluZ3MsIHRoaXMsIHRydWUsIGZhbHNlICk7XG5cblx0XHRpZiAoIHdpZHRoICkge1xuXHRcdFx0dGhpcy5zdHlsZS53aWR0aCA9IHdpZHRoO1xuXG5cdFx0XHQvLyBGb3Igc2Nyb2xsWCB3ZSBuZWVkIHRvIGZvcmNlIHRoZSBjb2x1bW4gd2lkdGggb3RoZXJ3aXNlIHRoZVxuXHRcdFx0Ly8gYnJvd3NlciB3aWxsIGNvbGxhcHNlIGl0LiBJZiB0aGlzIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiB0aGVcblx0XHRcdC8vIHdpZHRoIHRoZSBjb2x1bW4gcmVxdWlyZXMsIHRoZW4gaXQgd2lsbCBoYXZlIG5vIGVmZmVjdFxuXHRcdFx0aWYgKCBzY3JvbGxYICkge1xuXHRcdFx0XHR0aGlzLnN0eWxlLm1pbldpZHRoID0gd2lkdGg7XG5cblx0XHRcdFx0JCggdGhpcyApLmFwcGVuZCggJCgnPGRpdi8+JykuY3NzKCB7XG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoLFxuXHRcdFx0XHRcdG1hcmdpbjogMCxcblx0XHRcdFx0XHRwYWRkaW5nOiAwLFxuXHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHRoZWlnaHQ6IDFcblx0XHRcdFx0fSApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5zdHlsZS53aWR0aCA9ICcnO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIEZpbmQgdGhlIHdpZGVzdCBwaWVjZSBvZiBkYXRhIGZvciBlYWNoIGNvbHVtbiBhbmQgcHV0IGl0IGludG8gdGhlIHRhYmxlXG5cdGZvciAoIGk9MCA7IGk8dmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrICkge1xuXHRcdGNvbHVtbklkeCA9IHZpc2libGVDb2x1bW5zW2ldO1xuXHRcdGNvbHVtbiA9IGNvbHVtbnNbIGNvbHVtbklkeCBdO1xuXG5cdFx0dmFyIGxvbmdlc3QgPSBfZm5HZXRNYXhMZW5TdHJpbmcoc2V0dGluZ3MsIGNvbHVtbklkeCk7XG5cdFx0dmFyIGF1dG9DbGFzcyA9IF9leHQudHlwZS5jbGFzc05hbWVbY29sdW1uLnNUeXBlXTtcblx0XHR2YXIgdGV4dCA9IGxvbmdlc3QgKyBjb2x1bW4uc0NvbnRlbnRQYWRkaW5nO1xuXHRcdHZhciBpbnNlcnQgPSBsb25nZXN0LmluZGV4T2YoJzwnKSA9PT0gLTFcblx0XHRcdD8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcblx0XHRcdDogdGV4dFxuXHRcdFxuXHRcdCQoJzx0ZC8+Jylcblx0XHRcdC5hZGRDbGFzcyhhdXRvQ2xhc3MpXG5cdFx0XHQuYWRkQ2xhc3MoY29sdW1uLnNDbGFzcylcblx0XHRcdC5hcHBlbmQoaW5zZXJ0KVxuXHRcdFx0LmFwcGVuZFRvKHRyKTtcblx0fVxuXG5cdC8vIFRpZHkgdGhlIHRlbXBvcmFyeSB0YWJsZSAtIHJlbW92ZSBuYW1lIGF0dHJpYnV0ZXMgc28gdGhlcmUgYXJlbid0XG5cdC8vIGR1cGxpY2F0ZWQgaW4gdGhlIGRvbSAocmFkaW8gZWxlbWVudHMgZm9yIGV4YW1wbGUpXG5cdCQoJ1tuYW1lXScsIHRtcFRhYmxlKS5yZW1vdmVBdHRyKCduYW1lJyk7XG5cblx0Ly8gVGFibGUgaGFzIGJlZW4gYnVpbHQsIGF0dGFjaCB0byB0aGUgZG9jdW1lbnQgc28gd2UgY2FuIHdvcmsgd2l0aCBpdC5cblx0Ly8gQSBob2xkaW5nIGVsZW1lbnQgaXMgdXNlZCwgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mIHRoZSBjb250YWluZXJcblx0Ly8gd2l0aCBtaW5pbWFsIGhlaWdodCwgc28gaXQgaGFzIG5vIGVmZmVjdCBvbiBpZiB0aGUgY29udGFpbmVyIHNjcm9sbHNcblx0Ly8gb3Igbm90LiBPdGhlcndpc2UgaXQgbWlnaHQgdHJpZ2dlciBzY3JvbGxpbmcgd2hlbiBpdCBhY3R1YWxseSBpc24ndFxuXHQvLyBuZWVkZWRcblx0dmFyIGhvbGRlciA9ICQoJzxkaXYvPicpLmNzcyggc2Nyb2xsWCB8fCBzY3JvbGxZID9cblx0XHRcdHtcblx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0aGVpZ2h0OiAxLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHR9IDpcblx0XHRcdHt9XG5cdFx0KVxuXHRcdC5hcHBlbmQoIHRtcFRhYmxlIClcblx0XHQuYXBwZW5kVG8oIHRhYmxlQ29udGFpbmVyICk7XG5cblx0Ly8gV2hlbiBzY3JvbGxpbmcgKFggb3IgWSkgd2Ugd2FudCB0byBzZXQgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSBhcyBcblx0Ly8gYXBwcm9wcmlhdGUuIEhvd2V2ZXIsIHdoZW4gbm90IHNjcm9sbGluZyBsZWF2ZSB0aGUgdGFibGUgd2lkdGggYXMgaXRcblx0Ly8gaXMuIFRoaXMgcmVzdWx0cyBpbiBzbGlnaHRseSBkaWZmZXJlbnQsIGJ1dCBJIHRoaW5rIGNvcnJlY3QgYmVoYXZpb3VyXG5cdGlmICggc2Nyb2xsWCAmJiBzY3JvbGxYSW5uZXIgKSB7XG5cdFx0dG1wVGFibGUud2lkdGgoIHNjcm9sbFhJbm5lciApO1xuXHR9XG5cdGVsc2UgaWYgKCBzY3JvbGxYICkge1xuXHRcdHRtcFRhYmxlLmNzcyggJ3dpZHRoJywgJ2F1dG8nICk7XG5cdFx0dG1wVGFibGUucmVtb3ZlQXR0cignd2lkdGgnKTtcblxuXHRcdC8vIElmIHRoZXJlIGlzIG5vIHdpZHRoIGF0dHJpYnV0ZSBvciBzdHlsZSwgdGhlbiBhbGxvdyB0aGUgdGFibGUgdG9cblx0XHQvLyBjb2xsYXBzZVxuXHRcdGlmICggdG1wVGFibGUub3V0ZXJXaWR0aCgpIDwgdGFibGVDb250YWluZXIuY2xpZW50V2lkdGggJiYgdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0XHR0bXBUYWJsZS5vdXRlcldpZHRoKCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCApO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggc2Nyb2xsWSApIHtcblx0XHR0bXBUYWJsZS5vdXRlcldpZHRoKCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCApO1xuXHR9XG5cdGVsc2UgaWYgKCB0YWJsZVdpZHRoQXR0ciApIHtcblx0XHR0bXBUYWJsZS5vdXRlcldpZHRoKCB0YWJsZVdpZHRoQXR0ciApO1xuXHR9XG5cblx0Ly8gR2V0IHRoZSB3aWR0aCBvZiBlYWNoIGNvbHVtbiBpbiB0aGUgY29uc3RydWN0ZWQgdGFibGVcblx0dmFyIHRvdGFsID0gMDtcblx0dmFyIGJvZHlDZWxscyA9IHRtcFRhYmxlLmZpbmQoJ3Rib2R5IHRyJykuZXEoMCkuY2hpbGRyZW4oKTtcblxuXHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHQvLyBVc2UgZ2V0Qm91bmRpbmcgZm9yIHN1Yi1waXhlbCBhY2N1cmFjeSwgd2hpY2ggd2UgdGhlbiB3YW50IHRvIHJvdW5kIHVwIVxuXHRcdHZhciBib3VuZGluZyA9IGJvZHlDZWxsc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblxuXHRcdC8vIFRvdGFsIGlzIHRyYWNrZWQgdG8gcmVtb3ZlIGFueSBzdWItcGl4ZWwgZXJyb3JzIGFzIHRoZSBvdXRlcldpZHRoXG5cdFx0Ly8gb2YgdGhlIHRhYmxlIG1pZ2h0IG5vdCBlcXVhbCB0aGUgdG90YWwgZ2l2ZW4gaGVyZVxuXHRcdHRvdGFsICs9IGJvdW5kaW5nO1xuXG5cdFx0Ly8gV2lkdGggZm9yIGVhY2ggY29sdW1uIHRvIHVzZVxuXHRcdGNvbHVtbnNbIHZpc2libGVDb2x1bW5zW2ldIF0uc1dpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIGJvdW5kaW5nICk7XG5cdH1cblxuXHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0b3RhbCApO1xuXG5cdC8vIEZpbmlzaGVkIHdpdGggdGhlIHRhYmxlIC0gZGl0Y2ggaXRcblx0aG9sZGVyLnJlbW92ZSgpO1xuXG5cdC8vIElmIHRoZXJlIGlzIGEgd2lkdGggYXR0ciwgd2Ugd2FudCB0byBhdHRhY2ggYW4gZXZlbnQgbGlzdGVuZXIgd2hpY2hcblx0Ly8gYWxsb3dzIHRoZSB0YWJsZSBzaXppbmcgdG8gYXV0b21hdGljYWxseSBhZGp1c3Qgd2hlbiB0aGUgd2luZG93IGlzXG5cdC8vIHJlc2l6ZWQuIFVzZSB0aGUgd2lkdGggYXR0ciByYXRoZXIgdGhhbiBDU1MsIHNpbmNlIHdlIGNhbid0IGtub3cgaWYgdGhlXG5cdC8vIENTUyBpcyBhIHJlbGF0aXZlIHZhbHVlIG9yIGFic29sdXRlIC0gRE9NIHJlYWQgaXMgYWx3YXlzIHB4LlxuXHRpZiAoIHRhYmxlV2lkdGhBdHRyICkge1xuXHRcdHRhYmxlLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoIHRhYmxlV2lkdGhBdHRyICk7XG5cdH1cblxuXHRpZiAoICh0YWJsZVdpZHRoQXR0ciB8fCBzY3JvbGxYKSAmJiAhIHNldHRpbmdzLl9yZXN6RXZ0ICkge1xuXHRcdHZhciByZXNpemUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZSggZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIG5ld1dpZHRoID0gX2ZuV3JhcHBlcldpZHRoKHNldHRpbmdzKTtcblxuXHRcdFx0Ly8gRG9uJ3QgZG8gaXQgaWYgZGVzdHJveWluZyBvciB0aGUgY29udGFpbmVyIHdpZHRoIGlzIDBcblx0XHRcdGlmICghIHNldHRpbmdzLmJEZXN0cm95aW5nICYmIG5ld1dpZHRoICE9PSAwKSB7XG5cdFx0XHRcdF9mbkFkanVzdENvbHVtblNpemluZyggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0ICh+MjAyMCBvbndhcmRzIGZvciB3aWRlIHN1cHBvcnQpIHdlIGNhbiB3YXRjaCBmb3IgdGhlXG5cdFx0Ly8gY29udGFpbmVyIGNoYW5naW5nIHdpZHRoLlxuXHRcdGlmICh3aW5kb3cuUmVzaXplT2JzZXJ2ZXIpIHtcblx0XHRcdC8vIFRoaXMgaXMgYSB0cmlja3kgYmVhc3QgLSBpZiB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIHdoZW4gYC5vYnNlcnZlKClgIGlzIGNhbGxlZCxcblx0XHRcdC8vIHRoZW4gdGhlIGNhbGxiYWNrIGlzIGltbWVkaWF0ZWx5IHJ1bi4gV2hpY2ggd2UgZG9uJ3Qgd2FudC4gSWYgdGhlIGVsZW1lbnQgaXNuJ3Rcblx0XHRcdC8vIHZpc2libGUsIHRoZW4gaXQgaXNuJ3QgcnVuLCBidXQgd2Ugd2FudCBpdCB0byBydW4gd2hlbiBpdCBpcyB0aGVuIG1hZGUgdmlzaWJsZS5cblx0XHRcdC8vIFRoaXMgZmxhZyBhbGxvd3MgdGhlIGFib3ZlIHRvIGJlIHNhdGlzZmllZC5cblx0XHRcdHZhciBmaXJzdCA9ICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcikuaXMoJzp2aXNpYmxlJyk7XG5cblx0XHRcdC8vIFVzZSBhbiBlbXB0eSBkaXYgdG8gYXR0YWNoIHRoZSBvYnNlcnZlciBzbyBpdCBpc24ndCBpbXBhY3RlZCBieSBoZWlnaHQgY2hhbmdlc1xuXHRcdFx0dmFyIHJlc2l6ZXIgPSAkKCc8ZGl2PicpXG5cdFx0XHRcdC5jc3Moe1xuXHRcdFx0XHRcdHdpZHRoOiAnMTAwJScsXG5cdFx0XHRcdFx0aGVpZ2h0OiAwXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGRDbGFzcygnZHQtYXV0b3NpemUnKVxuXHRcdFx0XHQuYXBwZW5kVG8oc2V0dGluZ3MublRhYmxlV3JhcHBlcik7XG5cblx0XHRcdHNldHRpbmdzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cmVzaXplKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRzZXR0aW5ncy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlc2l6ZXJbMF0pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIEZvciBvbGQgYnJvd3NlcnMsIHRoZSBiZXN0IHdlIGNhbiBkbyBpcyBsaXN0ZW4gZm9yIGEgd2luZG93IHJlc2l6ZVxuXHRcdFx0JCh3aW5kb3cpLm9uKCdyZXNpemUuRFQtJytzZXR0aW5ncy5zSW5zdGFuY2UsIHJlc2l6ZSk7XG5cdFx0fVxuXG5cdFx0c2V0dGluZ3MuX3Jlc3pFdnQgPSB0cnVlO1xuXHR9XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aWR0aCBvZiB0aGUgRGF0YVRhYmxlcyB3cmFwcGVyIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcmV0dXJucyBXaWR0aFxuICovXG5mdW5jdGlvbiBfZm5XcmFwcGVyV2lkdGgoc2V0dGluZ3MpIHtcblx0cmV0dXJuICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcikuaXMoJzp2aXNpYmxlJylcblx0XHQ/ICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcikud2lkdGgoKVxuXHRcdDogMDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1heGltdW0gc3RybGVuIGZvciBlYWNoIGRhdGEgY29sdW1uXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3RcbiAqICBAcmV0dXJucyB7c3RyaW5nfSBzdHJpbmcgb2YgdGhlIG1heCBsZW5ndGhcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuR2V0TWF4TGVuU3RyaW5nKCBzZXR0aW5ncywgY29sSWR4IClcbntcblx0dmFyIGNvbHVtbiA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xuXG5cdGlmICghIGNvbHVtbi5tYXhMZW5TdHJpbmcpIHtcblx0XHR2YXIgcywgbWF4PScnLCBtYXhMZW4gPSAtMTtcblx0XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhciByb3dJZHggPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXJbaV07XG5cdFx0XHR2YXIgZGF0YSA9IF9mbkdldFJvd0Rpc3BsYXkoc2V0dGluZ3MsIHJvd0lkeClbY29sSWR4XTtcblxuXHRcdFx0dmFyIGNlbGxTdHJpbmcgPSBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhLm5vZGVUeXBlXG5cdFx0XHRcdD8gZGF0YS5pbm5lckhUTUxcblx0XHRcdFx0OiBkYXRhKycnO1xuXG5cdFx0XHQvLyBSZW1vdmUgaWQgLyBuYW1lIGF0dHJpYnV0ZXMgZnJvbSBlbGVtZW50cyBzbyB0aGV5XG5cdFx0XHQvLyBkb24ndCBpbnRlcmZlcmUgd2l0aCBleGlzdGluZyBlbGVtZW50c1xuXHRcdFx0Y2VsbFN0cmluZyA9IGNlbGxTdHJpbmdcblx0XHRcdFx0LnJlcGxhY2UoL2lkPVwiLio/XCIvZywgJycpXG5cdFx0XHRcdC5yZXBsYWNlKC9uYW1lPVwiLio/XCIvZywgJycpO1xuXG5cdFx0XHRzID0gX3N0cmlwSHRtbChjZWxsU3RyaW5nKVxuXHRcdFx0XHQucmVwbGFjZSggLyZuYnNwOy9nLCAnICcgKTtcblx0XG5cdFx0XHRpZiAoIHMubGVuZ3RoID4gbWF4TGVuICkge1xuXHRcdFx0XHQvLyBXZSB3YW50IHRoZSBIVE1MIGluIHRoZSBzdHJpbmcsIGJ1dCB0aGUgbGVuZ3RoIHRoYXRcblx0XHRcdFx0Ly8gaXMgaW1wb3J0YW50IGlzIHRoZSBzdHJpcHBlZCBzdHJpbmdcblx0XHRcdFx0bWF4ID0gY2VsbFN0cmluZztcblx0XHRcdFx0bWF4TGVuID0gcy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29sdW1uLm1heExlblN0cmluZyA9IG1heDtcblx0fVxuXG5cdHJldHVybiBjb2x1bW4ubWF4TGVuU3RyaW5nO1xufVxuXG5cbi8qKlxuICogQXBwZW5kIGEgQ1NTIHVuaXQgKG9ubHkgaWYgcmVxdWlyZWQpIHRvIGEgc3RyaW5nXG4gKiAgQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRvIGNzcy1pZnlcbiAqICBAcmV0dXJucyB7c3RyaW5nfSB2YWx1ZSB3aXRoIGNzcyB1bml0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblN0cmluZ1RvQ3NzKCBzIClcbntcblx0aWYgKCBzID09PSBudWxsICkge1xuXHRcdHJldHVybiAnMHB4Jztcblx0fVxuXG5cdGlmICggdHlwZW9mIHMgPT0gJ251bWJlcicgKSB7XG5cdFx0cmV0dXJuIHMgPCAwID9cblx0XHRcdCcwcHgnIDpcblx0XHRcdHMrJ3B4Jztcblx0fVxuXG5cdC8vIENoZWNrIGl0IGhhcyBhIHVuaXQgY2hhcmFjdGVyIGFscmVhZHlcblx0cmV0dXJuIHMubWF0Y2goL1xcZCQvKSA/XG5cdFx0cysncHgnIDpcblx0XHRzO1xufVxuXG4vKipcbiAqIFJlLWluc2VydCB0aGUgYGNvbGAgZWxlbWVudHMgZm9yIGN1cnJlbnQgdmlzaWJpbGl0eVxuICpcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRFQgc2V0dGluZ3NcbiAqL1xuZnVuY3Rpb24gX2NvbEdyb3VwKCBzZXR0aW5ncyApIHtcblx0dmFyIGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cblx0c2V0dGluZ3MuY29sZ3JvdXAuZW1wdHkoKTtcblxuXHRmb3IgKGk9MCA7IGk8Y29scy5sZW5ndGggOyBpKyspIHtcblx0XHRpZiAoY29sc1tpXS5iVmlzaWJsZSkge1xuXHRcdFx0c2V0dGluZ3MuY29sZ3JvdXAuYXBwZW5kKGNvbHNbaV0uY29sRWwpO1xuXHRcdH1cblx0fVxufVxuXG5cbmZ1bmN0aW9uIF9mblNvcnRJbml0KCBzZXR0aW5ncyApIHtcblx0dmFyIHRhcmdldCA9IHNldHRpbmdzLm5USGVhZDtcblx0dmFyIGhlYWRlclJvd3MgPSB0YXJnZXQucXVlcnlTZWxlY3RvckFsbCgndHInKTtcblx0dmFyIHRpdGxlUm93ID0gc2V0dGluZ3MudGl0bGVSb3c7XG5cdHZhciBub3RTZWxlY3RvciA9ICc6bm90KFtkYXRhLWR0LW9yZGVyPVwiZGlzYWJsZVwiXSk6bm90KFtkYXRhLWR0LW9yZGVyPVwiaWNvbi1vbmx5XCJdKSc7XG5cdFxuXHQvLyBMZWdhY3kgc3VwcG9ydCBmb3IgYG9yZGVyQ2VsbHNUb3BgXG5cdGlmICh0aXRsZVJvdyA9PT0gdHJ1ZSkge1xuXHRcdHRhcmdldCA9IGhlYWRlclJvd3NbMF07XG5cdH1cblx0ZWxzZSBpZiAodGl0bGVSb3cgPT09IGZhbHNlKSB7XG5cdFx0dGFyZ2V0ID0gaGVhZGVyUm93c1sgaGVhZGVyUm93cy5sZW5ndGggLSAxIF07XG5cdH1cblx0ZWxzZSBpZiAodGl0bGVSb3cgIT09IG51bGwpIHtcblx0XHR0YXJnZXQgPSBoZWFkZXJSb3dzW3RpdGxlUm93XTtcblx0fVxuXHQvLyBlbHNlIC0gYWxsIHJvd3NcblxuXHRpZiAoc2V0dGluZ3Mub3JkZXJIYW5kbGVyKSB7XG5cdFx0X2ZuU29ydEF0dGFjaExpc3RlbmVyKFxuXHRcdFx0c2V0dGluZ3MsXG5cdFx0XHR0YXJnZXQsXG5cdFx0XHR0YXJnZXQgPT09IHNldHRpbmdzLm5USGVhZFxuXHRcdFx0XHQ/ICd0cicrbm90U2VsZWN0b3IrJyB0aCcrbm90U2VsZWN0b3IrJywgdHInK25vdFNlbGVjdG9yKycgdGQnK25vdFNlbGVjdG9yXG5cdFx0XHRcdDogJ3RoJytub3RTZWxlY3RvcisnLCB0ZCcrbm90U2VsZWN0b3Jcblx0XHQpO1xuXHR9XG5cblx0Ly8gTmVlZCB0byByZXNvbHZlIHRoZSB1c2VyIGlucHV0IGFycmF5IGludG8gb3VyIGludGVybmFsIHN0cnVjdHVyZVxuXHR2YXIgb3JkZXIgPSBbXTtcblx0X2ZuU29ydFJlc29sdmUoIHNldHRpbmdzLCBvcmRlciwgc2V0dGluZ3MuYWFTb3J0aW5nICk7XG5cblx0c2V0dGluZ3MuYWFTb3J0aW5nID0gb3JkZXI7XG59XG5cblxuZnVuY3Rpb24gX2ZuU29ydEF0dGFjaExpc3RlbmVyKHNldHRpbmdzLCBub2RlLCBzZWxlY3RvciwgY29sdW1uLCBjYWxsYmFjaykge1xuXHRfZm5CaW5kQWN0aW9uKCBub2RlLCBzZWxlY3RvciwgZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgcnVuID0gZmFsc2U7XG5cdFx0dmFyIGNvbHVtbnMgPSBjb2x1bW4gPT09IHVuZGVmaW5lZFxuXHRcdFx0PyBfZm5Db2x1bW5zRnJvbUhlYWRlciggZS50YXJnZXQgKVxuXHRcdFx0OiBBcnJheS5pc0FycmF5KGNvbHVtbilcblx0XHRcdFx0PyBjb2x1bW5cblx0XHRcdFx0OiBbY29sdW1uXTtcblxuXHRcdGlmICggY29sdW1ucy5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49Y29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0dmFyIHJldCA9IF9mblNvcnRBZGQoIHNldHRpbmdzLCBjb2x1bW5zW2ldLCBpLCBlLnNoaWZ0S2V5ICk7XG5cblx0XHRcdFx0aWYgKHJldCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRydW4gPSB0cnVlO1xuXHRcdFx0XHR9XHRcdFx0XHRcdFxuXG5cdFx0XHRcdC8vIElmIHRoZSBmaXJzdCBlbnRyeSBpcyBubyBzb3J0LCB0aGVuIHN1YnNlcXVlbnRcblx0XHRcdFx0Ly8gc29ydCBjb2x1bW5zIGFyZSBpZ25vcmVkXG5cdFx0XHRcdGlmIChzZXR0aW5ncy5hYVNvcnRpbmcubGVuZ3RoID09PSAxICYmIHNldHRpbmdzLmFhU29ydGluZ1swXVsxXSA9PT0gJycpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocnVuKSB7XG5cdFx0XHRcdF9mblByb2Nlc3NpbmdSdW4oc2V0dGluZ3MsIHRydWUsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRfZm5Tb3J0KCBzZXR0aW5ncyApO1xuXHRcdFx0XHRcdF9mblNvcnREaXNwbGF5KCBzZXR0aW5ncywgc2V0dGluZ3MuYWlEaXNwbGF5ICk7XG5cblx0XHRcdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzLCBmYWxzZSwgZmFsc2UgKTtcblxuXHRcdFx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG4vKipcbiAqIFNvcnQgdGhlIGRpc3BsYXkgYXJyYXkgdG8gbWF0Y2ggdGhlIG1hc3RlcidzIG9yZGVyXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzXG4gKi9cbmZ1bmN0aW9uIF9mblNvcnREaXNwbGF5KHNldHRpbmdzLCBkaXNwbGF5KSB7XG5cdGlmIChkaXNwbGF5Lmxlbmd0aCA8IDIpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgbWFzdGVyID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xuXHR2YXIgbWFzdGVyTWFwID0ge307XG5cdHZhciBtYXAgPSB7fTtcblx0dmFyIGk7XG5cblx0Ly8gUmF0aGVyIHRoYW4gbmVlZGluZyBhbiBgaW5kZXhPZmAgb24gbWFzdGVyIGFycmF5LCB3ZSBjYW4gY3JlYXRlIGEgbWFwXG5cdGZvciAoaT0wIDsgaTxtYXN0ZXIubGVuZ3RoIDsgaSsrKSB7XG5cdFx0bWFzdGVyTWFwW21hc3RlcltpXV0gPSBpO1xuXHR9XG5cblx0Ly8gQW5kIHRoZW4gY2FjaGUgd2hhdCB3b3VsZCBiZSB0aGUgaW5kZXhPZiBmb20gdGhlIGRpc3BsYXlcblx0Zm9yIChpPTAgOyBpPGRpc3BsYXkubGVuZ3RoIDsgaSsrKSB7XG5cdFx0bWFwW2Rpc3BsYXlbaV1dID0gbWFzdGVyTWFwW2Rpc3BsYXlbaV1dO1xuXHR9XG5cblx0ZGlzcGxheS5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuXHRcdC8vIFNob3J0IHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvbiBpcyBzaW1wbHkgYG1hc3Rlci5pbmRleE9mKGEpIC0gbWFzdGVyLmluZGV4T2YoYik7YFxuXHRcdHJldHVybiBtYXBbYV0gLSBtYXBbYl07XG5cdH0pO1xufVxuXG5cbmZ1bmN0aW9uIF9mblNvcnRSZXNvbHZlIChzZXR0aW5ncywgbmVzdGVkU29ydCwgc29ydCkge1xuXHR2YXIgcHVzaCA9IGZ1bmN0aW9uICggYSApIHtcblx0XHRpZiAoJC5pc1BsYWluT2JqZWN0KGEpKSB7XG5cdFx0XHRpZiAoYS5pZHggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBJbmRleCBiYXNlZCBvcmRlcmluZ1xuXHRcdFx0XHRuZXN0ZWRTb3J0LnB1c2goW2EuaWR4LCBhLmRpcl0pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoYS5uYW1lKSB7XG5cdFx0XHRcdC8vIE5hbWUgYmFzZWQgb3JkZXJpbmdcblx0XHRcdFx0dmFyIGNvbHMgPSBfcGx1Y2soIHNldHRpbmdzLmFvQ29sdW1ucywgJ3NOYW1lJyk7XG5cdFx0XHRcdHZhciBpZHggPSBjb2xzLmluZGV4T2YoYS5uYW1lKTtcblxuXHRcdFx0XHRpZiAoaWR4ICE9PSAtMSkge1xuXHRcdFx0XHRcdG5lc3RlZFNvcnQucHVzaChbaWR4LCBhLmRpcl0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUGxhaW4gY29sdW1uIGluZGV4IGFuZCBkaXJlY3Rpb24gcGFpclxuXHRcdFx0bmVzdGVkU29ydC5wdXNoKGEpO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoICQuaXNQbGFpbk9iamVjdChzb3J0KSApIHtcblx0XHQvLyBPYmplY3Rcblx0XHRwdXNoKHNvcnQpO1xuXHR9XG5cdGVsc2UgaWYgKCBzb3J0Lmxlbmd0aCAmJiB0eXBlb2Ygc29ydFswXSA9PT0gJ251bWJlcicgKSB7XG5cdFx0Ly8gMUQgYXJyYXlcblx0XHRwdXNoKHNvcnQpO1xuXHR9XG5cdGVsc2UgaWYgKCBzb3J0Lmxlbmd0aCApIHtcblx0XHQvLyAyRCBhcnJheVxuXHRcdGZvciAodmFyIHo9MDsgejxzb3J0Lmxlbmd0aDsgeisrKSB7XG5cdFx0XHRwdXNoKHNvcnRbel0pOyAvLyBPYmplY3Qgb3IgYXJyYXlcblx0XHR9XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBfZm5Tb3J0RmxhdHRlbiAoIHNldHRpbmdzIClcbntcblx0dmFyXG5cdFx0aSwgaywga0xlbixcblx0XHRhU29ydCA9IFtdLFxuXHRcdGV4dFNvcnQgPSBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXIsXG5cdFx0YW9Db2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxuXHRcdGFEYXRhU29ydCwgaUNvbCwgc1R5cGUsIHNyY0NvbCxcblx0XHRmaXhlZCA9IHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkLFxuXHRcdGZpeGVkT2JqID0gJC5pc1BsYWluT2JqZWN0KCBmaXhlZCApLFxuXHRcdG5lc3RlZFNvcnQgPSBbXTtcblx0XG5cdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnQgKSB7XG5cdFx0cmV0dXJuIGFTb3J0O1xuXHR9XG5cblx0Ly8gQnVpbGQgdGhlIHNvcnQgYXJyYXksIHdpdGggcHJlLWZpeCBhbmQgcG9zdC1maXggb3B0aW9ucyBpZiB0aGV5IGhhdmUgYmVlblxuXHQvLyBzcGVjaWZpZWRcblx0aWYgKCBBcnJheS5pc0FycmF5KCBmaXhlZCApICkge1xuXHRcdF9mblNvcnRSZXNvbHZlKCBzZXR0aW5ncywgbmVzdGVkU29ydCwgZml4ZWQgKTtcblx0fVxuXG5cdGlmICggZml4ZWRPYmogJiYgZml4ZWQucHJlICkge1xuXHRcdF9mblNvcnRSZXNvbHZlKCBzZXR0aW5ncywgbmVzdGVkU29ydCwgZml4ZWQucHJlICk7XG5cdH1cblxuXHRfZm5Tb3J0UmVzb2x2ZSggc2V0dGluZ3MsIG5lc3RlZFNvcnQsIHNldHRpbmdzLmFhU29ydGluZyApO1xuXG5cdGlmIChmaXhlZE9iaiAmJiBmaXhlZC5wb3N0ICkge1xuXHRcdF9mblNvcnRSZXNvbHZlKCBzZXR0aW5ncywgbmVzdGVkU29ydCwgZml4ZWQucG9zdCApO1xuXHR9XG5cblx0Zm9yICggaT0wIDsgaTxuZXN0ZWRTb3J0Lmxlbmd0aCA7IGkrKyApXG5cdHtcblx0XHRzcmNDb2wgPSBuZXN0ZWRTb3J0W2ldWzBdO1xuXG5cdFx0aWYgKCBhb0NvbHVtbnNbIHNyY0NvbCBdICkge1xuXHRcdFx0YURhdGFTb3J0ID0gYW9Db2x1bW5zWyBzcmNDb2wgXS5hRGF0YVNvcnQ7XG5cblx0XHRcdGZvciAoIGs9MCwga0xlbj1hRGF0YVNvcnQubGVuZ3RoIDsgazxrTGVuIDsgaysrIClcblx0XHRcdHtcblx0XHRcdFx0aUNvbCA9IGFEYXRhU29ydFtrXTtcblx0XHRcdFx0c1R5cGUgPSBhb0NvbHVtbnNbIGlDb2wgXS5zVHlwZSB8fCAnc3RyaW5nJztcblxuXHRcdFx0XHRpZiAoIG5lc3RlZFNvcnRbaV0uX2lkeCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdG5lc3RlZFNvcnRbaV0uX2lkeCA9IGFvQ29sdW1uc1tpQ29sXS5hc1NvcnRpbmcuaW5kZXhPZihuZXN0ZWRTb3J0W2ldWzFdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmVzdGVkU29ydFtpXVsxXSApIHtcblx0XHRcdFx0XHRhU29ydC5wdXNoKCB7XG5cdFx0XHRcdFx0XHRzcmM6ICAgICAgIHNyY0NvbCxcblx0XHRcdFx0XHRcdGNvbDogICAgICAgaUNvbCxcblx0XHRcdFx0XHRcdGRpcjogICAgICAgbmVzdGVkU29ydFtpXVsxXSxcblx0XHRcdFx0XHRcdGluZGV4OiAgICAgbmVzdGVkU29ydFtpXS5faWR4LFxuXHRcdFx0XHRcdFx0dHlwZTogICAgICBzVHlwZSxcblx0XHRcdFx0XHRcdGZvcm1hdHRlcjogZXh0U29ydFsgc1R5cGUrXCItcHJlXCIgXSxcblx0XHRcdFx0XHRcdHNvcnRlcjogICAgZXh0U29ydFsgc1R5cGUrXCItXCIrbmVzdGVkU29ydFtpXVsxXSBdXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGFTb3J0O1xufVxuXG4vKipcbiAqIENoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Tb3J0ICggb1NldHRpbmdzLCBjb2wsIGRpciApXG57XG5cdHZhclxuXHRcdGksIGllbiwgaUxlbixcblx0XHRhaU9yaWcgPSBbXSxcblx0XHRleHRTb3J0ID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLFxuXHRcdGFvRGF0YSA9IG9TZXR0aW5ncy5hb0RhdGEsXG5cdFx0c29ydENvbCxcblx0XHRkaXNwbGF5TWFzdGVyID0gb1NldHRpbmdzLmFpRGlzcGxheU1hc3Rlcixcblx0XHRhU29ydDtcblxuXHQvLyBNYWtlIHN1cmUgdGhlIGNvbHVtbnMgYWxsIGhhdmUgdHlwZXMgZGVmaW5lZFxuXHRfZm5Db2x1bW5UeXBlcyhvU2V0dGluZ3MpO1xuXG5cdC8vIEFsbG93IGEgc3BlY2lmaWMgY29sdW1uIHRvIGJlIHNvcnRlZCwgd2hpY2ggd2lsbCBfbm90XyBhbHRlciB0aGUgZGlzcGxheVxuXHQvLyBtYXN0ZXJcblx0aWYgKGNvbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIHNyY0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbY29sXTtcblxuXHRcdGFTb3J0ID0gW3tcblx0XHRcdHNyYzogICAgICAgY29sLFxuXHRcdFx0Y29sOiAgICAgICBjb2wsXG5cdFx0XHRkaXI6ICAgICAgIGRpcixcblx0XHRcdGluZGV4OiAgICAgMCxcblx0XHRcdHR5cGU6ICAgICAgc3JjQ29sLnNUeXBlLFxuXHRcdFx0Zm9ybWF0dGVyOiBleHRTb3J0WyBzcmNDb2wuc1R5cGUrXCItcHJlXCIgXSxcblx0XHRcdHNvcnRlcjogICAgZXh0U29ydFsgc3JjQ29sLnNUeXBlK1wiLVwiK2RpciBdXG5cdFx0fV07XG5cdFx0ZGlzcGxheU1hc3RlciA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0fVxuXHRlbHNlIHtcblx0XHRhU29ydCA9IF9mblNvcnRGbGF0dGVuKCBvU2V0dGluZ3MgKTtcblx0fVxuXG5cdGZvciAoIGk9MCwgaWVuPWFTb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHNvcnRDb2wgPSBhU29ydFtpXTtcblxuXHRcdC8vIExvYWQgdGhlIGRhdGEgbmVlZGVkIGZvciB0aGUgc29ydCwgZm9yIGVhY2ggY2VsbFxuXHRcdF9mblNvcnREYXRhKCBvU2V0dGluZ3MsIHNvcnRDb2wuY29sICk7XG5cdH1cblxuXHQvKiBObyBzb3J0aW5nIHJlcXVpcmVkIGlmIHNlcnZlci1zaWRlIG9yIG5vIHNvcnRpbmcgYXJyYXkgKi9cblx0aWYgKCBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSAhPSAnc3NwJyAmJiBhU29ydC5sZW5ndGggIT09IDAgKVxuXHR7XG5cdFx0Ly8gUmVzZXQgdGhlIGluaXRpYWwgcG9zaXRpb25zIG9uIGVhY2ggcGFzcyBzbyB3ZSBnZXQgYSBzdGFibGUgc29ydFxuXHRcdGZvciAoIGk9MCwgaUxlbj1kaXNwbGF5TWFzdGVyLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdGFpT3JpZ1sgaSBdID0gaTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgZmlyc3Qgc29ydCBpcyBkZXNjLCB0aGVuIHJldmVyc2UgdGhlIGFycmF5IHRvIHByZXNlcnZlIG9yaWdpbmFsXG5cdFx0Ly8gb3JkZXIsIGp1c3QgaW4gcmV2ZXJzZVxuXHRcdGlmIChhU29ydC5sZW5ndGggJiYgYVNvcnRbMF0uZGlyID09PSAnZGVzYycgJiYgb1NldHRpbmdzLm9yZGVyRGVzY1JldmVyc2UpIHtcblx0XHRcdGFpT3JpZy5yZXZlcnNlKCk7XG5cdFx0fVxuXG5cdFx0LyogRG8gdGhlIHNvcnQgLSBoZXJlIHdlIHdhbnQgbXVsdGktY29sdW1uIHNvcnRpbmcgYmFzZWQgb24gYSBnaXZlbiBkYXRhIHNvdXJjZSAoY29sdW1uKVxuXHRcdCAqIGFuZCBzb3J0aW5nIGZ1bmN0aW9uIChmcm9tIG9Tb3J0KSBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uLiBJdCdzIHJlYXNvbmFibHkgY29tcGxleCB0b1xuXHRcdCAqIGZvbGxvdyBvbiBpdCdzIG93biwgYnV0IHRoaXMgaXMgd2hhdCB3ZSB3YW50IChleGFtcGxlIHR3byBjb2x1bW4gc29ydGluZyk6XG5cdFx0ICogIGZuTG9jYWxTb3J0aW5nID0gZnVuY3Rpb24oYSxiKXtcblx0XHQgKiAgICB2YXIgdGVzdDtcblx0XHQgKiAgICB0ZXN0ID0gb1NvcnRbJ3N0cmluZy1hc2MnXSgnZGF0YTExJywgJ2RhdGExMicpO1xuXHRcdCAqICAgICAgaWYgKHRlc3QgIT09IDApXG5cdFx0ICogICAgICAgIHJldHVybiB0ZXN0O1xuXHRcdCAqICAgIHRlc3QgPSBvU29ydFsnbnVtZXJpYy1kZXNjJ10oJ2RhdGEyMScsICdkYXRhMjInKTtcblx0XHQgKiAgICBpZiAodGVzdCAhPT0gMClcblx0XHQgKiAgICAgIHJldHVybiB0ZXN0O1xuXHRcdCAqICAgIHJldHVybiBvU29ydFsnbnVtZXJpYy1hc2MnXSggYWlPcmlnW2FdLCBhaU9yaWdbYl0gKTtcblx0XHQgKiAgfVxuXHRcdCAqIEJhc2ljYWxseSB3ZSBoYXZlIGEgdGVzdCBmb3IgZWFjaCBzb3J0aW5nIGNvbHVtbiwgaWYgdGhlIGRhdGEgaW4gdGhhdCBjb2x1bW4gaXMgZXF1YWwsXG5cdFx0ICogdGVzdCB0aGUgbmV4dCBjb2x1bW4uIElmIGFsbCBjb2x1bW5zIG1hdGNoLCB0aGVuIHdlIHVzZSBhIG51bWVyaWMgc29ydCBvbiB0aGUgcm93XG5cdFx0ICogcG9zaXRpb25zIGluIHRoZSBvcmlnaW5hbCBkYXRhIGFycmF5IHRvIHByb3ZpZGUgYSBzdGFibGUgc29ydC5cblx0XHQgKi9cblx0XHRkaXNwbGF5TWFzdGVyLnNvcnQoIGZ1bmN0aW9uICggYSwgYiApIHtcblx0XHRcdHZhclxuXHRcdFx0XHR4LCB5LCBrLCB0ZXN0LCBzb3J0LFxuXHRcdFx0XHRsZW49YVNvcnQubGVuZ3RoLFxuXHRcdFx0XHRkYXRhQSA9IGFvRGF0YVthXS5fYVNvcnREYXRhLFxuXHRcdFx0XHRkYXRhQiA9IGFvRGF0YVtiXS5fYVNvcnREYXRhO1xuXG5cdFx0XHRmb3IgKCBrPTAgOyBrPGxlbiA7IGsrKyApIHtcblx0XHRcdFx0c29ydCA9IGFTb3J0W2tdO1xuXG5cdFx0XHRcdC8vIERhdGEsIHdoaWNoIG1heSBoYXZlIGFscmVhZHkgYmVlbiB0aHJvdWdoIGEgYC1wcmVgIGZ1bmN0aW9uXG5cdFx0XHRcdHggPSBkYXRhQVsgc29ydC5jb2wgXTtcblx0XHRcdFx0eSA9IGRhdGFCWyBzb3J0LmNvbCBdO1xuXG5cdFx0XHRcdGlmIChzb3J0LnNvcnRlcikge1xuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGEgY3VzdG9tIHNvcnRlciAoYC1hc2NgIG9yIGAtZGVzY2ApIGZvciB0aGlzXG5cdFx0XHRcdFx0Ly8gZGF0YSB0eXBlLCB1c2UgaXRcblx0XHRcdFx0XHR0ZXN0ID0gc29ydC5zb3J0ZXIoeCwgeSk7XG5cblx0XHRcdFx0XHRpZiAoIHRlc3QgIT09IDAgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGVzdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB1c2UgZ2VuZXJpYyBzb3J0aW5nXG5cdFx0XHRcdFx0dGVzdCA9IHg8eSA/IC0xIDogeD55ID8gMSA6IDA7XG5cblx0XHRcdFx0XHRpZiAoIHRlc3QgIT09IDAgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc29ydC5kaXIgPT09ICdhc2MnID8gdGVzdCA6IC10ZXN0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR4ID0gYWlPcmlnW2FdO1xuXHRcdFx0eSA9IGFpT3JpZ1tiXTtcblxuXHRcdFx0cmV0dXJuIHg8eSA/IC0xIDogeD55ID8gMSA6IDA7XG5cdFx0fSApO1xuXHR9XG5cdGVsc2UgaWYgKCBhU29ydC5sZW5ndGggPT09IDAgKSB7XG5cdFx0Ly8gQXBwbHkgaW5kZXggb3JkZXJcblx0XHRkaXNwbGF5TWFzdGVyLnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcblx0XHRcdHJldHVybiB4PHkgPyAtMSA6IHg+eSA/IDEgOiAwO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKGNvbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gVGVsbCB0aGUgZHJhdyBmdW5jdGlvbiB0aGF0IHdlIGhhdmUgc29ydGVkIHRoZSBkYXRhXG5cdFx0b1NldHRpbmdzLmJTb3J0ZWQgPSB0cnVlO1xuXHRcdG9TZXR0aW5ncy5zb3J0RGV0YWlscyA9IGFTb3J0O1xuXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICdvcmRlcicsIFtvU2V0dGluZ3MsIGFTb3J0XSApO1xuXHR9XG5cblx0cmV0dXJuIGRpc3BsYXlNYXN0ZXI7XG59XG5cblxuLyoqXG4gKiBGdW5jdGlvbiB0byBydW4gb24gdXNlciBzb3J0IHJlcXVlc3RcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge25vZGV9IGF0dGFjaFRvIG5vZGUgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvXG4gKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gc29ydGluZyBpbmRleFxuICogIEBwYXJhbSB7aW50fSBhZGRJbmRleCBDb3VudGVyXG4gKiAgQHBhcmFtIHtib29sZWFufSBbc2hpZnQ9ZmFsc2VdIFNoaWZ0IGNsaWNrIGFkZFxuICogIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb25cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuU29ydEFkZCAoIHNldHRpbmdzLCBjb2xJZHgsIGFkZEluZGV4LCBzaGlmdCApXG57XG5cdHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbIGNvbElkeCBdO1xuXHR2YXIgc29ydGluZyA9IHNldHRpbmdzLmFhU29ydGluZztcblx0dmFyIGFzU29ydGluZyA9IGNvbC5hc1NvcnRpbmc7XG5cdHZhciBuZXh0U29ydElkeDtcblx0dmFyIG5leHQgPSBmdW5jdGlvbiAoIGEsIG92ZXJmbG93ICkge1xuXHRcdHZhciBpZHggPSBhLl9pZHg7XG5cdFx0aWYgKCBpZHggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlkeCA9IGFzU29ydGluZy5pbmRleE9mKGFbMV0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBpZHgrMSA8IGFzU29ydGluZy5sZW5ndGggP1xuXHRcdFx0aWR4KzEgOlxuXHRcdFx0b3ZlcmZsb3cgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0MDtcblx0fTtcblxuXHRpZiAoICEgY29sLmJTb3J0YWJsZSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBDb252ZXJ0IHRvIDJEIGFycmF5IGlmIG5lZWRlZFxuXHRpZiAoIHR5cGVvZiBzb3J0aW5nWzBdID09PSAnbnVtYmVyJyApIHtcblx0XHRzb3J0aW5nID0gc2V0dGluZ3MuYWFTb3J0aW5nID0gWyBzb3J0aW5nIF07XG5cdH1cblxuXHQvLyBJZiBhcHBlbmRpbmcgdGhlIHNvcnQgdGhlbiB3ZSBhcmUgbXVsdGktY29sdW1uIHNvcnRpbmdcblx0aWYgKCAoc2hpZnQgfHwgYWRkSW5kZXgpICYmIHNldHRpbmdzLm9GZWF0dXJlcy5iU29ydE11bHRpICkge1xuXHRcdC8vIEFyZSB3ZSBhbHJlYWR5IGRvaW5nIHNvbWUga2luZCBvZiBzb3J0IG9uIHRoaXMgY29sdW1uP1xuXHRcdHZhciBzb3J0SWR4ID0gX3BsdWNrKHNvcnRpbmcsICcwJykuaW5kZXhPZihjb2xJZHgpO1xuXG5cdFx0aWYgKCBzb3J0SWR4ICE9PSAtMSApIHtcblx0XHRcdC8vIFllcywgbW9kaWZ5IHRoZSBzb3J0XG5cdFx0XHRuZXh0U29ydElkeCA9IG5leHQoIHNvcnRpbmdbc29ydElkeF0sIHRydWUgKTtcblxuXHRcdFx0aWYgKCBuZXh0U29ydElkeCA9PT0gbnVsbCAmJiBzb3J0aW5nLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0bmV4dFNvcnRJZHggPSAwOyAvLyBjYW4ndCByZW1vdmUgc29ydGluZyBjb21wbGV0ZWx5XG5cdFx0XHR9XG5cblx0XHRcdGlmICggbmV4dFNvcnRJZHggPT09IG51bGwgKSB7XG5cdFx0XHRcdHNvcnRpbmcuc3BsaWNlKCBzb3J0SWR4LCAxICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c29ydGluZ1tzb3J0SWR4XVsxXSA9IGFzU29ydGluZ1sgbmV4dFNvcnRJZHggXTtcblx0XHRcdFx0c29ydGluZ1tzb3J0SWR4XS5faWR4ID0gbmV4dFNvcnRJZHg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHNoaWZ0KSB7XG5cdFx0XHQvLyBObyBzb3J0IG9uIHRoaXMgY29sdW1uIHlldCwgYmVpbmcgYWRkZWQgYnkgc2hpZnQgY2xpY2tcblx0XHRcdC8vIGFkZCBpdCBhcyBpdHNlbGZcblx0XHRcdHNvcnRpbmcucHVzaCggWyBjb2xJZHgsIGFzU29ydGluZ1swXSwgMCBdICk7XG5cdFx0XHRzb3J0aW5nW3NvcnRpbmcubGVuZ3RoLTFdLl9pZHggPSAwO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE5vIHNvcnQgb24gdGhpcyBjb2x1bW4geWV0LCBiZWluZyBhZGRlZCBmcm9tIGEgY29sc3BhblxuXHRcdFx0Ly8gc28gYWRkIHdpdGggc2FtZSBkaXJlY3Rpb24gYXMgZmlyc3QgY29sdW1uXG5cdFx0XHRzb3J0aW5nLnB1c2goIFsgY29sSWR4LCBzb3J0aW5nWzBdWzFdLCAwIF0gKTtcblx0XHRcdHNvcnRpbmdbc29ydGluZy5sZW5ndGgtMV0uX2lkeCA9IDA7XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKCBzb3J0aW5nLmxlbmd0aCAmJiBzb3J0aW5nWzBdWzBdID09IGNvbElkeCApIHtcblx0XHQvLyBTaW5nbGUgY29sdW1uIC0gYWxyZWFkeSBzb3J0aW5nIG9uIHRoaXMgY29sdW1uLCBtb2RpZnkgdGhlIHNvcnRcblx0XHRuZXh0U29ydElkeCA9IG5leHQoIHNvcnRpbmdbMF0gKTtcblxuXHRcdHNvcnRpbmcubGVuZ3RoID0gMTtcblx0XHRzb3J0aW5nWzBdWzFdID0gYXNTb3J0aW5nWyBuZXh0U29ydElkeCBdO1xuXHRcdHNvcnRpbmdbMF0uX2lkeCA9IG5leHRTb3J0SWR4O1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIFNpbmdsZSBjb2x1bW4gLSBzb3J0IG9ubHkgb24gdGhpcyBjb2x1bW5cblx0XHRzb3J0aW5nLmxlbmd0aCA9IDA7XG5cdFx0c29ydGluZy5wdXNoKCBbIGNvbElkeCwgYXNTb3J0aW5nWzBdIF0gKTtcblx0XHRzb3J0aW5nWzBdLl9pZHggPSAwO1xuXHR9XG59XG5cblxuLyoqXG4gKiBTZXQgdGhlIHNvcnRpbmcgY2xhc3NlcyBvbiB0YWJsZSdzIGJvZHksIE5vdGU6IGl0IGlzIHNhZmUgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uXG4gKiB3aGVuIGJTb3J0IGFuZCBiU29ydENsYXNzZXMgYXJlIGZhbHNlXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Tb3J0aW5nQ2xhc3Nlcyggc2V0dGluZ3MgKVxue1xuXHR2YXIgb2xkU29ydCA9IHNldHRpbmdzLmFMYXN0U29ydDtcblx0dmFyIHNvcnRDbGFzcyA9IHNldHRpbmdzLm9DbGFzc2VzLm9yZGVyLnBvc2l0aW9uO1xuXHR2YXIgc29ydCA9IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApO1xuXHR2YXIgZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXM7XG5cdHZhciBpLCBpZW4sIGNvbElkeDtcblxuXHRpZiAoIGZlYXR1cmVzLmJTb3J0ICYmIGZlYXR1cmVzLmJTb3J0Q2xhc3NlcyApIHtcblx0XHQvLyBSZW1vdmUgb2xkIHNvcnRpbmcgY2xhc3Nlc1xuXHRcdGZvciAoIGk9MCwgaWVuPW9sZFNvcnQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRjb2xJZHggPSBvbGRTb3J0W2ldLnNyYztcblxuXHRcdFx0Ly8gUmVtb3ZlIGNvbHVtbiBzb3J0aW5nXG5cdFx0XHQkKCBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ2FuQ2VsbHMnLCBjb2xJZHggKSApXG5cdFx0XHRcdC5yZW1vdmVDbGFzcyggc29ydENsYXNzICsgKGk8MiA/IGkrMSA6IDMpICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIG5ldyBjb2x1bW4gc29ydGluZ1xuXHRcdGZvciAoIGk9MCwgaWVuPXNvcnQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRjb2xJZHggPSBzb3J0W2ldLnNyYztcblxuXHRcdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4ICkgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIHNvcnRDbGFzcyArIChpPDIgPyBpKzEgOiAzKSApO1xuXHRcdH1cblx0fVxuXG5cdHNldHRpbmdzLmFMYXN0U29ydCA9IHNvcnQ7XG59XG5cblxuLy8gR2V0IHRoZSBkYXRhIHRvIHNvcnQgYSBjb2x1bW4sIGJlIGl0IGZyb20gY2FjaGUsIGZyZXNoIChwb3B1bGF0aW5nIHRoZVxuLy8gY2FjaGUpLCBvciBmcm9tIGEgc29ydCBmb3JtYXR0ZXJcbmZ1bmN0aW9uIF9mblNvcnREYXRhKCBzZXR0aW5ncywgY29sSWR4IClcbntcblx0Ly8gQ3VzdG9tIHNvcnRpbmcgZnVuY3Rpb24gLSBwcm92aWRlZCBieSB0aGUgc29ydCBkYXRhIHR5cGVcblx0dmFyIGNvbHVtbiA9IHNldHRpbmdzLmFvQ29sdW1uc1sgY29sSWR4IF07XG5cdHZhciBjdXN0b21Tb3J0ID0gRGF0YVRhYmxlLmV4dC5vcmRlclsgY29sdW1uLnNTb3J0RGF0YVR5cGUgXTtcblx0dmFyIGN1c3RvbURhdGE7XG5cblx0aWYgKCBjdXN0b21Tb3J0ICkge1xuXHRcdGN1c3RvbURhdGEgPSBjdXN0b21Tb3J0LmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIGNvbElkeCxcblx0XHRcdF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sSWR4IClcblx0XHQpO1xuXHR9XG5cblx0Ly8gVXNlIC8gcG9wdWxhdGUgY2FjaGVcblx0dmFyIHJvdywgY2VsbERhdGE7XG5cdHZhciBmb3JtYXR0ZXIgPSBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXJbIGNvbHVtbi5zVHlwZStcIi1wcmVcIiBdO1xuXHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblxuXHRmb3IgKCB2YXIgcm93SWR4PTAgOyByb3dJZHg8ZGF0YS5sZW5ndGggOyByb3dJZHgrKyApIHtcblx0XHQvLyBTcGFyc2UgYXJyYXlcblx0XHRpZiAoISBkYXRhW3Jvd0lkeF0pIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHJvdyA9IGRhdGFbcm93SWR4XTtcblxuXHRcdGlmICggISByb3cuX2FTb3J0RGF0YSApIHtcblx0XHRcdHJvdy5fYVNvcnREYXRhID0gW107XG5cdFx0fVxuXG5cdFx0aWYgKCAhIHJvdy5fYVNvcnREYXRhW2NvbElkeF0gfHwgY3VzdG9tU29ydCApIHtcblx0XHRcdGNlbGxEYXRhID0gY3VzdG9tU29ydCA/XG5cdFx0XHRcdGN1c3RvbURhdGFbcm93SWR4XSA6IC8vIElmIHRoZXJlIHdhcyBhIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLCB1c2UgZGF0YSBmcm9tIHRoZXJlXG5cdFx0XHRcdF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93SWR4LCBjb2xJZHgsICdzb3J0JyApO1xuXG5cdFx0XHRyb3cuX2FTb3J0RGF0YVsgY29sSWR4IF0gPSBmb3JtYXR0ZXIgP1xuXHRcdFx0XHRmb3JtYXR0ZXIoIGNlbGxEYXRhLCBzZXR0aW5ncyApIDpcblx0XHRcdFx0Y2VsbERhdGE7XG5cdFx0fVxuXHR9XG59XG5cblxuLyoqXG4gKiBTdGF0ZSBpbmZvcm1hdGlvbiBmb3IgYSB0YWJsZVxuICpcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3NcbiAqIEByZXR1cm5zIFN0YXRlIG9iamVjdFxuICovXG5mdW5jdGlvbiBfZm5TYXZlU3RhdGUgKCBzZXR0aW5ncyApXG57XG5cdGlmIChzZXR0aW5ncy5fYkxvYWRpbmdTdGF0ZSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFNvcnQgc3RhdGUgc2F2aW5nIHVzZXMgW1tpZHgsIG9yZGVyXV0gc3RydWN0dXJlLlxuXHR2YXIgc29ydGluZyA9IFtdO1xuXHRfZm5Tb3J0UmVzb2x2ZShzZXR0aW5ncywgc29ydGluZywgc2V0dGluZ3MuYWFTb3J0aW5nICk7XG5cblx0LyogU3RvcmUgdGhlIGludGVyZXN0aW5nIHZhcmlhYmxlcyAqL1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0dmFyIHN0YXRlID0ge1xuXHRcdHRpbWU6ICAgICtuZXcgRGF0ZSgpLFxuXHRcdHN0YXJ0OiAgIHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdGxlbmd0aDogIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRvcmRlcjogICBzb3J0aW5nLm1hcChmdW5jdGlvbiAoc29ydCkge1xuXHRcdFx0Ly8gSWYgYSBjb2x1bW4gbmFtZSBpcyBhdmFpbGFibGUsIHVzZSBpdFxuXHRcdFx0cmV0dXJuIGNvbHVtbnNbc29ydFswXV0gJiYgY29sdW1uc1tzb3J0WzBdXS5zTmFtZVxuXHRcdFx0XHQ/IFsgY29sdW1uc1tzb3J0WzBdXS5zTmFtZSwgc29ydFsxXSBdXG5cdFx0XHRcdDogc29ydC5zbGljZSgpO1xuXHRcdH0gKSxcblx0XHRzZWFyY2g6ICAkLmV4dGVuZCh7fSwgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoKSxcblx0XHRjb2x1bW5zOiBzZXR0aW5ncy5hb0NvbHVtbnMubWFwKCBmdW5jdGlvbiAoIGNvbCwgaSApIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG5hbWU6IGNvbC5zTmFtZSxcblx0XHRcdFx0dmlzaWJsZTogY29sLmJWaXNpYmxlLFxuXHRcdFx0XHRzZWFyY2g6ICQuZXh0ZW5kKHt9LCBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHNbaV0pXG5cdFx0XHR9O1xuXHRcdH0gKVxuXHR9O1xuXG5cdHNldHRpbmdzLm9TYXZlZFN0YXRlID0gc3RhdGU7XG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIFwiYW9TdGF0ZVNhdmVQYXJhbXNcIiwgJ3N0YXRlU2F2ZVBhcmFtcycsIFtzZXR0aW5ncywgc3RhdGVdICk7XG5cdFxuXHRpZiAoIHNldHRpbmdzLm9GZWF0dXJlcy5iU3RhdGVTYXZlICYmICFzZXR0aW5ncy5iRGVzdHJveWluZyApXG5cdHtcblx0XHRzZXR0aW5ncy5mblN0YXRlU2F2ZUNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHN0YXRlICk7XG5cdH1cdFxufVxuXG5cbi8qKlxuICogQXR0ZW1wdCB0byBsb2FkIGEgc2F2ZWQgdGFibGUgc3RhdGVcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtvYmplY3R9IG9Jbml0IERhdGFUYWJsZXMgaW5pdCBvYmplY3Qgc28gd2UgY2FuIG92ZXJyaWRlIHNldHRpbmdzXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBzdGF0ZSBoYXMgYmVlbiBsb2FkZWRcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuTG9hZFN0YXRlICggc2V0dGluZ3MsIGluaXQsIGNhbGxiYWNrIClcbntcblx0aWYgKCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iU3RhdGVTYXZlICkge1xuXHRcdGNhbGxiYWNrKCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGxvYWRlZCA9IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0X2ZuSW1wbGVtZW50U3RhdGUoc2V0dGluZ3MsIHN0YXRlLCBjYWxsYmFjayk7XG5cdH1cblxuXHR2YXIgc3RhdGUgPSBzZXR0aW5ncy5mblN0YXRlTG9hZENhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIGxvYWRlZCApO1xuXG5cdGlmICggc3RhdGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRfZm5JbXBsZW1lbnRTdGF0ZSggc2V0dGluZ3MsIHN0YXRlLCBjYWxsYmFjayApO1xuXHR9XG5cdC8vIG90aGVyd2lzZSwgd2FpdCBmb3IgdGhlIGxvYWRlZCBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuXG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBfZm5JbXBsZW1lbnRTdGF0ZSAoIHNldHRpbmdzLCBzLCBjYWxsYmFjaykge1xuXHR2YXIgaSwgaWVuO1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0dmFyIGN1cnJlbnROYW1lcyA9IF9wbHVjayhzZXR0aW5ncy5hb0NvbHVtbnMsICdzTmFtZScpO1xuXG5cdHNldHRpbmdzLl9iTG9hZGluZ1N0YXRlID0gdHJ1ZTtcblxuXHQvLyBXaGVuIFN0YXRlUmVzdG9yZSB3YXMgaW50cm9kdWNlZCB0aGUgc3RhdGUgY291bGQgbm93IGJlIGltcGxlbWVudGVkIGF0IGFueSB0aW1lXG5cdC8vIE5vdCBqdXN0IGluaXRpYWxpc2F0aW9uLiBUbyBkbyB0aGlzIGFuIGFwaSBpbnN0YW5jZSBpcyByZXF1aXJlZCBpbiBzb21lIHBsYWNlc1xuXHR2YXIgYXBpID0gc2V0dGluZ3MuX2JJbml0Q29tcGxldGUgPyBuZXcgRGF0YVRhYmxlLkFwaShzZXR0aW5ncykgOiBudWxsO1xuXG5cdGlmICggISBzIHx8ICEgcy50aW1lICkge1xuXHRcdHNldHRpbmdzLl9iTG9hZGluZ1N0YXRlID0gZmFsc2U7XG5cdFx0Y2FsbGJhY2soKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWplY3Qgb2xkIGRhdGFcblx0dmFyIGR1cmF0aW9uID0gc2V0dGluZ3MuaVN0YXRlRHVyYXRpb247XG5cdGlmICggZHVyYXRpb24gPiAwICYmIHMudGltZSA8ICtuZXcgRGF0ZSgpIC0gKGR1cmF0aW9uKjEwMDApICkge1xuXHRcdHNldHRpbmdzLl9iTG9hZGluZ1N0YXRlID0gZmFsc2U7XG5cdFx0Y2FsbGJhY2soKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBBbGxvdyBjdXN0b20gYW5kIHBsdWctaW4gbWFuaXB1bGF0aW9uIGZ1bmN0aW9ucyB0byBhbHRlciB0aGUgc2F2ZWQgZGF0YSBzZXQgYW5kXG5cdC8vIGNhbmNlbGxpbmcgb2YgbG9hZGluZyBieSByZXR1cm5pbmcgZmFsc2Vcblx0dmFyIGFiU3RhdGVMb2FkID0gX2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvU3RhdGVMb2FkUGFyYW1zJywgJ3N0YXRlTG9hZFBhcmFtcycsIFtzZXR0aW5ncywgc10gKTtcblx0aWYgKCBhYlN0YXRlTG9hZC5pbmRleE9mKGZhbHNlKSAhPT0gLTEgKSB7XG5cdFx0c2V0dGluZ3MuX2JMb2FkaW5nU3RhdGUgPSBmYWxzZTtcblx0XHRjYWxsYmFjaygpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN0b3JlIHRoZSBzYXZlZCBzdGF0ZSBzbyBpdCBtaWdodCBiZSBhY2Nlc3NlZCBhdCBhbnkgdGltZVxuXHRzZXR0aW5ncy5vTG9hZGVkU3RhdGUgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHMgKTtcblxuXHQvLyBUaGlzIGlzIG5lZWRlZCBmb3IgQ29sUmVvcmRlciwgd2hpY2ggaGFzIHRvIGhhcHBlbiBmaXJzdCB0byBhbGxvdyBhbGxcblx0Ly8gdGhlIHN0b3JlZCBpbmRleGVzIHRvIGJlIHVzYWJsZS4gSXQgaXMgbm90IHB1YmxpY2x5IGRvY3VtZW50ZWQuXG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdzdGF0ZUxvYWRJbml0JywgW3NldHRpbmdzLCBzXSwgdHJ1ZSApO1xuXG5cdC8vIFBhZ2UgTGVuZ3RoXG5cdGlmICggcy5sZW5ndGggIT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBJZiBhbHJlYWR5IGluaXRpYWxpc2VkIGp1c3Qgc2V0IHRoZSB2YWx1ZSBkaXJlY3RseSBzbyB0aGF0IHRoZSBzZWxlY3QgZWxlbWVudCBpcyBhbHNvIHVwZGF0ZWRcblx0XHRpZiAoYXBpKSB7XG5cdFx0XHRhcGkucGFnZS5sZW4ocy5sZW5ndGgpXG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoICAgPSBzLmxlbmd0aDtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXN0b3JlIGtleSBmZWF0dXJlc1xuXHRpZiAoIHMuc3RhcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRpZihhcGkgPT09IG51bGwpIHtcblx0XHRcdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICAgID0gcy5zdGFydDtcblx0XHRcdHNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gcy5zdGFydDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRfZm5QYWdlQ2hhbmdlKHNldHRpbmdzLCBzLnN0YXJ0L3NldHRpbmdzLl9pRGlzcGxheUxlbmd0aCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gT3JkZXJcblx0aWYgKCBzLm9yZGVyICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0c2V0dGluZ3MuYWFTb3J0aW5nID0gW107XG5cdFx0JC5lYWNoKCBzLm9yZGVyLCBmdW5jdGlvbiAoIGksIGNvbCApIHtcblx0XHRcdHZhciBzZXQgPSBbIGNvbFswXSwgY29sWzFdIF07XG5cblx0XHRcdC8vIEEgY29sdW1uIG5hbWUgd2FzIHN0b3JlZCBhbmQgc2hvdWxkIGJlIHVzZWQgZm9yIHJlc3RvcmVcblx0XHRcdGlmICh0eXBlb2YgY29sWzBdID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuYW1lIGZyb20gdGhlIGN1cnJlbnQgbGlzdCBvZiBjb2x1bW4gbmFtZXNcblx0XHRcdFx0dmFyIGlkeCA9IGN1cnJlbnROYW1lcy5pbmRleE9mKGNvbFswXSk7XG5cblx0XHRcdFx0aWYgKGlkeCA8IDApIHtcblx0XHRcdFx0XHQvLyBJZiB0aGUgY29sdW1uIHdhcyBub3QgZm91bmQgaWdub3JlIGl0IGFuZCBjb250aW51ZVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNldFswXSA9IGlkeDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHNldFswXSA+PSBjb2x1bW5zLmxlbmd0aCkge1xuXHRcdFx0XHQvLyBJZiB0aGUgY29sdW1uIGluZGV4IGlzIG91dCBvZiBib3VuZHMgaWdub3JlIGl0IGFuZCBjb250aW51ZVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHNldHRpbmdzLmFhU29ydGluZy5wdXNoKHNldCk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2VhcmNoXG5cdGlmICggcy5zZWFyY2ggIT09IHVuZGVmaW5lZCApIHtcblx0XHQkLmV4dGVuZCggc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCBzLnNlYXJjaCApO1xuXHR9XG5cblx0Ly8gQ29sdW1uc1xuXHRpZiAoIHMuY29sdW1ucyApIHtcblx0XHR2YXIgc2V0ID0gcy5jb2x1bW5zO1xuXHRcdHZhciBpbmNvbWluZyA9IF9wbHVjayhzLmNvbHVtbnMsICduYW1lJyk7XG5cblx0XHQvLyBDaGVjayBpZiBpdCBpcyBhIDIuMiBzdHlsZSBzdGF0ZSBvYmplY3Qgd2l0aCBhIGBuYW1lYCBwcm9wZXJ0eSBmb3IgdGhlIGNvbHVtbnMsIGFuZCBpZlxuXHRcdC8vIHRoZSBuYW1lIHdhcyBkZWZpbmVkLiBJZiBzbywgdGhlbiBjcmVhdGUgYSBuZXcgYXJyYXkgdGhhdCB3aWxsIG1hcCB0aGUgc3RhdGUgb2JqZWN0XG5cdFx0Ly8gZ2l2ZW4sIHRvIHRoZSBjdXJyZW50IGNvbHVtbnMgKGRvbid0IGJvdGhlciBpZiB0aGV5IGFyZSBhbHJlYWR5IG1hdGNoaW5nIHRobykuXG5cdFx0aWYgKGluY29taW5nLmpvaW4oJycpLmxlbmd0aCAmJiBpbmNvbWluZy5qb2luKCcnKSAhPT0gY3VycmVudE5hbWVzLmpvaW4oJycpKSB7XG5cdFx0XHRzZXQgPSBbXTtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggY29sdW1uLCB0cnkgdG8gZmluZCB0aGUgbmFtZSBpbiB0aGUgaW5jb21pbmcgYXJyYXlcblx0XHRcdGZvciAoaT0wIDsgaTxjdXJyZW50TmFtZXMubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHRcdGlmIChjdXJyZW50TmFtZXNbaV0gIT0gJycpIHtcblx0XHRcdFx0XHR2YXIgaWR4ID0gaW5jb21pbmcuaW5kZXhPZihjdXJyZW50TmFtZXNbaV0pO1xuXG5cdFx0XHRcdFx0aWYgKGlkeCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRzZXQucHVzaChzLmNvbHVtbnNbaWR4XSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gTm8gbWF0Y2hpbmcgY29sdW1uIG5hbWUgaW4gdGhlIHN0YXRlJ3MgY29sdW1ucywgc28gdGhpcyBtaWdodCBiZSBhIG5ld1xuXHRcdFx0XHRcdFx0Ly8gY29sdW1uIGFuZCB0aHVzIGNhbid0IGhhdmUgYSBzdGF0ZSBhbHJlYWR5LlxuXHRcdFx0XHRcdFx0c2V0LnB1c2goe30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBJZiBubyBuYW1lLCBidXQgb3RoZXIgY29sdW1ucyBkaWQgaGF2ZSBhIG5hbWUsIHRoZW4gdGhlcmUgaXMgbm8ga25vd2luZ1xuXHRcdFx0XHRcdC8vIHdoZXJlIHRoaXMgb25lIGNhbWUgZnJvbSBvcmlnaW5hbGx5IHNvIGl0IGNhbid0IGJlIHJlc3RvcmVkLlxuXHRcdFx0XHRcdHNldC5wdXNoKHt9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBudW1iZXIgb2YgY29sdW1ucyB0byByZXN0b3JlIGlzIGRpZmZlcmVudCBmcm9tIGN1cnJlbnQsIHRoZW4gYWxsIGJldHMgYXJlIG9mZi5cblx0XHRpZiAoc2V0Lmxlbmd0aCA9PT0gY29sdW1ucy5sZW5ndGgpIHtcblx0XHRcdGZvciAoIGk9MCwgaWVuPXNldC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0dmFyIGNvbCA9IHNldFtpXTtcblxuXHRcdFx0XHQvLyBWaXNpYmlsaXR5XG5cdFx0XHRcdGlmICggY29sLnZpc2libGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBJZiB0aGUgYXBpIGlzIGRlZmluZWQsIHRoZSB0YWJsZSBoYXMgYmVlbiBpbml0aWFsaXNlZCBzbyB3ZSBuZWVkIHRvIHVzZSBpdCByYXRoZXIgdGhhbiBpbnRlcm5hbCBzZXR0aW5nc1xuXHRcdFx0XHRcdGlmIChhcGkpIHtcblx0XHRcdFx0XHRcdC8vIERvbid0IHJlZHJhdyB0aGUgY29sdW1ucyBvbiBldmVyeSBpdGVyYXRpb24gb2YgdGhpcyBsb29wLCB3ZSB3aWxsIGRvIHRoaXMgYXQgdGhlIGVuZCBpbnN0ZWFkXG5cdFx0XHRcdFx0XHRhcGkuY29sdW1uKGkpLnZpc2libGUoY29sLnZpc2libGUsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRjb2x1bW5zW2ldLmJWaXNpYmxlID0gY29sLnZpc2libGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2VhcmNoXG5cdFx0XHRcdGlmICggY29sLnNlYXJjaCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdCQuZXh0ZW5kKCBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHNbaV0sIGNvbC5zZWFyY2ggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgYXBpIGlzIGRlZmluZWQgdGhlbiB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgY29sdW1ucyBvbmNlIHRoZSB2aXNpYmlsaXR5IGhhcyBiZWVuIGNoYW5nZWRcblx0XHRcdGlmIChhcGkpIHtcblx0XHRcdFx0YXBpLmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0c2V0dGluZ3MuX2JMb2FkaW5nU3RhdGUgPSBmYWxzZTtcblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvU3RhdGVMb2FkZWQnLCAnc3RhdGVMb2FkZWQnLCBbc2V0dGluZ3MsIHNdICk7XG5cdGNhbGxiYWNrKCk7XG59XG5cbi8qKlxuICogTG9nIGFuIGVycm9yIG1lc3NhZ2VcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2ludH0gbGV2ZWwgbG9nIGVycm9yIG1lc3NhZ2VzLCBvciBkaXNwbGF5IHRoZW0gdG8gdGhlIHVzZXJcbiAqICBAcGFyYW0ge3N0cmluZ30gbXNnIGVycm9yIG1lc3NhZ2VcbiAqICBAcGFyYW0ge2ludH0gdG4gVGVjaG5pY2FsIG5vdGUgaWQgdG8gZ2V0IG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yLlxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5Mb2coIHNldHRpbmdzLCBsZXZlbCwgbXNnLCB0biApXG57XG5cdG1zZyA9ICdEYXRhVGFibGVzIHdhcm5pbmc6ICcrXG5cdFx0KHNldHRpbmdzID8gJ3RhYmxlIGlkPScrc2V0dGluZ3Muc1RhYmxlSWQrJyAtICcgOiAnJykrbXNnO1xuXG5cdGlmICggdG4gKSB7XG5cdFx0bXNnICs9ICcuIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgZXJyb3IsIHBsZWFzZSBzZWUgJytcblx0XHQnaHR0cHM6Ly9kYXRhdGFibGVzLm5ldC90bi8nK3RuO1xuXHR9XG5cblx0aWYgKCAhIGxldmVsICApIHtcblx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBwcmUgMS4xMFxuXHRcdHZhciBleHQgPSBEYXRhVGFibGUuZXh0O1xuXHRcdHZhciB0eXBlID0gZXh0LnNFcnJNb2RlIHx8IGV4dC5lcnJNb2RlO1xuXG5cdFx0aWYgKCBzZXR0aW5ncyApIHtcblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdkdC1lcnJvcicsIFsgc2V0dGluZ3MsIHRuLCBtc2cgXSwgdHJ1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZSA9PSAnYWxlcnQnICkge1xuXHRcdFx0YWxlcnQoIG1zZyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZSA9PSAndGhyb3cnICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0dHlwZSggc2V0dGluZ3MsIHRuLCBtc2cgKTtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUubG9nICkge1xuXHRcdGNvbnNvbGUubG9nKCBtc2cgKTtcblx0fVxufVxuXG5cbi8qKlxuICogU2VlIGlmIGEgcHJvcGVydHkgaXMgZGVmaW5lZCBvbiBvbmUgb2JqZWN0LCBpZiBzbyBhc3NpZ24gaXQgdG8gdGhlIG90aGVyIG9iamVjdFxuICogIEBwYXJhbSB7b2JqZWN0fSByZXQgdGFyZ2V0IG9iamVjdFxuICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgc291cmNlIG9iamVjdFxuICogIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHByb3BlcnR5XG4gKiAgQHBhcmFtIHtzdHJpbmd9IFttYXBwZWROYW1lXSBuYW1lIHRvIG1hcCB0b28gLSBvcHRpb25hbCwgbmFtZSB1c2VkIGlmIG5vdCBnaXZlblxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5NYXAoIHJldCwgc3JjLCBuYW1lLCBtYXBwZWROYW1lIClcbntcblx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0JC5lYWNoKCBuYW1lLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRfZm5NYXAoIHJldCwgc3JjLCB2YWxbMF0sIHZhbFsxXSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdF9mbk1hcCggcmV0LCBzcmMsIHZhbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggbWFwcGVkTmFtZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdG1hcHBlZE5hbWUgPSBuYW1lO1xuXHR9XG5cblx0aWYgKCBzcmNbbmFtZV0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXRbbWFwcGVkTmFtZV0gPSBzcmNbbmFtZV07XG5cdH1cbn1cblxuXG4vKipcbiAqIEV4dGVuZCBvYmplY3RzIC0gdmVyeSBzaW1pbGFyIHRvIGpRdWVyeS5leHRlbmQsIGJ1dCBkZWVwIGNvcHkgb2JqZWN0cywgYW5kXG4gKiBzaGFsbG93IGNvcHkgYXJyYXlzLiBUaGUgcmVhc29uIHdlIG5lZWQgdG8gZG8gdGhpcywgaXMgdGhhdCB3ZSBkb24ndCB3YW50IHRvXG4gKiBkZWVwIGNvcHkgYXJyYXkgaW5pdCB2YWx1ZXMgKHN1Y2ggYXMgYWFTb3J0aW5nKSBzaW5jZSB0aGUgZGV2IHdvdWxkbid0IGJlXG4gKiBhYmxlIHRvIG92ZXJyaWRlIHRoZW0sIGJ1dCB3ZSBkbyB3YW50IHRvIGRlZXAgY29weSBhcnJheXMuXG4gKiAgQHBhcmFtIHtvYmplY3R9IG91dCBPYmplY3QgdG8gZXh0ZW5kXG4gKiAgQHBhcmFtIHtvYmplY3R9IGV4dGVuZGVyIE9iamVjdCBmcm9tIHdoaWNoIHRoZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYXBwbGllZCB0b1xuICogICAgICBvdXRcbiAqICBAcGFyYW0ge2Jvb2xlYW59IGJyZWFrUmVmcyBJZiB0cnVlLCB0aGVuIGFycmF5cyB3aWxsIGJlIHNsaWNlZCB0byB0YWtlIGFuXG4gKiAgICAgIGluZGVwZW5kZW50IGNvcHkgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSBgZGF0YWAgb3IgYGFhRGF0YWAgcGFyYW1ldGVyc1xuICogICAgICBpZiB0aGV5IGFyZSBwcmVzZW50LiBUaGlzIGlzIHNvIHlvdSBjYW4gcGFzcyBpbiBhIGNvbGxlY3Rpb24gdG9cbiAqICAgICAgRGF0YVRhYmxlcyBhbmQgaGF2ZSB0aGF0IHVzZWQgYXMgeW91ciBkYXRhIHNvdXJjZSB3aXRob3V0IGJyZWFraW5nIHRoZVxuICogICAgICByZWZlcmVuY2VzXG4gKiAgQHJldHVybnMge29iamVjdH0gb3V0IFJlZmVyZW5jZSwganVzdCBmb3IgY29udmVuaWVuY2UgLSBvdXQgPT09IHRoZSByZXR1cm4uXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKiAgQHRvZG8gVGhpcyBkb2Vzbid0IHRha2UgYWNjb3VudCBvZiBhcnJheXMgaW5zaWRlIHRoZSBkZWVwIGNvcGllZCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBfZm5FeHRlbmQoIG91dCwgZXh0ZW5kZXIsIGJyZWFrUmVmcyApXG57XG5cdHZhciB2YWw7XG5cblx0Zm9yICggdmFyIHByb3AgaW4gZXh0ZW5kZXIgKSB7XG5cdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXh0ZW5kZXIsIHByb3ApICkge1xuXHRcdFx0dmFsID0gZXh0ZW5kZXJbcHJvcF07XG5cblx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWwgKSApIHtcblx0XHRcdFx0aWYgKCAhICQuaXNQbGFpbk9iamVjdCggb3V0W3Byb3BdICkgKSB7XG5cdFx0XHRcdFx0b3V0W3Byb3BdID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0JC5leHRlbmQoIHRydWUsIG91dFtwcm9wXSwgdmFsICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggYnJlYWtSZWZzICYmIHByb3AgIT09ICdkYXRhJyAmJiBwcm9wICE9PSAnYWFEYXRhJyAmJiBBcnJheS5pc0FycmF5KHZhbCkgKSB7XG5cdFx0XHRcdG91dFtwcm9wXSA9IHZhbC5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdG91dFtwcm9wXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufVxuXG5cbi8qKlxuICogQmluZCBhbiBldmVudCBoYW5kZXJzIHRvIGFsbG93IGEgY2xpY2sgb3IgcmV0dXJuIGtleSB0byBhY3RpdmF0ZSB0aGUgY2FsbGJhY2suXG4gKiBUaGlzIGlzIGdvb2QgZm9yIGFjY2Vzc2liaWxpdHkgc2luY2UgYSByZXR1cm4gb24gdGhlIGtleWJvYXJkIHdpbGwgaGF2ZSB0aGVcbiAqIHNhbWUgZWZmZWN0IGFzIGEgY2xpY2ssIGlmIHRoZSBlbGVtZW50IGhhcyBmb2N1cy5cbiAqICBAcGFyYW0ge2VsZW1lbnR9IG4gRWxlbWVudCB0byBiaW5kIHRoZSBhY3Rpb24gdG9cbiAqICBAcGFyYW0ge29iamVjdHxzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIChmb3IgZGVsZWdhdGVkIGV2ZW50cykgb3IgZGF0YSBvYmplY3RcbiAqICAgdG8gcGFzcyB0byB0aGUgdHJpZ2dlcmVkIGZ1bmN0aW9uXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5CaW5kQWN0aW9uKCBuLCBzZWxlY3RvciwgZm4gKVxue1xuXHQkKG4pXG5cdFx0Lm9uKCAnY2xpY2suRFQnLCBzZWxlY3RvciwgZnVuY3Rpb24gKGUpIHtcblx0XHRcdGZuKGUpO1xuXHRcdH0gKVxuXHRcdC5vbiggJ2tleXByZXNzLkRUJywgc2VsZWN0b3IsIGZ1bmN0aW9uIChlKXtcblx0XHRcdGlmICggZS53aGljaCA9PT0gMTMgKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0Zm4oZSk7XG5cdFx0XHR9XG5cdFx0fSApXG5cdFx0Lm9uKCAnc2VsZWN0c3RhcnQuRFQnLCBzZWxlY3RvciwgZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gRG9uJ3Qgd2FudCBhIGRvdWJsZSBjbGljayByZXN1bHRpbmcgaW4gdGV4dCBzZWxlY3Rpb25cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9ICk7XG59XG5cblxuLyoqXG4gKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZ1bmN0aW9uLiBFYXNpbHkgYWxsb3dzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgYWRkZWQgdG9cbiAqIGFuIGFycmF5IHN0b3JlIG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IGNhbiB0aGVuIGFsbCBiZSBjYWxsZWQgdG9nZXRoZXIuXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtzdHJpbmd9IHN0b3JlIE5hbWUgb2YgdGhlIGFycmF5IHN0b3JhZ2UgZm9yIHRoZSBjYWxsYmFja3MgaW4gb1NldHRpbmdzXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGJhY2tcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQ2FsbGJhY2tSZWcoIHNldHRpbmdzLCBzdG9yZSwgZm4gKVxue1xuXHRpZiAoIGZuICkge1xuXHRcdHNldHRpbmdzW3N0b3JlXS5wdXNoKGZuKTtcblx0fVxufVxuXG5cbi8qKlxuICogRmlyZSBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIHRyaWdnZXIgZXZlbnRzLiBOb3RlIHRoYXQgdGhlIGxvb3Agb3ZlciB0aGVcbiAqIGNhbGxiYWNrIGFycmF5IHN0b3JlIGlzIGRvbmUgYmFja3dhcmRzISBGdXJ0aGVyIG5vdGUgdGhhdCB5b3UgZG8gbm90IHdhbnQgdG9cbiAqIGZpcmUgb2ZmIHRyaWdnZXJzIGluIHRpbWUgc2Vuc2l0aXZlIGFwcGxpY2F0aW9ucyAoZm9yIGV4YW1wbGUgY2VsbCBjcmVhdGlvbilcbiAqIGFzIGl0cyBzbG93LlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7c3RyaW5nfSBjYWxsYmFja0FyciBOYW1lIG9mIHRoZSBhcnJheSBzdG9yYWdlIGZvciB0aGUgY2FsbGJhY2tzIGluXG4gKiAgICAgIG9TZXR0aW5nc1xuICogIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiB0aGUgalF1ZXJ5IGN1c3RvbSBldmVudCB0byB0cmlnZ2VyLiBJZlxuICogICAgICBudWxsIG5vIHRyaWdnZXIgaXMgZmlyZWRcbiAqICBAcGFyYW0ge2FycmF5fSBhcmdzIEFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAvXG4gKiAgICAgIHRyaWdnZXJcbiAqICBAcGFyYW0ge2Jvb2xlYW59IFtidWJibGVzXSBUcnVlIGlmIHRoZSBldmVudCBzaG91bGQgYnViYmxlXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIGNhbGxiYWNrQXJyLCBldmVudE5hbWUsIGFyZ3MsIGJ1YmJsZXMgKVxue1xuXHR2YXIgcmV0ID0gW107XG5cblx0aWYgKCBjYWxsYmFja0FyciApIHtcblx0XHRyZXQgPSBzZXR0aW5nc1tjYWxsYmFja0Fycl0uc2xpY2UoKS5yZXZlcnNlKCkubWFwKCBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHRyZXR1cm4gdmFsLmFwcGx5KCBzZXR0aW5ncy5vSW5zdGFuY2UsIGFyZ3MgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGV2ZW50TmFtZSAhPT0gbnVsbCkge1xuXHRcdHZhciBlID0gJC5FdmVudCggZXZlbnROYW1lKycuZHQnICk7XG5cdFx0dmFyIHRhYmxlID0gJChzZXR0aW5ncy5uVGFibGUpO1xuXHRcdFxuXHRcdC8vIEV4cG9zZSB0aGUgRGF0YVRhYmxlcyBBUEkgb24gdGhlIGV2ZW50IG9iamVjdCBmb3IgZWFzeSBhY2Nlc3Ncblx0XHRlLmR0ID0gc2V0dGluZ3MuYXBpO1xuXG5cdFx0dGFibGVbYnViYmxlcyA/ICAndHJpZ2dlcicgOiAndHJpZ2dlckhhbmRsZXInXSggZSwgYXJncyApO1xuXG5cdFx0Ly8gSWYgbm90IHlldCBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQsIHRyaWdnZXIgdGhlIGV2ZW50XG5cdFx0Ly8gb24gdGhlIGJvZHkgZGlyZWN0bHkgdG8gc29ydCBvZiBzaW11bGF0ZSB0aGUgYnViYmxlXG5cdFx0aWYgKGJ1YmJsZXMgJiYgdGFibGUucGFyZW50cygnYm9keScpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0JCgnYm9keScpLnRyaWdnZXIoIGUsIGFyZ3MgKTtcblx0XHR9XG5cblx0XHRyZXQucHVzaCggZS5yZXN1bHQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gX2ZuTGVuZ3RoT3ZlcmZsb3cgKCBzZXR0aW5ncyApXG57XG5cdHZhclxuXHRcdHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0ZW5kID0gc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0bGVuID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoO1xuXG5cdC8qIElmIHdlIGhhdmUgc3BhY2UgdG8gc2hvdyBleHRyYSByb3dzIChiYWNraW5nIHVwIGZyb20gdGhlIGVuZCBwb2ludCAtIHRoZW4gZG8gc28gKi9cblx0aWYgKCBzdGFydCA+PSBlbmQgKVxuXHR7XG5cdFx0c3RhcnQgPSBlbmQgLSBsZW47XG5cdH1cblxuXHQvLyBLZWVwIHRoZSBzdGFydCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuXHRzdGFydCAtPSAoc3RhcnQgJSBsZW4pO1xuXG5cdGlmICggbGVuID09PSAtMSB8fCBzdGFydCA8IDAgKVxuXHR7XG5cdFx0c3RhcnQgPSAwO1xuXHR9XG5cblx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBzdGFydDtcbn1cblxuXG5mdW5jdGlvbiBfZm5SZW5kZXJlciggc2V0dGluZ3MsIHR5cGUgKVxue1xuXHR2YXIgcmVuZGVyZXIgPSBzZXR0aW5ncy5yZW5kZXJlcjtcblx0dmFyIGhvc3QgPSBEYXRhVGFibGUuZXh0LnJlbmRlcmVyW3R5cGVdO1xuXG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCByZW5kZXJlciApICYmIHJlbmRlcmVyW3R5cGVdICkge1xuXHRcdC8vIFNwZWNpZmljIHJlbmRlcmVyIGZvciB0aGlzIHR5cGUuIElmIGF2YWlsYWJsZSB1c2UgaXQsIG90aGVyd2lzZSB1c2Vcblx0XHQvLyB0aGUgZGVmYXVsdC5cblx0XHRyZXR1cm4gaG9zdFtyZW5kZXJlclt0eXBlXV0gfHwgaG9zdC5fO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgcmVuZGVyZXIgPT09ICdzdHJpbmcnICkge1xuXHRcdC8vIENvbW1vbiByZW5kZXJlciAtIGlmIHRoZXJlIGlzIG9uZSBhdmFpbGFibGUgZm9yIHRoaXMgdHlwZSB1c2UgaXQsXG5cdFx0Ly8gb3RoZXJ3aXNlIHVzZSB0aGUgZGVmYXVsdFxuXHRcdHJldHVybiBob3N0W3JlbmRlcmVyXSB8fCBob3N0Ll87XG5cdH1cblxuXHQvLyBVc2UgdGhlIGRlZmF1bHRcblx0cmV0dXJuIGhvc3QuXztcbn1cblxuXG4vKipcbiAqIERldGVjdCB0aGUgZGF0YSBzb3VyY2UgYmVpbmcgdXNlZCBmb3IgdGhlIHRhYmxlLiBVc2VkIHRvIHNpbXBsaWZ5IHRoZSBjb2RlXG4gKiBhIGxpdHRsZSAoYWpheCkgYW5kIHRvIG1ha2UgaXQgY29tcHJlc3MgYSBsaXR0bGUgc21hbGxlci5cbiAqXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHJldHVybnMge3N0cmluZ30gRGF0YSBzb3VyY2VcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuRGF0YVNvdXJjZSAoIHNldHRpbmdzIClcbntcblx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlNlcnZlclNpZGUgKSB7XG5cdFx0cmV0dXJuICdzc3AnO1xuXHR9XG5cdGVsc2UgaWYgKCBzZXR0aW5ncy5hamF4ICkge1xuXHRcdHJldHVybiAnYWpheCc7XG5cdH1cblx0cmV0dXJuICdkb20nO1xufVxuXG4vKipcbiAqIENvbW1vbiByZXBsYWNlbWVudCBmb3IgbGFuZ3VhZ2Ugc3RyaW5nc1xuICpcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRFQgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0geyp9IHN0ciBTdHJpbmcgd2l0aCB2YWx1ZXMgdG8gcmVwbGFjZVxuICogQHBhcmFtIHsqfSBlbnRyaWVzIFBsdXJhbCBudW1iZXIgZm9yIF9FTlRSSUVTXyAtIGNhbiBiZSB1bmRlZmluZWRcbiAqIEByZXR1cm5zIFN0cmluZ1xuICovXG5mdW5jdGlvbiBfZm5NYWNyb3MgKCBzZXR0aW5ncywgc3RyLCBlbnRyaWVzIClcbntcblx0Ly8gV2hlbiBpbmZpbml0ZSBzY3JvbGxpbmcsIHdlIGFyZSBhbHdheXMgc3RhcnRpbmcgYXQgMS4gX2lEaXNwbGF5U3RhcnQgaXNcblx0Ly8gdXNlZCBvbmx5IGludGVybmFsbHlcblx0dmFyXG5cdFx0Zm9ybWF0dGVyICA9IHNldHRpbmdzLmZuRm9ybWF0TnVtYmVyLFxuXHRcdHN0YXJ0ICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCsxLFxuXHRcdGxlbiAgICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0dmlzICAgICAgICA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRtYXggICAgICAgID0gc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSxcblx0XHRhbGwgICAgICAgID0gbGVuID09PSAtMTtcblxuXHRyZXR1cm4gc3RyLlxuXHRcdHJlcGxhY2UoL19TVEFSVF8vZywgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBzdGFydCApICkuXG5cdFx0cmVwbGFjZSgvX0VORF8vZywgICBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIHNldHRpbmdzLmZuRGlzcGxheUVuZCgpICkgKS5cblx0XHRyZXBsYWNlKC9fTUFYXy9nLCAgIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgbWF4ICkgKS5cblx0XHRyZXBsYWNlKC9fVE9UQUxfL2csIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgdmlzICkgKS5cblx0XHRyZXBsYWNlKC9fUEFHRV8vZywgIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgYWxsID8gMSA6IE1hdGguY2VpbCggc3RhcnQgLyBsZW4gKSApICkuXG5cdFx0cmVwbGFjZSgvX1BBR0VTXy9nLCBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIGFsbCA/IDEgOiBNYXRoLmNlaWwoIHZpcyAvIGxlbiApICkgKS5cblx0XHRyZXBsYWNlKC9fRU5UUklFU18vZywgc2V0dGluZ3MuYXBpLmkxOG4oJ2VudHJpZXMnLCAnJywgZW50cmllcykgKS5cblx0XHRyZXBsYWNlKC9fRU5UUklFUy1NQVhfL2csIHNldHRpbmdzLmFwaS5pMThuKCdlbnRyaWVzJywgJycsIG1heCkgKS5cblx0XHRyZXBsYWNlKC9fRU5UUklFUy1UT1RBTF8vZywgc2V0dGluZ3MuYXBpLmkxOG4oJ2VudHJpZXMnLCAnJywgdmlzKSApO1xufVxuXG4vKipcbiAqIEFkZCBlbGVtZW50cyB0byBhbiBhcnJheSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLCBidXQgc3RhY2sgc3RhZmUuXG4gKlxuICogQHBhcmFtIHsqfSBhcnIgQXJyYXkgdG8gYWRkIHRoZSBkYXRhIHRvXG4gKiBAcGFyYW0geyp9IGRhdGEgRGF0YSBhcnJheSB0aGF0IGlzIHRvIGJlIGFkZGVkXG4gKiBAcmV0dXJucyBcbiAqL1xuZnVuY3Rpb24gX2ZuQXJyYXlBcHBseShhcnIsIGRhdGEpIHtcblx0aWYgKCEgZGF0YSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIENocm9tZSBjYW4gdGhyb3cgYSBtYXggc3RhY2sgZXJyb3IgaWYgYXBwbHkgaXMgY2FsbGVkIHdpdGhcblx0Ly8gdG9vIGxhcmdlIGFuIGFycmF5LCBidXQgYXBwbHkgaXMgZmFzdGVyLlxuXHRpZiAoZGF0YS5sZW5ndGggPCAxMDAwMCkge1xuXHRcdGFyci5wdXNoLmFwcGx5KGFyciwgZGF0YSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Zm9yIChpPTAgOyBpPGRhdGEubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHRhcnIucHVzaChkYXRhW2ldKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBBZGQgb25lIG9yIG1vcmUgbGlzdGVuZXJzIHRvIHRoZSB0YWJsZVxuICpcbiAqIEBwYXJhbSB7Kn0gdGhhdCBKUSBmb3IgdGhlIHRhYmxlXG4gKiBAcGFyYW0geyp9IG5hbWUgRXZlbnQgbmFtZVxuICogQHBhcmFtIHsqfSBzcmMgTGlzdGVuZXIocylcbiAqL1xuZnVuY3Rpb24gX2ZuTGlzdGVuZXIodGhhdCwgbmFtZSwgc3JjKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShzcmMpKSB7XG5cdFx0c3JjID0gW3NyY107XG5cdH1cblxuXHRmb3IgKGk9MCA7IGk8c3JjLmxlbmd0aCA7IGkrKykge1xuXHRcdHRoYXQub24obmFtZSArICcuZHQnLCBzcmNbaV0pO1xuXHR9XG59XG5cblxuXG4vKipcbiAqIENvbXB1dGVkIHN0cnVjdHVyZSBvZiB0aGUgRGF0YVRhYmxlcyBBUEksIGRlZmluZWQgYnkgdGhlIG9wdGlvbnMgcGFzc2VkIHRvXG4gKiBgRGF0YVRhYmxlLkFwaS5yZWdpc3RlcigpYCB3aGVuIGJ1aWxkaW5nIHRoZSBBUEkuXG4gKlxuICogVGhlIHN0cnVjdHVyZSBpcyBidWlsdCBpbiBvcmRlciB0byBzcGVlZCBjcmVhdGlvbiBhbmQgZXh0ZW5zaW9uIG9mIHRoZSBBcGlcbiAqIG9iamVjdHMgc2luY2UgdGhlIGV4dGVuc2lvbnMgYXJlIGVmZmVjdGl2ZWx5IHByZS1wYXJzZWQuXG4gKlxuICogVGhlIGFycmF5IGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZSwgd2hlcmUgdGhpc1xuICogYmFzZSBhcnJheSByZXByZXNlbnRzIHRoZSBBcGkgcHJvdG90eXBlIGJhc2U6XG4gKlxuICogICAgIFtcbiAqICAgICAgIHtcbiAqICAgICAgICAgbmFtZTogICAgICAnZGF0YScgICAgICAgICAgICAgICAgLS0gc3RyaW5nICAgLSBQcm9wZXJ0eSBuYW1lXG4gKiAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sICAgICAgIC0tIGZ1bmN0aW9uIC0gQXBpIG1ldGhvZCAob3IgdW5kZWZpbmVkIGlmIGp1c3QgYW4gb2JqZWN0XG4gKiAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSwgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIG1ldGhvZCByZXN1bHRcbiAqICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdICAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgcHJvcGVydHlcbiAqICAgICAgIH0sXG4gKiAgICAgICB7XG4gKiAgICAgICAgIG5hbWU6ICAgICAncm93J1xuICogICAgICAgICB2YWw6ICAgICAgIHt9LFxuICogICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG4gKiAgICAgICAgIHByb3BFeHQ6ICAgW1xuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnXG4gKiAgICAgICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LFxuICogICAgICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuICogICAgICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdXG4gKiAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAuLi5cbiAqICAgICAgICAgXVxuICogICAgICAgfVxuICogICAgIF1cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAaWdub3JlXG4gKi9cbnZhciBfX2FwaVN0cnVjdCA9IFtdO1xuXG5cbi8qKlxuICogYEFycmF5LnByb3RvdHlwZWAgcmVmZXJlbmNlLlxuICpcbiAqIEB0eXBlIG9iamVjdFxuICogQGlnbm9yZVxuICovXG52YXIgX19hcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5cbi8qKlxuICogQWJzdHJhY3Rpb24gZm9yIGBjb250ZXh0YCBwYXJhbWV0ZXIgb2YgdGhlIGBBcGlgIGNvbnN0cnVjdG9yIHRvIGFsbG93IGl0IHRvXG4gKiB0YWtlIHNldmVyYWwgZGlmZmVyZW50IGZvcm1zIGZvciBlYXNlIG9mIHVzZS5cbiAqXG4gKiBFYWNoIG9mIHRoZSBpbnB1dCBwYXJhbWV0ZXIgdHlwZXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBEYXRhVGFibGVzIHNldHRpbmdzXG4gKiBvYmplY3Qgd2hlcmUgcG9zc2libGUuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfG5vZGV8alF1ZXJ5fG9iamVjdH0gbWl4ZWQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIENhbiBiZSBvbmVcbiAqICAgb2Y6XG4gKlxuICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXG4gKiAgICAgd2l0aCBiZSBmb3VuZCBhbmQgdXNlZC5cbiAqICAgKiBgbm9kZWAgLSBgVEFCTEVgIG5vZGUgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBmb3JtZWQgaW50byBhIERhdGFUYWJsZS5cbiAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxuICogICAqIGBvYmplY3RgIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICAgKiBgRGF0YVRhYmxlcy5BcGlgIC0gQVBJIGluc3RhbmNlXG4gKiBAcmV0dXJuIHthcnJheXxudWxsfSBNYXRjaGluZyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuIGBudWxsYCBvclxuICogICBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCBpZiBubyBtYXRjaGluZyBEYXRhVGFibGUgaXMgZm91bmQuXG4gKiBAaWdub3JlXG4gKi9cbnZhciBfdG9TZXR0aW5ncyA9IGZ1bmN0aW9uICggbWl4ZWQgKVxue1xuXHR2YXIgaWR4LCBqcTtcblx0dmFyIHNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHR2YXIgdGFibGVzID0gX3BsdWNrKHNldHRpbmdzLCAnblRhYmxlJyk7XG5cblx0aWYgKCAhIG1peGVkICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRlbHNlIGlmICggbWl4ZWQublRhYmxlICYmIG1peGVkLm9GZWF0dXJlcyApIHtcblx0XHQvLyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuXHRcdHJldHVybiBbIG1peGVkIF07XG5cdH1cblx0ZWxzZSBpZiAoIG1peGVkLm5vZGVOYW1lICYmIG1peGVkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0YWJsZScgKSB7XG5cdFx0Ly8gVGFibGUgbm9kZVxuXHRcdGlkeCA9IHRhYmxlcy5pbmRleE9mKG1peGVkKTtcblx0XHRyZXR1cm4gaWR4ICE9PSAtMSA/IFsgc2V0dGluZ3NbaWR4XSBdIDogbnVsbDtcblx0fVxuXHRlbHNlIGlmICggbWl4ZWQgJiYgdHlwZW9mIG1peGVkLnNldHRpbmdzID09PSAnZnVuY3Rpb24nICkge1xuXHRcdHJldHVybiBtaXhlZC5zZXR0aW5ncygpLnRvQXJyYXkoKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIG1peGVkID09PSAnc3RyaW5nJyApIHtcblx0XHQvLyBqUXVlcnkgc2VsZWN0b3Jcblx0XHRqcSA9ICQobWl4ZWQpLmdldCgpO1xuXHR9XG5cdGVsc2UgaWYgKCBtaXhlZCBpbnN0YW5jZW9mICQgKSB7XG5cdFx0Ly8galF1ZXJ5IG9iamVjdCAoYWxzbyBEYXRhVGFibGVzIGluc3RhbmNlKVxuXHRcdGpxID0gbWl4ZWQuZ2V0KCk7XG5cdH1cblxuXHRpZiAoIGpxICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5maWx0ZXIoZnVuY3Rpb24gKHYsIGlkeCkge1xuXHRcdFx0cmV0dXJuIGpxLmluY2x1ZGVzKHRhYmxlc1tpZHhdKTtcblx0XHR9KTtcblx0fVxufTtcblxuXG4vKipcbiAqIERhdGFUYWJsZXMgQVBJIGNsYXNzIC0gdXNlZCB0byBjb250cm9sIGFuZCBpbnRlcmZhY2Ugd2l0aCAgb25lIG9yIG1vcmVcbiAqIERhdGFUYWJsZXMgZW5oYW5jZWQgdGFibGVzLlxuICpcbiAqIFRoZSBBUEkgY2xhc3MgaXMgaGVhdmlseSBiYXNlZCBvbiBqUXVlcnksIHByZXNlbnRpbmcgYSBjaGFpbmFibGUgaW50ZXJmYWNlXG4gKiB0aGF0IHlvdSBjYW4gdXNlIHRvIGludGVyYWN0IHdpdGggdGFibGVzLiBFYWNoIGluc3RhbmNlIG9mIHRoZSBBUEkgY2xhc3MgaGFzXG4gKiBhIFwiY29udGV4dFwiIC0gaS5lLiB0aGUgdGFibGVzIHRoYXQgaXQgd2lsbCBvcGVyYXRlIG9uLiBUaGlzIGNvdWxkIGJlIGEgc2luZ2xlXG4gKiB0YWJsZSwgYWxsIHRhYmxlcyBvbiBhIHBhZ2Ugb3IgYSBzdWItc2V0IHRoZXJlb2YuXG4gKlxuICogQWRkaXRpb25hbGx5IHRoZSBBUEkgaXMgZGVzaWduZWQgdG8gYWxsb3cgeW91IHRvIGVhc2lseSB3b3JrIHdpdGggdGhlIGRhdGEgaW5cbiAqIHRoZSB0YWJsZXMsIHJldHJpZXZpbmcgYW5kIG1hbmlwdWxhdGluZyBpdCBhcyByZXF1aXJlZC4gVGhpcyBpcyBkb25lIGJ5XG4gKiBwcmVzZW50aW5nIHRoZSBBUEkgY2xhc3MgYXMgYW4gYXJyYXkgbGlrZSBpbnRlcmZhY2UuIFRoZSBjb250ZW50cyBvZiB0aGVcbiAqIGFycmF5IGRlcGVuZCB1cG9uIHRoZSBhY3Rpb25zIHJlcXVlc3RlZCBieSBlYWNoIG1ldGhvZCAoZm9yIGV4YW1wbGVcbiAqIGByb3dzKCkubm9kZXMoKWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygbm9kZXMsIHdoaWxlIGByb3dzKCkuZGF0YSgpYCB3aWxsXG4gKiByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0cyBvciBhcnJheXMgZGVwZW5kaW5nIHVwb24geW91ciB0YWJsZSdzXG4gKiBjb25maWd1cmF0aW9uKS4gVGhlIEFQSSBvYmplY3QgaGFzIGEgbnVtYmVyIG9mIGFycmF5IGxpa2UgbWV0aG9kcyAoYHB1c2hgLFxuICogYHBvcGAsIGByZXZlcnNlYCBldGMpIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyAoYGVhY2hgLCBgcGx1Y2tgLFxuICogYHVuaXF1ZWAgZXRjKSB0byBhc3Npc3QgeW91ciB3b3JraW5nIHdpdGggdGhlIGRhdGEgaGVsZCBpbiBhIHRhYmxlLlxuICpcbiAqIE1vc3QgbWV0aG9kcyAodGhvc2Ugd2hpY2ggcmV0dXJuIGFuIEFwaSBpbnN0YW5jZSkgYXJlIGNoYWluYWJsZSwgd2hpY2ggbWVhbnNcbiAqIHRoZSByZXR1cm4gZnJvbSBhIG1ldGhvZCBjYWxsIGFsc28gaGFzIGFsbCBvZiB0aGUgbWV0aG9kcyBhdmFpbGFibGUgdGhhdCB0aGVcbiAqIHRvcCBsZXZlbCBvYmplY3QgaGFkLiBGb3IgZXhhbXBsZSwgdGhlc2UgdHdvIGNhbGxzIGFyZSBlcXVpdmFsZW50OlxuICpcbiAqICAgICAvLyBOb3QgY2hhaW5lZFxuICogICAgIGFwaS5yb3cuYWRkKCB7Li4ufSApO1xuICogICAgIGFwaS5kcmF3KCk7XG4gKlxuICogICAgIC8vIENoYWluZWRcbiAqICAgICBhcGkucm93LmFkZCggey4uLn0gKS5kcmF3KCk7XG4gKlxuICogQGNsYXNzIERhdGFUYWJsZS5BcGlcbiAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fHN0cmluZ3xqUXVlcnl9IGNvbnRleHQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIFRoaXMgaXNcbiAqICAgdXNlZCB0byBkZWZpbmUgd2hpY2ggRGF0YVRhYmxlcyBlbmhhbmNlZCB0YWJsZXMgdGhpcyBBUEkgd2lsbCBvcGVyYXRlIG9uLlxuICogICBDYW4gYmUgb25lIG9mOlxuICpcbiAqICAgKiBgc3RyaW5nYCAtIGpRdWVyeSBzZWxlY3Rvci4gQW55IERhdGFUYWJsZXMnIG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3RvclxuICogICAgIHdpdGggYmUgZm91bmQgYW5kIHVzZWQuXG4gKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXG4gKiAgICogYGpRdWVyeWAgLSBBIGpRdWVyeSBvYmplY3Qgb2YgYFRBQkxFYCBub2Rlcy5cbiAqICAgKiBgb2JqZWN0YCAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0ge2FycmF5fSBbZGF0YV0gRGF0YSB0byBpbml0aWFsaXNlIHRoZSBBcGkgaW5zdGFuY2Ugd2l0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBEaXJlY3QgaW5pdGlhbGlzYXRpb24gZHVyaW5nIERhdGFUYWJsZXMgY29uc3RydWN0aW9uXG4gKiAgIHZhciBhcGkgPSAkKCcjZXhhbXBsZScpLkRhdGFUYWJsZSgpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIEluaXRpYWxpc2F0aW9uIHVzaW5nIGEgRGF0YVRhYmxlcyBqUXVlcnkgb2JqZWN0XG4gKiAgIHZhciBhcGkgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmFwaSgpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIEluaXRpYWxpc2F0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAqICAgdmFyIGFwaSA9IG5ldyBEYXRhVGFibGUuQXBpKCAndGFibGUuZGF0YVRhYmxlJyApO1xuICovXG5fQXBpID0gZnVuY3Rpb24gKCBjb250ZXh0LCBkYXRhIClcbntcblx0aWYgKCAhICh0aGlzIGluc3RhbmNlb2YgX0FwaSkgKSB7XG5cdFx0cmV0dXJuIG5ldyBfQXBpKCBjb250ZXh0LCBkYXRhICk7XG5cdH1cblxuXHR2YXIgaTtcblx0dmFyIHNldHRpbmdzID0gW107XG5cdHZhciBjdHhTZXR0aW5ncyA9IGZ1bmN0aW9uICggbyApIHtcblx0XHR2YXIgYSA9IF90b1NldHRpbmdzKCBvICk7XG5cdFx0aWYgKCBhICkge1xuXHRcdFx0c2V0dGluZ3MucHVzaC5hcHBseSggc2V0dGluZ3MsIGEgKTtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBjb250ZXh0ICkgKSB7XG5cdFx0Zm9yICggaT0wIDsgaTxjb250ZXh0Lmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdGN0eFNldHRpbmdzKCBjb250ZXh0W2ldICk7XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdGN0eFNldHRpbmdzKCBjb250ZXh0ICk7XG5cdH1cblxuXHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHR0aGlzLmNvbnRleHQgPSBzZXR0aW5ncy5sZW5ndGggPiAxXG5cdFx0PyBfdW5pcXVlKCBzZXR0aW5ncyApXG5cdFx0OiBzZXR0aW5ncztcblxuXHQvLyBJbml0aWFsIGRhdGFcblx0X2ZuQXJyYXlBcHBseSh0aGlzLCBkYXRhKTtcblxuXHQvLyBzZWxlY3RvclxuXHR0aGlzLnNlbGVjdG9yID0ge1xuXHRcdHJvd3M6IG51bGwsXG5cdFx0Y29sczogbnVsbCxcblx0XHRvcHRzOiBudWxsXG5cdH07XG5cblx0X0FwaS5leHRlbmQoIHRoaXMsIHRoaXMsIF9fYXBpU3RydWN0ICk7XG59O1xuXG5EYXRhVGFibGUuQXBpID0gX0FwaTtcblxuLy8gRG9uJ3QgZGVzdHJveSB0aGUgZXhpc3RpbmcgcHJvdG90eXBlLCBqdXN0IGV4dGVuZCBpdC4gUmVxdWlyZWQgZm9yIGpRdWVyeSAyJ3Ncbi8vIGlzUGxhaW5PYmplY3QuXG4kLmV4dGVuZCggX0FwaS5wcm90b3R5cGUsIHtcblx0YW55OiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuY291bnQoKSAhPT0gMDtcblx0fSxcblxuXHRjb250ZXh0OiBbXSwgLy8gYXJyYXkgb2YgdGFibGUgc2V0dGluZ3Mgb2JqZWN0c1xuXG5cdGNvdW50OiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuZmxhdHRlbigpLmxlbmd0aDtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiAoIGZuIClcblx0e1xuXHRcdGZvciAoIHZhciBpPTAsIGllbj10aGlzLmxlbmd0aCA7IGk8aWVuOyBpKysgKSB7XG5cdFx0XHRmbi5jYWxsKCB0aGlzLCB0aGlzW2ldLCBpLCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uICggaWR4IClcblx0e1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCA+IGlkeCA/XG5cdFx0XHRuZXcgX0FwaSggY3R4W2lkeF0sIHRoaXNbaWR4XSApIDpcblx0XHRcdG51bGw7XG5cdH0sXG5cblx0ZmlsdGVyOiBmdW5jdGlvbiAoIGZuIClcblx0e1xuXHRcdHZhciBhID0gX19hcnJheVByb3RvLmZpbHRlci5jYWxsKCB0aGlzLCBmbiwgdGhpcyApO1xuXG5cdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIGEgKTtcblx0fSxcblxuXHRmbGF0dGVuOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0dmFyIGEgPSBbXTtcblxuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBhLmNvbmNhdC5hcHBseSggYSwgdGhpcy50b0FycmF5KCkgKSApO1xuXHR9LFxuXG5cdGdldDogZnVuY3Rpb24gKCBpZHggKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXNbIGlkeCBdO1xuXHR9LFxuXG5cdGpvaW46ICAgIF9fYXJyYXlQcm90by5qb2luLFxuXG5cdGluY2x1ZGVzOiBmdW5jdGlvbiAoIGZpbmQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5kZXhPZiggZmluZCApID09PSAtMSA/IGZhbHNlIDogdHJ1ZTtcblx0fSxcblxuXHRpbmRleE9mOiBfX2FycmF5UHJvdG8uaW5kZXhPZixcblxuXHRpdGVyYXRvcjogZnVuY3Rpb24gKCBmbGF0dGVuLCB0eXBlLCBmbiwgYWx3YXlzTmV3ICkge1xuXHRcdHZhclxuXHRcdFx0YSA9IFtdLCByZXQsXG5cdFx0XHRpLCBpZW4sIGosIGplbixcblx0XHRcdGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXG5cdFx0XHRyb3dzLCBpdGVtcywgaXRlbSxcblx0XHRcdHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcblxuXHRcdC8vIEFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0aWYgKCB0eXBlb2YgZmxhdHRlbiA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRhbHdheXNOZXcgPSBmbjtcblx0XHRcdGZuID0gdHlwZTtcblx0XHRcdHR5cGUgPSBmbGF0dGVuO1xuXHRcdFx0ZmxhdHRlbiA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdGZvciAoIGk9MCwgaWVuPWNvbnRleHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHR2YXIgYXBpSW5zdCA9IG5ldyBfQXBpKCBjb250ZXh0W2ldICk7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gJ3RhYmxlJyApIHtcblx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaSApO1xuXG5cdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0YS5wdXNoKCByZXQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdjb2x1bW5zJyB8fCB0eXBlID09PSAncm93cycgKSB7XG5cdFx0XHRcdC8vIHRoaXMgaGFzIHNhbWUgbGVuZ3RoIGFzIGNvbnRleHQgLSBvbmUgZW50cnkgZm9yIGVhY2ggdGFibGVcblx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgdGhpc1tpXSwgaSApO1xuXG5cdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0YS5wdXNoKCByZXQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGUgPT09ICdldmVyeScgfHwgdHlwZSA9PT0gJ2NvbHVtbicgfHwgdHlwZSA9PT0gJ2NvbHVtbi1yb3dzJyB8fCB0eXBlID09PSAncm93JyB8fCB0eXBlID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdC8vIGNvbHVtbnMgYW5kIHJvd3Mgc2hhcmUgdGhlIHNhbWUgc3RydWN0dXJlLlxuXHRcdFx0XHQvLyAndGhpcycgaXMgYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgZm9yIGVhY2ggY29udGV4dFxuXHRcdFx0XHRpdGVtcyA9IHRoaXNbaV07XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSAnY29sdW1uLXJvd3MnICkge1xuXHRcdFx0XHRcdHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoIGNvbnRleHRbaV0sIHNlbGVjdG9yLm9wdHMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGo9MCwgamVuPWl0ZW1zLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRcdGl0ZW0gPSBpdGVtc1tqXTtcblxuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gJ2NlbGwnICkge1xuXHRcdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaXRlbS5yb3csIGl0ZW0uY29sdW1uLCBpLCBqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0ID0gZm4uY2FsbCggYXBpSW5zdCwgY29udGV4dFtpXSwgaXRlbSwgaSwgaiwgcm93cyApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRhLnB1c2goIHJldCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggYS5sZW5ndGggfHwgYWx3YXlzTmV3ICkge1xuXHRcdFx0dmFyIGFwaSA9IG5ldyBfQXBpKCBjb250ZXh0LCBmbGF0dGVuID8gYS5jb25jYXQuYXBwbHkoIFtdLCBhICkgOiBhICk7XG5cdFx0XHR2YXIgYXBpU2VsZWN0b3IgPSBhcGkuc2VsZWN0b3I7XG5cdFx0XHRhcGlTZWxlY3Rvci5yb3dzID0gc2VsZWN0b3Iucm93cztcblx0XHRcdGFwaVNlbGVjdG9yLmNvbHMgPSBzZWxlY3Rvci5jb2xzO1xuXHRcdFx0YXBpU2VsZWN0b3Iub3B0cyA9IHNlbGVjdG9yLm9wdHM7XG5cdFx0XHRyZXR1cm4gYXBpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRsYXN0SW5kZXhPZjogX19hcnJheVByb3RvLmxhc3RJbmRleE9mLFxuXG5cdGxlbmd0aDogIDAsXG5cblx0bWFwOiBmdW5jdGlvbiAoIGZuIClcblx0e1xuXHRcdHZhciBhID0gX19hcnJheVByb3RvLm1hcC5jYWxsKCB0aGlzLCBmbiwgdGhpcyApO1xuXG5cdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIGEgKTtcblx0fSxcblxuXHRwbHVjazogZnVuY3Rpb24gKCBwcm9wIClcblx0e1xuXHRcdHZhciBmbiA9IERhdGFUYWJsZS51dGlsLmdldChwcm9wKTtcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24gKCBlbCApIHtcblx0XHRcdHJldHVybiBmbihlbCk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHBvcDogICAgIF9fYXJyYXlQcm90by5wb3AsXG5cblx0cHVzaDogICAgX19hcnJheVByb3RvLnB1c2gsXG5cblx0cmVkdWNlOiBfX2FycmF5UHJvdG8ucmVkdWNlLFxuXG5cdHJlZHVjZVJpZ2h0OiBfX2FycmF5UHJvdG8ucmVkdWNlUmlnaHQsXG5cblx0cmV2ZXJzZTogX19hcnJheVByb3RvLnJldmVyc2UsXG5cblx0Ly8gT2JqZWN0IHdpdGggcm93cywgY29sdW1ucyBhbmQgb3B0c1xuXHRzZWxlY3RvcjogbnVsbCxcblxuXHRzaGlmdDogICBfX2FycmF5UHJvdG8uc2hpZnQsXG5cblx0c2xpY2U6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgdGhpcyApO1xuXHR9LFxuXG5cdHNvcnQ6ICAgIF9fYXJyYXlQcm90by5zb3J0LFxuXG5cdHNwbGljZTogIF9fYXJyYXlQcm90by5zcGxpY2UsXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiBfX2FycmF5UHJvdG8uc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdHRvJDogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiAkKCB0aGlzICk7XG5cdH0sXG5cblx0dG9KUXVlcnk6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRyZXR1cm4gJCggdGhpcyApO1xuXHR9LFxuXG5cdHVuaXF1ZTogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBfdW5pcXVlKHRoaXMudG9BcnJheSgpKSApO1xuXHR9LFxuXG5cdHVuc2hpZnQ6IF9fYXJyYXlQcm90by51bnNoaWZ0XG59ICk7XG5cblxuZnVuY3Rpb24gX2FwaV9zY29wZSggc2NvcGUsIGZuLCBzdHJ1YyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmV0ID0gZm4uYXBwbHkoIHNjb3BlIHx8IHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdFx0Ly8gTWV0aG9kIGV4dGVuc2lvblxuXHRcdF9BcGkuZXh0ZW5kKCByZXQsIHJldCwgc3RydWMubWV0aG9kRXh0ICk7XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn1cblxuZnVuY3Rpb24gX2FwaV9maW5kKCBzcmMsIG5hbWUgKSB7XG5cdGZvciAoIHZhciBpPTAsIGllbj1zcmMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0aWYgKCBzcmNbaV0ubmFtZSA9PT0gbmFtZSApIHtcblx0XHRcdHJldHVybiBzcmNbaV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBudWxsO1xufVxuXG53aW5kb3cuX19hcGlTdHJ1Y3QgPSBfX2FwaVN0cnVjdDtcblxuX0FwaS5leHRlbmQgPSBmdW5jdGlvbiAoIHNjb3BlLCBvYmosIGV4dCApXG57XG5cdC8vIE9ubHkgZXh0ZW5kIEFQSSBpbnN0YW5jZXMgYW5kIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBBUElcblx0aWYgKCAhIGV4dC5sZW5ndGggfHwgISBvYmogfHwgKCAhIChvYmogaW5zdGFuY2VvZiBfQXBpKSAmJiAhIG9iai5fX2R0X3dyYXBwZXIgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXJcblx0XHRpLCBpZW4sXG5cdFx0c3RydWN0O1xuXG5cdGZvciAoIGk9MCwgaWVuPWV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRzdHJ1Y3QgPSBleHRbaV07XG5cblx0XHRpZiAoc3RydWN0Lm5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHQvLyBWYWx1ZVxuXHRcdG9ialsgc3RydWN0Lm5hbWUgXSA9IHN0cnVjdC50eXBlID09PSAnZnVuY3Rpb24nID9cblx0XHRcdF9hcGlfc2NvcGUoIHNjb3BlLCBzdHJ1Y3QudmFsLCBzdHJ1Y3QgKSA6XG5cdFx0XHRzdHJ1Y3QudHlwZSA9PT0gJ29iamVjdCcgP1xuXHRcdFx0XHR7fSA6XG5cdFx0XHRcdHN0cnVjdC52YWw7XG5cblx0XHRvYmpbIHN0cnVjdC5uYW1lIF0uX19kdF93cmFwcGVyID0gdHJ1ZTtcblxuXHRcdC8vIFByb3BlcnR5IGV4dGVuc2lvblxuXHRcdF9BcGkuZXh0ZW5kKCBzY29wZSwgb2JqWyBzdHJ1Y3QubmFtZSBdLCBzdHJ1Y3QucHJvcEV4dCApO1xuXHR9XG59O1xuXG4vLyAgICAgW1xuLy8gICAgICAge1xuLy8gICAgICAgICBuYW1lOiAgICAgICdkYXRhJyAgICAgICAgICAgICAgICAtLSBzdHJpbmcgICAtIFByb3BlcnR5IG5hbWVcbi8vICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSwgICAgICAgLS0gZnVuY3Rpb24gLSBBcGkgbWV0aG9kIChvciB1bmRlZmluZWQgaWYganVzdCBhbiBvYmplY3Rcbi8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxuLy8gICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF0gICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBwcm9wZXJ0eVxuLy8gICAgICAgfSxcbi8vICAgICAgIHtcbi8vICAgICAgICAgbmFtZTogICAgICdyb3cnXG4vLyAgICAgICAgIHZhbDogICAgICAge30sXG4vLyAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcbi8vICAgICAgICAgcHJvcEV4dDogICBbXG4vLyAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcbi8vICAgICAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sXG4vLyAgICAgICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG4vLyAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cbi8vICAgICAgICAgICB9LFxuLy8gICAgICAgICAgIC4uLlxuLy8gICAgICAgICBdXG4vLyAgICAgICB9XG4vLyAgICAgXVxuXG5cbl9BcGkucmVnaXN0ZXIgPSBfYXBpX3JlZ2lzdGVyID0gZnVuY3Rpb24gKCBuYW1lLCB2YWwgKVxue1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRmb3IgKCB2YXIgaj0wLCBqZW49bmFtZS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdF9BcGkucmVnaXN0ZXIoIG5hbWVbal0sIHZhbCApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXJcblx0XHRpLCBpZW4sXG5cdFx0aGVpciA9IG5hbWUuc3BsaXQoJy4nKSxcblx0XHRzdHJ1Y3QgPSBfX2FwaVN0cnVjdCxcblx0XHRrZXksIG1ldGhvZDtcblxuXHRmb3IgKCBpPTAsIGllbj1oZWlyLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdG1ldGhvZCA9IGhlaXJbaV0uaW5kZXhPZignKCknKSAhPT0gLTE7XG5cdFx0a2V5ID0gbWV0aG9kID9cblx0XHRcdGhlaXJbaV0ucmVwbGFjZSgnKCknLCAnJykgOlxuXHRcdFx0aGVpcltpXTtcblxuXHRcdHZhciBzcmMgPSBfYXBpX2ZpbmQoIHN0cnVjdCwga2V5ICk7XG5cdFx0aWYgKCAhIHNyYyApIHtcblx0XHRcdHNyYyA9IHtcblx0XHRcdFx0bmFtZTogICAgICBrZXksXG5cdFx0XHRcdHZhbDogICAgICAge30sXG5cdFx0XHRcdG1ldGhvZEV4dDogW10sXG5cdFx0XHRcdHByb3BFeHQ6ICAgW10sXG5cdFx0XHRcdHR5cGU6ICAgICAgJ29iamVjdCdcblx0XHRcdH07XG5cdFx0XHRzdHJ1Y3QucHVzaCggc3JjICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpID09PSBpZW4tMSApIHtcblx0XHRcdHNyYy52YWwgPSB2YWw7XG5cdFx0XHRzcmMudHlwZSA9IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHQnZnVuY3Rpb24nIDpcblx0XHRcdFx0JC5pc1BsYWluT2JqZWN0KCB2YWwgKSA/XG5cdFx0XHRcdFx0J29iamVjdCcgOlxuXHRcdFx0XHRcdCdvdGhlcic7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c3RydWN0ID0gbWV0aG9kID9cblx0XHRcdFx0c3JjLm1ldGhvZEV4dCA6XG5cdFx0XHRcdHNyYy5wcm9wRXh0O1xuXHRcdH1cblx0fVxufTtcblxuX0FwaS5yZWdpc3RlclBsdXJhbCA9IF9hcGlfcmVnaXN0ZXJQbHVyYWwgPSBmdW5jdGlvbiAoIHBsdXJhbE5hbWUsIHNpbmd1bGFyTmFtZSwgdmFsICkge1xuXHRfQXBpLnJlZ2lzdGVyKCBwbHVyYWxOYW1lLCB2YWwgKTtcblxuXHRfQXBpLnJlZ2lzdGVyKCBzaW5ndWxhck5hbWUsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmV0ID0gdmFsLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdGlmICggcmV0ID09PSB0aGlzICkge1xuXHRcdFx0Ly8gUmV0dXJuZWQgaXRlbSBpcyB0aGUgQVBJIGluc3RhbmNlIHRoYXQgd2FzIHBhc3NlZCBpbiwgcmV0dXJuIGl0XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHJldCBpbnN0YW5jZW9mIF9BcGkgKSB7XG5cdFx0XHQvLyBOZXcgQVBJIGluc3RhbmNlIHJldHVybmVkLCB3YW50IHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBpdGVtXG5cdFx0XHQvLyBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgZm9yIHRoZSBzaW5ndWxhciByZXN1bHQuXG5cdFx0XHRyZXR1cm4gcmV0Lmxlbmd0aCA/XG5cdFx0XHRcdEFycmF5LmlzQXJyYXkoIHJldFswXSApID9cblx0XHRcdFx0XHRuZXcgX0FwaSggcmV0LmNvbnRleHQsIHJldFswXSApIDogLy8gQXJyYXkgcmVzdWx0cyBhcmUgJ2VuaGFuY2VkJ1xuXHRcdFx0XHRcdHJldFswXSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBOb24tQVBJIHJldHVybiAtIGp1c3QgZmlyZSBpdCBiYWNrXG5cdFx0cmV0dXJuIHJldDtcblx0fSApO1xufTtcblxuXG4vKipcbiAqIFNlbGVjdG9yIGZvciBIVE1MIHRhYmxlcy4gQXBwbHkgdGhlIGdpdmVuIHNlbGVjdG9yIHRvIHRoZSBnaXZlIGFycmF5IG9mXG4gKiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8aW50ZWdlcn0gW3NlbGVjdG9yXSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nIG9yIGludGVnZXJcbiAqIEBwYXJhbSAge2FycmF5fSBBcnJheSBvZiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMgdG8gYmUgZmlsdGVyZWRcbiAqIEByZXR1cm4ge2FycmF5fVxuICogQGlnbm9yZVxuICovXG52YXIgX190YWJsZV9zZWxlY3RvciA9IGZ1bmN0aW9uICggc2VsZWN0b3IsIGEgKVxue1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoc2VsZWN0b3IpICkge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblxuXHRcdHNlbGVjdG9yLmZvckVhY2goZnVuY3Rpb24gKHNlbCkge1xuXHRcdFx0dmFyIGlubmVyID0gX190YWJsZV9zZWxlY3RvcihzZWwsIGEpO1xuXG5cdFx0XHRfZm5BcnJheUFwcGx5KHJlc3VsdCwgaW5uZXIpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHJlc3VsdC5maWx0ZXIoIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRyZXR1cm4gaXRlbTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIEludGVnZXIgaXMgdXNlZCB0byBwaWNrIG91dCBhIHRhYmxlIGJ5IGluZGV4XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSAnbnVtYmVyJyApIHtcblx0XHRyZXR1cm4gWyBhWyBzZWxlY3RvciBdIF07XG5cdH1cblxuXHQvLyBQZXJmb3JtIGEgalF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSB0YWJsZSBub2Rlc1xuXHR2YXIgbm9kZXMgPSBhLm1hcCggZnVuY3Rpb24gKGVsKSB7XG5cdFx0cmV0dXJuIGVsLm5UYWJsZTtcblx0fSApO1xuXG5cdHJldHVybiAkKG5vZGVzKVxuXHRcdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQubWFwKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBOZWVkIHRvIHRyYW5zbGF0ZSBiYWNrIGZyb20gdGhlIHRhYmxlIG5vZGUgdG8gdGhlIHNldHRpbmdzXG5cdFx0XHR2YXIgaWR4ID0gbm9kZXMuaW5kZXhPZih0aGlzKTtcblx0XHRcdHJldHVybiBhWyBpZHggXTtcblx0XHR9IClcblx0XHQudG9BcnJheSgpO1xufTtcblxuXG5cbi8qKlxuICogQ29udGV4dCBzZWxlY3RvciBmb3IgdGhlIEFQSSdzIGNvbnRleHQgKGkuZS4gdGhlIHRhYmxlcyB0aGUgQVBJIGluc3RhbmNlXG4gKiByZWZlcnMgdG8uXG4gKlxuICogQG5hbWUgICAgRGF0YVRhYmxlLkFwaSN0YWJsZXNcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0gU2VsZWN0b3IgdG8gcGljayB3aGljaCB0YWJsZXMgdGhlIGl0ZXJhdG9yXG4gKiAgIHNob3VsZCBvcGVyYXRlIG9uLiBJZiBub3QgZ2l2ZW4sIGFsbCB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dCBhcmVcbiAqICAgdXNlZC4gVGhpcyBjYW4gYmUgZ2l2ZW4gYXMgYSBqUXVlcnkgc2VsZWN0b3IgKGZvciBleGFtcGxlIGAnOmd0KDApJ2ApIHRvXG4gKiAgIHNlbGVjdCBtdWx0aXBsZSB0YWJsZXMgb3IgYXMgYW4gaW50ZWdlciB0byBzZWxlY3QgYSBzaW5nbGUgdGFibGUuXG4gKiBAcmV0dXJucyB7RGF0YVRhYmxlLkFwaX0gUmV0dXJucyBhIG5ldyBBUEkgaW5zdGFuY2UgaWYgYSBzZWxlY3RvciBpcyBnaXZlbi5cbiAqL1xuX2FwaV9yZWdpc3RlciggJ3RhYmxlcygpJywgZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcblx0Ly8gQSBuZXcgaW5zdGFuY2UgaXMgY3JlYXRlZCBpZiB0aGVyZSB3YXMgYSBzZWxlY3RvciBzcGVjaWZpZWRcblx0cmV0dXJuIHNlbGVjdG9yICE9PSB1bmRlZmluZWQgJiYgc2VsZWN0b3IgIT09IG51bGwgP1xuXHRcdG5ldyBfQXBpKCBfX3RhYmxlX3NlbGVjdG9yKCBzZWxlY3RvciwgdGhpcy5jb250ZXh0ICkgKSA6XG5cdFx0dGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAndGFibGUoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG5cdHZhciB0YWJsZXMgPSB0aGlzLnRhYmxlcyggc2VsZWN0b3IgKTtcblx0dmFyIGN0eCA9IHRhYmxlcy5jb250ZXh0O1xuXG5cdC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCBtYXRjaGVkIHRhYmxlXG5cdHJldHVybiBjdHgubGVuZ3RoID9cblx0XHRuZXcgX0FwaSggY3R4WzBdICkgOlxuXHRcdHRhYmxlcztcbn0gKTtcblxuLy8gQ29tbW9uIG1ldGhvZHMsIGNvbWJpbmVkIHRvIHJlZHVjZSBzaXplXG5bXG5cdFsnbm9kZXMnLCAnbm9kZScsICduVGFibGUnXSxcblx0Wydib2R5JywgJ2JvZHknLCAnblRCb2R5J10sXG5cdFsnaGVhZGVyJywgJ2hlYWRlcicsICduVEhlYWQnXSxcblx0Wydmb290ZXInLCAnZm9vdGVyJywgJ25URm9vdCddLFxuXS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdF9hcGlfcmVnaXN0ZXJQbHVyYWwoXG5cdFx0J3RhYmxlcygpLicgKyBpdGVtWzBdICsgJygpJyxcblx0XHQndGFibGUoKS4nICsgaXRlbVsxXSArICcoKScgLFxuXHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRcdFx0cmV0dXJuIGN0eFtpdGVtWzJdXTtcblx0XHRcdH0sIDEgKTtcblx0XHR9XG5cdCk7XG59KTtcblxuLy8gU3RydWN0dXJlIG1ldGhvZHNcbltcblx0WydoZWFkZXInLCAnYW9IZWFkZXInXSxcblx0Wydmb290ZXInLCAnYW9Gb290ZXInXSxcbl0uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHRfYXBpX3JlZ2lzdGVyKCAndGFibGUoKS4nICsgaXRlbVswXSArICcuc3RydWN0dXJlKCknICwgZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdFx0dmFyIGluZGV4ZXMgPSB0aGlzLmNvbHVtbnMoc2VsZWN0b3IpLmluZGV4ZXMoKS5mbGF0dGVuKCkudG9BcnJheSgpO1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cdFx0dmFyIHN0cnVjdHVyZSA9IF9mbkhlYWRlckxheW91dChjdHgsIGN0eFtpdGVtWzFdXSwgaW5kZXhlcyk7XG5cblx0XHQvLyBUaGUgc3RydWN0dXJlIGlzIGluIGNvbHVtbiBpbmRleCBvcmRlciAtIGJ1dCBmcm9tIHRoaXMgbWV0aG9kIHdlIHdhbnQgdGhlIHJldHVybiB0byBiZVxuXHRcdC8vIGluIHRoZSBjb2x1bW5zKCkgc2VsZWN0b3IgQVBJIG9yZGVyLiBJbiBvcmRlciB0byBkbyB0aGF0IHdlIG5lZWQgdG8gbWFwIGZyb20gb25lIGZvcm1cblx0XHQvLyB0byB0aGUgb3RoZXJcblx0XHR2YXIgb3JkZXJlZEluZGV4ZXMgPSBpbmRleGVzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHN0cnVjdHVyZS5tYXAoZnVuY3Rpb24gKHJvdykge1xuXHRcdFx0cmV0dXJuIGluZGV4ZXMubWFwKGZ1bmN0aW9uIChjb2xJZHgpIHtcblx0XHRcdFx0cmV0dXJuIHJvd1tvcmRlcmVkSW5kZXhlcy5pbmRleE9mKGNvbElkeCldO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH0pO1xufSk7XG5cblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ3RhYmxlcygpLmNvbnRhaW5lcnMoKScsICd0YWJsZSgpLmNvbnRhaW5lcigpJyAsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdHJldHVybiBjdHgublRhYmxlV3JhcHBlcjtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyKCAndGFibGVzKCkuZXZlcnkoKScsIGZ1bmN0aW9uICggZm4gKSB7XG5cdHZhciB0aGF0ID0gdGhpcztcblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAocywgaSkge1xuXHRcdGZuLmNhbGwodGhhdC50YWJsZShpKSwgaSk7XG5cdH0pO1xufSk7XG5cbl9hcGlfcmVnaXN0ZXIoICdjYXB0aW9uKCknLCBmdW5jdGlvbiAoIHZhbHVlLCBzaWRlICkge1xuXHR2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHQvLyBHZXR0ZXIgLSByZXR1cm4gZXhpc3Rpbmcgbm9kZSdzIGNvbnRlbnRcblx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHZhciBjYXB0aW9uID0gY29udGV4dFswXS5jYXB0aW9uTm9kZTtcblxuXHRcdHJldHVybiBjYXB0aW9uICYmIGNvbnRleHQubGVuZ3RoID9cblx0XHRcdGNhcHRpb24uaW5uZXJIVE1MIDogXG5cdFx0XHRudWxsO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdHZhciB0YWJsZSA9ICQoY3R4Lm5UYWJsZSk7XG5cdFx0dmFyIGNhcHRpb24gPSAkKGN0eC5jYXB0aW9uTm9kZSk7XG5cdFx0dmFyIGNvbnRhaW5lciA9ICQoY3R4Lm5UYWJsZVdyYXBwZXIpO1xuXG5cdFx0Ly8gQ3JlYXRlIHRoZSBub2RlIGlmIGl0IGRvZXNuJ3QgZXhpc3QgeWV0XG5cdFx0aWYgKCAhIGNhcHRpb24ubGVuZ3RoICkge1xuXHRcdFx0Y2FwdGlvbiA9ICQoJzxjYXB0aW9uLz4nKS5odG1sKCB2YWx1ZSApO1xuXHRcdFx0Y3R4LmNhcHRpb25Ob2RlID0gY2FwdGlvblswXTtcblxuXHRcdFx0Ly8gSWYgc2lkZSBpc24ndCBzZXQsIHdlIG5lZWQgdG8gaW5zZXJ0IGludG8gdGhlIGRvY3VtZW50IHRvIGxldCB0aGVcblx0XHRcdC8vIENTUyBkZWNpZGUgc28gd2UgY2FuIHJlYWQgaXQgYmFjaywgb3RoZXJ3aXNlIHRoZXJlIGlzIG5vIHdheSB0b1xuXHRcdFx0Ly8ga25vdyBpZiB0aGUgQ1NTIHdvdWxkIHB1dCBpdCB0b3Agb3IgYm90dG9tIGZvciBzY3JvbGxpbmdcblx0XHRcdGlmICghIHNpZGUpIHtcblx0XHRcdFx0dGFibGUucHJlcGVuZChjYXB0aW9uKTtcblxuXHRcdFx0XHRzaWRlID0gY2FwdGlvbi5jc3MoJ2NhcHRpb24tc2lkZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNhcHRpb24uaHRtbCggdmFsdWUgKTtcblxuXHRcdGlmICggc2lkZSApIHtcblx0XHRcdGNhcHRpb24uY3NzKCAnY2FwdGlvbi1zaWRlJywgc2lkZSApO1xuXHRcdFx0Y2FwdGlvblswXS5fY2FwdGlvblNpZGUgPSBzaWRlO1xuXHRcdH1cblxuXHRcdGlmIChjb250YWluZXIuZmluZCgnZGl2LmRhdGFUYWJsZXNfc2Nyb2xsJykubGVuZ3RoKSB7XG5cdFx0XHR2YXIgc2VsZWN0b3IgPSAoc2lkZSA9PT0gJ3RvcCcgPyAnSGVhZCcgOiAnRm9vdCcpO1xuXG5cdFx0XHRjb250YWluZXIuZmluZCgnZGl2LmRhdGFUYWJsZXNfc2Nyb2xsJysgc2VsZWN0b3IgKycgdGFibGUnKS5wcmVwZW5kKGNhcHRpb24pO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRhYmxlLnByZXBlbmQoY2FwdGlvbik7XG5cdFx0fVxuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXIoICdjYXB0aW9uLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRyZXR1cm4gY3R4Lmxlbmd0aCA/IGN0eFswXS5jYXB0aW9uTm9kZSA6IG51bGw7XG59ICk7XG5cblxuLyoqXG4gKiBSZWRyYXcgdGhlIHRhYmxlcyBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuICovXG5fYXBpX3JlZ2lzdGVyKCAnZHJhdygpJywgZnVuY3Rpb24gKCBwYWdpbmcgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdGlmICggcGFnaW5nID09PSAncGFnZScgKSB7XG5cdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICggdHlwZW9mIHBhZ2luZyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHBhZ2luZyA9IHBhZ2luZyA9PT0gJ2Z1bGwtaG9sZCcgP1xuXHRcdFx0XHRcdGZhbHNlIDpcblx0XHRcdFx0XHR0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzLCBwYWdpbmc9PT1mYWxzZSApO1xuXHRcdH1cblx0fSApO1xufSApO1xuXG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBpbmRleC5cbiAqXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfSBDdXJyZW50IHBhZ2UgaW5kZXggKHplcm8gYmFzZWQpXG4gKi8vKipcbiAqIFNldCB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE5vdGUgdGhhdCBpZiB5b3UgYXR0ZW1wdCB0byBzaG93IGEgcGFnZSB3aGljaCBkb2VzIG5vdCBleGlzdCwgRGF0YVRhYmxlcyB3aWxsXG4gKiBub3QgdGhyb3cgYW4gZXJyb3IsIGJ1dCByYXRoZXIgcmVzZXQgdGhlIHBhZ2luZy5cbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJ8c3RyaW5nfSBhY3Rpb24gVGhlIHBhZ2luZyBhY3Rpb24gdG8gdGFrZS4gVGhpcyBjYW4gYmUgb25lIG9mOlxuICogICogYGludGVnZXJgIC0gVGhlIHBhZ2UgaW5kZXggdG8ganVtcCB0b1xuICogICogYHN0cmluZ2AgLSBBbiBhY3Rpb24gdG8gdGFrZTpcbiAqICAgICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZS5cbiAqICAgICogYG5leHRgIC0gSnVtcCB0byB0aGUgbmV4dCBwYWdlXG4gKiAgICAqIGBwcmV2aW91c2AgLSBKdW1wIHRvIHByZXZpb3VzIHBhZ2VcbiAqICAgICogYGxhc3RgIC0gSnVtcCB0byB0aGUgbGFzdCBwYWdlLlxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdwYWdlKCknLCBmdW5jdGlvbiAoIGFjdGlvbiApIHtcblx0aWYgKCBhY3Rpb24gPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5wYWdlLmluZm8oKS5wYWdlOyAvLyBub3QgYW4gZXhwZW5zaXZlIGNhbGxcblx0fVxuXG5cdC8vIGVsc2UsIGhhdmUgYW4gYWN0aW9uIHRvIHRha2Ugb24gYWxsIHRhYmxlc1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5QYWdlQ2hhbmdlKCBzZXR0aW5ncywgYWN0aW9uICk7XG5cdH0gKTtcbn0gKTtcblxuXG4vKipcbiAqIFBhZ2luZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGZpcnN0IHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gKlxuICogSWYgeW91IHJlcXVpcmUgcGFnaW5nIGluZm9ybWF0aW9uIGZvciBhbm90aGVyIHRhYmxlLCB1c2UgdGhlIGB0YWJsZSgpYCBtZXRob2RcbiAqIHdpdGggYSBzdWl0YWJsZSBzZWxlY3Rvci5cbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBzZXQ6XG4gKiAgKiBgcGFnZWAgLSBDdXJyZW50IHBhZ2UgaW5kZXggKHplcm8gYmFzZWQgLSBpLmUuIHRoZSBmaXJzdCBwYWdlIGlzIGAwYClcbiAqICAqIGBwYWdlc2AgLSBUb3RhbCBudW1iZXIgb2YgcGFnZXNcbiAqICAqIGBzdGFydGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgZmlyc3QgcmVjb3JkIHNob3duIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAqICAqIGBlbmRgIC0gRGlzcGxheSBpbmRleCBmb3IgdGhlIGxhc3QgcmVjb3JkIHNob3duIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAqICAqIGBsZW5ndGhgIC0gRGlzcGxheSBsZW5ndGggKG51bWJlciBvZiByZWNvcmRzKS4gTm90ZSB0aGF0IGdlbmVyYWxseSBgc3RhcnRcbiAqICAgICsgbGVuZ3RoID0gZW5kYCwgYnV0IHRoaXMgaXMgbm90IGFsd2F5cyB0cnVlLCBmb3IgZXhhbXBsZSBpZiB0aGVyZSBhcmVcbiAqICAgIG9ubHkgMiByZWNvcmRzIHRvIHNob3cgb24gdGhlIGZpbmFsIHBhZ2UsIHdpdGggYSBsZW5ndGggb2YgMTAuXG4gKiAgKiBgcmVjb3Jkc1RvdGFsYCAtIEZ1bGwgZGF0YSBzZXQgbGVuZ3RoXG4gKiAgKiBgcmVjb3Jkc0Rpc3BsYXlgIC0gRGF0YSBzZXQgbGVuZ3RoIG9uY2UgdGhlIGN1cnJlbnQgZmlsdGVyaW5nIGNyaXRlcmlvblxuICogICAgYXJlIGFwcGxpZWQuXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdwYWdlLmluZm8oKScsIGZ1bmN0aW9uICgpIHtcblx0aWYgKCB0aGlzLmNvbnRleHQubGVuZ3RoID09PSAwICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHR2YXJcblx0XHRzZXR0aW5ncyAgID0gdGhpcy5jb250ZXh0WzBdLFxuXHRcdHN0YXJ0ICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRsZW4gICAgICAgID0gc2V0dGluZ3Mub0ZlYXR1cmVzLmJQYWdpbmF0ZSA/IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA6IC0xLFxuXHRcdHZpc1JlY29yZHMgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXG5cdFx0YWxsICAgICAgICA9IGxlbiA9PT0gLTE7XG5cblx0cmV0dXJuIHtcblx0XHRcInBhZ2VcIjogICAgICAgICAgIGFsbCA/IDAgOiBNYXRoLmZsb29yKCBzdGFydCAvIGxlbiApLFxuXHRcdFwicGFnZXNcIjogICAgICAgICAgYWxsID8gMSA6IE1hdGguY2VpbCggdmlzUmVjb3JkcyAvIGxlbiApLFxuXHRcdFwic3RhcnRcIjogICAgICAgICAgc3RhcnQsXG5cdFx0XCJlbmRcIjogICAgICAgICAgICBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcblx0XHRcImxlbmd0aFwiOiAgICAgICAgIGxlbixcblx0XHRcInJlY29yZHNUb3RhbFwiOiAgIHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXG5cdFx0XCJyZWNvcmRzRGlzcGxheVwiOiB2aXNSZWNvcmRzLFxuXHRcdFwic2VydmVyU2lkZVwiOiAgICAgX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PT0gJ3NzcCdcblx0fTtcbn0gKTtcblxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBwYWdlIGxlbmd0aC5cbiAqXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfSBDdXJyZW50IHBhZ2UgbGVuZ3RoLiBOb3RlIGAtMWAgaW5kaWNhdGVzIHRoYXQgYWxsIHJlY29yZHNcbiAqICAgYXJlIHRvIGJlIHNob3duLlxuICovLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgcGFnZSBsZW5ndGguXG4gKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBQYWdlIGxlbmd0aCB0byBzZXQuIFVzZSBgLTFgIHRvIHNob3cgYWxsIHJlY29yZHMuXG4gKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAqL1xuX2FwaV9yZWdpc3RlciggJ3BhZ2UubGVuKCknLCBmdW5jdGlvbiAoIGxlbiApIHtcblx0Ly8gTm90ZSB0aGF0IHdlIGNhbid0IGNhbGwgdGhpcyBmdW5jdGlvbiAnbGVuZ3RoKCknIGJlY2F1c2UgYGxlbmd0aGBcblx0Ly8gaXMgYSBKYXZhc2NyaXB0IHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB3aGljaCBkZWZpbmVzIGhvdyBtYW55IGFyZ3VtZW50c1xuXHQvLyB0aGUgZnVuY3Rpb24gZXhwZWN0cy5cblx0aWYgKCBsZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHR0aGlzLmNvbnRleHRbMF0uX2lEaXNwbGF5TGVuZ3RoIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIGVsc2UsIHNldCB0aGUgcGFnZSBsZW5ndGhcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0X2ZuTGVuZ3RoQ2hhbmdlKCBzZXR0aW5ncywgbGVuICk7XG5cdH0gKTtcbn0gKTtcblxuXG5cbnZhciBfX3JlbG9hZCA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIGhvbGRQb3NpdGlvbiwgY2FsbGJhY2sgKSB7XG5cdC8vIFVzZSB0aGUgZHJhdyBldmVudCB0byB0cmlnZ2VyIGEgY2FsbGJhY2tcblx0aWYgKCBjYWxsYmFjayApIHtcblx0XHR2YXIgYXBpID0gbmV3IF9BcGkoIHNldHRpbmdzICk7XG5cblx0XHRhcGkub25lKCAnZHJhdycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdGNhbGxiYWNrKCBhcGkuYWpheC5qc29uKCkgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgPT0gJ3NzcCcgKSB7XG5cdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uICk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cblx0XHQvLyBDYW5jZWwgYW4gZXhpc3RpbmcgcmVxdWVzdFxuXHRcdHZhciB4aHIgPSBzZXR0aW5ncy5qcVhIUjtcblx0XHRpZiAoIHhociAmJiB4aHIucmVhZHlTdGF0ZSAhPT0gNCApIHtcblx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIFRyaWdnZXIgeGhyXG5cdFx0X2ZuQnVpbGRBamF4KCBzZXR0aW5ncywge30sIGZ1bmN0aW9uKCBqc29uICkge1xuXHRcdFx0X2ZuQ2xlYXJUYWJsZSggc2V0dGluZ3MgKTtcblxuXHRcdFx0dmFyIGRhdGEgPSBfZm5BamF4RGF0YVNyYyggc2V0dGluZ3MsIGpzb24gKTtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRfZm5BZGREYXRhKCBzZXR0aW5ncywgZGF0YVtpXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24gKTtcblx0XHRcdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MgKTtcblx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHR9ICk7XG5cdH1cbn07XG5cblxuLyoqXG4gKiBHZXQgdGhlIEpTT04gcmVzcG9uc2UgZnJvbSB0aGUgbGFzdCBBamF4IHJlcXVlc3QgdGhhdCBEYXRhVGFibGVzIG1hZGUgdG8gdGhlXG4gKiBzZXJ2ZXIuIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgdGhlIEpTT04gZnJvbSB0aGUgZmlyc3QgdGFibGUgaW4gdGhlIGN1cnJlbnRcbiAqIGNvbnRleHQuXG4gKlxuICogQHJldHVybiB7b2JqZWN0fSBKU09OIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAqL1xuX2FwaV9yZWdpc3RlciggJ2FqYXguanNvbigpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdGlmICggY3R4Lmxlbmd0aCA+IDAgKSB7XG5cdFx0cmV0dXJuIGN0eFswXS5qc29uO1xuXHR9XG5cblx0Ly8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xufSApO1xuXG5cbi8qKlxuICogR2V0IHRoZSBkYXRhIHN1Ym1pdHRlZCBpbiB0aGUgbGFzdCBBamF4IHJlcXVlc3RcbiAqL1xuX2FwaV9yZWdpc3RlciggJ2FqYXgucGFyYW1zKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCBjdHgubGVuZ3RoID4gMCApIHtcblx0XHRyZXR1cm4gY3R4WzBdLm9BamF4RGF0YTtcblx0fVxuXG5cdC8vIGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcbn0gKTtcblxuXG4vKipcbiAqIFJlbG9hZCB0YWJsZXMgZnJvbSB0aGUgQWpheCBkYXRhIHNvdXJjZS4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbFxuICogYXV0b21hdGljYWxseSByZS1kcmF3IHRoZSB0YWJsZSB3aGVuIHRoZSByZW1vdGUgZGF0YSBoYXMgYmVlbiBsb2FkZWQuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBbcmVzZXQ9dHJ1ZV0gUmVzZXQgKGRlZmF1bHQpIG9yIGhvbGQgdGhlIGN1cnJlbnQgcGFnaW5nXG4gKiAgIHBvc2l0aW9uLiBBIGZ1bGwgcmUtc29ydCBhbmQgcmUtZmlsdGVyIGlzIHBlcmZvcm1lZCB3aGVuIHRoaXMgbWV0aG9kIGlzXG4gKiAgIGNhbGxlZCwgd2hpY2ggaXMgd2h5IHRoZSBwYWdpbmF0aW9uIHJlc2V0IGlzIHRoZSBkZWZhdWx0IGFjdGlvbi5cbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovXG5fYXBpX3JlZ2lzdGVyKCAnYWpheC5yZWxvYWQoKScsIGZ1bmN0aW9uICggY2FsbGJhY2ssIHJlc2V0UGFnaW5nICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XG5cdFx0X19yZWxvYWQoIHNldHRpbmdzLCByZXNldFBhZ2luZz09PWZhbHNlLCBjYWxsYmFjayApO1xuXHR9ICk7XG59ICk7XG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgdGhlIFVSTCBmcm9tIHRoZSBmaXJzdFxuICogdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEN1cnJlbnQgQWpheCBzb3VyY2UgVVJMXG4gKi8vKipcbiAqIFNldCB0aGUgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2V0IHRoZSBVUkwgZm9yIGFsbCB0YWJsZXMgaW4gdGhlXG4gKiBjdXJyZW50IGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gc2V0LlxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdhamF4LnVybCgpJywgZnVuY3Rpb24gKCB1cmwgKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCB1cmwgPT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBnZXRcblx0XHRpZiAoIGN0eC5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRjdHggPSBjdHhbMF07XG5cblx0XHRyZXR1cm4gJC5pc1BsYWluT2JqZWN0KCBjdHguYWpheCApID9cblx0XHRcdGN0eC5hamF4LnVybCA6XG5cdFx0XHRjdHguYWpheDtcblx0fVxuXG5cdC8vIHNldFxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggc2V0dGluZ3MuYWpheCApICkge1xuXHRcdFx0c2V0dGluZ3MuYWpheC51cmwgPSB1cmw7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c2V0dGluZ3MuYWpheCA9IHVybDtcblx0XHR9XG5cdH0gKTtcbn0gKTtcblxuXG4vKipcbiAqIExvYWQgZGF0YSBmcm9tIHRoZSBuZXdseSBzZXQgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBvbmx5XG4gKiBhdmFpbGFibGUgd2hlbiBgYWpheC51cmwoKWAgaXMgdXNlZCB0byBzZXQgYSBVUkwuIEFkZGl0aW9uYWxseSwgdGhpcyBtZXRob2RcbiAqIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgY2FsbGluZyBgYWpheC5yZWxvYWQoKWAgYnV0IGlzIHByb3ZpZGVkIGZvclxuICogY29udmVuaWVuY2Ugd2hlbiBzZXR0aW5nIGEgbmV3IFVSTC4gTGlrZSBgYWpheC5yZWxvYWQoKWAgaXQgd2lsbFxuICogYXV0b21hdGljYWxseSByZWRyYXcgdGhlIHRhYmxlIG9uY2UgdGhlIHJlbW90ZSBkYXRhIGhhcyBiZWVuIGxvYWRlZC5cbiAqXG4gKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAqL1xuX2FwaV9yZWdpc3RlciggJ2FqYXgudXJsKCkubG9hZCgpJywgZnVuY3Rpb24gKCBjYWxsYmFjaywgcmVzZXRQYWdpbmcgKSB7XG5cdC8vIFNhbWUgYXMgYSByZWxvYWQsIGJ1dCBtYWtlcyBzZW5zZSB0byBwcmVzZW50IGl0IGZvciBlYXN5IGFjY2VzcyBhZnRlciBhXG5cdC8vIHVybCBjaGFuZ2Vcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdF9fcmVsb2FkKCBjdHgsIHJlc2V0UGFnaW5nPT09ZmFsc2UsIGNhbGxiYWNrICk7XG5cdH0gKTtcbn0gKTtcblxuXG5cblxudmFyIF9zZWxlY3Rvcl9ydW4gPSBmdW5jdGlvbiAoIHR5cGUsIHNlbGVjdG9yLCBzZWxlY3RGbiwgc2V0dGluZ3MsIG9wdHMgKVxue1xuXHR2YXJcblx0XHRvdXQgPSBbXSwgcmVzLFxuXHRcdGksIGllbixcblx0XHRzZWxlY3RvclR5cGUgPSB0eXBlb2Ygc2VsZWN0b3I7XG5cblx0Ly8gQ2FuJ3QganVzdCBjaGVjayBmb3IgaXNBcnJheSBoZXJlLCBhcyBhbiBBUEkgb3IgalF1ZXJ5IGluc3RhbmNlIG1pZ2h0IGJlXG5cdC8vIGdpdmVuIHdpdGggdGhlaXIgYXJyYXkgbGlrZSBsb29rXG5cdGlmICggISBzZWxlY3RvciB8fCBzZWxlY3RvclR5cGUgPT09ICdzdHJpbmcnIHx8IHNlbGVjdG9yVHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBzZWxlY3Rvci5sZW5ndGggPT09IHVuZGVmaW5lZCApIHtcblx0XHRzZWxlY3RvciA9IFsgc2VsZWN0b3IgXTtcblx0fVxuXG5cdGZvciAoIGk9MCwgaWVuPXNlbGVjdG9yLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHJlcyA9IHNlbGVjdEZuKCB0eXBlb2Ygc2VsZWN0b3JbaV0gPT09ICdzdHJpbmcnID8gc2VsZWN0b3JbaV0udHJpbSgpIDogc2VsZWN0b3JbaV0gKTtcblxuXHRcdC8vIFJlbW92ZSBlbXB0eSBpdGVtc1xuXHRcdHJlcyA9IHJlcy5maWx0ZXIoIGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRyZXR1cm4gaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB1bmRlZmluZWQ7XG5cdFx0fSk7XG5cblx0XHRpZiAoIHJlcyAmJiByZXMubGVuZ3RoICkge1xuXHRcdFx0b3V0ID0gb3V0LmNvbmNhdCggcmVzICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gc2VsZWN0b3IgZXh0ZW5zaW9uc1xuXHR2YXIgZXh0ID0gX2V4dC5zZWxlY3RvclsgdHlwZSBdO1xuXHRpZiAoIGV4dC5sZW5ndGggKSB7XG5cdFx0Zm9yICggaT0wLCBpZW49ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0b3V0ID0gZXh0W2ldKCBzZXR0aW5ncywgb3B0cywgb3V0ICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIF91bmlxdWUoIG91dCApO1xufTtcblxuXG52YXIgX3NlbGVjdG9yX29wdHMgPSBmdW5jdGlvbiAoIG9wdHMgKVxue1xuXHRpZiAoICEgb3B0cyApIHtcblx0XHRvcHRzID0ge307XG5cdH1cblxuXHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgMS45LSB3aGljaCB1c2VkIHRoZSB0ZXJtaW5vbG9neSBmaWx0ZXIgcmF0aGVyXG5cdC8vIHRoYW4gc2VhcmNoXG5cdGlmICggb3B0cy5maWx0ZXIgJiYgb3B0cy5zZWFyY2ggPT09IHVuZGVmaW5lZCApIHtcblx0XHRvcHRzLnNlYXJjaCA9IG9wdHMuZmlsdGVyO1xuXHR9XG5cblx0cmV0dXJuICQuZXh0ZW5kKCB7XG5cdFx0Y29sdW1uT3JkZXI6ICdpbXBsaWVkJyxcblx0XHRzZWFyY2g6ICdub25lJyxcblx0XHRvcmRlcjogJ2N1cnJlbnQnLFxuXHRcdHBhZ2U6ICdhbGwnXG5cdH0sIG9wdHMgKTtcbn07XG5cblxuLy8gUmVkdWNlIHRoZSBBUEkgaW5zdGFuY2UgdG8gdGhlIGZpcnN0IGl0ZW0gZm91bmRcbnZhciBfc2VsZWN0b3JfZmlyc3QgPSBmdW5jdGlvbiAoIG9sZCApXG57XG5cdHZhciBpbnN0ID0gbmV3IF9BcGkob2xkLmNvbnRleHRbMF0pO1xuXG5cdC8vIFVzZSBhIHB1c2ggcmF0aGVyIHRoYW4gcGFzc2luZyB0byB0aGUgY29uc3RydWN0b3IsIHNpbmNlIGl0IHdpbGxcblx0Ly8gbWVyZ2UgYXJyYXlzIGRvd24gYXV0b21hdGljYWxseSwgd2hpY2ggaXNuJ3Qgd2hhdCBpcyB3YW50ZWQgaGVyZVxuXHRpZiAob2xkLmxlbmd0aCkge1xuXHRcdGluc3QucHVzaCggb2xkWzBdICk7XG5cdH1cblxuXHRpbnN0LnNlbGVjdG9yID0gb2xkLnNlbGVjdG9yO1xuXG5cdC8vIExpbWl0IHRvIGEgc2luZ2xlIHJvdyAvIGNvbHVtbiAvIGNlbGxcblx0aWYgKGluc3QubGVuZ3RoICYmIGluc3RbMF0ubGVuZ3RoID4gMSkge1xuXHRcdGluc3RbMF0uc3BsaWNlKDEpO1xuXHR9XG5cblx0cmV0dXJuIGluc3Q7XG59O1xuXG5cbnZhciBfc2VsZWN0b3Jfcm93X2luZGV4ZXMgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBvcHRzIClcbntcblx0dmFyXG5cdFx0aSwgaWVuLCB0bXAsIGE9W10sXG5cdFx0ZGlzcGxheUZpbHRlcmVkID0gc2V0dGluZ3MuYWlEaXNwbGF5LFxuXHRcdGRpc3BsYXlNYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XG5cblx0dmFyXG5cdFx0c2VhcmNoID0gb3B0cy5zZWFyY2gsICAvLyBub25lLCBhcHBsaWVkLCByZW1vdmVkXG5cdFx0b3JkZXIgID0gb3B0cy5vcmRlciwgICAvLyBhcHBsaWVkLCBjdXJyZW50LCBpbmRleCAob3JpZ2luYWwgLSBjb21wYXRpYmlsaXR5IHdpdGggMS45KVxuXHRcdHBhZ2UgICA9IG9wdHMucGFnZTsgICAgLy8gYWxsLCBjdXJyZW50XG5cblx0aWYgKCBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09ICdzc3AnICkge1xuXHRcdC8vIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgbW9kZSwgbW9zdCBvcHRpb25zIGFyZSBpcnJlbGV2YW50IHNpbmNlXG5cdFx0Ly8gcm93cyBub3Qgc2hvd24gZG9uJ3QgZXhpc3QgYW5kIHRoZSBpbmRleCBvcmRlciBpcyB0aGUgYXBwbGllZCBvcmRlclxuXHRcdC8vIFJlbW92ZWQgaXMgYSBzcGVjaWFsIGNhc2UgLSBmb3IgY29uc2lzdGVuY3kganVzdCByZXR1cm4gYW4gZW1wdHlcblx0XHQvLyBhcnJheVxuXHRcdHJldHVybiBzZWFyY2ggPT09ICdyZW1vdmVkJyA/XG5cdFx0XHRbXSA6XG5cdFx0XHRfcmFuZ2UoIDAsIGRpc3BsYXlNYXN0ZXIubGVuZ3RoICk7XG5cdH1cblxuXHRpZiAoIHBhZ2UgPT0gJ2N1cnJlbnQnICkge1xuXHRcdC8vIEN1cnJlbnQgcGFnZSBpbXBsaWVzIHRoYXQgb3JkZXI9Y3VycmVudCBhbmQgZmlsdGVyPWFwcGxpZWQsIHNpbmNlIGl0IGlzXG5cdFx0Ly8gZmFpcmx5IHNlbnNlbGVzcyBvdGhlcndpc2UsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBvcmRlciBhbmQgc2VhcmNoIGFjdHVhbGx5XG5cdFx0Ly8gYXJlXG5cdFx0Zm9yICggaT1zZXR0aW5ncy5faURpc3BsYXlTdGFydCwgaWVuPXNldHRpbmdzLmZuRGlzcGxheUVuZCgpIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRhLnB1c2goIGRpc3BsYXlGaWx0ZXJlZFtpXSApO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggb3JkZXIgPT0gJ2N1cnJlbnQnIHx8IG9yZGVyID09ICdhcHBsaWVkJyApIHtcblx0XHRpZiAoIHNlYXJjaCA9PSAnbm9uZScpIHtcblx0XHRcdGEgPSBkaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzZWFyY2ggPT0gJ2FwcGxpZWQnICkge1xuXHRcdFx0YSA9IGRpc3BsYXlGaWx0ZXJlZC5zbGljZSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggc2VhcmNoID09ICdyZW1vdmVkJyApIHtcblx0XHRcdC8vIE8obittKSBzb2x1dGlvbiBieSBjcmVhdGluZyBhIGhhc2ggbWFwXG5cdFx0XHR2YXIgZGlzcGxheUZpbHRlcmVkTWFwID0ge307XG5cblx0XHRcdGZvciAoIGk9MCwgaWVuPWRpc3BsYXlGaWx0ZXJlZC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0ZGlzcGxheUZpbHRlcmVkTWFwW2Rpc3BsYXlGaWx0ZXJlZFtpXV0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRkaXNwbGF5TWFzdGVyLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0aWYgKCEgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRpc3BsYXlGaWx0ZXJlZE1hcCwgaXRlbSkpIHtcblx0XHRcdFx0XHRhLnB1c2goaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggb3JkZXIgPT0gJ2luZGV4JyB8fCBvcmRlciA9PSAnb3JpZ2luYWwnICkge1xuXHRcdGZvciAoIGk9MCwgaWVuPXNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICghIHNldHRpbmdzLmFvRGF0YVtpXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzZWFyY2ggPT0gJ25vbmUnICkge1xuXHRcdFx0XHRhLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgeyAvLyBhcHBsaWVkIHwgcmVtb3ZlZFxuXHRcdFx0XHR0bXAgPSBkaXNwbGF5RmlsdGVyZWQuaW5kZXhPZihpKTtcblxuXHRcdFx0XHRpZiAoKHRtcCA9PT0gLTEgJiYgc2VhcmNoID09ICdyZW1vdmVkJykgfHxcblx0XHRcdFx0XHQodG1wID49IDAgICAmJiBzZWFyY2ggPT0gJ2FwcGxpZWQnKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJyApIHtcblx0XHQvLyBPcmRlciB0aGUgcm93cyBieSB0aGUgZ2l2ZW4gY29sdW1uXG5cdFx0dmFyIG9yZGVyZWQgPSBfZm5Tb3J0KHNldHRpbmdzLCBvcmRlciwgJ2FzYycpO1xuXG5cdFx0aWYgKHNlYXJjaCA9PT0gJ25vbmUnKSB7XG5cdFx0XHRhID0gb3JkZXJlZDtcblx0XHR9XG5cdFx0ZWxzZSB7IC8vIGFwcGxpZWQgfCByZW1vdmVkXG5cdFx0XHRmb3IgKGk9MDsgaTxvcmRlcmVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRtcCA9IGRpc3BsYXlGaWx0ZXJlZC5pbmRleE9mKG9yZGVyZWRbaV0pO1xuXG5cdFx0XHRcdGlmICgodG1wID09PSAtMSAmJiBzZWFyY2ggPT0gJ3JlbW92ZWQnKSB8fFxuXHRcdFx0XHRcdCh0bXAgPj0gMCAgICYmIHNlYXJjaCA9PSAnYXBwbGllZCcpIClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGEucHVzaCggb3JkZXJlZFtpXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGE7XG59O1xuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogUm93c1xuICpcbiAqIHt9ICAgICAgICAgIC0gbm8gc2VsZWN0b3IgLSB1c2UgYWxsIGF2YWlsYWJsZSByb3dzXG4gKiB7aW50ZWdlcn0gICAtIHJvdyBhb0RhdGEgaW5kZXhcbiAqIHtub2RlfSAgICAgIC0gVFIgbm9kZVxuICoge3N0cmluZ30gICAgLSBqUXVlcnkgc2VsZWN0b3IgdG8gYXBwbHkgdG8gdGhlIFRSIGVsZW1lbnRzXG4gKiB7YXJyYXl9ICAgICAtIGpRdWVyeSBhcnJheSBvZiBub2Rlcywgb3Igc2ltcGx5IGFuIGFycmF5IG9mIFRSIG5vZGVzXG4gKlxuICovXG52YXIgX19yb3dfc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApXG57XG5cdHZhciByb3dzO1xuXHR2YXIgcnVuID0gZnVuY3Rpb24gKCBzZWwgKSB7XG5cdFx0dmFyIHNlbEludCA9IF9pbnRWYWwoIHNlbCApO1xuXHRcdHZhciBhb0RhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cblx0XHQvLyBTaG9ydCBjdXQgLSBzZWxlY3RvciBpcyBhIG51bWJlciBhbmQgbm8gb3B0aW9ucyBwcm92aWRlZCAoZGVmYXVsdCBpc1xuXHRcdC8vIGFsbCByZWNvcmRzLCBzbyBubyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBpbmRleCBpcyBpbiB0aGVyZSwgc2luY2UgaXRcblx0XHQvLyBtdXN0IGJlIC0gZGV2IGVycm9yIGlmIHRoZSBpbmRleCBkb2Vzbid0IGV4aXN0KS5cblx0XHRpZiAoIHNlbEludCAhPT0gbnVsbCAmJiAhIG9wdHMgKSB7XG5cdFx0XHRyZXR1cm4gWyBzZWxJbnQgXTtcblx0XHR9XG5cblx0XHRpZiAoICEgcm93cyApIHtcblx0XHRcdHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoIHNldHRpbmdzLCBvcHRzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgJiYgcm93cy5pbmRleE9mKHNlbEludCkgIT09IC0xICkge1xuXHRcdFx0Ly8gU2VsZWN0b3IgLSBpbnRlZ2VyXG5cdFx0XHRyZXR1cm4gWyBzZWxJbnQgXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHNlbCA9PT0gbnVsbCB8fCBzZWwgPT09IHVuZGVmaW5lZCB8fCBzZWwgPT09ICcnICkge1xuXHRcdFx0Ly8gU2VsZWN0b3IgLSBub25lXG5cdFx0XHRyZXR1cm4gcm93cztcblx0XHR9XG5cblx0XHQvLyBTZWxlY3RvciAtIGZ1bmN0aW9uXG5cdFx0aWYgKCB0eXBlb2Ygc2VsID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0cmV0dXJuIHJvd3MubWFwKCBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdHZhciByb3cgPSBhb0RhdGFbIGlkeCBdO1xuXHRcdFx0XHRyZXR1cm4gc2VsKCBpZHgsIHJvdy5fYURhdGEsIHJvdy5uVHIgKSA/IGlkeCA6IG51bGw7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2VsZWN0b3IgLSBub2RlXG5cdFx0aWYgKCBzZWwubm9kZU5hbWUgKSB7XG5cdFx0XHR2YXIgcm93SWR4ID0gc2VsLl9EVF9Sb3dJbmRleDsgIC8vIFByb3BlcnR5IGFkZGVkIGJ5IERUIGZvciBmYXN0IGxvb2t1cFxuXHRcdFx0dmFyIGNlbGxJZHggPSBzZWwuX0RUX0NlbGxJbmRleDtcblxuXHRcdFx0aWYgKCByb3dJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIHJvdyBpcyBhY3R1YWxseSBzdGlsbCBwcmVzZW50IGluIHRoZSB0YWJsZVxuXHRcdFx0XHRyZXR1cm4gYW9EYXRhWyByb3dJZHggXSAmJiBhb0RhdGFbIHJvd0lkeCBdLm5UciA9PT0gc2VsID9cblx0XHRcdFx0XHRbIHJvd0lkeCBdIDpcblx0XHRcdFx0XHRbXTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBjZWxsSWR4ICkge1xuXHRcdFx0XHRyZXR1cm4gYW9EYXRhWyBjZWxsSWR4LnJvdyBdICYmIGFvRGF0YVsgY2VsbElkeC5yb3cgXS5uVHIgPT09IHNlbC5wYXJlbnROb2RlID9cblx0XHRcdFx0XHRbIGNlbGxJZHgucm93IF0gOlxuXHRcdFx0XHRcdFtdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHZhciBob3N0ID0gJChzZWwpLmNsb3Nlc3QoJypbZGF0YS1kdC1yb3ddJyk7XG5cdFx0XHRcdHJldHVybiBob3N0Lmxlbmd0aCA/XG5cdFx0XHRcdFx0WyBob3N0LmRhdGEoJ2R0LXJvdycpIF0gOlxuXHRcdFx0XHRcdFtdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElEIHNlbGVjdG9yLiBXYW50IHRvIGFsd2F5cyBiZSBhYmxlIHRvIHNlbGVjdCByb3dzIGJ5IGlkLCByZWdhcmRsZXNzXG5cdFx0Ly8gb2YgaWYgdGhlIHRyIGVsZW1lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciBub3QsIHNvIGNhbid0IHJlbHkgdXBvblxuXHRcdC8vIGpRdWVyeSBoZXJlIC0gaGVuY2UgYSBjdXN0b20gaW1wbGVtZW50YXRpb24uIFRoaXMgZG9lcyBub3QgbWF0Y2hcblx0XHQvLyBTaXp6bGUncyBmYXN0IHNlbGVjdG9yIG9yIEhUTUw0IC0gaW4gSFRNTDUgdGhlIElEIGNhbiBiZSBhbnl0aGluZyxcblx0XHQvLyBidXQgdG8gc2VsZWN0IGl0IHVzaW5nIGEgQ1NTIHNlbGVjdG9yIGVuZ2luZSAobGlrZSBTaXp6bGUgb3Jcblx0XHQvLyBxdWVyeVNlbGVjdCkgaXQgd291bGQgbmVlZCB0byBuZWVkIHRvIGJlIGVzY2FwZWQgZm9yIHNvbWUgY2hhcmFjdGVycy5cblx0XHQvLyBEYXRhVGFibGVzIHNpbXBsaWZpZXMgdGhpcyBmb3Igcm93IHNlbGVjdG9ycyBzaW5jZSB5b3UgY2FuIHNlbGVjdFxuXHRcdC8vIG9ubHkgYSByb3cuIEEgIyBpbmRpY2F0ZXMgYW4gaWQgYW55IGFueXRoaW5nIHRoYXQgZm9sbG93cyBpcyB0aGUgaWQgLVxuXHRcdC8vIHVuZXNjYXBlZC5cblx0XHRpZiAoIHR5cGVvZiBzZWwgPT09ICdzdHJpbmcnICYmIHNlbC5jaGFyQXQoMCkgPT09ICcjJyApIHtcblx0XHRcdC8vIGdldCByb3cgaW5kZXggZnJvbSBpZFxuXHRcdFx0dmFyIHJvd09iaiA9IHNldHRpbmdzLmFJZHNbIHNlbC5yZXBsYWNlKCAvXiMvLCAnJyApIF07XG5cdFx0XHRpZiAoIHJvd09iaiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gWyByb3dPYmouaWR4IF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIG5lZWQgdG8gZmFsbCB0aHJvdWdoIHRvIGpRdWVyeSBpbiBjYXNlIHRoZXJlIGlzIERPTSBpZCB0aGF0XG5cdFx0XHQvLyBtYXRjaGVzXG5cdFx0fVxuXHRcdFxuXHRcdC8vIEdldCBub2RlcyBpbiB0aGUgb3JkZXIgZnJvbSB0aGUgYHJvd3NgIGFycmF5IHdpdGggbnVsbCB2YWx1ZXMgcmVtb3ZlZFxuXHRcdHZhciBub2RlcyA9IF9yZW1vdmVFbXB0eShcblx0XHRcdF9wbHVja19vcmRlciggc2V0dGluZ3MuYW9EYXRhLCByb3dzLCAnblRyJyApXG5cdFx0KTtcblxuXHRcdC8vIFNlbGVjdG9yIC0galF1ZXJ5IHNlbGVjdG9yIHN0cmluZywgYXJyYXkgb2Ygbm9kZXMgb3IgalF1ZXJ5IG9iamVjdC9cblx0XHQvLyBBcyBqUXVlcnkncyAuZmlsdGVyKCkgYWxsb3dzIGpRdWVyeSBvYmplY3RzIHRvIGJlIHBhc3NlZCBpbiBmaWx0ZXIsXG5cdFx0Ly8gaXQgYWxzbyBhbGxvd3MgYXJyYXlzLCBzbyB0aGlzIHdpbGwgY29wZSB3aXRoIGFsbCB0aHJlZSBvcHRpb25zXG5cdFx0cmV0dXJuICQobm9kZXMpXG5cdFx0XHQuZmlsdGVyKCBzZWwgKVxuXHRcdFx0Lm1hcCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fRFRfUm93SW5kZXg7XG5cdFx0XHR9IClcblx0XHRcdC50b0FycmF5KCk7XG5cdH07XG5cblx0dmFyIG1hdGNoZWQgPSBfc2VsZWN0b3JfcnVuKCAncm93Jywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMgKTtcblxuXHRpZiAob3B0cy5vcmRlciA9PT0gJ2N1cnJlbnQnIHx8IG9wdHMub3JkZXIgPT09ICdhcHBsaWVkJykge1xuXHRcdF9mblNvcnREaXNwbGF5KHNldHRpbmdzLCBtYXRjaGVkKTtcblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAncm93cygpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0Ly8gYXJndW1lbnQgc2hpZnRpbmdcblx0aWYgKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHNlbGVjdG9yID0gJyc7XG5cdH1cblx0ZWxzZSBpZiAoICQuaXNQbGFpbk9iamVjdCggc2VsZWN0b3IgKSApIHtcblx0XHRvcHRzID0gc2VsZWN0b3I7XG5cdFx0c2VsZWN0b3IgPSAnJztcblx0fVxuXG5cdG9wdHMgPSBfc2VsZWN0b3Jfb3B0cyggb3B0cyApO1xuXG5cdHZhciBpbnN0ID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gX19yb3dfc2VsZWN0b3IoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApO1xuXHR9LCAxICk7XG5cblx0Ly8gV2FudCBhcmd1bWVudCBzaGlmdGluZyBoZXJlIGFuZCBpbiBfX3Jvd19zZWxlY3Rvcj9cblx0aW5zdC5zZWxlY3Rvci5yb3dzID0gc2VsZWN0b3I7XG5cdGluc3Quc2VsZWN0b3Iub3B0cyA9IG9wdHM7XG5cblx0cmV0dXJuIGluc3Q7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXIoICdyb3dzKCkubm9kZXMoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzLmFvRGF0YVsgcm93IF0ublRyIHx8IHVuZGVmaW5lZDtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyKCAncm93cygpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoIHRydWUsICdyb3dzJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93cyApIHtcblx0XHRyZXR1cm4gX3BsdWNrX29yZGVyKCBzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICdfYURhdGEnICk7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5jYWNoZSgpJywgJ3JvdygpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdHZhciByID0gc2V0dGluZ3MuYW9EYXRhWyByb3cgXTtcblx0XHRyZXR1cm4gdHlwZSA9PT0gJ3NlYXJjaCcgPyByLl9hRmlsdGVyRGF0YSA6IHIuX2FTb3J0RGF0YTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLmludmFsaWRhdGUoKScsICdyb3coKS5pbnZhbGlkYXRlKCknLCBmdW5jdGlvbiAoIHNyYyApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0X2ZuSW52YWxpZGF0ZSggc2V0dGluZ3MsIHJvdywgc3JjICk7XG5cdH0gKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5pbmRleGVzKCknLCAncm93KCkuaW5kZXgoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0cmV0dXJuIHJvdztcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLmlkcygpJywgJ3JvdygpLmlkKCknLCBmdW5jdGlvbiAoIGhhc2ggKSB7XG5cdHZhciBhID0gW107XG5cdHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG5cdC8vIGBpdGVyYXRvcmAgd2lsbCBkcm9wIHVuZGVmaW5lZCB2YWx1ZXMsIGJ1dCBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0aGVtXG5cdGZvciAoIHZhciBpPTAsIGllbj1jb250ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdGZvciAoIHZhciBqPTAsIGplbj10aGlzW2ldLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0dmFyIGlkID0gY29udGV4dFtpXS5yb3dJZEZuKCBjb250ZXh0W2ldLmFvRGF0YVsgdGhpc1tpXVtqXSBdLl9hRGF0YSApO1xuXHRcdFx0YS5wdXNoKCAoaGFzaCA9PT0gdHJ1ZSA/ICcjJyA6ICcnICkrIGlkICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ldyBfQXBpKCBjb250ZXh0LCBhICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkucmVtb3ZlKCknLCAncm93KCkucmVtb3ZlKCknLCBmdW5jdGlvbiAoKSB7XG5cdHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3cgKSB7XG5cdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdFx0dmFyIHJvd0RhdGEgPSBkYXRhWyByb3cgXTtcblxuXHRcdC8vIERlbGV0ZSBmcm9tIHRoZSBkaXNwbGF5IGFycmF5c1xuXHRcdHZhciBpZHggPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuaW5kZXhPZihyb3cpO1xuXHRcdGlmIChpZHggIT09IC0xKSB7XG5cdFx0XHRzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGFibGVzIC0gc3VidHJhY3QgdGhlIGRlbGV0ZWQgcm93IGZyb20gdGhlIGNvdW50XG5cdFx0aWYgKCBzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5ID4gMCApIHtcblx0XHRcdHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXktLTtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgYW4gJ292ZXJmbG93JyB0aGV5IGNhc2UgZm9yIGRpc3BsYXlpbmcgdGhlIHRhYmxlXG5cdFx0X2ZuTGVuZ3RoT3ZlcmZsb3coIHNldHRpbmdzICk7XG5cblx0XHQvLyBSZW1vdmUgdGhlIHJvdydzIElEIHJlZmVyZW5jZSBpZiB0aGVyZSBpcyBvbmVcblx0XHR2YXIgaWQgPSBzZXR0aW5ncy5yb3dJZEZuKCByb3dEYXRhLl9hRGF0YSApO1xuXHRcdGlmICggaWQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGRlbGV0ZSBzZXR0aW5ncy5hSWRzWyBpZCBdO1xuXHRcdH1cblxuXHRcdGRhdGFbcm93XSA9IG51bGw7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAncm93cy5hZGQoKScsIGZ1bmN0aW9uICggcm93cyApIHtcblx0dmFyIG5ld1Jvd3MgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0dmFyIHJvdywgaSwgaWVuO1xuXHRcdFx0dmFyIG91dCA9IFtdO1xuXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1yb3dzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRyb3cgPSByb3dzW2ldO1xuXG5cdFx0XHRcdGlmICggcm93Lm5vZGVOYW1lICYmIHJvdy5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnVFInICkge1xuXHRcdFx0XHRcdG91dC5wdXNoKCBfZm5BZGRUciggc2V0dGluZ3MsIHJvdyApWzBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXQ7XG5cdFx0fSwgMSApO1xuXG5cdC8vIFJldHVybiBhbiBBcGkucm93cygpIGV4dGVuZGVkIGluc3RhbmNlLCBzbyByb3dzKCkubm9kZXMoKSBldGMgY2FuIGJlIHVzZWRcblx0dmFyIG1vZFJvd3MgPSB0aGlzLnJvd3MoIC0xICk7XG5cdG1vZFJvd3MucG9wKCk7XG5cdF9mbkFycmF5QXBwbHkobW9kUm93cywgbmV3Um93cyk7XG5cblx0cmV0dXJuIG1vZFJvd3M7XG59ICk7XG5cblxuXG5cblxuLyoqXG4gKlxuICovXG5fYXBpX3JlZ2lzdGVyKCAncm93KCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLnJvd3MoIHNlbGVjdG9yLCBvcHRzICkgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAncm93KCkuZGF0YSgpJywgZnVuY3Rpb24gKCBkYXRhICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdC8vIEdldFxuXHRcdHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoICYmIHRoaXNbMF0ubGVuZ3RoID9cblx0XHRcdGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fYURhdGEgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2V0XG5cdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF07XG5cdHJvdy5fYURhdGEgPSBkYXRhO1xuXG5cdC8vIElmIHRoZSBET00gaGFzIGFuIGlkLCBhbmQgdGhlIGRhdGEgc291cmNlIGlzIGFuIGFycmF5XG5cdGlmICggQXJyYXkuaXNBcnJheSggZGF0YSApICYmIHJvdy5uVHIgJiYgcm93Lm5Uci5pZCApIHtcblx0XHRfZm5TZXRPYmplY3REYXRhRm4oIGN0eFswXS5yb3dJZCApKCBkYXRhLCByb3cublRyLmlkICk7XG5cdH1cblxuXHQvLyBBdXRvbWF0aWNhbGx5IGludmFsaWRhdGVcblx0X2ZuSW52YWxpZGF0ZSggY3R4WzBdLCB0aGlzWzBdLCAnZGF0YScgKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAncm93KCkubm9kZSgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdGlmIChjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoICYmIHRoaXNbMF0ubGVuZ3RoKSB7XG5cdFx0dmFyIHJvdyA9IGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXTtcblxuXHRcdGlmIChyb3cgJiYgcm93Lm5Ucikge1xuXHRcdFx0cmV0dXJuIHJvdy5uVHI7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3Jvdy5hZGQoKScsIGZ1bmN0aW9uICggcm93ICkge1xuXHQvLyBBbGxvdyBhIGpRdWVyeSBvYmplY3QgdG8gYmUgcGFzc2VkIGluIC0gb25seSBhIHNpbmdsZSByb3cgaXMgYWRkZWQgZnJvbVxuXHQvLyBpdCB0aG91Z2ggLSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG5cdGlmICggcm93IGluc3RhbmNlb2YgJCAmJiByb3cubGVuZ3RoICkge1xuXHRcdHJvdyA9IHJvd1swXTtcblx0fVxuXG5cdHZhciByb3dzID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRpZiAoIHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJyApIHtcblx0XHRcdHJldHVybiBfZm5BZGRUciggc2V0dGluZ3MsIHJvdyApWzBdO1xuXHRcdH1cblx0XHRyZXR1cm4gX2ZuQWRkRGF0YSggc2V0dGluZ3MsIHJvdyApO1xuXHR9ICk7XG5cblx0Ly8gUmV0dXJuIGFuIEFwaS5yb3dzKCkgZXh0ZW5kZWQgaW5zdGFuY2UsIHdpdGggdGhlIG5ld2x5IGFkZGVkIHJvdyBzZWxlY3RlZFxuXHRyZXR1cm4gdGhpcy5yb3coIHJvd3NbMF0gKTtcbn0gKTtcblxuXG4kKGRvY3VtZW50KS5vbigncGx1Z2luLWluaXQuZHQnLCBmdW5jdGlvbiAoZSwgY29udGV4dCkge1xuXHR2YXIgYXBpID0gbmV3IF9BcGkoIGNvbnRleHQgKTtcblxuXHRhcGkub24oICdzdGF0ZVNhdmVQYXJhbXMuRFQnLCBmdW5jdGlvbiAoIGUsIHNldHRpbmdzLCBkICkge1xuXHRcdC8vIFRoaXMgY291bGQgYmUgbW9yZSBjb21wYWN0IHdpdGggdGhlIEFQSSwgYnV0IGl0IGlzIGEgbG90IGZhc3RlciBhcyBhIHNpbXBsZVxuXHRcdC8vIGludGVybmFsIGxvb3Bcblx0XHR2YXIgaWRGbiA9IHNldHRpbmdzLnJvd0lkRm47XG5cdFx0dmFyIHJvd3MgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XG5cdFx0dmFyIGlkcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaT0wIDsgaTxyb3dzLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0dmFyIHJvd0lkeCA9IHJvd3NbaV07XG5cdFx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdO1xuXG5cdFx0XHRpZiAoZGF0YS5fZGV0YWlsc1Nob3cpIHtcblx0XHRcdFx0aWRzLnB1c2goICcjJyArIGlkRm4oZGF0YS5fYURhdGEpICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZC5jaGlsZFJvd3MgPSBpZHM7XG5cdH0pO1xuXG5cdC8vIEZvciBmdXR1cmUgc3RhdGUgbG9hZHMgKGUuZy4gd2l0aCBTdGF0ZVJlc3RvcmUpXG5cdGFwaS5vbiggJ3N0YXRlTG9hZGVkLkRUJywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBzdGF0ZSkge1xuXHRcdF9fZGV0YWlsc19zdGF0ZV9sb2FkKCBhcGksIHN0YXRlICk7XG5cdH0pO1xuXG5cdC8vIEFuZCB0aGUgaW5pdGlhbCBsb2FkIHN0YXRlXG5cdF9fZGV0YWlsc19zdGF0ZV9sb2FkKCBhcGksIGFwaS5zdGF0ZS5sb2FkZWQoKSApO1xufSk7XG5cbnZhciBfX2RldGFpbHNfc3RhdGVfbG9hZCA9IGZ1bmN0aW9uIChhcGksIHN0YXRlKVxue1xuXHRpZiAoIHN0YXRlICYmIHN0YXRlLmNoaWxkUm93cyApIHtcblx0XHRhcGlcblx0XHRcdC5yb3dzKCBzdGF0ZS5jaGlsZFJvd3MubWFwKGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0XHQvLyBFc2NhcGUgYW55IGA6YCBjaGFyYWN0ZXJzIGZyb20gdGhlIHJvdyBpZC4gQWNjb3VudHMgZm9yXG5cdFx0XHRcdC8vIGFscmVhZHkgZXNjYXBlZCBjaGFyYWN0ZXJzLlxuXHRcdFx0XHRyZXR1cm4gaWQucmVwbGFjZSgvKFteOlxcXFxdKig/OlxcXFwuW146XFxcXF0qKSopOi9nLCBcIiQxXFxcXDpcIik7XG5cdFx0XHR9KSApXG5cdFx0XHQuZXZlcnkoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBhcGkuc2V0dGluZ3MoKVswXSwgbnVsbCwgJ3JlcXVlc3RDaGlsZCcsIFsgdGhpcyBdIClcblx0XHRcdH0pO1xuXHR9XG59XG5cbnZhciBfX2RldGFpbHNfYWRkID0gZnVuY3Rpb24gKCBjdHgsIHJvdywgZGF0YSwga2xhc3MgKVxue1xuXHQvLyBDb252ZXJ0IHRvIGFycmF5IG9mIFRSIGVsZW1lbnRzXG5cdHZhciByb3dzID0gW107XG5cdHZhciBhZGRSb3cgPSBmdW5jdGlvbiAoIHIsIGsgKSB7XG5cdFx0Ly8gUmVjdXJzaW9uIHRvIGFsbG93IGZvciBhcnJheXMgb2YgalF1ZXJ5IG9iamVjdHNcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHIgKSB8fCByIGluc3RhbmNlb2YgJCApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1yLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRhZGRSb3coIHJbaV0sIGsgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgYSBUUiBlbGVtZW50LCB0aGVuIGp1c3QgYWRkIGl0IGRpcmVjdGx5IC0gdXAgdG8gdGhlIGRldlxuXHRcdC8vIHRvIGFkZCB0aGUgY29ycmVjdCBudW1iZXIgb2YgY29sdW1ucyBldGNcblx0XHRpZiAoIHIubm9kZU5hbWUgJiYgci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndHInICkge1xuXHRcdFx0ci5zZXRBdHRyaWJ1dGUoICdkYXRhLWR0LXJvdycsIHJvdy5pZHggKTtcblx0XHRcdHJvd3MucHVzaCggciApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIE90aGVyd2lzZSBjcmVhdGUgYSByb3cgd2l0aCBhIHdyYXBwZXJcblx0XHRcdHZhciBjcmVhdGVkID0gJCgnPHRyPjx0ZD48L3RkPjwvdHI+Jylcblx0XHRcdFx0LmF0dHIoICdkYXRhLWR0LXJvdycsIHJvdy5pZHggKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIGsgKTtcblx0XHRcdFxuXHRcdFx0JCgndGQnLCBjcmVhdGVkKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIGsgKVxuXHRcdFx0XHQuaHRtbCggciApWzBdLmNvbFNwYW4gPSBfZm5WaXNibGVDb2x1bW5zKCBjdHggKTtcblxuXHRcdFx0cm93cy5wdXNoKCBjcmVhdGVkWzBdICk7XG5cdFx0fVxuXHR9O1xuXG5cdGFkZFJvdyggZGF0YSwga2xhc3MgKTtcblxuXHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRyb3cuX2RldGFpbHMuZGV0YWNoKCk7XG5cdH1cblxuXHRyb3cuX2RldGFpbHMgPSAkKHJvd3MpO1xuXG5cdC8vIElmIHRoZSBjaGlsZHJlbiB3ZXJlIGFscmVhZHkgc2hvd24sIHRoYXQgc3RhdGUgc2hvdWxkIGJlIHJldGFpbmVkXG5cdGlmICggcm93Ll9kZXRhaWxzU2hvdyApIHtcblx0XHRyb3cuX2RldGFpbHMuaW5zZXJ0QWZ0ZXIoIHJvdy5uVHIgKTtcblx0fVxufTtcblxuXG4vLyBNYWtlIHN0YXRlIHNhdmluZyBvZiBjaGlsZCByb3cgZGV0YWlscyBhc3luYyB0byBhbGxvdyB0aGVtIHRvIGJlIGJhdGNoIHByb2Nlc3NlZFxudmFyIF9fZGV0YWlsc19zdGF0ZSA9IERhdGFUYWJsZS51dGlsLnRocm90dGxlKFxuXHRmdW5jdGlvbiAoY3R4KSB7XG5cdFx0X2ZuU2F2ZVN0YXRlKCBjdHhbMF0gKVxuXHR9LFxuXHQ1MDBcbik7XG5cblxudmFyIF9fZGV0YWlsc19yZW1vdmUgPSBmdW5jdGlvbiAoIGFwaSwgaWR4IClcbntcblx0dmFyIGN0eCA9IGFwaS5jb250ZXh0O1xuXG5cdGlmICggY3R4Lmxlbmd0aCApIHtcblx0XHR2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVsgaWR4ICE9PSB1bmRlZmluZWQgPyBpZHggOiBhcGlbMF0gXTtcblxuXHRcdGlmICggcm93ICYmIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdHJvdy5fZGV0YWlscy5yZW1vdmUoKTtcblxuXHRcdFx0cm93Ll9kZXRhaWxzU2hvdyA9IHVuZGVmaW5lZDtcblx0XHRcdHJvdy5fZGV0YWlscyA9IHVuZGVmaW5lZDtcblx0XHRcdCQoIHJvdy5uVHIgKS5yZW1vdmVDbGFzcyggJ2R0LWhhc0NoaWxkJyApO1xuXHRcdFx0X19kZXRhaWxzX3N0YXRlKCBjdHggKTtcblx0XHR9XG5cdH1cbn07XG5cblxudmFyIF9fZGV0YWlsc19kaXNwbGF5ID0gZnVuY3Rpb24gKCBhcGksIHNob3cgKSB7XG5cdHZhciBjdHggPSBhcGkuY29udGV4dDtcblxuXHRpZiAoIGN0eC5sZW5ndGggJiYgYXBpLmxlbmd0aCApIHtcblx0XHR2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVsgYXBpWzBdIF07XG5cblx0XHRpZiAoIHJvdy5fZGV0YWlscyApIHtcblx0XHRcdHJvdy5fZGV0YWlsc1Nob3cgPSBzaG93O1xuXG5cdFx0XHRpZiAoIHNob3cgKSB7XG5cdFx0XHRcdHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlciggcm93Lm5UciApO1xuXHRcdFx0XHQkKCByb3cublRyICkuYWRkQ2xhc3MoICdkdC1oYXNDaGlsZCcgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyb3cuX2RldGFpbHMuZGV0YWNoKCk7XG5cdFx0XHRcdCQoIHJvdy5uVHIgKS5yZW1vdmVDbGFzcyggJ2R0LWhhc0NoaWxkJyApO1xuXHRcdFx0fVxuXG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIGN0eFswXSwgbnVsbCwgJ2NoaWxkUm93JywgWyBzaG93LCBhcGkucm93KCBhcGlbMF0gKSBdIClcblxuXHRcdFx0X19kZXRhaWxzX2V2ZW50cyggY3R4WzBdICk7XG5cdFx0XHRfX2RldGFpbHNfc3RhdGUoIGN0eCApO1xuXHRcdH1cblx0fVxufTtcblxuXG52YXIgX19kZXRhaWxzX2V2ZW50cyA9IGZ1bmN0aW9uICggc2V0dGluZ3MgKVxue1xuXHR2YXIgYXBpID0gbmV3IF9BcGkoIHNldHRpbmdzICk7XG5cdHZhciBuYW1lc3BhY2UgPSAnLmR0LkRUX2RldGFpbHMnO1xuXHR2YXIgZHJhd0V2ZW50ID0gJ2RyYXcnK25hbWVzcGFjZTtcblx0dmFyIGNvbHZpc0V2ZW50ID0gJ2NvbHVtbi1zaXppbmcnK25hbWVzcGFjZTtcblx0dmFyIGRlc3Ryb3lFdmVudCA9ICdkZXN0cm95JytuYW1lc3BhY2U7XG5cdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXG5cdGFwaS5vZmYoIGRyYXdFdmVudCArJyAnKyBjb2x2aXNFdmVudCArJyAnKyBkZXN0cm95RXZlbnQgKTtcblxuXHRpZiAoIF9wbHVjayggZGF0YSwgJ19kZXRhaWxzJyApLmxlbmd0aCA+IDAgKSB7XG5cdFx0Ly8gT24gZWFjaCBkcmF3LCBpbnNlcnQgdGhlIHJlcXVpcmVkIGVsZW1lbnRzIGludG8gdGhlIGRvY3VtZW50XG5cdFx0YXBpLm9uKCBkcmF3RXZlbnQsIGZ1bmN0aW9uICggZSwgY3R4ICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGFwaS5yb3dzKCB7cGFnZTonY3VycmVudCd9ICkuZXEoMCkuZWFjaCggZnVuY3Rpb24gKGlkeCkge1xuXHRcdFx0XHQvLyBJbnRlcm5hbCBkYXRhIGdyYWJcblx0XHRcdFx0dmFyIHJvdyA9IGRhdGFbIGlkeCBdO1xuXG5cdFx0XHRcdGlmICggcm93Ll9kZXRhaWxzU2hvdyApIHtcblx0XHRcdFx0XHRyb3cuX2RldGFpbHMuaW5zZXJ0QWZ0ZXIoIHJvdy5uVHIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblxuXHRcdC8vIENvbHVtbiB2aXNpYmlsaXR5IGNoYW5nZSAtIHVwZGF0ZSB0aGUgY29sc3BhblxuXHRcdGFwaS5vbiggY29sdmlzRXZlbnQsIGZ1bmN0aW9uICggZSwgY3R4ICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFVwZGF0ZSB0aGUgY29sc3BhbiBmb3IgdGhlIGRldGFpbHMgcm93cyAobm90ZSwgb25seSBpZiBpdCBhbHJlYWR5IGhhc1xuXHRcdFx0Ly8gYSBjb2xzcGFuKVxuXHRcdFx0dmFyIHJvdywgdmlzaWJsZSA9IF9mblZpc2JsZUNvbHVtbnMoIGN0eCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0cm93ID0gZGF0YVtpXTtcblxuXHRcdFx0XHRpZiAoIHJvdyAmJiByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRcdFx0cm93Ll9kZXRhaWxzLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dmFyIGVsID0gJCh0aGlzKS5jaGlsZHJlbigndGQnKTtcblxuXHRcdFx0XHRcdFx0aWYgKGVsLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRcdFx0XHRcdGVsLmF0dHIoJ2NvbHNwYW4nLCB2aXNpYmxlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdC8vIFRhYmxlIGRlc3Ryb3llZCAtIG51a2UgYW55IGNoaWxkIHJvd3Ncblx0XHRhcGkub24oIGRlc3Ryb3lFdmVudCwgZnVuY3Rpb24gKCBlLCBjdHggKSB7XG5cdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggZGF0YVtpXSAmJiBkYXRhW2ldLl9kZXRhaWxzICkge1xuXHRcdFx0XHRcdF9fZGV0YWlsc19yZW1vdmUoIGFwaSwgaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59O1xuXG4vLyBTdHJpbmdzIGZvciB0aGUgbWV0aG9kIG5hbWVzIHRvIGhlbHAgbWluaWZpY2F0aW9uXG52YXIgX2VtcCA9ICcnO1xudmFyIF9jaGlsZF9vYmogPSBfZW1wKydyb3coKS5jaGlsZCc7XG52YXIgX2NoaWxkX210aCA9IF9jaGlsZF9vYmorJygpJztcblxuLy8gZGF0YSBjYW4gYmU6XG4vLyAgdHJcbi8vICBzdHJpbmdcbi8vICBqUXVlcnkgb3IgYXJyYXkgb2YgYW55IG9mIHRoZSBhYm92ZVxuX2FwaV9yZWdpc3RlciggX2NoaWxkX210aCwgZnVuY3Rpb24gKCBkYXRhLCBrbGFzcyApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBnZXRcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCAmJiBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF1cblx0XHRcdD8gY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9kZXRhaWxzXG5cdFx0XHQ6IHVuZGVmaW5lZDtcblx0fVxuXHRlbHNlIGlmICggZGF0YSA9PT0gdHJ1ZSApIHtcblx0XHQvLyBzaG93XG5cdFx0dGhpcy5jaGlsZC5zaG93KCk7XG5cdH1cblx0ZWxzZSBpZiAoIGRhdGEgPT09IGZhbHNlICkge1xuXHRcdC8vIHJlbW92ZVxuXHRcdF9fZGV0YWlsc19yZW1vdmUoIHRoaXMgKTtcblx0fVxuXHRlbHNlIGlmICggY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCApIHtcblx0XHQvLyBzZXRcblx0XHRfX2RldGFpbHNfYWRkKCBjdHhbMF0sIGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXSwgZGF0YSwga2xhc3MgKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoIFtcblx0X2NoaWxkX29iaisnLnNob3coKScsXG5cdF9jaGlsZF9tdGgrJy5zaG93KCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcbl0sIGZ1bmN0aW9uICgpIHsgICAgICAgICAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCBhbmQgdGhpcyBtZXRob2QgaXMgbm90IGV4ZWN1dGVkKVxuXHRfX2RldGFpbHNfZGlzcGxheSggdGhpcywgdHJ1ZSApO1xuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCBbXG5cdF9jaGlsZF9vYmorJy5oaWRlKCknLFxuXHRfY2hpbGRfbXRoKycuaGlkZSgpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XG5dLCBmdW5jdGlvbiAoKSB7ICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0X19kZXRhaWxzX2Rpc3BsYXkoIHRoaXMsIGZhbHNlICk7XG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoIFtcblx0X2NoaWxkX29iaisnLnJlbW92ZSgpJyxcblx0X2NoaWxkX210aCsnLnJlbW92ZSgpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XG5dLCBmdW5jdGlvbiAoKSB7ICAgICAgICAgICAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCBhbmQgdGhpcyBtZXRob2QgaXMgbm90IGV4ZWN1dGVkKVxuXHRfX2RldGFpbHNfcmVtb3ZlKCB0aGlzICk7XG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoIF9jaGlsZF9vYmorJy5pc1Nob3duKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoICYmIGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXSApIHtcblx0XHQvLyBfZGV0YWlsc1Nob3duIGFzIGZhbHNlIG9yIHVuZGVmaW5lZCB3aWxsIGZhbGwgdGhyb3VnaCB0byByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdLl9kZXRhaWxzU2hvdyB8fCBmYWxzZTtcblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59ICk7XG5cblxuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIENvbHVtbnNcbiAqXG4gKiB7aW50ZWdlcn0gICAgICAgICAgIC0gY29sdW1uIGluZGV4ICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxuICogXCJ7aW50ZWdlcn06dmlzSWR4XCIgIC0gdmlzaWJsZSBjb2x1bW4gaW5kZXggKGkuZS4gdHJhbnNsYXRlIHRvIGNvbHVtbiBpbmRleCkgICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxuICogXCJ7aW50ZWdlcn06dmlzaWJsZVwiIC0gYWxpYXMgZm9yIHtpbnRlZ2VyfTp2aXNJZHggICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxuICogXCJ7c3RyaW5nfTpuYW1lXCIgICAgIC0gY29sdW1uIG5hbWVcbiAqIFwie3N0cmluZ31cIiAgICAgICAgICAtIGpRdWVyeSBzZWxlY3RvciBvbiBjb2x1bW4gaGVhZGVyIG5vZGVzXG4gKlxuICovXG5cbi8vIGNhbiBiZSBhbiBhcnJheSBvZiB0aGVzZSBpdGVtcywgY29tbWEgc2VwYXJhdGVkIGxpc3QsIG9yIGFuIGFycmF5IG9mIGNvbW1hXG4vLyBzZXBhcmF0ZWQgbGlzdHNcblxudmFyIF9fcmVfY29sdW1uX3NlbGVjdG9yID0gL14oW146XSspPzoobmFtZXx0aXRsZXx2aXNJZHh8dmlzaWJsZSkkLztcblxuXG4vLyByMSBhbmQgcjIgYXJlIHJlZHVuZGFudCAtIGJ1dCBpdCBtZWFucyB0aGF0IHRoZSBwYXJhbWV0ZXJzIG1hdGNoIGZvciB0aGVcbi8vIGl0ZXJhdG9yIGNhbGxiYWNrIGluIGNvbHVtbnMoKS5kYXRhKClcbnZhciBfX2NvbHVtbkRhdGEgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIHIxLCByMiwgcm93cywgdHlwZSApIHtcblx0dmFyIGEgPSBbXTtcblx0Zm9yICggdmFyIHJvdz0wLCBpZW49cm93cy5sZW5ndGggOyByb3c8aWVuIDsgcm93KysgKSB7XG5cdFx0YS5wdXNoKCBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd3Nbcm93XSwgY29sdW1uLCB0eXBlICkgKTtcblx0fVxuXHRyZXR1cm4gYTtcbn07XG5cblxudmFyIF9fY29sdW1uX2hlYWRlciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgcm93ICkge1xuXHR2YXIgaGVhZGVyID0gc2V0dGluZ3MuYW9IZWFkZXI7XG5cdHZhciB0aXRsZVJvdyA9IHNldHRpbmdzLnRpdGxlUm93O1xuXHR2YXIgdGFyZ2V0ID0gbnVsbDtcblxuXHRpZiAocm93ICE9PSB1bmRlZmluZWQpIHtcblx0XHR0YXJnZXQgPSByb3c7XG5cdH1cblx0ZWxzZSBpZiAodGl0bGVSb3cgPT09IHRydWUpIHsgLy8gbGVnYWN5IG9yZGVyQ2VsbHNUb3Agc3VwcG9ydFxuXHRcdHRhcmdldCA9IDA7XG5cdH1cblx0ZWxzZSBpZiAodGl0bGVSb3cgPT09IGZhbHNlKSB7XG5cdFx0dGFyZ2V0ID0gaGVhZGVyLmxlbmd0aCAtIDE7XG5cdH1cblx0ZWxzZSBpZiAodGl0bGVSb3cgIT09IG51bGwpIHtcblx0XHR0YXJnZXQgPSB0aXRsZVJvdztcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBBdXRvbWF0aWMgLSBmaW5kIHRoZSBfbGFzdF8gdW5pcXVlIGNlbGwgZnJvbSB0aGUgdG9wIHRoYXQgaXMgbm90IGVtcHR5IChsYXN0IGZvclxuXHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuXHRcdGZvciAodmFyIGk9MCA7IGk8aGVhZGVyLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0aWYgKGhlYWRlcltpXVtjb2x1bW5dLnVuaXF1ZSAmJiAkKCdzcGFuLmR0LWNvbHVtbi10aXRsZScsIGhlYWRlcltpXVtjb2x1bW5dLmNlbGwpLnRleHQoKSkge1xuXHRcdFx0XHR0YXJnZXQgPSBpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0YXJnZXQgPT09IG51bGwpIHtcblx0XHRcdHRhcmdldCA9IDA7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGhlYWRlclt0YXJnZXRdW2NvbHVtbl0uY2VsbDtcbn07XG5cbnZhciBfX2NvbHVtbl9oZWFkZXJfY2VsbHMgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG5cdHZhciBvdXQgPSBbXTtcblxuXHRmb3IgKHZhciBpPTAgOyBpPGhlYWRlci5sZW5ndGggOyBpKyspIHtcblx0XHRmb3IgKHZhciBqPTAgOyBqPGhlYWRlcltpXS5sZW5ndGggOyBqKyspIHtcblx0XHRcdHZhciBjZWxsID0gaGVhZGVyW2ldW2pdLmNlbGw7XG5cblx0XHRcdGlmICghb3V0LmluY2x1ZGVzKGNlbGwpKSB7XG5cdFx0XHRcdG91dC5wdXNoKGNlbGwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59XG5cbnZhciBfX2NvbHVtbl9zZWxlY3RvciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzIClcbntcblx0dmFyXG5cdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRuYW1lcywgdGl0bGVzLFxuXHRcdG5vZGVzID0gX19jb2x1bW5faGVhZGVyX2NlbGxzKHNldHRpbmdzLmFvSGVhZGVyKTtcblx0XG5cdHZhciBydW4gPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0dmFyIHNlbEludCA9IF9pbnRWYWwoIHMgKTtcblxuXHRcdC8vIFNlbGVjdG9yIC0gYWxsXG5cdFx0aWYgKCBzID09PSAnJyApIHtcblx0XHRcdHJldHVybiBfcmFuZ2UoIGNvbHVtbnMubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdGlmICggc2VsSW50ICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIFsgc2VsSW50ID49IDAgP1xuXHRcdFx0XHRzZWxJbnQgOiAvLyBDb3VudCBmcm9tIGxlZnRcblx0XHRcdFx0Y29sdW1ucy5sZW5ndGggKyBzZWxJbnQgLy8gQ291bnQgZnJvbSByaWdodCAoKyBiZWNhdXNlIGl0cyBhIG5lZ2F0aXZlIHZhbHVlKVxuXHRcdFx0XTtcblx0XHR9XG5cblx0XHQvLyBTZWxlY3RvciA9IGZ1bmN0aW9uXG5cdFx0aWYgKCB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHZhciByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBzZXR0aW5ncywgb3B0cyApO1xuXG5cdFx0XHRyZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbCwgaWR4KSB7XG5cdFx0XHRcdHJldHVybiBzKFxuXHRcdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdFx0X19jb2x1bW5EYXRhKCBzZXR0aW5ncywgaWR4LCAwLCAwLCByb3dzICksXG5cdFx0XHRcdFx0XHRfX2NvbHVtbl9oZWFkZXIoIHNldHRpbmdzLCBpZHggKVxuXHRcdFx0XHRcdCkgPyBpZHggOiBudWxsO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8galF1ZXJ5IG9yIHN0cmluZyBzZWxlY3RvclxuXHRcdHZhciBtYXRjaCA9IHR5cGVvZiBzID09PSAnc3RyaW5nJyA/XG5cdFx0XHRzLm1hdGNoKCBfX3JlX2NvbHVtbl9zZWxlY3RvciApIDpcblx0XHRcdCcnO1xuXG5cdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdHN3aXRjaCggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdGNhc2UgJ3Zpc0lkeCc6XG5cdFx0XHRcdGNhc2UgJ3Zpc2libGUnOlxuXHRcdFx0XHRcdC8vIFNlbGVjdG9yIGlzIGEgY29sdW1uIGluZGV4XG5cdFx0XHRcdFx0aWYgKG1hdGNoWzFdICYmIG1hdGNoWzFdLm1hdGNoKC9eXFxkKyQvKSkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCA9IHBhcnNlSW50KCBtYXRjaFsxXSwgMTAgKTtcblxuXHRcdFx0XHRcdFx0Ly8gVmlzaWJsZSBpbmRleCBnaXZlbiwgY29udmVydCB0byBjb2x1bW4gaW5kZXhcblx0XHRcdFx0XHRcdGlmICggaWR4IDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ291bnRpbmcgZnJvbSB0aGUgcmlnaHRcblx0XHRcdFx0XHRcdFx0dmFyIHZpc0NvbHVtbnMgPSBjb2x1bW5zLm1hcCggZnVuY3Rpb24gKGNvbCxpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbC5iVmlzaWJsZSA/IGkgOiBudWxsO1xuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIHZpc0NvbHVtbnNbIHZpc0NvbHVtbnMubGVuZ3RoICsgaWR4IF0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIENvdW50aW5nIGZyb20gdGhlIGxlZnRcblx0XHRcdFx0XHRcdHJldHVybiBbIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBzZXR0aW5ncywgaWR4ICkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0cmV0dXJuIGNvbHVtbnMubWFwKCBmdW5jdGlvbiAoY29sLCBpZHgpIHtcblx0XHRcdFx0XHRcdC8vIE5vdCB2aXNpYmxlLCBjYW4ndCBtYXRjaFxuXHRcdFx0XHRcdFx0aWYgKCEgY29sLmJWaXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBTZWxlY3RvclxuXHRcdFx0XHRcdFx0aWYgKG1hdGNoWzFdKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAkKG5vZGVzW2lkeF0pLmZpbHRlcihtYXRjaFsxXSkubGVuZ3RoID4gMCA/IGlkeCA6IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGA6dmlzaWJsZWAgb24gaXRzIG93blxuXHRcdFx0XHRcdFx0cmV0dXJuIGlkeDtcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Y2FzZSAnbmFtZSc6XG5cdFx0XHRcdFx0Ly8gRG9uJ3QgZ2V0IG5hbWVzLCB1bmxlc3MgbmVlZGVkLCBhbmQgb25seSBnZXQgb25jZSBpZiBpdCBpc1xuXHRcdFx0XHRcdGlmICghbmFtZXMpIHtcblx0XHRcdFx0XHRcdG5hbWVzID0gX3BsdWNrKCBjb2x1bW5zLCAnc05hbWUnICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gbWF0Y2ggYnkgbmFtZS4gYG5hbWVzYCBpcyBjb2x1bW4gaW5kZXggY29tcGxldGUgYW5kIGluIG9yZGVyXG5cdFx0XHRcdFx0cmV0dXJuIG5hbWVzLm1hcCggZnVuY3Rpb24gKG5hbWUsIGkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBuYW1lID09PSBtYXRjaFsxXSA/IGkgOiBudWxsO1xuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRjYXNlICd0aXRsZSc6XG5cdFx0XHRcdFx0aWYgKCF0aXRsZXMpIHtcblx0XHRcdFx0XHRcdHRpdGxlcyA9IF9wbHVjayggY29sdW1ucywgJ3NUaXRsZScgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBtYXRjaCBieSBjb2x1bW4gdGl0bGVcblx0XHRcdFx0XHRyZXR1cm4gdGl0bGVzLm1hcCggZnVuY3Rpb24gKHRpdGxlLCBpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGl0bGUgPT09IG1hdGNoWzFdID8gaSA6IG51bGw7XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENlbGwgaW4gdGhlIHRhYmxlIGJvZHlcblx0XHRpZiAoIHMubm9kZU5hbWUgJiYgcy5fRFRfQ2VsbEluZGV4ICkge1xuXHRcdFx0cmV0dXJuIFsgcy5fRFRfQ2VsbEluZGV4LmNvbHVtbiBdO1xuXHRcdH1cblxuXHRcdC8vIGpRdWVyeSBzZWxlY3RvciBvbiB0aGUgVEggZWxlbWVudHMgZm9yIHRoZSBjb2x1bW5zXG5cdFx0dmFyIGpxUmVzdWx0ID0gJCggbm9kZXMgKVxuXHRcdFx0LmZpbHRlciggcyApXG5cdFx0XHQubWFwKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBfZm5Db2x1bW5zRnJvbUhlYWRlciggdGhpcyApOyAvLyBgbm9kZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcblx0XHRcdH0gKVxuXHRcdFx0LnRvQXJyYXkoKVxuXHRcdFx0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdFx0fSk7XG5cblx0XHRpZiAoIGpxUmVzdWx0Lmxlbmd0aCB8fCAhIHMubm9kZU5hbWUgKSB7XG5cdFx0XHRyZXR1cm4ganFSZXN1bHQ7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIGEgbm9kZSB3aGljaCBtaWdodCBoYXZlIGEgYGR0LWNvbHVtbmAgZGF0YSBhdHRyaWJ1dGUsIG9yIGJlXG5cdFx0Ly8gYSBjaGlsZCBvciBzdWNoIGFuIGVsZW1lbnRcblx0XHR2YXIgaG9zdCA9ICQocykuY2xvc2VzdCgnKltkYXRhLWR0LWNvbHVtbl0nKTtcblx0XHRyZXR1cm4gaG9zdC5sZW5ndGggP1xuXHRcdFx0WyBob3N0LmRhdGEoJ2R0LWNvbHVtbicpIF0gOlxuXHRcdFx0W107XG5cdH07XG5cblx0dmFyIHNlbGVjdGVkID0gX3NlbGVjdG9yX3J1biggJ2NvbHVtbicsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG5cblx0cmV0dXJuIG9wdHMuY29sdW1uT3JkZXIgJiYgb3B0cy5jb2x1bW5PcmRlciA9PT0gJ2luZGV4J1xuXHRcdD8gc2VsZWN0ZWQuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pXG5cdFx0OiBzZWxlY3RlZDsgLy8gaW1wbGllZFxufTtcblxuXG52YXIgX19zZXRDb2x1bW5WaXMgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIHZpcyApIHtcblx0dmFyXG5cdFx0Y29scyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRjb2wgID0gY29sc1sgY29sdW1uIF0sXG5cdFx0ZGF0YSA9IHNldHRpbmdzLmFvRGF0YSxcblx0XHRjZWxscywgaSwgaWVuLCB0cjtcblxuXHQvLyBHZXRcblx0aWYgKCB2aXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gY29sLmJWaXNpYmxlO1xuXHR9XG5cblx0Ly8gU2V0XG5cdC8vIE5vIGNoYW5nZVxuXHRpZiAoIGNvbC5iVmlzaWJsZSA9PT0gdmlzICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggdmlzICkge1xuXHRcdC8vIEluc2VydCBjb2x1bW5cblx0XHQvLyBOZWVkIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgdXNlIGFwcGVuZENoaWxkIG9yIGluc2VydEJlZm9yZVxuXHRcdHZhciBpbnNlcnRCZWZvcmUgPSBfcGx1Y2soY29scywgJ2JWaXNpYmxlJykuaW5kZXhPZih0cnVlLCBjb2x1bW4rMSk7XG5cblx0XHRmb3IgKCBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKGRhdGFbaV0pIHtcblx0XHRcdFx0dHIgPSBkYXRhW2ldLm5Ucjtcblx0XHRcdFx0Y2VsbHMgPSBkYXRhW2ldLmFuQ2VsbHM7XG5cblx0XHRcdFx0aWYgKCB0ciApIHtcblx0XHRcdFx0XHQvLyBpbnNlcnRCZWZvcmUgY2FuIGFjdCBsaWtlIGFwcGVuZENoaWxkIGlmIDJuZCBhcmcgaXMgbnVsbFxuXHRcdFx0XHRcdHRyLmluc2VydEJlZm9yZSggY2VsbHNbIGNvbHVtbiBdLCBjZWxsc1sgaW5zZXJ0QmVmb3JlIF0gfHwgbnVsbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIFJlbW92ZSBjb2x1bW5cblx0XHQkKCBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ2FuQ2VsbHMnLCBjb2x1bW4gKSApLmRldGFjaCgpO1xuXHR9XG5cblx0Ly8gQ29tbW9uIGFjdGlvbnNcblx0Y29sLmJWaXNpYmxlID0gdmlzO1xuXG5cdF9jb2xHcm91cChzZXR0aW5ncyk7XG5cdFxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cblxuX2FwaV9yZWdpc3RlciggJ2NvbHVtbnMoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdC8vIGFyZ3VtZW50IHNoaWZ0aW5nXG5cdGlmICggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzZWxlY3RvciA9ICcnO1xuXHR9XG5cdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIHNlbGVjdG9yICkgKSB7XG5cdFx0b3B0cyA9IHNlbGVjdG9yO1xuXHRcdHNlbGVjdG9yID0gJyc7XG5cdH1cblxuXHRvcHRzID0gX3NlbGVjdG9yX29wdHMoIG9wdHMgKTtcblxuXHR2YXIgaW5zdCA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIF9fY29sdW1uX3NlbGVjdG9yKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKTtcblx0fSwgMSApO1xuXG5cdC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX3Jvd19zZWxlY3Rvcj9cblx0aW5zdC5zZWxlY3Rvci5jb2xzID0gc2VsZWN0b3I7XG5cdGluc3Quc2VsZWN0b3Iub3B0cyA9IG9wdHM7XG5cblx0cmV0dXJuIGluc3Q7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuaGVhZGVyKCknLCAnY29sdW1uKCkuaGVhZGVyKCknLCBmdW5jdGlvbiAoIHJvdyApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xuXHRcdHJldHVybiBfX2NvbHVtbl9oZWFkZXIoc2V0dGluZ3MsIGNvbHVtbiwgcm93KTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmZvb3RlcigpJywgJ2NvbHVtbigpLmZvb3RlcigpJywgZnVuY3Rpb24gKCByb3cgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdHZhciBmb290ZXIgPSBzZXR0aW5ncy5hb0Zvb3RlcjtcblxuXHRcdGlmICghIGZvb3Rlci5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZXR0aW5ncy5hb0Zvb3Rlcltyb3cgIT09IHVuZGVmaW5lZCA/IHJvdyA6IDBdW2NvbHVtbl0uY2VsbDtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmRhdGEoKScsICdjb2x1bW4oKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBfX2NvbHVtbkRhdGEsIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5yZW5kZXIoKScsICdjb2x1bW4oKS5yZW5kZXIoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4tcm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiwgaSwgaiwgcm93cyApIHtcblx0XHRyZXR1cm4gX19jb2x1bW5EYXRhKCBzZXR0aW5ncywgY29sdW1uLCBpLCBqLCByb3dzLCB0eXBlICk7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5kYXRhU3JjKCknLCAnY29sdW1uKCkuZGF0YVNyYygpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ubURhdGE7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5jYWNoZSgpJywgJ2NvbHVtbigpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MgKSB7XG5cdFx0cmV0dXJuIF9wbHVja19vcmRlciggc2V0dGluZ3MuYW9EYXRhLCByb3dzLFxuXHRcdFx0dHlwZSA9PT0gJ3NlYXJjaCcgPyAnX2FGaWx0ZXJEYXRhJyA6ICdfYVNvcnREYXRhJywgY29sdW1uXG5cdFx0KTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmluaXQoKScsICdjb2x1bW4oKS5pbml0KCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1uXTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLm5hbWVzKCknLCAnY29sdW1uKCkubmFtZSgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0uc05hbWU7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5ub2RlcygpJywgJ2NvbHVtbigpLm5vZGVzKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MgKSB7XG5cdFx0cmV0dXJuIF9wbHVja19vcmRlciggc2V0dGluZ3MuYW9EYXRhLCByb3dzLCAnYW5DZWxscycsIGNvbHVtbiApIDtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnRpdGxlcygpJywgJ2NvbHVtbigpLnRpdGxlKCknLCBmdW5jdGlvbiAodGl0bGUsIHJvdykge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHQvLyBBcmd1bWVudCBzaGlmdGluZ1xuXHRcdGlmICh0eXBlb2YgdGl0bGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRyb3cgPSB0aXRsZTtcblx0XHRcdHRpdGxlID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdHZhciBzcGFuID0gJCgnc3Bhbi5kdC1jb2x1bW4tdGl0bGUnLCB0aGlzLmNvbHVtbihjb2x1bW4pLmhlYWRlcihyb3cpKTtcblxuXHRcdGlmICh0aXRsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzcGFuLmh0bWwodGl0bGUpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNwYW4uaHRtbCgpO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkudHlwZXMoKScsICdjb2x1bW4oKS50eXBlKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdHZhciB0eXBlID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0uc1R5cGU7XG5cblx0XHQvLyBJZiB0aGUgdHlwZSB3YXMgaW52YWxpZGF0ZWQsIHRoZW4gcmVzb2x2ZSBpdC4gVGhpcyBhY3R1YWxseSBkb2VzXG5cdFx0Ly8gYWxsIGNvbHVtbnMgYXQgdGhlIG1vbWVudC4gV291bGQgb25seSBoYXBwZW4gb25jZSBpZiBnZXR0aW5nIGFsbFxuXHRcdC8vIGNvbHVtbidzIGRhdGEgdHlwZXMuXG5cdFx0aWYgKCEgdHlwZSkge1xuXHRcdFx0X2ZuQ29sdW1uVHlwZXMoc2V0dGluZ3MpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0eXBlO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkudmlzaWJsZSgpJywgJ2NvbHVtbigpLnZpc2libGUoKScsIGZ1bmN0aW9uICggdmlzLCBjYWxjICkge1xuXHR2YXIgdGhhdCA9IHRoaXM7XG5cdHZhciBjaGFuZ2VkID0gW107XG5cdHZhciByZXQgPSB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uICkge1xuXHRcdGlmICggdmlzID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2x1bW4gXS5iVmlzaWJsZTtcblx0XHR9IC8vIGVsc2Vcblx0XHRcblx0XHRpZiAoX19zZXRDb2x1bW5WaXMoIHNldHRpbmdzLCBjb2x1bW4sIHZpcyApKSB7XG5cdFx0XHRjaGFuZ2VkLnB1c2goY29sdW1uKTtcblx0XHR9XG5cdH0gKTtcblxuXHQvLyBHcm91cCB0aGUgY29sdW1uIHZpc2liaWxpdHkgY2hhbmdlc1xuXHRpZiAoIHZpcyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHQvLyBSZWRyYXcgdGhlIGhlYWRlciBhZnRlciBjaGFuZ2VzXG5cdFx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvSGVhZGVyICk7XG5cdFx0XHRfZm5EcmF3SGVhZCggc2V0dGluZ3MsIHNldHRpbmdzLmFvRm9vdGVyICk7XG5cdFxuXHRcdFx0Ly8gVXBkYXRlIGNvbHNwYW4gZm9yIG5vIHJlY29yZHMgZGlzcGxheS4gQ2hpbGQgcm93cyBhbmQgZXh0ZW5zaW9ucyB3aWxsIHVzZSB0aGVpciBvd25cblx0XHRcdC8vIGxpc3RlbmVycyB0byBkbyB0aGlzIC0gb25seSBuZWVkIHRvIHVwZGF0ZSB0aGUgZW1wdHkgdGFibGUgaXRlbSBoZXJlXG5cdFx0XHRpZiAoICEgc2V0dGluZ3MuYWlEaXNwbGF5Lmxlbmd0aCApIHtcblx0XHRcdFx0JChzZXR0aW5ncy5uVEJvZHkpLmZpbmQoJ3RkW2NvbHNwYW5dJykuYXR0cignY29sc3BhbicsIF9mblZpc2JsZUNvbHVtbnMoc2V0dGluZ3MpKTtcblx0XHRcdH1cblx0XG5cdFx0XHRfZm5TYXZlU3RhdGUoIHNldHRpbmdzICk7XG5cblx0XHRcdC8vIFNlY29uZCBsb29wIG9uY2UgdGhlIGZpcnN0IGlzIGRvbmUgZm9yIGV2ZW50c1xuXHRcdFx0dGhhdC5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdFx0aWYgKGNoYW5nZWQuaW5jbHVkZXMoY29sdW1uKSkge1xuXHRcdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdjb2x1bW4tdmlzaWJpbGl0eScsIFtzZXR0aW5ncywgY29sdW1uLCB2aXMsIGNhbGNdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdFx0aWYgKCBjaGFuZ2VkLmxlbmd0aCAmJiAoY2FsYyA9PT0gdW5kZWZpbmVkIHx8IGNhbGMpICkge1xuXHRcdFx0XHR0aGF0LmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLndpZHRocygpJywgJ2NvbHVtbigpLndpZHRoKCknLCBmdW5jdGlvbiAoKSB7XG5cdC8vIEluamVjdHMgYSBmYWtlIHJvdyBpbnRvIHRoZSB0YWJsZSBmb3IganVzdCBhIG1vbWVudCBzbyB0aGUgd2lkdGhzIGNhblxuXHQvLyBiZSByZWFkLCByZWdhcmRsZXNzIG9mIGNvbHNwYW4gaW4gdGhlIGhlYWRlciBhbmQgcm93cyBiZWluZyBwcmVzZW50IGluXG5cdC8vIHRoZSBib2R5XG5cdHZhciBjb2x1bW5zID0gdGhpcy5jb2x1bW5zKCc6dmlzaWJsZScpLmNvdW50KCk7XG5cdHZhciByb3cgPSAkKCc8dHI+JykuaHRtbCgnPHRkPicgKyBBcnJheShjb2x1bW5zKS5qb2luKCc8L3RkPjx0ZD4nKSArICc8L3RkPicpO1xuXG5cdCQodGhpcy50YWJsZSgpLmJvZHkoKSkuYXBwZW5kKHJvdyk7XG5cblx0dmFyIHdpZHRocyA9IHJvdy5jaGlsZHJlbigpLm1hcChmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICQodGhpcykub3V0ZXJXaWR0aCgpO1xuXHR9KTtcblxuXHRyb3cucmVtb3ZlKCk7XG5cdFxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHR2YXIgdmlzSWR4ID0gX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoIHNldHRpbmdzLCBjb2x1bW4gKTtcblxuXHRcdHJldHVybiB2aXNJZHggIT09IG51bGwgPyB3aWR0aHNbdmlzSWR4XSA6IDA7XG5cdH0sIDEpO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmluZGV4ZXMoKScsICdjb2x1bW4oKS5pbmRleCgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRyZXR1cm4gdHlwZSA9PT0gJ3Zpc2libGUnID9cblx0XHRcdF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sdW1uICkgOlxuXHRcdFx0Y29sdW1uO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXIoICdjb2x1bW5zLmFkanVzdCgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHQvLyBGb3JjZSBhIGNvbHVtbiBzaXppbmcgdG8gaGFwcGVuIHdpdGggYSBtYW51YWwgY2FsbCAtIG90aGVyd2lzZSBpdCBjYW4gc2tpcFxuXHRcdC8vIGlmIHRoZSBzaXplIGhhc24ndCBjaGFuZ2VkXG5cdFx0c2V0dGluZ3MuY29udGFpbmVyV2lkdGggPSAtMTtcblxuXHRcdF9mbkFkanVzdENvbHVtblNpemluZyggc2V0dGluZ3MgKTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyKCAnY29sdW1uLmluZGV4KCknLCBmdW5jdGlvbiAoIHR5cGUsIGlkeCApIHtcblx0aWYgKCB0aGlzLmNvbnRleHQubGVuZ3RoICE9PSAwICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cblx0XHRpZiAoIHR5cGUgPT09ICdmcm9tVmlzaWJsZScgfHwgdHlwZSA9PT0gJ3RvRGF0YScgKSB7XG5cdFx0XHRyZXR1cm4gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoIGN0eCwgaWR4ICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlID09PSAnZnJvbURhdGEnIHx8IHR5cGUgPT09ICd0b1Zpc2libGUnICkge1xuXHRcdFx0cmV0dXJuIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBjdHgsIGlkeCApO1xuXHRcdH1cblx0fVxufSApO1xuXG5fYXBpX3JlZ2lzdGVyKCAnY29sdW1uKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLmNvbHVtbnMoIHNlbGVjdG9yLCBvcHRzICkgKTtcbn0gKTtcblxudmFyIF9fY2VsbF9zZWxlY3RvciA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzIClcbntcblx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cdHZhciByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBzZXR0aW5ncywgb3B0cyApO1xuXHR2YXIgY2VsbHMgPSBfcmVtb3ZlRW1wdHkoIF9wbHVja19vcmRlciggZGF0YSwgcm93cywgJ2FuQ2VsbHMnICkgKTtcblx0dmFyIGFsbENlbGxzID0gJChfZmxhdHRlbiggW10sIGNlbGxzICkpO1xuXHR2YXIgcm93O1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XG5cdHZhciBhLCBpLCBpZW4sIGosIG8sIGhvc3Q7XG5cblx0dmFyIHJ1biA9IGZ1bmN0aW9uICggcyApIHtcblx0XHR2YXIgZm5TZWxlY3RvciA9IHR5cGVvZiBzID09PSAnZnVuY3Rpb24nO1xuXG5cdFx0aWYgKCBzID09PSBudWxsIHx8IHMgPT09IHVuZGVmaW5lZCB8fCBmblNlbGVjdG9yICkge1xuXHRcdFx0Ly8gQWxsIGNlbGxzIGFuZCBmdW5jdGlvbiBzZWxlY3RvcnNcblx0XHRcdGEgPSBbXTtcblxuXHRcdFx0Zm9yICggaT0wLCBpZW49cm93cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0cm93ID0gcm93c1tpXTtcblxuXHRcdFx0XHRmb3IgKCBqPTAgOyBqPGNvbHVtbnMgOyBqKysgKSB7XG5cdFx0XHRcdFx0byA9IHtcblx0XHRcdFx0XHRcdHJvdzogcm93LFxuXHRcdFx0XHRcdFx0Y29sdW1uOiBqXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGlmICggZm5TZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdC8vIFNlbGVjdG9yIC0gZnVuY3Rpb25cblx0XHRcdFx0XHRcdGhvc3QgPSBkYXRhWyByb3cgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBzKCBvLCBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgcm93LCBqKSwgaG9zdC5hbkNlbGxzID8gaG9zdC5hbkNlbGxzW2pdIDogbnVsbCApICkge1xuXHRcdFx0XHRcdFx0XHRhLnB1c2goIG8gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBTZWxlY3RvciAtIGFsbFxuXHRcdFx0XHRcdFx0YS5wdXNoKCBvICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhO1xuXHRcdH1cblx0XHRcblx0XHQvLyBTZWxlY3RvciAtIGluZGV4XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHMgKSApIHtcblx0XHRcdC8vIFZhbGlkIGNlbGwgaW5kZXggYW5kIGl0cyBpbiB0aGUgYXJyYXkgb2Ygc2VsZWN0YWJsZSByb3dzXG5cdFx0XHRyZXR1cm4gcy5jb2x1bW4gIT09IHVuZGVmaW5lZCAmJiBzLnJvdyAhPT0gdW5kZWZpbmVkICYmIHJvd3MuaW5kZXhPZihzLnJvdykgIT09IC0xID9cblx0XHRcdFx0W3NdIDpcblx0XHRcdFx0W107XG5cdFx0fVxuXG5cdFx0Ly8gU2VsZWN0b3IgLSBqUXVlcnkgZmlsdGVyZWQgY2VsbHNcblx0XHR2YXIganFSZXN1bHQgPSBhbGxDZWxsc1xuXHRcdFx0LmZpbHRlciggcyApXG5cdFx0XHQubWFwKCBmdW5jdGlvbiAoaSwgZWwpIHtcblx0XHRcdFx0cmV0dXJuIHsgLy8gdXNlIGEgbmV3IG9iamVjdCwgaW4gY2FzZSBzb21lb25lIGNoYW5nZXMgdGhlIHZhbHVlc1xuXHRcdFx0XHRcdHJvdzogICAgZWwuX0RUX0NlbGxJbmRleC5yb3csXG5cdFx0XHRcdFx0Y29sdW1uOiBlbC5fRFRfQ2VsbEluZGV4LmNvbHVtblxuXHRcdFx0XHR9O1xuXHRcdFx0fSApXG5cdFx0XHQudG9BcnJheSgpO1xuXG5cdFx0aWYgKCBqcVJlc3VsdC5sZW5ndGggfHwgISBzLm5vZGVOYW1lICkge1xuXHRcdFx0cmV0dXJuIGpxUmVzdWx0O1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB0aGUgc2VsZWN0b3IgaXMgYSBub2RlLCBhbmQgdGhlcmUgaXMgb25lIGxhc3Qgb3B0aW9uIC0gdGhlXG5cdFx0Ly8gZWxlbWVudCBtaWdodCBiZSBhIGNoaWxkIG9mIGFuIGVsZW1lbnQgd2hpY2ggaGFzIGR0LXJvdyBhbmQgZHQtY29sdW1uXG5cdFx0Ly8gZGF0YSBhdHRyaWJ1dGVzXG5cdFx0aG9zdCA9ICQocykuY2xvc2VzdCgnKltkYXRhLWR0LXJvd10nKTtcblx0XHRyZXR1cm4gaG9zdC5sZW5ndGggP1xuXHRcdFx0WyB7XG5cdFx0XHRcdHJvdzogaG9zdC5kYXRhKCdkdC1yb3cnKSxcblx0XHRcdFx0Y29sdW1uOiBob3N0LmRhdGEoJ2R0LWNvbHVtbicpXG5cdFx0XHR9IF0gOlxuXHRcdFx0W107XG5cdH07XG5cblx0cmV0dXJuIF9zZWxlY3Rvcl9ydW4oICdjZWxsJywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMgKTtcbn07XG5cblxuXG5cbl9hcGlfcmVnaXN0ZXIoICdjZWxscygpJywgZnVuY3Rpb24gKCByb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMgKSB7XG5cdC8vIEFyZ3VtZW50IHNoaWZ0aW5nXG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCByb3dTZWxlY3RvciApICkge1xuXHRcdC8vIEluZGV4ZXNcblx0XHRpZiAoIHJvd1NlbGVjdG9yLnJvdyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gU2VsZWN0b3Igb3B0aW9ucyBpbiBmaXJzdCBwYXJhbWV0ZXJcblx0XHRcdG9wdHMgPSByb3dTZWxlY3Rvcjtcblx0XHRcdHJvd1NlbGVjdG9yID0gbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBDZWxsIGluZGV4IG9iamVjdHMgaW4gZmlyc3QgcGFyYW1ldGVyXG5cdFx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0XHRjb2x1bW5TZWxlY3RvciA9IG51bGw7XG5cdFx0fVxuXHR9XG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCBjb2x1bW5TZWxlY3RvciApICkge1xuXHRcdG9wdHMgPSBjb2x1bW5TZWxlY3Rvcjtcblx0XHRjb2x1bW5TZWxlY3RvciA9IG51bGw7XG5cdH1cblxuXHQvLyBDZWxsIHNlbGVjdG9yXG5cdGlmICggY29sdW1uU2VsZWN0b3IgPT09IG51bGwgfHwgY29sdW1uU2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHJldHVybiBfX2NlbGxfc2VsZWN0b3IoIHNldHRpbmdzLCByb3dTZWxlY3RvciwgX3NlbGVjdG9yX29wdHMoIG9wdHMgKSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFRoZSBkZWZhdWx0IGJ1aWx0IGluIG9wdGlvbnMgbmVlZCB0byBhcHBseSB0byByb3cgYW5kIGNvbHVtbnNcblx0dmFyIGludGVybmFsT3B0cyA9IG9wdHMgPyB7XG5cdFx0cGFnZTogb3B0cy5wYWdlLFxuXHRcdG9yZGVyOiBvcHRzLm9yZGVyLFxuXHRcdHNlYXJjaDogb3B0cy5zZWFyY2hcblx0fSA6IHt9O1xuXG5cdC8vIFJvdyArIGNvbHVtbiBzZWxlY3RvclxuXHR2YXIgY29sdW1ucyA9IHRoaXMuY29sdW1ucyggY29sdW1uU2VsZWN0b3IsIGludGVybmFsT3B0cyApO1xuXHR2YXIgcm93cyA9IHRoaXMucm93cyggcm93U2VsZWN0b3IsIGludGVybmFsT3B0cyApO1xuXHR2YXIgaSwgaWVuLCBqLCBqZW47XG5cblx0dmFyIGNlbGxzTm9PcHRzID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgaWR4ICkge1xuXHRcdHZhciBhID0gW107XG5cblx0XHRmb3IgKCBpPTAsIGllbj1yb3dzW2lkeF0ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRmb3IgKCBqPTAsIGplbj1jb2x1bW5zW2lkeF0ubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdGEucHVzaCgge1xuXHRcdFx0XHRcdHJvdzogICAgcm93c1tpZHhdW2ldLFxuXHRcdFx0XHRcdGNvbHVtbjogY29sdW1uc1tpZHhdW2pdXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gYTtcblx0fSwgMSApO1xuXG5cdC8vIFRoZXJlIGlzIGN1cnJlbnRseSBvbmx5IG9uZSBleHRlbnNpb24gd2hpY2ggdXNlcyBhIGNlbGwgc2VsZWN0b3IgZXh0ZW5zaW9uXG5cdC8vIEl0IGlzIGEgX21ham9yXyBwZXJmb3JtYW5jZSBkcmFnIHRvIHJ1biB0aGlzIGlmIGl0IGlzbid0IG5lZWRlZCwgc28gdGhpcyBpc1xuXHQvLyBhbiBleHRlbnNpb24gc3BlY2lmaWMgY2hlY2sgYXQgdGhlIG1vbWVudFxuXHR2YXIgY2VsbHMgPSBvcHRzICYmIG9wdHMuc2VsZWN0ZWQgP1xuXHRcdHRoaXMuY2VsbHMoIGNlbGxzTm9PcHRzLCBvcHRzICkgOlxuXHRcdGNlbGxzTm9PcHRzO1xuXG5cdCQuZXh0ZW5kKCBjZWxscy5zZWxlY3Rvciwge1xuXHRcdGNvbHM6IGNvbHVtblNlbGVjdG9yLFxuXHRcdHJvd3M6IHJvd1NlbGVjdG9yLFxuXHRcdG9wdHM6IG9wdHNcblx0fSApO1xuXG5cdHJldHVybiBjZWxscztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5ub2RlcygpJywgJ2NlbGwoKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhWyByb3cgXTtcblxuXHRcdHJldHVybiBkYXRhICYmIGRhdGEuYW5DZWxscyA/XG5cdFx0XHRkYXRhLmFuQ2VsbHNbIGNvbHVtbiBdIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdjZWxscygpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmNhY2hlKCknLCAnY2VsbCgpLmNhY2hlKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdHR5cGUgPSB0eXBlID09PSAnc2VhcmNoJyA/ICdfYUZpbHRlckRhdGEnIDogJ19hU29ydERhdGEnO1xuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdWyB0eXBlIF1bIGNvbHVtbiBdO1xuXHR9LCAxICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkucmVuZGVyKCknLCAnY2VsbCgpLnJlbmRlcigpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRyZXR1cm4gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3csIGNvbHVtbiwgdHlwZSApO1xuXHR9LCAxICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkuaW5kZXhlcygpJywgJ2NlbGwoKS5pbmRleCgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cm93OiByb3csXG5cdFx0XHRjb2x1bW46IGNvbHVtbixcblx0XHRcdGNvbHVtblZpc2libGU6IF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sdW1uIClcblx0XHR9O1xuXHR9LCAxICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkuaW52YWxpZGF0ZSgpJywgJ2NlbGwoKS5pbnZhbGlkYXRlKCknLCBmdW5jdGlvbiAoIHNyYyApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0X2ZuSW52YWxpZGF0ZSggc2V0dGluZ3MsIHJvdywgc3JjLCBjb2x1bW4gKTtcblx0fSApO1xufSApO1xuXG5cblxuX2FwaV9yZWdpc3RlciggJ2NlbGwoKScsIGZ1bmN0aW9uICggcm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzICkge1xuXHRyZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KCB0aGlzLmNlbGxzKCByb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMgKSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdjZWxsKCkuZGF0YSgpJywgZnVuY3Rpb24gKCBkYXRhICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHR2YXIgY2VsbCA9IHRoaXNbMF07XG5cblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gR2V0XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgY2VsbC5sZW5ndGggP1xuXHRcdFx0X2ZuR2V0Q2VsbERhdGEoIGN0eFswXSwgY2VsbFswXS5yb3csIGNlbGxbMF0uY29sdW1uICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2V0XG5cdF9mblNldENlbGxEYXRhKCBjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbiwgZGF0YSApO1xuXHRfZm5JbnZhbGlkYXRlKCBjdHhbMF0sIGNlbGxbMF0ucm93LCAnZGF0YScsIGNlbGxbMF0uY29sdW1uICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cblxuXG4vKipcbiAqIEdldCBjdXJyZW50IG9yZGVyaW5nIChzb3J0aW5nKSB0aGF0IGhhcyBiZWVuIGFwcGxpZWQgdG8gdGhlIHRhYmxlLlxuICpcbiAqIEByZXR1cm5zIHthcnJheX0gMkQgYXJyYXkgY29udGFpbmluZyB0aGUgc29ydGluZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGZpcnN0XG4gKiAgIHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuIEVhY2ggZWxlbWVudCBpbiB0aGUgcGFyZW50IGFycmF5IHJlcHJlc2VudHNcbiAqICAgYSBjb2x1bW4gYmVpbmcgc29ydGVkIHVwb24gKGkuZS4gbXVsdGktc29ydGluZyB3aXRoIHR3byBjb2x1bW5zIHdvdWxkIGhhdmVcbiAqICAgMiBpbm5lciBhcnJheXMpLiBUaGUgaW5uZXIgYXJyYXlzIG1heSBoYXZlIDIgb3IgMyBlbGVtZW50cy4gVGhlIGZpcnN0IGlzXG4gKiAgIHRoZSBjb2x1bW4gaW5kZXggdGhhdCB0aGUgc29ydGluZyBjb25kaXRpb24gYXBwbGllcyB0bywgdGhlIHNlY29uZCBpcyB0aGVcbiAqICAgZGlyZWN0aW9uIG9mIHRoZSBzb3J0IChgZGVzY2Agb3IgYGFzY2ApIGFuZCwgb3B0aW9uYWxseSwgdGhlIHRoaXJkIGlzIHRoZVxuICogICBpbmRleCBvZiB0aGUgc29ydGluZyBvcmRlciBmcm9tIHRoZSBgY29sdW1uLnNvcnRpbmdgIGluaXRpYWxpc2F0aW9uIGFycmF5LlxuICovLyoqXG4gKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG4gKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvcmRlciBDb2x1bW4gaW5kZXggdG8gc29ydCB1cG9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiBEaXJlY3Rpb24gb2YgdGhlIHNvcnQgdG8gYmUgYXBwbGllZCAoYGFzY2Agb3IgYGRlc2NgKVxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi8vKipcbiAqIFNldCB0aGUgb3JkZXJpbmcgZm9yIHRoZSB0YWJsZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBvcmRlciAxRCBhcnJheSBvZiBzb3J0aW5nIGluZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge2FycmF5fSBbLi4uXSBPcHRpb25hbCBhZGRpdGlvbmFsIHNvcnRpbmcgY29uZGl0aW9uc1xuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi8vKipcbiAqIFNldCB0aGUgb3JkZXJpbmcgZm9yIHRoZSB0YWJsZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBvcmRlciAyRCBhcnJheSBvZiBzb3J0aW5nIGluZm9ybWF0aW9uIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAqL1xuX2FwaV9yZWdpc3RlciggJ29yZGVyKCknLCBmdW5jdGlvbiAoIG9yZGVyLCBkaXIgKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG5cdGlmICggb3JkZXIgPT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBnZXRcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAhPT0gMCA/XG5cdFx0XHRjdHhbMF0uYWFTb3J0aW5nIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIHNldFxuXHRpZiAoIHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicgKSB7XG5cdFx0Ly8gU2ltcGxlIGNvbHVtbiAvIGRpcmVjdGlvbiBwYXNzZWQgaW5cblx0XHRvcmRlciA9IFsgWyBvcmRlciwgZGlyIF0gXTtcblx0fVxuXHRlbHNlIGlmICggYXJncy5sZW5ndGggPiAxICkge1xuXHRcdC8vIEFyZ3VtZW50cyBwYXNzZWQgaW4gKGxpc3Qgb2YgMUQgYXJyYXlzKVxuXHRcdG9yZGVyID0gYXJncztcblx0fVxuXHQvLyBvdGhlcndpc2UgYSAyRCBhcnJheSB3YXMgcGFzc2VkIGluXG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0dmFyIHJlc29sdmVkID0gW107XG5cdFx0X2ZuU29ydFJlc29sdmUoc2V0dGluZ3MsIHJlc29sdmVkLCBvcmRlcik7XG5cblx0XHRzZXR0aW5ncy5hYVNvcnRpbmcgPSByZXNvbHZlZDtcblx0fSApO1xufSApO1xuXG5cbi8qKlxuICogQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IGZvciBhIGdpdmVuIGNvbHVtblxuICpcbiAqIEBwYXJhbSB7bm9kZXxqUXVlcnl8c3RyaW5nfSBub2RlIElkZW50aWZpZXIgZm9yIHRoZSBlbGVtZW50KHMpIHRvIGF0dGFjaCB0aGVcbiAqICAgbGlzdGVuZXIgdG8uIFRoaXMgY2FuIHRha2UgdGhlIGZvcm0gb2YgYSBzaW5nbGUgRE9NIG5vZGUsIGEgalF1ZXJ5XG4gKiAgIGNvbGxlY3Rpb24gb2Ygbm9kZXMgb3IgYSBqUXVlcnkgc2VsZWN0b3Igd2hpY2ggd2lsbCBpZGVudGlmeSB0aGUgbm9kZShzKS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gY29sdW1uIHRoZSBjb2x1bW4gdGhhdCBhIGNsaWNrIG9uIHRoaXMgbm9kZSB3aWxsIHNvcnQgb25cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBzb3J0IGlzIHJ1blxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdvcmRlci5saXN0ZW5lcigpJywgZnVuY3Rpb24gKCBub2RlLCBjb2x1bW4sIGNhbGxiYWNrICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5Tb3J0QXR0YWNoTGlzdGVuZXIoc2V0dGluZ3MsIG5vZGUsIHt9LCBjb2x1bW4sIGNhbGxiYWNrKTtcblx0fSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdvcmRlci5maXhlZCgpJywgZnVuY3Rpb24gKCBzZXQgKSB7XG5cdGlmICggISBzZXQgKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0XHR2YXIgZml4ZWQgPSBjdHgubGVuZ3RoID9cblx0XHRcdGN0eFswXS5hYVNvcnRpbmdGaXhlZCA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheSggZml4ZWQgKSA/XG5cdFx0XHR7IHByZTogZml4ZWQgfSA6XG5cdFx0XHRmaXhlZDtcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkID0gJC5leHRlbmQoIHRydWUsIHt9LCBzZXQgKTtcblx0fSApO1xufSApO1xuXG5cbi8vIE9yZGVyIGJ5IHRoZSBzZWxlY3RlZCBjb2x1bW4ocylcbl9hcGlfcmVnaXN0ZXIoIFtcblx0J2NvbHVtbnMoKS5vcmRlcigpJyxcblx0J2NvbHVtbigpLm9yZGVyKCknXG5dLCBmdW5jdGlvbiAoIGRpciApIHtcblx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdGlmICggISBkaXIgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpZHggKSB7XG5cdFx0XHR2YXIgc29ydCA9IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49c29ydC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBzb3J0W2ldLmNvbCA9PT0gaWR4ICkge1xuXHRcdFx0XHRcdHJldHVybiBzb3J0W2ldLmRpcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LCAxICk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGkgKSB7XG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcgPSB0aGF0W2ldLm1hcCggZnVuY3Rpb24gKGNvbCkge1xuXHRcdFx0XHRyZXR1cm4gWyBjb2wsIGRpciBdO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkub3JkZXJhYmxlKCknLCAnY29sdW1uKCkub3JkZXJhYmxlKCknLCBmdW5jdGlvbiAoIGRpcmVjdGlvbnMgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgaWR4ICkge1xuXHRcdHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbaWR4XTtcblxuXHRcdHJldHVybiBkaXJlY3Rpb25zID9cblx0XHRcdGNvbC5hc1NvcnRpbmcgOlxuXHRcdFx0Y29sLmJTb3J0YWJsZTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdwcm9jZXNzaW5nKCknLCBmdW5jdGlvbiAoIHNob3cgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggY3R4LCBzaG93ICk7XG5cdH0gKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnc2VhcmNoKCknLCBmdW5jdGlvbiAoIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbiApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoIGlucHV0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gZ2V0XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggIT09IDAgP1xuXHRcdFx0Y3R4WzBdLm9QcmV2aW91c1NlYXJjaC5zZWFyY2ggOlxuXHRcdFx0dW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gc2V0XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYkZpbHRlciApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHJlZ2V4ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Ly8gTmV3IHN0eWxlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgc2VhcmNoIGJ1aWxkZXJcblx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgJC5leHRlbmQoIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwgcmVnZXgsIHtcblx0XHRcdFx0c2VhcmNoOiBpbnB1dFxuXHRcdFx0fSApICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gQ29tcGF0IGZvciB0aGUgb2xkIG9wdGlvbnNcblx0XHRcdF9mbkZpbHRlckNvbXBsZXRlKCBzZXR0aW5ncywgJC5leHRlbmQoIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwge1xuXHRcdFx0XHRzZWFyY2g6IGlucHV0LFxuXHRcdFx0XHRyZWdleDogIHJlZ2V4ID09PSBudWxsID8gZmFsc2UgOiByZWdleCxcblx0XHRcdFx0c21hcnQ6ICBzbWFydCA9PT0gbnVsbCA/IHRydWUgIDogc21hcnQsXG5cdFx0XHRcdGNhc2VJbnNlbnNpdGl2ZTogY2FzZUluc2VuID09PSBudWxsID8gdHJ1ZSA6IGNhc2VJbnNlblxuXHRcdFx0fSApICk7XG5cdFx0fVxuXHR9ICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXIoICdzZWFyY2guZml4ZWQoKScsIGZ1bmN0aW9uICggbmFtZSwgc2VhcmNoICkge1xuXHR2YXIgcmV0ID0gdGhpcy5pdGVyYXRvciggdHJ1ZSwgJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHR2YXIgZml4ZWQgPSBzZXR0aW5ncy5zZWFyY2hGaXhlZDtcblxuXHRcdGlmICghIG5hbWUpIHtcblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyhmaXhlZCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHNlYXJjaCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gZml4ZWRbbmFtZV07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHNlYXJjaCA9PT0gbnVsbCkge1xuXHRcdFx0ZGVsZXRlIGZpeGVkW25hbWVdO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGZpeGVkW25hbWVdID0gc2VhcmNoO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9ICk7XG5cblx0cmV0dXJuIG5hbWUgIT09IHVuZGVmaW5lZCAmJiBzZWFyY2ggPT09IHVuZGVmaW5lZFxuXHRcdD8gcmV0WzBdXG5cdFx0OiByZXQ7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoXG5cdCdjb2x1bW5zKCkuc2VhcmNoKCknLFxuXHQnY29sdW1uKCkuc2VhcmNoKCknLFxuXHRmdW5jdGlvbiAoIGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbiApIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRcdHZhciBwcmVTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XG5cblx0XHRcdGlmICggaW5wdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gZ2V0XG5cdFx0XHRcdHJldHVybiBwcmVTZWFyY2hbIGNvbHVtbiBdLnNlYXJjaDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0XG5cdFx0XHRpZiAoICEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiByZWdleCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Ly8gTmV3IHN0eWxlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgc2VhcmNoIGJ1aWxkZXJcblx0XHRcdFx0JC5leHRlbmQoIHByZVNlYXJjaFsgY29sdW1uIF0sIHJlZ2V4LCB7XG5cdFx0XHRcdFx0c2VhcmNoOiBpbnB1dFxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gT2xkIHN0eWxlICh3aXRoIG5vdCBhbGwgb3B0aW9ucyBhdmFpbGFibGUpXG5cdFx0XHRcdCQuZXh0ZW5kKCBwcmVTZWFyY2hbIGNvbHVtbiBdLCB7XG5cdFx0XHRcdFx0c2VhcmNoOiBpbnB1dCxcblx0XHRcdFx0XHRyZWdleDogIHJlZ2V4ID09PSBudWxsID8gZmFsc2UgOiByZWdleCxcblx0XHRcdFx0XHRzbWFydDogIHNtYXJ0ID09PSBudWxsID8gdHJ1ZSAgOiBzbWFydCxcblx0XHRcdFx0XHRjYXNlSW5zZW5zaXRpdmU6IGNhc2VJbnNlbiA9PT0gbnVsbCA/IHRydWUgOiBjYXNlSW5zZW5cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCApO1xuXHRcdH0gKTtcblx0fVxuKTtcblxuX2FwaV9yZWdpc3RlcihbXG5cdFx0J2NvbHVtbnMoKS5zZWFyY2guZml4ZWQoKScsXG5cdFx0J2NvbHVtbigpLnNlYXJjaC5maXhlZCgpJ1xuXHRdLFxuXHRmdW5jdGlvbiAoIG5hbWUsIHNlYXJjaCApIHtcblx0XHR2YXIgcmV0ID0gdGhpcy5pdGVyYXRvciggdHJ1ZSwgJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbElkeCApIHtcblx0XHRcdHZhciBmaXhlZCA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdLnNlYXJjaEZpeGVkO1xuXG5cdFx0XHRpZiAoISBuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBPYmplY3Qua2V5cyhmaXhlZCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChzZWFyY2ggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gZml4ZWRbbmFtZV0gfHwgbnVsbDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHNlYXJjaCA9PT0gbnVsbCkge1xuXHRcdFx0XHRkZWxldGUgZml4ZWRbbmFtZV07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Zml4ZWRbbmFtZV0gPSBzZWFyY2g7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0gKTtcblxuXHRcdHJldHVybiBuYW1lICE9PSB1bmRlZmluZWQgJiYgc2VhcmNoID09PSB1bmRlZmluZWRcblx0XHRcdD8gcmV0WzBdXG5cdFx0XHQ6IHJldDtcblx0fVxuKTtcbi8qXG4gKiBTdGF0ZSBBUEkgbWV0aG9kc1xuICovXG5cbl9hcGlfcmVnaXN0ZXIoICdzdGF0ZSgpJywgZnVuY3Rpb24gKCBzZXQsIGlnbm9yZVRpbWUgKSB7XG5cdC8vIGdldHRlclxuXHRpZiAoICEgc2V0ICkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoID9cblx0XHRcdHRoaXMuY29udGV4dFswXS5vU2F2ZWRTdGF0ZSA6XG5cdFx0XHRudWxsO1xuXHR9XG5cblx0dmFyIHNldE11dGF0ZSA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgc2V0ICk7XG5cblx0Ly8gc2V0dGVyXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdGlmICggaWdub3JlVGltZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzZXRNdXRhdGUudGltZSA9ICtuZXcgRGF0ZSgpICsgMTAwO1xuXHRcdH1cblxuXHRcdF9mbkltcGxlbWVudFN0YXRlKCBzZXR0aW5ncywgc2V0TXV0YXRlLCBmdW5jdGlvbigpe30gKTtcblx0fSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdzdGF0ZS5jbGVhcigpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHQvLyBTYXZlIGFuIGVtcHR5IG9iamVjdFxuXHRcdHNldHRpbmdzLmZuU3RhdGVTYXZlQ2FsbGJhY2suY2FsbCggc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywge30gKTtcblx0fSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdzdGF0ZS5sb2FkZWQoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggP1xuXHRcdHRoaXMuY29udGV4dFswXS5vTG9hZGVkU3RhdGUgOlxuXHRcdG51bGw7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3N0YXRlLnNhdmUoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0X2ZuU2F2ZVN0YXRlKCBzZXR0aW5ncyApO1xuXHR9ICk7XG59ICk7XG5cbi8vIENhbiBiZSBhc3NpZ25lZCBpbiBEYXRlVGFibGUudXNlKCkgLSBub3RlIGx1eG9uIGFuZCBtb21lbnQgdmFycyBhcmUgaW4gaGVscGVycy5qc1xudmFyIF9fYm9vdHN0cmFwO1xudmFyIF9fZm91bmRhdGlvbjtcblxuLyoqXG4gKiBTZXQgdGhlIGxpYnJhcmllcyB0aGF0IERhdGFUYWJsZXMgdXNlcywgb3IgdGhlIGdsb2JhbCBvYmplY3RzLlxuICogTm90ZSB0aGF0IHRoZSBhcmd1bWVudHMgY2FuIGJlIGVpdGhlciB3YXkgYXJvdW5kIChsZWdhY3kgc3VwcG9ydClcbiAqIGFuZCB0aGUgc2Vjb25kIGlzIG9wdGlvbmFsLiBTZWUgZG9jcy5cbiAqL1xuRGF0YVRhYmxlLnVzZSA9IGZ1bmN0aW9uIChhcmcxLCBhcmcyKSB7XG5cdC8vIFJldmVyc2UgYXJndW1lbnRzIGZvciBsZWdhY3kgc3VwcG9ydFxuXHR2YXIgbW9kdWxlID0gdHlwZW9mIGFyZzEgPT09ICdzdHJpbmcnXG5cdFx0PyBhcmcyXG5cdFx0OiBhcmcxO1xuXHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcyID09PSAnc3RyaW5nJ1xuXHRcdD8gYXJnMlxuXHRcdDogYXJnMTtcblxuXHQvLyBHZXR0ZXJcblx0aWYgKG1vZHVsZSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnbGliJzpcblx0XHRcdGNhc2UgJ2pxJzpcblx0XHRcdFx0cmV0dXJuICQ7XG5cblx0XHRcdGNhc2UgJ3dpbic6XG5cdFx0XHRcdHJldHVybiB3aW5kb3c7XG5cblx0XHRcdGNhc2UgJ2RhdGV0aW1lJzpcblx0XHRcdFx0cmV0dXJuIERhdGFUYWJsZS5EYXRlVGltZTtcblxuXHRcdFx0Y2FzZSAnbHV4b24nOlxuXHRcdFx0XHRyZXR1cm4gX19sdXhvbjtcblxuXHRcdFx0Y2FzZSAnbW9tZW50Jzpcblx0XHRcdFx0cmV0dXJuIF9fbW9tZW50O1xuXG5cdFx0XHRjYXNlICdib290c3RyYXAnOlxuXHRcdFx0XHQvLyBVc2UgbG9jYWwgaWYgc2V0LCBvdGhlcndpc2UgdHJ5IHdpbmRvdywgd2hpY2ggY291bGQgYmUgdW5kZWZpbmVkXG5cdFx0XHRcdHJldHVybiBfX2Jvb3RzdHJhcCB8fCB3aW5kb3cuYm9vdHN0cmFwO1xuXG5cdFx0XHRjYXNlICdmb3VuZGF0aW9uJzpcblx0XHRcdFx0Ly8gRGl0dG9cblx0XHRcdFx0cmV0dXJuIF9fZm91bmRhdGlvbiB8fCB3aW5kb3cuRm91bmRhdGlvbjtcblxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0dGVyXG5cdGlmICh0eXBlID09PSAnbGliJyB8fCB0eXBlID09PSAnanEnIHx8IChtb2R1bGUgJiYgbW9kdWxlLmZuICYmIG1vZHVsZS5mbi5qcXVlcnkpKSB7XG5cdFx0JCA9IG1vZHVsZTtcblx0fVxuXHRlbHNlIGlmICh0eXBlID09PSAnd2luJyB8fCAobW9kdWxlICYmIG1vZHVsZS5kb2N1bWVudCkpIHtcblx0XHR3aW5kb3cgPSBtb2R1bGU7XG5cdFx0ZG9jdW1lbnQgPSBtb2R1bGUuZG9jdW1lbnQ7XG5cdH1cblx0ZWxzZSBpZiAodHlwZSA9PT0gJ2RhdGV0aW1lJyB8fCAobW9kdWxlICYmIG1vZHVsZS50eXBlID09PSAnRGF0ZVRpbWUnKSkge1xuXHRcdERhdGFUYWJsZS5EYXRlVGltZSA9IG1vZHVsZTtcblx0fVxuXHRlbHNlIGlmICh0eXBlID09PSAnbHV4b24nIHx8IChtb2R1bGUgJiYgbW9kdWxlLkZpeGVkT2Zmc2V0Wm9uZSkpIHtcblx0XHRfX2x1eG9uID0gbW9kdWxlO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGUgPT09ICdtb21lbnQnIHx8IChtb2R1bGUgJiYgbW9kdWxlLmlzTW9tZW50KSkge1xuXHRcdF9fbW9tZW50ID0gbW9kdWxlO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGUgPT09ICdib290c3RyYXAnIHx8IChtb2R1bGUgJiYgbW9kdWxlLk1vZGFsICYmIG1vZHVsZS5Nb2RhbC5OQU1FID09PSAnbW9kYWwnKSlcblx0e1xuXHRcdC8vIFRoaXMgaXMgY3VycmVudGx5IGZvciBCUzUgb25seS4gQlMzLzQgYXR0YWNoIHRvIGpRdWVyeSwgc28gbm8gbmVlZCB0byB1c2UgYC51c2UoKWBcblx0XHRfX2Jvb3RzdHJhcCA9IG1vZHVsZTtcblx0fVxuXHRlbHNlIGlmICh0eXBlID09PSAnZm91bmRhdGlvbicgfHwgKG1vZHVsZSAmJiBtb2R1bGUuUmV2ZWFsKSkge1xuXHRcdF9fZm91bmRhdGlvbiA9IG1vZHVsZTtcblx0fVxufVxuXG4vKipcbiAqIENvbW1vbkpTIGZhY3RvcnkgZnVuY3Rpb24gcGFzcyB0aHJvdWdoLiBUaGlzIHdpbGwgY2hlY2sgaWYgdGhlIGFyZ3VtZW50c1xuICogZ2l2ZW4gYXJlIGEgd2luZG93IG9iamVjdCBvciBhIGpRdWVyeSBvYmplY3QuIElmIHNvIHRoZXkgYXJlIHNldFxuICogYWNjb3JkaW5nbHkuXG4gKiBAcGFyYW0geyp9IHJvb3QgV2luZG93XG4gKiBAcGFyYW0geyp9IGpxIGpRVWVyeVxuICogQHJldHVybnMge2Jvb2xlYW59IEluZGljYXRvclxuICovXG5EYXRhVGFibGUuZmFjdG9yeSA9IGZ1bmN0aW9uIChyb290LCBqcSkge1xuXHR2YXIgaXMgPSBmYWxzZTtcblxuXHQvLyBUZXN0IGlmIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB3aW5kb3cgb2JqZWN0XG5cdGlmIChyb290ICYmIHJvb3QuZG9jdW1lbnQpIHtcblx0XHR3aW5kb3cgPSByb290O1xuXHRcdGRvY3VtZW50ID0gcm9vdC5kb2N1bWVudDtcblx0fVxuXG5cdC8vIFRlc3QgaWYgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgYSBqUXVlcnkgb2JqZWN0XG5cdGlmIChqcSAmJiBqcS5mbiAmJiBqcS5mbi5qcXVlcnkpIHtcblx0XHQkID0ganE7XG5cdFx0aXMgPSB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGlzO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nXG4gKiB1c2VkLCBpbiBvcmRlciB0byBlbnN1cmUgY29tcGF0aWJpbGl0eS5cbiAqXG4gKiAgQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gVmVyc2lvbiBzdHJpbmcgdG8gY2hlY2sgZm9yLCBpbiB0aGUgZm9ybWF0IFwiWC5ZLlpcIi5cbiAqICAgIE5vdGUgdGhhdCB0aGUgZm9ybWF0cyBcIlhcIiBhbmQgXCJYLllcIiBhcmUgYWxzbyBhY2NlcHRhYmxlLlxuICogIEBwYXJhbSB7c3RyaW5nfSBbdmVyc2lvbjI9Y3VycmVudCBEYXRhVGFibGVzIHZlcnNpb25dIEFzIGFib3ZlLCBidXQgb3B0aW9uYWwuXG4gKiAgIElmIG5vdCBnaXZlbiB0aGUgY3VycmVudCBEYXRhVGFibGVzIHZlcnNpb24gd2lsbCBiZSB1c2VkLlxuICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG9cbiAqICAgIHRoZSByZXF1aXJlZCB2ZXJzaW9uLCBvciBmYWxzZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhbGVzIGlzIG5vdFxuICogICAgc3VpdGFibGVcbiAqICBAc3RhdGljXG4gKiAgQGR0b3B0IEFQSS1TdGF0aWNcbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgIGFsZXJ0KCAkLmZuLmRhdGFUYWJsZS52ZXJzaW9uQ2hlY2soICcxLjkuMCcgKSApO1xuICovXG5EYXRhVGFibGUudmVyc2lvbkNoZWNrID0gZnVuY3Rpb24oIHZlcnNpb24sIHZlcnNpb24yIClcbntcblx0dmFyIGFUaGlzID0gdmVyc2lvbjIgP1xuXHRcdHZlcnNpb24yLnNwbGl0KCcuJykgOlxuXHRcdERhdGFUYWJsZS52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdHZhciBhVGhhdCA9IHZlcnNpb24uc3BsaXQoJy4nKTtcblx0dmFyIGlUaGlzLCBpVGhhdDtcblxuXHRmb3IgKCB2YXIgaT0wLCBpTGVuPWFUaGF0Lmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRpVGhpcyA9IHBhcnNlSW50KCBhVGhpc1tpXSwgMTAgKSB8fCAwO1xuXHRcdGlUaGF0ID0gcGFyc2VJbnQoIGFUaGF0W2ldLCAxMCApIHx8IDA7XG5cblx0XHQvLyBQYXJ0cyBhcmUgdGhlIHNhbWUsIGtlZXAgY29tcGFyaW5nXG5cdFx0aWYgKGlUaGlzID09PSBpVGhhdCkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Ly8gUGFydHMgYXJlIGRpZmZlcmVudCwgcmV0dXJuIGltbWVkaWF0ZWx5XG5cdFx0cmV0dXJuIGlUaGlzID4gaVRoYXQ7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBDaGVjayBpZiBhIGA8dGFibGU+YCBub2RlIGlzIGEgRGF0YVRhYmxlIHRhYmxlIGFscmVhZHkgb3Igbm90LlxuICpcbiAqICBAcGFyYW0ge25vZGV8anF1ZXJ5fHN0cmluZ30gdGFibGUgVGFibGUgbm9kZSwgalF1ZXJ5IG9iamVjdCBvciBqUXVlcnlcbiAqICAgICAgc2VsZWN0b3IgZm9yIHRoZSB0YWJsZSB0byB0ZXN0LiBOb3RlIHRoYXQgaWYgbW9yZSB0aGFuIG1vcmUgdGhhbiBvbmVcbiAqICAgICAgdGFibGUgaXMgcGFzc2VkIG9uLCBvbmx5IHRoZSBmaXJzdCB3aWxsIGJlIGNoZWNrZWRcbiAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSB0aGUgdGFibGUgZ2l2ZW4gaXMgYSBEYXRhVGFibGUsIG9yIGZhbHNlIG90aGVyd2lzZVxuICogIEBzdGF0aWNcbiAqICBAZHRvcHQgQVBJLVN0YXRpY1xuICpcbiAqICBAZXhhbXBsZVxuICogICAgaWYgKCAhICQuZm4uRGF0YVRhYmxlLmlzRGF0YVRhYmxlKCAnI2V4YW1wbGUnICkgKSB7XG4gKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG4gKiAgICB9XG4gKi9cbkRhdGFUYWJsZS5pc0RhdGFUYWJsZSA9IGZ1bmN0aW9uICggdGFibGUgKVxue1xuXHR2YXIgdCA9ICQodGFibGUpLmdldCgwKTtcblx0dmFyIGlzID0gZmFsc2U7XG5cblx0aWYgKCB0YWJsZSBpbnN0YW5jZW9mIERhdGFUYWJsZS5BcGkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQkLmVhY2goIERhdGFUYWJsZS5zZXR0aW5ncywgZnVuY3Rpb24gKGksIG8pIHtcblx0XHR2YXIgaGVhZCA9IG8ublNjcm9sbEhlYWQgPyAkKCd0YWJsZScsIG8ublNjcm9sbEhlYWQpWzBdIDogbnVsbDtcblx0XHR2YXIgZm9vdCA9IG8ublNjcm9sbEZvb3QgPyAkKCd0YWJsZScsIG8ublNjcm9sbEZvb3QpWzBdIDogbnVsbDtcblxuXHRcdGlmICggby5uVGFibGUgPT09IHQgfHwgaGVhZCA9PT0gdCB8fCBmb290ID09PSB0ICkge1xuXHRcdFx0aXMgPSB0cnVlO1xuXHRcdH1cblx0fSApO1xuXG5cdHJldHVybiBpcztcbn07XG5cblxuLyoqXG4gKiBHZXQgYWxsIERhdGFUYWJsZSB0YWJsZXMgdGhhdCBoYXZlIGJlZW4gaW5pdGlhbGlzZWQgLSBvcHRpb25hbGx5IHlvdSBjYW5cbiAqIHNlbGVjdCB0byBnZXQgb25seSBjdXJyZW50bHkgdmlzaWJsZSB0YWJsZXMuXG4gKlxuICogIEBwYXJhbSB7Ym9vbGVhbn0gW3Zpc2libGU9ZmFsc2VdIEZsYWcgdG8gaW5kaWNhdGUgaWYgeW91IHdhbnQgYWxsIChkZWZhdWx0KVxuICogICAgb3IgdmlzaWJsZSB0YWJsZXMgb25seS5cbiAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGB0YWJsZWAgbm9kZXMgKG5vdCBEYXRhVGFibGUgaW5zdGFuY2VzKSB3aGljaCBhcmVcbiAqICAgIERhdGFUYWJsZXNcbiAqICBAc3RhdGljXG4gKiAgQGR0b3B0IEFQSS1TdGF0aWNcbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgICQuZWFjaCggJC5mbi5kYXRhVGFibGUudGFibGVzKHRydWUpLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICQodGFibGUpLkRhdGFUYWJsZSgpLmNvbHVtbnMuYWRqdXN0KCk7XG4gKiAgICB9ICk7XG4gKi9cbkRhdGFUYWJsZS50YWJsZXMgPSBmdW5jdGlvbiAoIHZpc2libGUgKVxue1xuXHR2YXIgYXBpID0gZmFsc2U7XG5cblx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHZpc2libGUgKSApIHtcblx0XHRhcGkgPSB2aXNpYmxlLmFwaTtcblx0XHR2aXNpYmxlID0gdmlzaWJsZS52aXNpYmxlO1xuXHR9XG5cblx0dmFyIGEgPSBEYXRhVGFibGUuc2V0dGluZ3Ncblx0XHQuZmlsdGVyKCBmdW5jdGlvbiAobykge1xuXHRcdFx0cmV0dXJuICF2aXNpYmxlIHx8ICh2aXNpYmxlICYmICQoby5uVGFibGUpLmlzKCc6dmlzaWJsZScpKSBcblx0XHRcdFx0PyB0cnVlXG5cdFx0XHRcdDogZmFsc2U7XG5cdFx0fSApXG5cdFx0Lm1hcCggZnVuY3Rpb24gKG8pIHtcblx0XHRcdHJldHVybiBvLm5UYWJsZTtcblx0XHR9KTtcblxuXHRyZXR1cm4gYXBpID9cblx0XHRuZXcgX0FwaSggYSApIDpcblx0XHRhO1xufTtcblxuXG4vKipcbiAqIENvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gSHVuZ2FyaWFuIG5vdGF0aW9uLiBUaGlzIGlzIG1hZGUgcHVibGljXG4gKiBmb3IgdGhlIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSB0aGUgc2FtZSBhYmlsaXR5IGFzIERhdGFUYWJsZXMgY29yZSB0byBhY2NlcHRcbiAqIGVpdGhlciB0aGUgMS45IHN0eWxlIEh1bmdhcmlhbiBub3RhdGlvbiwgb3IgdGhlIDEuMTArIHN0eWxlIGNhbWVsQ2FzZVxuICogcGFyYW1ldGVycy5cbiAqXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBUaGUgbW9kZWwgb2JqZWN0IHdoaWNoIGhvbGRzIGFsbCBwYXJhbWV0ZXJzIHRoYXQgY2FuIGJlXG4gKiAgICBtYXBwZWQuXG4gKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXG4gKiAgQHBhcmFtIHtib29sZWFufSBmb3JjZSBXaGVuIHNldCB0byBgdHJ1ZWAsIHByb3BlcnRpZXMgd2hpY2ggYWxyZWFkeSBoYXZlIGFcbiAqICAgIEh1bmdhcmlhbiB2YWx1ZSBpbiB0aGUgYHVzZXJgIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0dGVuLiBPdGhlcndpc2UgdGhleVxuICogICAgd29uJ3QgYmUuXG4gKi9cbkRhdGFUYWJsZS5jYW1lbFRvSHVuZ2FyaWFuID0gX2ZuQ2FtZWxUb0h1bmdhcmlhbjtcblxuXG5cbi8qKlxuICpcbiAqL1xuX2FwaV9yZWdpc3RlciggJyQoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdHZhclxuXHRcdHJvd3MgICA9IHRoaXMucm93cyggb3B0cyApLm5vZGVzKCksIC8vIEdldCBhbGwgcm93c1xuXHRcdGpxUm93cyA9ICQocm93cyk7XG5cblx0cmV0dXJuICQoIFtdLmNvbmNhdChcblx0XHRqcVJvd3MuZmlsdGVyKCBzZWxlY3RvciApLnRvQXJyYXkoKSxcblx0XHRqcVJvd3MuZmluZCggc2VsZWN0b3IgKS50b0FycmF5KClcblx0KSApO1xufSApO1xuXG5cbi8vIGpRdWVyeSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiB0aGUgdGFibGVzXG4kLmVhY2goIFsgJ29uJywgJ29uZScsICdvZmYnIF0sIGZ1bmN0aW9uIChpLCBrZXkpIHtcblx0X2FwaV9yZWdpc3Rlcigga2V5KycoKScsIGZ1bmN0aW9uICggLyogZXZlbnQsIGhhbmRsZXIgKi8gKSB7XG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG5cdFx0Ly8gQWRkIHRoZSBgZHRgIG5hbWVzcGFjZSBhdXRvbWF0aWNhbGx5IGlmIGl0IGlzbid0IGFscmVhZHkgcHJlc2VudFxuXHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnNwbGl0KCAvXFxzLyApLm1hcCggZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0cmV0dXJuICEgZS5tYXRjaCgvXFwuZHRcXGIvKSA/XG5cdFx0XHRcdGUrJy5kdCcgOlxuXHRcdFx0XHRlO1xuXHRcdFx0fSApLmpvaW4oICcgJyApO1xuXG5cdFx0dmFyIGluc3QgPSAkKCB0aGlzLnRhYmxlcygpLm5vZGVzKCkgKTtcblx0XHRpbnN0W2tleV0uYXBwbHkoIGluc3QsIGFyZ3MgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdjbGVhcigpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApO1xuXHR9ICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ2Vycm9yKCknLCBmdW5jdGlvbiAobXNnKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdF9mbkxvZyggc2V0dGluZ3MsIDAsIG1zZyApO1xuXHR9ICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3NldHRpbmdzKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCB0aGlzLmNvbnRleHQgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnaW5pdCgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHRyZXR1cm4gY3R4Lmxlbmd0aCA/IGN0eFswXS5vSW5pdCA6IG51bGw7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ2RhdGEoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyApO1xuXHR9ICkuZmxhdHRlbigpO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICd0cmlnZ2VyKCknLCBmdW5jdGlvbiAoIG5hbWUsIGFyZ3MsIGJ1YmJsZXMgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCBuYW1lLCBhcmdzLCBidWJibGVzICk7XG5cdH0gKS5mbGF0dGVuKCk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3JlYWR5KCknLCBmdW5jdGlvbiAoIGZuICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdC8vIEdldCBzdGF0dXMgb2YgZmlyc3QgdGFibGVcblx0aWYgKCEgZm4pIHtcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aFxuXHRcdFx0PyAoY3R4WzBdLl9iSW5pdENvbXBsZXRlIHx8IGZhbHNlKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0Ly8gRnVuY3Rpb24gdG8gcnVuIGVpdGhlciBvbmNlIHRoZSB0YWJsZSBiZWNvbWVzIHJlYWR5IG9yXG5cdC8vIGltbWVkaWF0ZWx5IGlmIGl0IGlzIGFscmVhZHkgcmVhZHkuXG5cdHJldHVybiB0aGlzLnRhYmxlcygpLmV2ZXJ5KGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgYXBpID0gdGhpcztcblxuXHRcdGlmICh0aGlzLmNvbnRleHRbMF0uX2JJbml0Q29tcGxldGUpIHtcblx0XHRcdGZuLmNhbGwoYXBpKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0aGlzLm9uKCdpbml0LmR0LkRUJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRmbi5jYWxsKGFwaSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0gKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnZGVzdHJveSgpJywgZnVuY3Rpb24gKCByZW1vdmUgKSB7XG5cdHJlbW92ZSA9IHJlbW92ZSB8fCBmYWxzZTtcblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHR2YXIgY2xhc3NlcyAgID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdFx0dmFyIHRhYmxlICAgICA9IHNldHRpbmdzLm5UYWJsZTtcblx0XHR2YXIgdGJvZHkgICAgID0gc2V0dGluZ3MublRCb2R5O1xuXHRcdHZhciB0aGVhZCAgICAgPSBzZXR0aW5ncy5uVEhlYWQ7XG5cdFx0dmFyIHRmb290ICAgICA9IHNldHRpbmdzLm5URm9vdDtcblx0XHR2YXIganFUYWJsZSAgID0gJCh0YWJsZSk7XG5cdFx0dmFyIGpxVGJvZHkgICA9ICQodGJvZHkpO1xuXHRcdHZhciBqcVdyYXBwZXIgPSAkKHNldHRpbmdzLm5UYWJsZVdyYXBwZXIpO1xuXHRcdHZhciByb3dzICAgICAgPSBzZXR0aW5ncy5hb0RhdGEubWFwKCBmdW5jdGlvbiAocikgeyByZXR1cm4gciA/IHIublRyIDogbnVsbDsgfSApO1xuXHRcdHZhciBvcmRlckNsYXNzZXMgPSBjbGFzc2VzLm9yZGVyO1xuXG5cdFx0Ly8gRmxhZyB0byBub3RlIHRoYXQgdGhlIHRhYmxlIGlzIGN1cnJlbnRseSBiZWluZyBkZXN0cm95ZWQgLSBubyBhY3Rpb25cblx0XHQvLyBzaG91bGQgYmUgdGFrZW5cblx0XHRzZXR0aW5ncy5iRGVzdHJveWluZyA9IHRydWU7XG5cblx0XHQvLyBGaXJlIG9mZiB0aGUgZGVzdHJveSBjYWxsYmFja3MgZm9yIHBsdWctaW5zIGV0Y1xuXHRcdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIFwiYW9EZXN0cm95Q2FsbGJhY2tcIiwgXCJkZXN0cm95XCIsIFtzZXR0aW5nc10sIHRydWUgKTtcblxuXHRcdC8vIElmIG5vdCBiZWluZyByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50LCBtYWtlIGFsbCBjb2x1bW5zIHZpc2libGVcblx0XHRpZiAoICEgcmVtb3ZlICkge1xuXHRcdFx0bmV3IF9BcGkoIHNldHRpbmdzICkuY29sdW1ucygpLnZpc2libGUoIHRydWUgKTtcblx0XHR9XG5cblx0XHQvLyBDb250YWluZXIgd2lkdGggY2hhbmdlIGxpc3RlbmVyXG5cdFx0aWYgKHNldHRpbmdzLnJlc2l6ZU9ic2VydmVyKSB7XG5cdFx0XHRzZXR0aW5ncy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQmxpdHogYWxsIGBEVGAgbmFtZXNwYWNlZCBldmVudHMgKHRoZXNlIGFyZSBpbnRlcm5hbCBldmVudHMsIHRoZVxuXHRcdC8vIGxvd2VyY2FzZSwgYGR0YCBldmVudHMgYXJlIHVzZXIgc3Vic2NyaWJlZCBhbmQgdGhleSBhcmUgcmVzcG9uc2libGVcblx0XHQvLyBmb3IgcmVtb3ZpbmcgdGhlbVxuXHRcdGpxV3JhcHBlci5vZmYoJy5EVCcpLmZpbmQoJzpub3QodGJvZHkgKiknKS5vZmYoJy5EVCcpO1xuXHRcdCQod2luZG93KS5vZmYoJy5EVC0nK3NldHRpbmdzLnNJbnN0YW5jZSk7XG5cblx0XHQvLyBXaGVuIHNjcm9sbGluZyB3ZSBoYWQgdG8gYnJlYWsgdGhlIHRhYmxlIHVwIC0gcmVzdG9yZSBpdFxuXHRcdGlmICggdGFibGUgIT0gdGhlYWQucGFyZW50Tm9kZSApIHtcblx0XHRcdGpxVGFibGUuY2hpbGRyZW4oJ3RoZWFkJykuZGV0YWNoKCk7XG5cdFx0XHRqcVRhYmxlLmFwcGVuZCggdGhlYWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRmb290ICYmIHRhYmxlICE9IHRmb290LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRqcVRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpLmRldGFjaCgpO1xuXHRcdFx0anFUYWJsZS5hcHBlbmQoIHRmb290ICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGhlYWRlciAvIGZvb3RlclxuXHRcdGNsZWFuSGVhZGVyKHRoZWFkLCAnaGVhZGVyJyk7XG5cdFx0Y2xlYW5IZWFkZXIodGZvb3QsICdmb290ZXInKTtcblx0XHRzZXR0aW5ncy5jb2xncm91cC5yZW1vdmUoKTtcblxuXHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkID0gW107XG5cdFx0X2ZuU29ydGluZ0NsYXNzZXMoIHNldHRpbmdzICk7XG5cblx0XHQkKGpxVGFibGUpLmZpbmQoJ3RoLCB0ZCcpLnJlbW92ZUNsYXNzKFxuXHRcdFx0JC5tYXAoRGF0YVRhYmxlLmV4dC50eXBlLmNsYXNzTmFtZSwgZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0cmV0dXJuIHY7XG5cdFx0XHR9KS5qb2luKCcgJylcblx0XHQpO1xuXG5cdFx0JCgndGgsIHRkJywgdGhlYWQpXG5cdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdG9yZGVyQ2xhc3Nlcy5ub25lICsgJyAnICtcblx0XHRcdFx0b3JkZXJDbGFzc2VzLmNhbkFzYyArICcgJyArXG5cdFx0XHRcdG9yZGVyQ2xhc3Nlcy5jYW5EZXNjICsgJyAnICtcblx0XHRcdFx0b3JkZXJDbGFzc2VzLmlzQXNjICsgJyAnICtcblx0XHRcdFx0b3JkZXJDbGFzc2VzLmlzRGVzY1xuXHRcdFx0KVxuXHRcdFx0LmNzcygnd2lkdGgnLCAnJylcblx0XHRcdC5yZW1vdmVBdHRyKCdhcmlhLXNvcnQnKTtcblxuXHRcdC8vIEFkZCB0aGUgVFIgZWxlbWVudHMgYmFjayBpbnRvIHRoZSB0YWJsZSBpbiB0aGVpciBvcmlnaW5hbCBvcmRlclxuXHRcdGpxVGJvZHkuY2hpbGRyZW4oKS5kZXRhY2goKTtcblx0XHRqcVRib2R5LmFwcGVuZCggcm93cyApO1xuXG5cdFx0dmFyIG9yaWcgPSBzZXR0aW5ncy5uVGFibGVXcmFwcGVyLnBhcmVudE5vZGU7XG5cdFx0dmFyIGluc2VydEJlZm9yZSA9IHNldHRpbmdzLm5UYWJsZVdyYXBwZXIubmV4dFNpYmxpbmc7XG5cblx0XHQvLyBSZW1vdmUgdGhlIERhdGFUYWJsZXMgZ2VuZXJhdGVkIG5vZGVzLCBldmVudHMgYW5kIGNsYXNzZXNcblx0XHR2YXIgcmVtb3ZlZE1ldGhvZCA9IHJlbW92ZSA/ICdyZW1vdmUnIDogJ2RldGFjaCc7XG5cdFx0anFUYWJsZVsgcmVtb3ZlZE1ldGhvZCBdKCk7XG5cdFx0anFXcmFwcGVyWyByZW1vdmVkTWV0aG9kIF0oKTtcblxuXHRcdC8vIElmIHdlIG5lZWQgdG8gcmVhdHRhY2ggdGhlIHRhYmxlIHRvIHRoZSBkb2N1bWVudFxuXHRcdGlmICggISByZW1vdmUgJiYgb3JpZyApIHtcblx0XHRcdC8vIGluc2VydEJlZm9yZSBhY3RzIGxpa2UgYXBwZW5kQ2hpbGQgaWYgIWFyZ1sxXVxuXHRcdFx0b3JpZy5pbnNlcnRCZWZvcmUoIHRhYmxlLCBpbnNlcnRCZWZvcmUgKTtcblxuXHRcdFx0Ly8gUmVzdG9yZSB0aGUgd2lkdGggb2YgdGhlIG9yaWdpbmFsIHRhYmxlIC0gd2FzIHJlYWQgZnJvbSB0aGUgc3R5bGUgcHJvcGVydHksXG5cdFx0XHQvLyBzbyB3ZSBjYW4gcmVzdG9yZSBkaXJlY3RseSB0byB0aGF0XG5cdFx0XHRqcVRhYmxlXG5cdFx0XHRcdC5jc3MoICd3aWR0aCcsIHNldHRpbmdzLnNEZXN0cm95V2lkdGggKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIGNsYXNzZXMudGFibGUgKTtcblx0XHR9XG5cblx0XHQvKiBSZW1vdmUgdGhlIHNldHRpbmdzIG9iamVjdCBmcm9tIHRoZSBzZXR0aW5ncyBhcnJheSAqL1xuXHRcdHZhciBpZHggPSBEYXRhVGFibGUuc2V0dGluZ3MuaW5kZXhPZihzZXR0aW5ncyk7XG5cdFx0aWYgKCBpZHggIT09IC0xICkge1xuXHRcdFx0RGF0YVRhYmxlLnNldHRpbmdzLnNwbGljZSggaWR4LCAxICk7XG5cdFx0fVxuXHR9ICk7XG59ICk7XG5cblxuLy8gQWRkIHRoZSBgZXZlcnkoKWAgbWV0aG9kIGZvciByb3dzLCBjb2x1bW5zIGFuZCBjZWxscyBpbiBhIGNvbXBhY3QgZm9ybVxuJC5lYWNoKCBbICdjb2x1bW4nLCAncm93JywgJ2NlbGwnIF0sIGZ1bmN0aW9uICggaSwgdHlwZSApIHtcblx0X2FwaV9yZWdpc3RlciggdHlwZSsncygpLmV2ZXJ5KCknLCBmdW5jdGlvbiAoIGZuICkge1xuXHRcdHZhciBvcHRzID0gdGhpcy5zZWxlY3Rvci5vcHRzO1xuXHRcdHZhciBhcGkgPSB0aGlzO1xuXHRcdHZhciBpbnN0O1xuXHRcdHZhciBjb3VudGVyID0gMDtcblxuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnZXZlcnknLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3RlZElkeCwgdGFibGVJZHggKSB7XG5cdFx0XHRpbnN0ID0gYXBpWyB0eXBlIF0oc2VsZWN0ZWRJZHgsIG9wdHMpO1xuXG5cdFx0XHRpZiAodHlwZSA9PT0gJ2NlbGwnKSB7XG5cdFx0XHRcdGZuLmNhbGwoaW5zdCwgaW5zdFswXVswXS5yb3csIGluc3RbMF1bMF0uY29sdW1uLCB0YWJsZUlkeCwgY291bnRlcik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Zm4uY2FsbChpbnN0LCBzZWxlY3RlZElkeCwgdGFibGVJZHgsIGNvdW50ZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb3VudGVyKys7XG5cdFx0fSApO1xuXHR9ICk7XG59ICk7XG5cblxuLy8gaTE4biBtZXRob2QgZm9yIGV4dGVuc2lvbnMgdG8gYmUgYWJsZSB0byB1c2UgdGhlIGxhbmd1YWdlIG9iamVjdCBmcm9tIHRoZVxuLy8gRGF0YVRhYmxlXG5fYXBpX3JlZ2lzdGVyKCAnaTE4bigpJywgZnVuY3Rpb24gKCB0b2tlbiwgZGVmLCBwbHVyYWwgKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cdHZhciByZXNvbHZlZCA9IF9mbkdldE9iamVjdERhdGFGbiggdG9rZW4gKSggY3R4Lm9MYW5ndWFnZSApO1xuXG5cdGlmICggcmVzb2x2ZWQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXNvbHZlZCA9IGRlZjtcblx0fVxuXG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCByZXNvbHZlZCApICkge1xuXHRcdHJlc29sdmVkID0gcGx1cmFsICE9PSB1bmRlZmluZWQgJiYgcmVzb2x2ZWRbIHBsdXJhbCBdICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0cmVzb2x2ZWRbIHBsdXJhbCBdIDpcblx0XHRcdHJlc29sdmVkLl87XG5cdH1cblxuXHRyZXR1cm4gdHlwZW9mIHJlc29sdmVkID09PSAnc3RyaW5nJ1xuXHRcdD8gcmVzb2x2ZWQucmVwbGFjZSggJyVkJywgcGx1cmFsICkgLy8gbmI6IHBsdXJhbCBtaWdodCBiZSB1bmRlZmluZWQsXG5cdFx0OiByZXNvbHZlZDtcbn0gKTtcblxuLy8gTmVlZGVkIGZvciBoZWFkZXIgYW5kIGZvb3Rlciwgc28gcHVsbGVkIGludG8gaXRzIG93biBmdW5jdGlvblxuZnVuY3Rpb24gY2xlYW5IZWFkZXIobm9kZSwgY2xhc3NOYW1lKSB7XG5cdCQobm9kZSkuZmluZCgnc3Bhbi5kdC1jb2x1bW4tb3JkZXInKS5yZW1vdmUoKTtcblx0JChub2RlKS5maW5kKCdzcGFuLmR0LWNvbHVtbi10aXRsZScpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aXRsZSA9ICQodGhpcykuaHRtbCgpO1xuXHRcdCQodGhpcykucGFyZW50KCkucGFyZW50KCkuYXBwZW5kKHRpdGxlKTtcblx0XHQkKHRoaXMpLnJlbW92ZSgpO1xuXHR9KTtcblx0JChub2RlKS5maW5kKCdkaXYuZHQtY29sdW1uLScgKyBjbGFzc05hbWUpLnJlbW92ZSgpO1xuXG5cdCQoJ3RoLCB0ZCcsIG5vZGUpLnJlbW92ZUF0dHIoJ2RhdGEtZHQtY29sdW1uJyk7XG59XG5cbi8qKlxuICogVmVyc2lvbiBzdHJpbmcgZm9yIHBsdWctaW5zIHRvIGNoZWNrIGNvbXBhdGliaWxpdHkuIEFsbG93ZWQgZm9ybWF0IGlzXG4gKiBgYS5iLmMtZGAgd2hlcmU6IGE6aW50LCBiOmludCwgYzppbnQsIGQ6c3RyaW5nKGRldnxiZXRhfGFscGhhKS4gYGRgIGlzIHVzZWRcbiAqIG9ubHkgZm9yIG5vbi1yZWxlYXNlIGJ1aWxkcy4gU2VlIGh0dHBzOi8vc2VtdmVyLm9yZy8gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiAgQG1lbWJlclxuICogIEB0eXBlIHN0cmluZ1xuICogIEBkZWZhdWx0IFZlcnNpb24gbnVtYmVyXG4gKi9cbkRhdGFUYWJsZS52ZXJzaW9uID0gXCIyLjMuMFwiO1xuXG4vKipcbiAqIFByaXZhdGUgZGF0YSBzdG9yZSwgY29udGFpbmluZyBhbGwgb2YgdGhlIHNldHRpbmdzIG9iamVjdHMgdGhhdCBhcmVcbiAqIGNyZWF0ZWQgZm9yIHRoZSB0YWJsZXMgb24gYSBnaXZlbiBwYWdlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZS5zZXR0aW5nc2Agb2JqZWN0IGlzIGFsaWFzZWQgdG9cbiAqIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCB0aHJvdWdoIHdoaWNoIGl0IG1heSBiZSBhY2Nlc3NlZCBhbmRcbiAqIG1hbmlwdWxhdGVkLCBvciBgalF1ZXJ5LmZuLmRhdGFUYWJsZS5zZXR0aW5nc2AuXG4gKiAgQG1lbWJlclxuICogIEB0eXBlIGFycmF5XG4gKiAgQGRlZmF1bHQgW11cbiAqICBAcHJpdmF0ZVxuICovXG5EYXRhVGFibGUuc2V0dGluZ3MgPSBbXTtcblxuLyoqXG4gKiBPYmplY3QgbW9kZWxzIGNvbnRhaW5lciwgZm9yIHRoZSB2YXJpb3VzIG1vZGVscyB0aGF0IERhdGFUYWJsZXMgaGFzXG4gKiBhdmFpbGFibGUgdG8gaXQuIFRoZXNlIG1vZGVscyBkZWZpbmUgdGhlIG9iamVjdHMgdGhhdCBhcmUgdXNlZCB0byBob2xkXG4gKiB0aGUgYWN0aXZlIHN0YXRlIGFuZCBjb25maWd1cmF0aW9uIG9mIHRoZSB0YWJsZS5cbiAqICBAbmFtZXNwYWNlXG4gKi9cbkRhdGFUYWJsZS5tb2RlbHMgPSB7fTtcblxuXG5cbi8qKlxuICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcbiAqIHNlYXJjaCBpbmZvcm1hdGlvbiBmb3IgdGhlIGdsb2JhbCBmaWx0ZXIgYW5kIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlcnMuXG4gKiAgQG5hbWVzcGFjZVxuICovXG5EYXRhVGFibGUubW9kZWxzLm9TZWFyY2ggPSB7XG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBmaWx0ZXJpbmcgc2hvdWxkIGJlIGNhc2UgaW5zZW5zaXRpdmUgb3Igbm90XG5cdCAqL1xuXHRcImNhc2VJbnNlbnNpdGl2ZVwiOiB0cnVlLFxuXG5cdC8qKlxuXHQgKiBBcHBsaWVkIHNlYXJjaCB0ZXJtXG5cdCAqL1xuXHRcInNlYXJjaFwiOiBcIlwiLFxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBzZWFyY2ggdGVybSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYVxuXHQgKiByZWd1bGFyIGV4cHJlc3Npb24gKHRydWUpIG9yIG5vdCAoZmFsc2UpIGFuZCB0aGVyZWZvcmUgYW5kIHNwZWNpYWxcblx0ICogcmVnZXggY2hhcmFjdGVycyBlc2NhcGVkLlxuXHQgKi9cblx0XCJyZWdleFwiOiBmYWxzZSxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBEYXRhVGFibGVzIGlzIHRvIHVzZSBpdHMgc21hcnQgZmlsdGVyaW5nIG9yIG5vdC5cblx0ICovXG5cdFwic21hcnRcIjogdHJ1ZSxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBEYXRhVGFibGVzIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZWFyY2ggd2hlblxuXHQgKiB0aGUgcmV0dXJuIGtleSBpcyBwcmVzc2VkLlxuXHQgKi9cblx0XCJyZXR1cm5cIjogZmFsc2Vcbn07XG5cblxuXG5cbi8qKlxuICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcbiAqIGVhY2ggaW5kaXZpZHVhbCByb3cuIFRoaXMgaXMgdGhlIG9iamVjdCBmb3JtYXQgdXNlZCBmb3IgdGhlIHNldHRpbmdzXG4gKiBhb0RhdGEgYXJyYXkuXG4gKiAgQG5hbWVzcGFjZVxuICovXG5EYXRhVGFibGUubW9kZWxzLm9Sb3cgPSB7XG5cdC8qKlxuXHQgKiBUUiBlbGVtZW50IGZvciB0aGUgcm93XG5cdCAqL1xuXHRcIm5UclwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBURCBlbGVtZW50cyBmb3IgZWFjaCByb3cuIFRoaXMgaXMgbnVsbCB1bnRpbCB0aGUgcm93IGhhcyBiZWVuXG5cdCAqIGNyZWF0ZWQuXG5cdCAqL1xuXHRcImFuQ2VsbHNcIjogbnVsbCxcblxuXHQvKipcblx0ICogRGF0YSBvYmplY3QgZnJvbSB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cuIFRoaXMgaXMgZWl0aGVyXG5cdCAqIGFuIGFycmF5IGlmIHVzaW5nIHRoZSB0cmFkaXRpb25hbCBmb3JtIG9mIERhdGFUYWJsZXMsIG9yIGFuIG9iamVjdCBpZlxuXHQgKiB1c2luZyBtRGF0YSBvcHRpb25zLiBUaGUgZXhhY3QgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgcGFzc2VkIGluXG5cdCAqIGRhdGEgZnJvbSB0aGUgZGF0YSBzb3VyY2UsIG9yIHdpbGwgYmUgYW4gYXJyYXkgaWYgdXNpbmcgRE9NIGEgZGF0YVxuXHQgKiBzb3VyY2UuXG5cdCAqL1xuXHRcIl9hRGF0YVwiOiBbXSxcblxuXHQvKipcblx0ICogU29ydGluZyBkYXRhIGNhY2hlIC0gdGhpcyBhcnJheSBpcyBvc3RlbnNpYmx5IHRoZSBzYW1lIGxlbmd0aCBhcyB0aGVcblx0ICogbnVtYmVyIG9mIGNvbHVtbnMgKGFsdGhvdWdoIGVhY2ggaW5kZXggaXMgZ2VuZXJhdGVkIG9ubHkgYXMgaXQgaXNcblx0ICogbmVlZGVkKSwgYW5kIGhvbGRzIHRoZSBkYXRhIHRoYXQgaXMgdXNlZCBmb3Igc29ydGluZyBlYWNoIGNvbHVtbiBpbiB0aGVcblx0ICogcm93LiBXZSBkbyB0aGlzIGNhY2hlIGdlbmVyYXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzb3J0IGluIG9yZGVyIHRoYXRcblx0ICogdGhlIGZvcm1hdHRpbmcgb2YgdGhlIHNvcnQgZGF0YSBuZWVkIGJlIGRvbmUgb25seSBvbmNlIGZvciBlYWNoIGNlbGxcblx0ICogcGVyIHNvcnQuIFRoaXMgYXJyYXkgc2hvdWxkIG5vdCBiZSByZWFkIGZyb20gb3Igd3JpdHRlbiB0byBieSBhbnl0aGluZ1xuXHQgKiBvdGhlciB0aGFuIHRoZSBtYXN0ZXIgc29ydGluZyBtZXRob2RzLlxuXHQgKi9cblx0XCJfYVNvcnREYXRhXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFBlciBjZWxsIGZpbHRlcmluZyBkYXRhIGNhY2hlLiBBcyBwZXIgdGhlIHNvcnQgZGF0YSBjYWNoZSwgdXNlZCB0b1xuXHQgKiBpbmNyZWFzZSB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhlIGZpbHRlcmluZyBpbiBEYXRhVGFibGVzXG5cdCAqL1xuXHRcIl9hRmlsdGVyRGF0YVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBGaWx0ZXJpbmcgZGF0YSBjYWNoZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgY2VsbCBmaWx0ZXJpbmcgY2FjaGUsIGJ1dFxuXHQgKiBpbiB0aGlzIGNhc2UgYSBzdHJpbmcgcmF0aGVyIHRoYW4gYW4gYXJyYXkuIFRoaXMgaXMgZWFzaWx5IGNvbXB1dGVkIHdpdGhcblx0ICogYSBqb2luIG9uIGBfYUZpbHRlckRhdGFgLCBidXQgaXMgcHJvdmlkZWQgYXMgYSBjYWNoZSBzbyB0aGUgam9pbiBpc24ndFxuXHQgKiBuZWVkZWQgb24gZXZlcnkgc2VhcmNoIChtZW1vcnkgdHJhZGVkIGZvciBwZXJmb3JtYW5jZSlcblx0ICovXG5cdFwiX3NGaWx0ZXJSb3dcIjogbnVsbCxcblxuXHQvKipcblx0ICogRGVub3RlIGlmIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSB3YXMgZnJvbSB0aGUgRE9NLCBvciB0aGUgZGF0YSBzb3VyY2Vcblx0ICogb2JqZWN0LiBUaGlzIGlzIHVzZWQgZm9yIGludmFsaWRhdGluZyBkYXRhLCBzbyBEYXRhVGFibGVzIGNhblxuXHQgKiBhdXRvbWF0aWNhbGx5IHJlYWQgZGF0YSBmcm9tIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHVubGVzcyB1bmluc3RydWN0ZWRcblx0ICogb3RoZXJ3aXNlLlxuXHQgKi9cblx0XCJzcmNcIjogbnVsbCxcblxuXHQvKipcblx0ICogSW5kZXggaW4gdGhlIGFvRGF0YSBhcnJheS4gVGhpcyBzYXZlcyBhbiBpbmRleE9mIGxvb2t1cCB3aGVuIHdlIGhhdmUgdGhlXG5cdCAqIG9iamVjdCwgYnV0IHdhbnQgdG8ga25vdyB0aGUgaW5kZXhcblx0ICovXG5cdFwiaWR4XCI6IC0xLFxuXG5cdC8qKlxuXHQgKiBDYWNoZWQgZGlzcGxheSB2YWx1ZVxuXHQgKi9cblx0ZGlzcGxheURhdGE6IG51bGxcbn07XG5cblxuLyoqXG4gKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSBjb2x1bW4gaW5mb3JtYXRpb24gb2JqZWN0IGluIERhdGFUYWJsZXMuIFRoaXMgb2JqZWN0XG4gKiBpcyBoZWxkIGluIHRoZSBzZXR0aW5ncyBhb0NvbHVtbnMgYXJyYXkgYW5kIGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gdGhhdFxuICogRGF0YVRhYmxlcyBuZWVkcyBhYm91dCBlYWNoIGluZGl2aWR1YWwgY29sdW1uLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBpcyByZWxhdGVkIHRvIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufVxuICogYnV0IHRoaXMgb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy5cbiAqIEl0IHNob3VsZCBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGRcbiAqIGJlIGRvbmUgdGhyb3VnaCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucy5cbiAqICBAbmFtZXNwYWNlXG4gKi9cbkRhdGFUYWJsZS5tb2RlbHMub0NvbHVtbiA9IHtcblx0LyoqXG5cdCAqIENvbHVtbiBpbmRleC5cblx0ICovXG5cdFwiaWR4XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEEgbGlzdCBvZiB0aGUgY29sdW1ucyB0aGF0IHNvcnRpbmcgc2hvdWxkIG9jY3VyIG9uIHdoZW4gdGhpcyBjb2x1bW5cblx0ICogaXMgc29ydGVkLiBUaGF0IHRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXkgYWxsb3dzIG11bHRpLWNvbHVtbiBzb3J0aW5nXG5cdCAqIHRvIGJlIGRlZmluZWQgZm9yIGEgY29sdW1uIChmb3IgZXhhbXBsZSBmaXJzdCBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnNcblx0ICogd291bGQgYmVuZWZpdCBmcm9tIHRoaXMpLiBUaGUgdmFsdWVzIGFyZSBpbnRlZ2VycyBwb2ludGluZyB0byB0aGVcblx0ICogY29sdW1ucyB0byBiZSBzb3J0ZWQgb24gKHR5cGljYWxseSBpdCB3aWxsIGJlIGEgc2luZ2xlIGludGVnZXIgcG9pbnRpbmdcblx0ICogYXQgaXRzZWxmLCBidXQgdGhhdCBkb2Vzbid0IG5lZWQgdG8gYmUgdGhlIGNhc2UpLlxuXHQgKi9cblx0XCJhRGF0YVNvcnRcIjogbnVsbCxcblxuXHQvKipcblx0ICogRGVmaW5lIHRoZSBzb3J0aW5nIGRpcmVjdGlvbnMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgY29sdW1uLCBpbiBzZXF1ZW5jZVxuXHQgKiBhcyB0aGUgY29sdW1uIGlzIHJlcGVhdGVkbHkgc29ydGVkIHVwb24gLSBpLmUuIHRoZSBmaXJzdCB2YWx1ZSBpcyB1c2VkXG5cdCAqIGFzIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiB3aGVuIHRoZSBjb2x1bW4gaWYgZmlyc3Qgc29ydGVkIChjbGlja2VkIG9uKS5cblx0ICogU29ydCBpdCBhZ2FpbiAoY2xpY2sgYWdhaW4pIGFuZCBpdCB3aWxsIG1vdmUgb24gdG8gdGhlIG5leHQgaW5kZXguXG5cdCAqIFJlcGVhdCB1bnRpbCBsb29wLlxuXHQgKi9cblx0XCJhc1NvcnRpbmdcIjogbnVsbCxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgY29sdW1uIGlzIHNlYXJjaGFibGUsIGFuZCB0aHVzIHNob3VsZCBiZSBpbmNsdWRlZFxuXHQgKiBpbiB0aGUgZmlsdGVyaW5nIG9yIG5vdC5cblx0ICovXG5cdFwiYlNlYXJjaGFibGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgY29sdW1uIGlzIHNvcnRhYmxlIG9yIG5vdC5cblx0ICovXG5cdFwiYlNvcnRhYmxlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB0aGUgdGFibGUgb3Igbm90XG5cdCAqL1xuXHRcImJWaXNpYmxlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFN0b3JlIGZvciBtYW51YWwgdHlwZSBhc3NpZ25tZW50IHVzaW5nIHRoZSBgY29sdW1uLnR5cGVgIG9wdGlvbi4gVGhpc1xuXHQgKiBpcyBoZWxkIGluIHN0b3JlIHNvIHdlIGNhbiBtYW5pcHVsYXRlIHRoZSBjb2x1bW4ncyBgc1R5cGVgIHByb3BlcnR5LlxuXHQgKi9cblx0XCJfc01hbnVhbFR5cGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiBIVE1MNSBkYXRhIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGRhdGFcblx0ICogc291cmNlIGZvciBmaWx0ZXJpbmcgb3Igc29ydGluZy4gVHJ1ZSBpcyBlaXRoZXIgYXJlLlxuXHQgKi9cblx0XCJfYkF0dHJTcmNcIjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxuXHQgKiBldGMpIG9yIHByb2Nlc3NlZCBmb3IgaW5wdXQgKERPTSBzb3VyY2UpLiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgY29tcGxpbWVudCB0byBtUmVuZGVyXG5cdCAqIGFsbG93aW5nIHlvdSB0byBtb2RpZnkgdGhlIERPTSBlbGVtZW50IChhZGQgYmFja2dyb3VuZCBjb2xvdXIgZm9yIGV4YW1wbGUpIHdoZW4gdGhlXG5cdCAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxuXHQgKi9cblx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRvIGdldCBkYXRhIGZyb20gYSBjZWxsIGluIGEgY29sdW1uLiBZb3Ugc2hvdWxkIDxiPm5ldmVyPC9iPlxuXHQgKiBhY2Nlc3MgZGF0YSBkaXJlY3RseSB0aHJvdWdoIF9hRGF0YSBpbnRlcm5hbGx5IGluIERhdGFUYWJsZXMgLSBhbHdheXMgdXNlXG5cdCAqIHRoZSBtZXRob2QgYXR0YWNoZWQgdG8gdGhpcyBwcm9wZXJ0eS4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzXG5cdCAqIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtblxuXHQgKiBpbml0aWFsaXNhdGlvbiBtZXRob2Rcblx0ICovXG5cdFwiZm5HZXREYXRhXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHRvIHNldCBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gWW91IHNob3VsZCA8Yj5uZXZlcjwvYj5cblx0ICogc2V0IHRoZSBkYXRhIGRpcmVjdGx5IHRvIF9hRGF0YSBpbnRlcm5hbGx5IGluIERhdGFUYWJsZXMgLSBhbHdheXMgdXNlXG5cdCAqIHRoaXMgbWV0aG9kLiBJdCBhbGxvd3MgbURhdGEgdG8gZnVuY3Rpb24gYXMgcmVxdWlyZWQuIFRoaXMgZnVuY3Rpb25cblx0ICogaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCBieSB0aGUgY29sdW1uIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxuXHQgKi9cblx0XCJmblNldERhdGFcIjogbnVsbCxcblxuXHQvKipcblx0ICogUHJvcGVydHkgdG8gcmVhZCB0aGUgdmFsdWUgZm9yIHRoZSBjZWxscyBpbiB0aGUgY29sdW1uIGZyb20gdGhlIGRhdGFcblx0ICogc291cmNlIGFycmF5IC8gb2JqZWN0LiBJZiBudWxsLCB0aGVuIHRoZSBkZWZhdWx0IGNvbnRlbnQgaXMgdXNlZCwgaWYgYVxuXHQgKiBmdW5jdGlvbiBpcyBnaXZlbiB0aGVuIHRoZSByZXR1cm4gZnJvbSB0aGUgZnVuY3Rpb24gaXMgdXNlZC5cblx0ICovXG5cdFwibURhdGFcIjogbnVsbCxcblxuXHQvKipcblx0ICogUGFydG5lciBwcm9wZXJ0eSB0byBtRGF0YSB3aGljaCBpcyB1c2VkIChvbmx5IHdoZW4gZGVmaW5lZCkgdG8gZ2V0XG5cdCAqIHRoZSBkYXRhIC0gaS5lLiBpdCBpcyBiYXNpY2FsbHkgdGhlIHNhbWUgYXMgbURhdGEsIGJ1dCB3aXRob3V0IHRoZVxuXHQgKiAnc2V0JyBvcHRpb24sIGFuZCBhbHNvIHRoZSBkYXRhIGZlZCB0byBpdCBpcyB0aGUgcmVzdWx0IGZyb20gbURhdGEuXG5cdCAqIFRoaXMgaXMgdGhlIHJlbmRlcmluZyBtZXRob2QgdG8gbWF0Y2ggdGhlIGRhdGEgbWV0aG9kIG9mIG1EYXRhLlxuXHQgKi9cblx0XCJtUmVuZGVyXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFRoZSBjbGFzcyB0byBhcHBseSB0byBhbGwgVEQgZWxlbWVudHMgaW4gdGhlIHRhYmxlJ3MgVEJPRFkgZm9yIHRoZSBjb2x1bW5cblx0ICovXG5cdFwic0NsYXNzXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFdoZW4gRGF0YVRhYmxlcyBjYWxjdWxhdGVzIHRoZSBjb2x1bW4gd2lkdGhzIHRvIGFzc2lnbiB0byBlYWNoIGNvbHVtbixcblx0ICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxuXHQgKiB0ZW1wb3JhcnkgdGFibGUgYW5kIHJlYWRzIHRoZSB3aWR0aHMgZnJvbSB0aGF0LiBUaGUgcHJvYmxlbSB3aXRoIHRoaXNcblx0ICogaXMgdGhhdCBcIm1tbVwiIGlzIG11Y2ggd2lkZXIgdGhlbiBcImlpaWlcIiwgYnV0IHRoZSBsYXR0ZXIgaXMgYSBsb25nZXJcblx0ICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xuXHQgKiBpdCBpbnRvIGFuIERPTSBvYmplY3QgYW5kIG1lYXN1cmluZyB0aGF0IGlzIGhvcnJpYmx5KCEpIHNsb3cpLiBUaHVzIGFzXG5cdCAqIGEgXCJ3b3JrIGFyb3VuZFwiIHdlIHByb3ZpZGUgdGhpcyBvcHRpb24uIEl0IHdpbGwgYXBwZW5kIGl0cyB2YWx1ZSB0byB0aGVcblx0ICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cblx0ICovXG5cdFwic0NvbnRlbnRQYWRkaW5nXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEFsbG93cyBhIGRlZmF1bHQgdmFsdWUgdG8gYmUgZ2l2ZW4gZm9yIGEgY29sdW1uJ3MgZGF0YSwgYW5kIHdpbGwgYmUgdXNlZFxuXHQgKiB3aGVuZXZlciBhIG51bGwgZGF0YSBzb3VyY2UgaXMgZW5jb3VudGVyZWQgKHRoaXMgY2FuIGJlIGJlY2F1c2UgbURhdGFcblx0ICogaXMgc2V0IHRvIG51bGwsIG9yIGJlY2F1c2UgdGhlIGRhdGEgc291cmNlIGl0c2VsZiBpcyBudWxsKS5cblx0ICovXG5cdFwic0RlZmF1bHRDb250ZW50XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIE5hbWUgZm9yIHRoZSBjb2x1bW4sIGFsbG93aW5nIHJlZmVyZW5jZSB0byB0aGUgY29sdW1uIGJ5IG5hbWUgYXMgd2VsbCBhc1xuXHQgKiBieSBpbmRleCAobmVlZHMgYSBsb29rdXAgdG8gd29yayBieSBuYW1lKS5cblx0ICovXG5cdFwic05hbWVcIjogbnVsbCxcblxuXHQvKipcblx0ICogQ3VzdG9tIHNvcnRpbmcgZGF0YSB0eXBlIC0gZGVmaW5lcyB3aGljaCBvZiB0aGUgYXZhaWxhYmxlIHBsdWctaW5zIGluXG5cdCAqIGFmblNvcnREYXRhIHRoZSBjdXN0b20gc29ydGluZyB3aWxsIHVzZSAtIGlmIGFueSBpcyBkZWZpbmVkLlxuXHQgKi9cblx0XCJzU29ydERhdGFUeXBlXCI6ICdzdGQnLFxuXG5cdC8qKlxuXHQgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBoZWFkZXIgZWxlbWVudCB3aGVuIHNvcnRpbmcgb24gdGhpcyBjb2x1bW5cblx0ICovXG5cdFwic1NvcnRpbmdDbGFzc1wiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBUaXRsZSBvZiB0aGUgY29sdW1uIC0gd2hhdCBpcyBzZWVuIGluIHRoZSBUSCBlbGVtZW50IChuVGgpLlxuXHQgKi9cblx0XCJzVGl0bGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogQ29sdW1uIHNvcnRpbmcgYW5kIGZpbHRlcmluZyB0eXBlXG5cdCAqL1xuXHRcInNUeXBlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFdpZHRoIG9mIHRoZSBjb2x1bW5cblx0ICovXG5cdFwic1dpZHRoXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFdpZHRoIG9mIHRoZSBjb2x1bW4gd2hlbiBpdCB3YXMgZmlyc3QgXCJlbmNvdW50ZXJlZFwiXG5cdCAqL1xuXHRcInNXaWR0aE9yaWdcIjogbnVsbCxcblxuXHQvKiogQ2FjaGVkIHN0cmluZyB3aGljaCBpcyB0aGUgbG9uZ2VzdCBpbiB0aGUgY29sdW1uICovXG5cdG1heExlblN0cmluZzogbnVsbCxcblxuXHQvKipcblx0ICogU3RvcmUgZm9yIG5hbWVkIHNlYXJjaGVzXG5cdCAqL1xuXHRzZWFyY2hGaXhlZDogbnVsbFxufTtcblxuXG4vKlxuICogRGV2ZWxvcGVyIG5vdGU6IFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYmVsb3cgYXJlIGdpdmVuIGluIEh1bmdhcmlhblxuICogbm90YXRpb24sIHRoYXQgd2FzIHVzZWQgYXMgdGhlIGludGVyZmFjZSBmb3IgRGF0YVRhYmxlcyBwcmlvciB0byB2MS4xMCwgaG93ZXZlclxuICogZnJvbSB2MS4xMCBvbndhcmRzIHRoZSBwcmltYXJ5IGludGVyZmFjZSBpcyBjYW1lbCBjYXNlLiBJbiBvcmRlciB0byBhdm9pZFxuICogYnJlYWtpbmcgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdXR0ZXJseSB3aXRoIHRoaXMgY2hhbmdlLCB0aGUgSHVuZ2FyaWFuXG4gKiB2ZXJzaW9uIGlzIHN0aWxsLCBpbnRlcm5hbGx5IHRoZSBwcmltYXJ5IGludGVyZmFjZSwgYnV0IGlzIGlzIG5vdCBkb2N1bWVudGVkXG4gKiAtIGhlbmNlIHRoZSBAbmFtZSB0YWdzIGluIGVhY2ggZG9jIGNvbW1lbnQuIFRoaXMgYWxsb3dzIGEgSmF2YXNjcmlwdCBmdW5jdGlvblxuICogdG8gY3JlYXRlIGEgbWFwIGZyb20gSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UgKGdvaW5nIHRoZSBvdGhlciBkaXJlY3Rpb25cbiAqIHdvdWxkIHJlcXVpcmUgZWFjaCBwcm9wZXJ0eSB0byBiZSBsaXN0ZWQsIHdoaWNoIHdvdWxkIGFkZCBhcm91bmQgM0sgdG8gdGhlIHNpemVcbiAqIG9mIERhdGFUYWJsZXMsIHdoaWxlIHRoaXMgbWV0aG9kIGlzIGFib3V0IGEgMC41SyBoaXQpLlxuICpcbiAqIFVsdGltYXRlbHkgdGhpcyBkb2VzIHBhdmUgdGhlIHdheSBmb3IgSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGJlIGRyb3BwZWRcbiAqIGNvbXBsZXRlbHksIGJ1dCB0aGF0IGlzIGEgbWFzc2l2ZSBhbW91bnQgb2Ygd29yayBhbmQgd2lsbCBicmVhayBjdXJyZW50XG4gKiBpbnN0YWxscyAodGhlcmVmb3JlIGlzIG9uLWhvbGQgdW50aWwgdjIpLlxuICovXG5cbi8qKlxuICogSW5pdGlhbGlzYXRpb24gb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB0byBEYXRhVGFibGVzIGF0IGluaXRpYWxpc2F0aW9uXG4gKiB0aW1lLlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLmRlZmF1bHRzID0ge1xuXHQvKipcblx0ICogQW4gYXJyYXkgb2YgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWJsZSwgcGFzc2VkIGluIGF0IGluaXRpYWxpc2F0aW9uIHdoaWNoXG5cdCAqIHdpbGwgYmUgdXNlZCBpbiBwcmVmZXJlbmNlIHRvIGFueSBkYXRhIHdoaWNoIGlzIGFscmVhZHkgaW4gdGhlIERPTS4gVGhpcyBpc1xuXHQgKiBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBjb25zdHJ1Y3RpbmcgdGFibGVzIHB1cmVseSBpbiBKYXZhc2NyaXB0LCBmb3Jcblx0ICogZXhhbXBsZSB3aXRoIGEgY3VzdG9tIEFqYXggY2FsbC5cblx0ICovXG5cdFwiYWFEYXRhXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogSWYgb3JkZXJpbmcgaXMgZW5hYmxlZCwgdGhlbiBEYXRhVGFibGVzIHdpbGwgcGVyZm9ybSBhIGZpcnN0IHBhc3Mgc29ydCBvblxuXHQgKiBpbml0aWFsaXNhdGlvbi4gWW91IGNhbiBkZWZpbmUgd2hpY2ggY29sdW1uKHMpIHRoZSBzb3J0IGlzIHBlcmZvcm1lZFxuXHQgKiB1cG9uLCBhbmQgdGhlIHNvcnRpbmcgZGlyZWN0aW9uLCB3aXRoIHRoaXMgdmFyaWFibGUuIFRoZSBgc29ydGluZ2AgYXJyYXlcblx0ICogc2hvdWxkIGNvbnRhaW4gYW4gYXJyYXkgZm9yIGVhY2ggY29sdW1uIHRvIGJlIHNvcnRlZCBpbml0aWFsbHkgY29udGFpbmluZ1xuXHQgKiB0aGUgY29sdW1uJ3MgaW5kZXggYW5kIGEgZGlyZWN0aW9uIHN0cmluZyAoJ2FzYycgb3IgJ2Rlc2MnKS5cblx0ICovXG5cdFwiYWFTb3J0aW5nXCI6IFtbMCwnYXNjJ11dLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgcGFyYW1ldGVyIGlzIGJhc2ljYWxseSBpZGVudGljYWwgdG8gdGhlIGBzb3J0aW5nYCBwYXJhbWV0ZXIsIGJ1dFxuXHQgKiBjYW5ub3QgYmUgb3ZlcnJpZGRlbiBieSB1c2VyIGludGVyYWN0aW9uIHdpdGggdGhlIHRhYmxlLiBXaGF0IHRoaXMgbWVhbnNcblx0ICogaXMgdGhhdCB5b3UgY291bGQgaGF2ZSBhIGNvbHVtbiAodmlzaWJsZSBvciBoaWRkZW4pIHdoaWNoIHRoZSBzb3J0aW5nXG5cdCAqIHdpbGwgYWx3YXlzIGJlIGZvcmNlZCBvbiBmaXJzdCAtIGFueSBzb3J0aW5nIGFmdGVyIHRoYXQgKGZyb20gdGhlIHVzZXIpXG5cdCAqIHdpbGwgdGhlbiBiZSBwZXJmb3JtZWQgYXMgcmVxdWlyZWQuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgZ3JvdXBpbmcgcm93c1xuXHQgKiB0b2dldGhlci5cblx0ICovXG5cdFwiYWFTb3J0aW5nRml4ZWRcIjogW10sXG5cblxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBjYW4gYmUgaW5zdHJ1Y3RlZCB0byBsb2FkIGRhdGEgdG8gZGlzcGxheSBpbiB0aGUgdGFibGUgZnJvbSBhXG5cdCAqIEFqYXggc291cmNlLiBUaGlzIG9wdGlvbiBkZWZpbmVzIGhvdyB0aGF0IEFqYXggY2FsbCBpcyBtYWRlIGFuZCB3aGVyZSB0by5cblx0ICpcblx0ICogVGhlIGBhamF4YCBwcm9wZXJ0eSBoYXMgdGhyZWUgZGlmZmVyZW50IG1vZGVzIG9mIG9wZXJhdGlvbiwgZGVwZW5kaW5nIG9uXG5cdCAqIGhvdyBpdCBpcyBkZWZpbmVkLiBUaGVzZSBhcmU6XG5cdCAqXG5cdCAqICogYHN0cmluZ2AgLSBTZXQgdGhlIFVSTCBmcm9tIHdoZXJlIHRoZSBkYXRhIHNob3VsZCBiZSBsb2FkZWQgZnJvbS5cblx0ICogKiBgb2JqZWN0YCAtIERlZmluZSBwcm9wZXJ0aWVzIGZvciBgalF1ZXJ5LmFqYXhgLlxuXHQgKiAqIGBmdW5jdGlvbmAgLSBDdXN0b20gZGF0YSBnZXQgZnVuY3Rpb25cblx0ICpcblx0ICogYHN0cmluZ2Bcblx0ICogLS0tLS0tLS1cblx0ICpcblx0ICogQXMgYSBzdHJpbmcsIHRoZSBgYWpheGAgcHJvcGVydHkgc2ltcGx5IGRlZmluZXMgdGhlIFVSTCBmcm9tIHdoaWNoXG5cdCAqIERhdGFUYWJsZXMgd2lsbCBsb2FkIGRhdGEuXG5cdCAqXG5cdCAqIGBvYmplY3RgXG5cdCAqIC0tLS0tLS0tXG5cdCAqXG5cdCAqIEFzIGFuIG9iamVjdCwgdGhlIHBhcmFtZXRlcnMgaW4gdGhlIG9iamVjdCBhcmUgcGFzc2VkIHRvXG5cdCAqIFtqUXVlcnkuYWpheF0oaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuYWpheC8pIGFsbG93aW5nIGZpbmUgY29udHJvbFxuXHQgKiBvZiB0aGUgQWpheCByZXF1ZXN0LiBEYXRhVGFibGVzIGhhcyBhIG51bWJlciBvZiBkZWZhdWx0IHBhcmFtZXRlcnMgd2hpY2hcblx0ICogeW91IGNhbiBvdmVycmlkZSB1c2luZyB0aGlzIG9wdGlvbi4gUGxlYXNlIHJlZmVyIHRvIHRoZSBqUXVlcnlcblx0ICogZG9jdW1lbnRhdGlvbiBmb3IgYSBmdWxsIGRlc2NyaXB0aW9uIG9mIHRoZSBvcHRpb25zIGF2YWlsYWJsZSwgYWx0aG91Z2hcblx0ICogdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzIHByb3ZpZGUgYWRkaXRpb25hbCBvcHRpb25zIGluIERhdGFUYWJsZXMgb3Jcblx0ICogcmVxdWlyZSBzcGVjaWFsIGNvbnNpZGVyYXRpb246XG5cdCAqXG5cdCAqICogYGRhdGFgIC0gQXMgd2l0aCBqUXVlcnksIGBkYXRhYCBjYW4gYmUgcHJvdmlkZWQgYXMgYW4gb2JqZWN0LCBidXQgaXRcblx0ICogICBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSBEYXRhVGFibGVzIHNlbmRzXG5cdCAqICAgdG8gdGhlIHNlcnZlci4gVGhlIGZ1bmN0aW9uIHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlciwgYW4gb2JqZWN0IG9mXG5cdCAqICAgcGFyYW1ldGVycyB3aXRoIHRoZSB2YWx1ZXMgdGhhdCBEYXRhVGFibGVzIGhhcyByZWFkaWVkIGZvciBzZW5kaW5nLiBBblxuXHQgKiAgIG9iamVjdCBtYXkgYmUgcmV0dXJuZWQgd2hpY2ggd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgRGF0YVRhYmxlc1xuXHQgKiAgIGRlZmF1bHRzLCBvciB5b3UgY2FuIGFkZCB0aGUgaXRlbXMgdG8gdGhlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgaW4gYW5kXG5cdCAqICAgbm90IHJldHVybiBhbnl0aGluZyBmcm9tIHRoZSBmdW5jdGlvbi4gVGhpcyBzdXBlcnNlZGVzIGBmblNlcnZlclBhcmFtc2Bcblx0ICogICBmcm9tIERhdGFUYWJsZXMgMS45LS5cblx0ICpcblx0ICogKiBgZGF0YVNyY2AgLSBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb29rIGZvciB0aGUgcHJvcGVydHkgYGRhdGFgIChvclxuXHQgKiAgIGBhYURhdGFgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhXG5cdCAqICAgZnJvbSBhbiBBamF4IHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyXG5cdCAqICAgYWxsb3dzIHRoYXQgcHJvcGVydHkgdG8gYmUgY2hhbmdlZC4gWW91IGNhbiB1c2UgSmF2YXNjcmlwdCBkb3R0ZWRcblx0ICogICBvYmplY3Qgbm90YXRpb24gdG8gZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLCBvclxuXHQgKiAgIGl0IG15IGJlIHVzZWQgYXMgYSBmdW5jdGlvbi4gQXMgYSBmdW5jdGlvbiBpdCB0YWtlcyBhIHNpbmdsZSBwYXJhbWV0ZXIsXG5cdCAqICAgdGhlIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCB3aGljaCBjYW4gYmUgbWFuaXB1bGF0ZWQgYXNcblx0ICogICByZXF1aXJlZCwgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWUgYmVpbmcgdGhhdCB1c2VkIGJ5IERhdGFUYWJsZXMgYXMgdGhlXG5cdCAqICAgZGF0YSBzb3VyY2UgZm9yIHRoZSB0YWJsZS5cblx0ICpcblx0ICogKiBgc3VjY2Vzc2AgLSBTaG91bGQgbm90IGJlIG92ZXJyaWRkZW4gaXQgaXMgdXNlZCBpbnRlcm5hbGx5IGluXG5cdCAqICAgRGF0YVRhYmxlcy4gVG8gbWFuaXB1bGF0ZSAvIHRyYW5zZm9ybSB0aGUgZGF0YSByZXR1cm5lZCBieSB0aGUgc2VydmVyXG5cdCAqICAgdXNlIGBhamF4LmRhdGFTcmNgLCBvciB1c2UgYGFqYXhgIGFzIGEgZnVuY3Rpb24gKHNlZSBiZWxvdykuXG5cdCAqXG5cdCAqIGBmdW5jdGlvbmBcblx0ICogLS0tLS0tLS0tLVxuXHQgKlxuXHQgKiBBcyBhIGZ1bmN0aW9uLCBtYWtpbmcgdGhlIEFqYXggY2FsbCBpcyBsZWZ0IHVwIHRvIHlvdXJzZWxmIGFsbG93aW5nXG5cdCAqIGNvbXBsZXRlIGNvbnRyb2wgb2YgdGhlIEFqYXggcmVxdWVzdC4gSW5kZWVkLCBpZiBkZXNpcmVkLCBhIG1ldGhvZCBvdGhlclxuXHQgKiB0aGFuIEFqYXggY291bGQgYmUgdXNlZCB0byBvYnRhaW4gdGhlIHJlcXVpcmVkIGRhdGEsIHN1Y2ggYXMgV2ViIHN0b3JhZ2Vcblx0ICogb3IgYW4gQUlSIGRhdGFiYXNlLlxuXHQgKlxuXHQgKiBUaGUgZnVuY3Rpb24gaXMgZ2l2ZW4gZm91ciBwYXJhbWV0ZXJzIGFuZCBubyByZXR1cm4gaXMgcmVxdWlyZWQuIFRoZVxuXHQgKiBwYXJhbWV0ZXJzIGFyZTpcblx0ICpcblx0ICogMS4gX29iamVjdF8gLSBEYXRhIHRvIHNlbmQgdG8gdGhlIHNlcnZlclxuXHQgKiAyLiBfZnVuY3Rpb25fIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBtdXN0IGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHJlcXVpcmVkXG5cdCAqICAgIGRhdGEgaGFzIGJlZW4gb2J0YWluZWQuIFRoYXQgZGF0YSBzaG91bGQgYmUgcGFzc2VkIGludG8gdGhlIGNhbGxiYWNrXG5cdCAqICAgIGFzIHRoZSBvbmx5IHBhcmFtZXRlclxuXHQgKiAzLiBfb2JqZWN0XyAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgdGFibGVcblx0ICovXG5cdFwiYWpheFwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gcmVhZGlseSBzcGVjaWZ5IHRoZSBlbnRyaWVzIGluIHRoZSBsZW5ndGggZHJvcFxuXHQgKiBkb3duIG1lbnUgdGhhdCBEYXRhVGFibGVzIHNob3dzIHdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLiBJdCBjYW4gYmVcblx0ICogZWl0aGVyIGEgMUQgYXJyYXkgb2Ygb3B0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIGJvdGggdGhlIGRpc3BsYXllZFxuXHQgKiBvcHRpb24gYW5kIHRoZSB2YWx1ZSwgb3IgYSAyRCBhcnJheSB3aGljaCB3aWxsIHVzZSB0aGUgYXJyYXkgaW4gdGhlIGZpcnN0XG5cdCAqIHBvc2l0aW9uIGFzIHRoZSB2YWx1ZSwgYW5kIHRoZSBhcnJheSBpbiB0aGUgc2Vjb25kIHBvc2l0aW9uIGFzIHRoZVxuXHQgKiBkaXNwbGF5ZWQgb3B0aW9ucyAodXNlZnVsIGZvciBsYW5ndWFnZSBzdHJpbmdzIHN1Y2ggYXMgJ0FsbCcpLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhlIGBwYWdlTGVuZ3RoYCBwcm9wZXJ0eSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZVxuXHQgKiBmaXJzdCB2YWx1ZSBnaXZlbiBpbiB0aGlzIGFycmF5LCB1bmxlc3MgYHBhZ2VMZW5ndGhgIGlzIGFsc28gcHJvdmlkZWQuXG5cdCAqL1xuXHRcImFMZW5ndGhNZW51XCI6IFsgMTAsIDI1LCA1MCwgMTAwIF0sXG5cblxuXHQvKipcblx0ICogVGhlIGBjb2x1bW5zYCBvcHRpb24gaW4gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIGRlZmluZVxuXHQgKiBkZXRhaWxzIGFib3V0IHRoZSB3YXkgaW5kaXZpZHVhbCBjb2x1bW5zIGJlaGF2ZS4gRm9yIGEgZnVsbCBsaXN0IG9mXG5cdCAqIGNvbHVtbiBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCwgcGxlYXNlIHNlZVxuXHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn0uIE5vdGUgdGhhdCBpZiB5b3UgdXNlIGBjb2x1bW5zYCB0b1xuXHQgKiBkZWZpbmUgeW91ciBjb2x1bW5zLCB5b3UgbXVzdCBoYXZlIGFuIGVudHJ5IGluIHRoZSBhcnJheSBmb3IgZXZlcnkgc2luZ2xlXG5cdCAqIGNvbHVtbiB0aGF0IHlvdSBoYXZlIGluIHlvdXIgdGFibGUgKHRoZXNlIGNhbiBiZSBudWxsIGlmIHlvdSBkb24ndCB3aGljaFxuXHQgKiB0byBzcGVjaWZ5IGFueSBvcHRpb25zKS5cblx0ICovXG5cdFwiYW9Db2x1bW5zXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFZlcnkgc2ltaWxhciB0byBgY29sdW1uc2AsIGBjb2x1bW5EZWZzYCBhbGxvd3MgeW91IHRvIHRhcmdldCBhIHNwZWNpZmljXG5cdCAqIGNvbHVtbiwgbXVsdGlwbGUgY29sdW1ucywgb3IgYWxsIGNvbHVtbnMsIHVzaW5nIHRoZSBgdGFyZ2V0c2AgcHJvcGVydHkgb2Zcblx0ICogZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5LiBUaGlzIGFsbG93cyBncmVhdCBmbGV4aWJpbGl0eSB3aGVuIGNyZWF0aW5nXG5cdCAqIHRhYmxlcywgYXMgdGhlIGBjb2x1bW5EZWZzYCBhcnJheXMgY2FuIGJlIG9mIGFueSBsZW5ndGgsIHRhcmdldGluZyB0aGVcblx0ICogY29sdW1ucyB5b3Ugc3BlY2lmaWNhbGx5IHdhbnQuIGBjb2x1bW5EZWZzYCBtYXkgdXNlIGFueSBvZiB0aGUgY29sdW1uXG5cdCAqIG9wdGlvbnMgYXZhaWxhYmxlOiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn0sIGJ1dCBpdCBfbXVzdF9cblx0ICogaGF2ZSBgdGFyZ2V0c2AgZGVmaW5lZCBpbiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkuIFZhbHVlcyBpbiB0aGUgYHRhcmdldHNgXG5cdCAqIGFycmF5IG1heSBiZTpcblx0ICogICA8dWw+XG5cdCAqICAgICA8bGk+YSBzdHJpbmcgLSBjbGFzcyBuYW1lIHdpbGwgYmUgbWF0Y2hlZCBvbiB0aGUgVEggZm9yIHRoZSBjb2x1bW48L2xpPlxuXHQgKiAgICAgPGxpPjAgb3IgYSBwb3NpdGl2ZSBpbnRlZ2VyIC0gY29sdW1uIGluZGV4IGNvdW50aW5nIGZyb20gdGhlIGxlZnQ8L2xpPlxuXHQgKiAgICAgPGxpPmEgbmVnYXRpdmUgaW50ZWdlciAtIGNvbHVtbiBpbmRleCBjb3VudGluZyBmcm9tIHRoZSByaWdodDwvbGk+XG5cdCAqICAgICA8bGk+dGhlIHN0cmluZyBcIl9hbGxcIiAtIGFsbCBjb2x1bW5zIChpLmUuIGFzc2lnbiBhIGRlZmF1bHQpPC9saT5cblx0ICogICA8L3VsPlxuXHQgKi9cblx0XCJhb0NvbHVtbkRlZnNcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBCYXNpY2FsbHkgdGhlIHNhbWUgYXMgYHNlYXJjaGAsIHRoaXMgcGFyYW1ldGVyIGRlZmluZXMgdGhlIGluZGl2aWR1YWwgY29sdW1uXG5cdCAqIGZpbHRlcmluZyBzdGF0ZSBhdCBpbml0aWFsaXNhdGlvbiB0aW1lLiBUaGUgYXJyYXkgbXVzdCBiZSBvZiB0aGUgc2FtZSBzaXplXG5cdCAqIGFzIHRoZSBudW1iZXIgb2YgY29sdW1ucywgYW5kIGVhY2ggZWxlbWVudCBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgcGFyYW1ldGVyc1xuXHQgKiBgc2VhcmNoYCBhbmQgYGVzY2FwZVJlZ2V4YCAodGhlIGxhdHRlciBpcyBvcHRpb25hbCkuICdudWxsJyBpcyBhbHNvXG5cdCAqIGFjY2VwdGVkIGFuZCB0aGUgZGVmYXVsdCB3aWxsIGJlIHVzZWQuXG5cdCAqL1xuXHRcImFvU2VhcmNoQ29sc1wiOiBbXSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvbWF0aWMgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uLiBUaGlzIGNhbiBiZSBkaXNhYmxlZFxuXHQgKiBhcyBhbiBvcHRpbWlzYXRpb24gKGl0IHRha2VzIHNvbWUgdGltZSB0byBjYWxjdWxhdGUgdGhlIHdpZHRocykgaWYgdGhlXG5cdCAqIHRhYmxlcyB3aWR0aHMgYXJlIHBhc3NlZCBpbiB1c2luZyBgY29sdW1uc2AuXG5cdCAqL1xuXHRcImJBdXRvV2lkdGhcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBEZWZlcnJlZCByZW5kZXJpbmcgY2FuIHByb3ZpZGUgRGF0YVRhYmxlcyB3aXRoIGEgaHVnZSBzcGVlZCBib29zdCB3aGVuIHlvdVxuXHQgKiBhcmUgdXNpbmcgYW4gQWpheCBvciBKUyBkYXRhIHNvdXJjZSBmb3IgdGhlIHRhYmxlLiBUaGlzIG9wdGlvbiwgd2hlbiBzZXQgdG9cblx0ICogdHJ1ZSwgd2lsbCBjYXVzZSBEYXRhVGFibGVzIHRvIGRlZmVyIHRoZSBjcmVhdGlvbiBvZiB0aGUgdGFibGUgZWxlbWVudHMgZm9yXG5cdCAqIGVhY2ggcm93IHVudGlsIHRoZXkgYXJlIG5lZWRlZCBmb3IgYSBkcmF3IC0gc2F2aW5nIGEgc2lnbmlmaWNhbnQgYW1vdW50IG9mXG5cdCAqIHRpbWUuXG5cdCAqL1xuXHRcImJEZWZlclJlbmRlclwiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIFJlcGxhY2UgYSBEYXRhVGFibGUgd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gc2VsZWN0b3IgYW5kIHJlcGxhY2UgaXQgd2l0aFxuXHQgKiBvbmUgd2hpY2ggaGFzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBuZXcgaW5pdGlhbGlzYXRpb24gb2JqZWN0IHBhc3NlZC4gSWYgbm9cblx0ICogdGFibGUgbWF0Y2hlcyB0aGUgc2VsZWN0b3IsIHRoZW4gdGhlIG5ldyBEYXRhVGFibGUgd2lsbCBiZSBjb25zdHJ1Y3RlZCBhc1xuXHQgKiBwZXIgbm9ybWFsLlxuXHQgKi9cblx0XCJiRGVzdHJveVwiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb2YgZGF0YS4gRmlsdGVyaW5nIGluIERhdGFUYWJsZXMgaXMgXCJzbWFydFwiIGluXG5cdCAqIHRoYXQgaXQgYWxsb3dzIHRoZSBlbmQgdXNlciB0byBpbnB1dCBtdWx0aXBsZSB3b3JkcyAoc3BhY2Ugc2VwYXJhdGVkKSBhbmRcblx0ICogd2lsbCBtYXRjaCBhIHJvdyBjb250YWluaW5nIHRob3NlIHdvcmRzLCBldmVuIGlmIG5vdCBpbiB0aGUgb3JkZXIgdGhhdCB3YXNcblx0ICogc3BlY2lmaWVkICh0aGlzIGFsbG93IG1hdGNoaW5nIGFjcm9zcyBtdWx0aXBsZSBjb2x1bW5zKS4gTm90ZSB0aGF0IGlmIHlvdVxuXHQgKiB3aXNoIHRvIHVzZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlcyB0aGlzIG11c3QgcmVtYWluICd0cnVlJyAtIHRvIHJlbW92ZSB0aGVcblx0ICogZGVmYXVsdCBmaWx0ZXJpbmcgaW5wdXQgYm94IGFuZCByZXRhaW4gZmlsdGVyaW5nIGFiaWxpdGllcywgcGxlYXNlIHVzZVxuXHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbX0uXG5cdCAqL1xuXHRcImJGaWx0ZXJcIjogdHJ1ZSxcblxuXHQvKipcblx0ICogVXNlZCBvbmx5IGZvciBjb21wYXRpYmxpdHkgd2l0aCBEVDFcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdFwiYkluZm9cIjogdHJ1ZSxcblxuXHQvKipcblx0ICogVXNlZCBvbmx5IGZvciBjb21wYXRpYmxpdHkgd2l0aCBEVDFcblx0ICogQGRlcHJlY2F0ZWRcblx0ICovXG5cdFwiYkxlbmd0aENoYW5nZVwiOiB0cnVlLFxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSBwYWdpbmF0aW9uLlxuXHQgKi9cblx0XCJiUGFnaW5hdGVcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgZGlzcGxheSBvZiBhICdwcm9jZXNzaW5nJyBpbmRpY2F0b3Igd2hlbiB0aGUgdGFibGUgaXNcblx0ICogYmVpbmcgcHJvY2Vzc2VkIChlLmcuIGEgc29ydCkuIFRoaXMgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgdGFibGVzIHdpdGhcblx0ICogbGFyZ2UgYW1vdW50cyBvZiBkYXRhIHdoZXJlIGl0IGNhbiB0YWtlIGEgbm90aWNlYWJsZSBhbW91bnQgb2YgdGltZSB0byBzb3J0XG5cdCAqIHRoZSBlbnRyaWVzLlxuXHQgKi9cblx0XCJiUHJvY2Vzc2luZ1wiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZSB0aGUgRGF0YVRhYmxlcyBvYmplY3QgZm9yIHRoZSBnaXZlbiBzZWxlY3Rvci4gTm90ZSB0aGF0IGlmIHRoZVxuXHQgKiB0YWJsZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpc2VkLCB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlIERhdGFUYWJsZXNcblx0ICogdG8gc2ltcGx5IHJldHVybiB0aGUgb2JqZWN0IHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzZXQgdXAgLSBpdCB3aWxsIG5vdCB0YWtlXG5cdCAqIGFjY291bnQgb2YgYW55IGNoYW5nZXMgeW91IG1pZ2h0IGhhdmUgbWFkZSB0byB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0XG5cdCAqIHBhc3NlZCB0byBEYXRhVGFibGVzIChzZXR0aW5nIHRoaXMgcGFyYW1ldGVyIHRvIHRydWUgaXMgYW4gYWNrbm93bGVkZ2VtZW50XG5cdCAqIHRoYXQgeW91IHVuZGVyc3RhbmQgdGhpcykuIGBkZXN0cm95YCBjYW4gYmUgdXNlZCB0byByZWluaXRpYWxpc2UgYSB0YWJsZSBpZlxuXHQgKiB5b3UgbmVlZC5cblx0ICovXG5cdFwiYlJldHJpZXZlXCI6IGZhbHNlLFxuXG5cblx0LyoqXG5cdCAqIFdoZW4gdmVydGljYWwgKHkpIHNjcm9sbGluZyBpcyBlbmFibGVkLCBEYXRhVGFibGVzIHdpbGwgZm9yY2UgdGhlIGhlaWdodCBvZlxuXHQgKiB0aGUgdGFibGUncyB2aWV3cG9ydCB0byB0aGUgZ2l2ZW4gaGVpZ2h0IGF0IGFsbCB0aW1lcyAodXNlZnVsIGZvciBsYXlvdXQpLlxuXHQgKiBIb3dldmVyLCB0aGlzIGNhbiBsb29rIG9kZCB3aGVuIGZpbHRlcmluZyBkYXRhIGRvd24gdG8gYSBzbWFsbCBkYXRhIHNldCxcblx0ICogYW5kIHRoZSBmb290ZXIgaXMgbGVmdCBcImZsb2F0aW5nXCIgZnVydGhlciBkb3duLiBUaGlzIHBhcmFtZXRlciAod2hlblxuXHQgKiBlbmFibGVkKSB3aWxsIGNhdXNlIERhdGFUYWJsZXMgdG8gY29sbGFwc2UgdGhlIHRhYmxlJ3Mgdmlld3BvcnQgZG93biB3aGVuXG5cdCAqIHRoZSByZXN1bHQgc2V0IHdpbGwgZml0IHdpdGhpbiB0aGUgZ2l2ZW4gWSBoZWlnaHQuXG5cdCAqL1xuXHRcImJTY3JvbGxDb2xsYXBzZVwiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBDb25maWd1cmUgRGF0YVRhYmxlcyB0byB1c2Ugc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gTm90ZSB0aGF0IHRoZVxuXHQgKiBgYWpheGAgcGFyYW1ldGVyIG11c3QgYWxzbyBiZSBnaXZlbiBpbiBvcmRlciB0byBnaXZlIERhdGFUYWJsZXMgYVxuXHQgKiBzb3VyY2UgdG8gb2J0YWluIHRoZSByZXF1aXJlZCBkYXRhIGZvciBlYWNoIGRyYXcuXG5cdCAqL1xuXHRcImJTZXJ2ZXJTaWRlXCI6IGZhbHNlLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIHNvcnRpbmcgb2YgY29sdW1ucy4gU29ydGluZyBvZiBpbmRpdmlkdWFsIGNvbHVtbnMgY2FuIGJlXG5cdCAqIGRpc2FibGVkIGJ5IHRoZSBgc29ydGFibGVgIG9wdGlvbiBmb3IgZWFjaCBjb2x1bW4uXG5cdCAqL1xuXHRcImJTb3J0XCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc3BsYXkgRGF0YVRhYmxlcycgYWJpbGl0eSB0byBzb3J0IG11bHRpcGxlIGNvbHVtbnMgYXQgdGhlXG5cdCAqIHNhbWUgdGltZSAoYWN0aXZhdGVkIGJ5IHNoaWZ0LWNsaWNrIGJ5IHRoZSB1c2VyKS5cblx0ICovXG5cdFwiYlNvcnRNdWx0aVwiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIEFsbG93cyBjb250cm9sIG92ZXIgd2hldGhlciBEYXRhVGFibGVzIHNob3VsZCB1c2UgdGhlIHRvcCAodHJ1ZSkgdW5pcXVlXG5cdCAqIGNlbGwgdGhhdCBpcyBmb3VuZCBmb3IgYSBzaW5nbGUgY29sdW1uLCBvciB0aGUgYm90dG9tIChmYWxzZSAtIGRlZmF1bHQpLlxuXHQgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGNvbXBsZXggaGVhZGVycy5cblx0ICovXG5cdFwiYlNvcnRDZWxsc1RvcFwiOiBudWxsLFxuXG5cblx0LyoqIFNwZWNpZnkgd2hpY2ggcm93IGlzIHRoZSB0aXRsZSByb3cgaW4gdGhlIGhlYWRlci4gUmVwbGFjZW1lbnQgZm9yIGJTb3J0Q2VsbHNUb3AgKi9cblx0dGl0bGVSb3c6IG51bGwsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGFkZGl0aW9uIG9mIHRoZSBjbGFzc2VzIGBzb3J0aW5nXFxfMWAsIGBzb3J0aW5nXFxfMmAgYW5kXG5cdCAqIGBzb3J0aW5nXFxfM2AgdG8gdGhlIGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBiZWluZyBzb3J0ZWQgb24uIFRoaXMgaXNcblx0ICogcHJlc2VudGVkIGFzIGEgZmVhdHVyZSBzd2l0Y2ggYXMgaXQgY2FuIGluY3JlYXNlIHByb2Nlc3NpbmcgdGltZSAod2hpbGVcblx0ICogY2xhc3NlcyBhcmUgcmVtb3ZlZCBhbmQgYWRkZWQpIHNvIGZvciBsYXJnZSBkYXRhIHNldHMgeW91IG1pZ2h0IHdhbnQgdG9cblx0ICogdHVybiB0aGlzIG9mZi5cblx0ICovXG5cdFwiYlNvcnRDbGFzc2VzXCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgc3RhdGUgc2F2aW5nLiBXaGVuIGVuYWJsZWQgSFRNTDUgYGxvY2FsU3RvcmFnZWAgd2lsbCBiZVxuXHQgKiB1c2VkIHRvIHNhdmUgdGFibGUgZGlzcGxheSBpbmZvcm1hdGlvbiBzdWNoIGFzIHBhZ2luYXRpb24gaW5mb3JtYXRpb24sXG5cdCAqIGRpc3BsYXkgbGVuZ3RoLCBmaWx0ZXJpbmcgYW5kIHNvcnRpbmcuIEFzIHN1Y2ggd2hlbiB0aGUgZW5kIHVzZXIgcmVsb2Fkc1xuXHQgKiB0aGUgcGFnZSB0aGUgZGlzcGxheSBkaXNwbGF5IHdpbGwgbWF0Y2ggd2hhdCB0aHkgaGFkIHByZXZpb3VzbHkgc2V0IHVwLlxuXHQgKi9cblx0XCJiU3RhdGVTYXZlXCI6IGZhbHNlLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gYSBUUiBlbGVtZW50IGlzIGNyZWF0ZWQgKGFuZCBhbGwgVEQgY2hpbGRcblx0ICogZWxlbWVudHMgaGF2ZSBiZWVuIGluc2VydGVkKSwgb3IgcmVnaXN0ZXJlZCBpZiB1c2luZyBhIERPTSBzb3VyY2UsIGFsbG93aW5nXG5cdCAqIG1hbmlwdWxhdGlvbiBvZiB0aGUgVFIgZWxlbWVudCAoYWRkaW5nIGNsYXNzZXMgZXRjKS5cblx0ICovXG5cdFwiZm5DcmVhdGVkUm93XCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LCBhbmQgYWxsb3dzIHlvdSB0b1xuXHQgKiBkeW5hbWljYWxseSBtb2RpZnkgYW55IGFzcGVjdCB5b3Ugd2FudCBhYm91dCB0aGUgY3JlYXRlZCBET00uXG5cdCAqL1xuXHRcImZuRHJhd0NhbGxiYWNrXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogSWRlbnRpY2FsIHRvIGZuSGVhZGVyQ2FsbGJhY2soKSBidXQgZm9yIHRoZSB0YWJsZSBmb290ZXIgdGhpcyBmdW5jdGlvblxuXHQgKiBhbGxvd3MgeW91IHRvIG1vZGlmeSB0aGUgdGFibGUgZm9vdGVyIG9uIGV2ZXJ5ICdkcmF3JyBldmVudC5cblx0ICovXG5cdFwiZm5Gb290ZXJDYWxsYmFja1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFdoZW4gcmVuZGVyaW5nIGxhcmdlIG51bWJlcnMgaW4gdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgZm9yIHRoZSB0YWJsZVxuXHQgKiAoaS5lLiBcIlNob3dpbmcgMSB0byAxMCBvZiA1NyBlbnRyaWVzXCIpIERhdGFUYWJsZXMgd2lsbCByZW5kZXIgbGFyZ2UgbnVtYmVyc1xuXHQgKiB0byBoYXZlIGEgY29tbWEgc2VwYXJhdG9yIGZvciB0aGUgJ3Rob3VzYW5kcycgdW5pdHMgKGUuZy4gMSBtaWxsaW9uIGlzXG5cdCAqIHJlbmRlcmVkIGFzIFwiMSwwMDAsMDAwXCIpIHRvIGhlbHAgcmVhZGFiaWxpdHkgZm9yIHRoZSBlbmQgdXNlci4gVGhpc1xuXHQgKiBmdW5jdGlvbiB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1ldGhvZCBEYXRhVGFibGVzIHVzZXMuXG5cdCAqL1xuXHRcImZuRm9ybWF0TnVtYmVyXCI6IGZ1bmN0aW9uICggdG9Gb3JtYXQgKSB7XG5cdFx0cmV0dXJuIHRvRm9ybWF0LnRvU3RyaW5nKCkucmVwbGFjZShcblx0XHRcdC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLFxuXHRcdFx0dGhpcy5vTGFuZ3VhZ2Uuc1Rob3VzYW5kc1xuXHRcdCk7XG5cdH0sXG5cblxuXHQvKipcblx0ICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LCBhbmQgYWxsb3dzIHlvdSB0b1xuXHQgKiBkeW5hbWljYWxseSBtb2RpZnkgdGhlIGhlYWRlciByb3cuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGFuZFxuXHQgKiBkaXNwbGF5IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUuXG5cdCAqL1xuXHRcImZuSGVhZGVyQ2FsbGJhY2tcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBUaGUgaW5mb3JtYXRpb24gZWxlbWVudCBjYW4gYmUgdXNlZCB0byBjb252ZXkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnRcblx0ICogc3RhdGUgb2YgdGhlIHRhYmxlLiBBbHRob3VnaCB0aGUgaW50ZXJuYXRpb25hbGlzYXRpb24gb3B0aW9ucyBwcmVzZW50ZWQgYnlcblx0ICogRGF0YVRhYmxlcyBhcmUgcXVpdGUgY2FwYWJsZSBvZiBkZWFsaW5nIHdpdGggbW9zdCBjdXN0b21pc2F0aW9ucywgdGhlcmUgbWF5XG5cdCAqIGJlIHRpbWVzIHdoZXJlIHlvdSB3aXNoIHRvIGN1c3RvbWlzZSB0aGUgc3RyaW5nIGZ1cnRoZXIuIFRoaXMgY2FsbGJhY2tcblx0ICogYWxsb3dzIHlvdSB0byBkbyBleGFjdGx5IHRoYXQuXG5cdCAqL1xuXHRcImZuSW5mb0NhbGxiYWNrXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gdGhlIHRhYmxlIGhhcyBiZWVuIGluaXRpYWxpc2VkLiBOb3JtYWxseSBEYXRhVGFibGVzIHdpbGxcblx0ICogaW5pdGlhbGlzZSBzZXF1ZW50aWFsbHkgYW5kIHRoZXJlIHdpbGwgYmUgbm8gbmVlZCBmb3IgdGhpcyBmdW5jdGlvbixcblx0ICogaG93ZXZlciwgdGhpcyBkb2VzIG5vdCBob2xkIHRydWUgd2hlbiB1c2luZyBleHRlcm5hbCBsYW5ndWFnZSBpbmZvcm1hdGlvblxuXHQgKiBzaW5jZSB0aGF0IGlzIG9idGFpbmVkIHVzaW5nIGFuIGFzeW5jIFhIUiBjYWxsLlxuXHQgKi9cblx0XCJmbkluaXRDb21wbGV0ZVwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIENhbGxlZCBhdCB0aGUgdmVyeSBzdGFydCBvZiBlYWNoIHRhYmxlIGRyYXcgYW5kIGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGVcblx0ICogZHJhdyBieSByZXR1cm5pbmcgZmFsc2UsIGFueSBvdGhlciByZXR1cm4gKGluY2x1ZGluZyB1bmRlZmluZWQpIHJlc3VsdHMgaW5cblx0ICogdGhlIGZ1bGwgZHJhdyBvY2N1cnJpbmcpLlxuXHQgKi9cblx0XCJmblByZURyYXdDYWxsYmFja1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byAncG9zdCBwcm9jZXNzJyBlYWNoIHJvdyBhZnRlciBpdCBoYXZlIGJlZW5cblx0ICogZ2VuZXJhdGVkIGZvciBlYWNoIHRhYmxlIGRyYXcsIGJ1dCBiZWZvcmUgaXQgaXMgcmVuZGVyZWQgb24gc2NyZWVuLiBUaGlzXG5cdCAqIGZ1bmN0aW9uIG1pZ2h0IGJlIHVzZWQgZm9yIHNldHRpbmcgdGhlIHJvdyBjbGFzcyBuYW1lIGV0Yy5cblx0ICovXG5cdFwiZm5Sb3dDYWxsYmFja1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIExvYWQgdGhlIHRhYmxlIHN0YXRlLiBXaXRoIHRoaXMgZnVuY3Rpb24geW91IGNhbiBkZWZpbmUgZnJvbSB3aGVyZSwgYW5kIGhvdywgdGhlXG5cdCAqIHN0YXRlIG9mIGEgdGFibGUgaXMgbG9hZGVkLiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb2FkIGZyb20gYGxvY2FsU3RvcmFnZWBcblx0ICogYnV0IHlvdSBtaWdodCB3aXNoIHRvIHVzZSBhIHNlcnZlci1zaWRlIGRhdGFiYXNlIG9yIGNvb2tpZXMuXG5cdCAqL1xuXHRcImZuU3RhdGVMb2FkQ2FsbGJhY2tcIjogZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoXG5cdFx0XHRcdChzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbiA9PT0gLTEgPyBzZXNzaW9uU3RvcmFnZSA6IGxvY2FsU3RvcmFnZSkuZ2V0SXRlbShcblx0XHRcdFx0XHQnRGF0YVRhYmxlc18nK3NldHRpbmdzLnNJbnN0YW5jZSsnXycrbG9jYXRpb24ucGF0aG5hbWVcblx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIHdoaWNoIGFsbG93cyBtb2RpZmljYXRpb24gb2YgdGhlIHNhdmVkIHN0YXRlIHByaW9yIHRvIGxvYWRpbmcgdGhhdCBzdGF0ZS5cblx0ICogVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGFibGUgaXMgbG9hZGluZyBzdGF0ZSBmcm9tIHRoZSBzdG9yZWQgZGF0YSwgYnV0XG5cdCAqIHByaW9yIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgYmVpbmcgbW9kaWZpZWQgYnkgdGhlIHNhdmVkIHN0YXRlLiBOb3RlIHRoYXQgZm9yXG5cdCAqIHBsdWctaW4gYXV0aG9ycywgeW91IHNob3VsZCB1c2UgdGhlIGBzdGF0ZUxvYWRQYXJhbXNgIGV2ZW50IHRvIGxvYWQgcGFyYW1ldGVycyBmb3Jcblx0ICogYSBwbHVnLWluLlxuXHQgKi9cblx0XCJmblN0YXRlTG9hZFBhcmFtc1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHN0YXRlIGhhcyBiZWVuIGxvYWRlZCBmcm9tIHRoZSBzdGF0ZSBzYXZpbmcgbWV0aG9kXG5cdCAqIGFuZCB0aGUgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgaGFzIGJlZW4gbW9kaWZpZWQgYXMgYSByZXN1bHQgb2YgdGhlIGxvYWRlZCBzdGF0ZS5cblx0ICovXG5cdFwiZm5TdGF0ZUxvYWRlZFwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFNhdmUgdGhlIHRhYmxlIHN0YXRlLiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gZGVmaW5lIHdoZXJlIGFuZCBob3cgdGhlIHN0YXRlXG5cdCAqIGluZm9ybWF0aW9uIGZvciB0aGUgdGFibGUgaXMgc3RvcmVkIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIHVzZSBgbG9jYWxTdG9yYWdlYFxuXHQgKiBidXQgeW91IG1pZ2h0IHdpc2ggdG8gdXNlIGEgc2VydmVyLXNpZGUgZGF0YWJhc2Ugb3IgY29va2llcy5cblx0ICovXG5cdFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiOiBmdW5jdGlvbiAoIHNldHRpbmdzLCBkYXRhICkge1xuXHRcdHRyeSB7XG5cdFx0XHQoc2V0dGluZ3MuaVN0YXRlRHVyYXRpb24gPT09IC0xID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpLnNldEl0ZW0oXG5cdFx0XHRcdCdEYXRhVGFibGVzXycrc2V0dGluZ3Muc0luc3RhbmNlKydfJytsb2NhdGlvbi5wYXRobmFtZSxcblx0XHRcdFx0SlNPTi5zdHJpbmdpZnkoIGRhdGEgKVxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyBub29wXG5cdFx0fVxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIHdoaWNoIGFsbG93cyBtb2RpZmljYXRpb24gb2YgdGhlIHN0YXRlIHRvIGJlIHNhdmVkLiBDYWxsZWQgd2hlbiB0aGUgdGFibGVcblx0ICogaGFzIGNoYW5nZWQgc3RhdGUgYSBuZXcgc3RhdGUgc2F2ZSBpcyByZXF1aXJlZC4gVGhpcyBtZXRob2QgYWxsb3dzIG1vZGlmaWNhdGlvbiBvZlxuXHQgKiB0aGUgc3RhdGUgc2F2aW5nIG9iamVjdCBwcmlvciB0byBhY3R1YWxseSBkb2luZyB0aGUgc2F2ZSwgaW5jbHVkaW5nIGFkZGl0aW9uIG9yXG5cdCAqIG90aGVyIHN0YXRlIHByb3BlcnRpZXMgb3IgbW9kaWZpY2F0aW9uLiBOb3RlIHRoYXQgZm9yIHBsdWctaW4gYXV0aG9ycywgeW91IHNob3VsZFxuXHQgKiB1c2UgdGhlIGBzdGF0ZVNhdmVQYXJhbXNgIGV2ZW50IHRvIHNhdmUgcGFyYW1ldGVycyBmb3IgYSBwbHVnLWluLlxuXHQgKi9cblx0XCJmblN0YXRlU2F2ZVBhcmFtc1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIER1cmF0aW9uIGZvciB3aGljaCB0aGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb24gaXMgY29uc2lkZXJlZCB2YWxpZC4gQWZ0ZXIgdGhpcyBwZXJpb2Rcblx0ICogaGFzIGVsYXBzZWQgdGhlIHN0YXRlIHdpbGwgYmUgcmV0dXJuZWQgdG8gdGhlIGRlZmF1bHQuXG5cdCAqIFZhbHVlIGlzIGdpdmVuIGluIHNlY29uZHMuXG5cdCAqL1xuXHRcImlTdGF0ZUR1cmF0aW9uXCI6IDcyMDAsXG5cblxuXHQvKipcblx0ICogTnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSBvbiBhIHNpbmdsZSBwYWdlIHdoZW4gdXNpbmcgcGFnaW5hdGlvbi4gSWZcblx0ICogZmVhdHVyZSBlbmFibGVkIChgbGVuZ3RoQ2hhbmdlYCkgdGhlbiB0aGUgZW5kIHVzZXIgd2lsbCBiZSBhYmxlIHRvIG92ZXJyaWRlXG5cdCAqIHRoaXMgdG8gYSBjdXN0b20gc2V0dGluZyB1c2luZyBhIHBvcC11cCBtZW51LlxuXHQgKi9cblx0XCJpRGlzcGxheUxlbmd0aFwiOiAxMCxcblxuXG5cdC8qKlxuXHQgKiBEZWZpbmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciBkYXRhIGRpc3BsYXkgd2hlbiB1c2luZyBEYXRhVGFibGVzIHdpdGhcblx0ICogcGFnaW5hdGlvbi4gTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIGlzIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmF0aGVyIHRoYW5cblx0ICogdGhlIHBhZ2UgbnVtYmVyLCBzbyBpZiB5b3UgaGF2ZSAxMCByZWNvcmRzIHBlciBwYWdlIGFuZCB3YW50IHRvIHN0YXJ0IG9uXG5cdCAqIHRoZSB0aGlyZCBwYWdlLCBpdCBzaG91bGQgYmUgXCIyMFwiLlxuXHQgKi9cblx0XCJpRGlzcGxheVN0YXJ0XCI6IDAsXG5cblxuXHQvKipcblx0ICogQnkgZGVmYXVsdCBEYXRhVGFibGVzIGFsbG93cyBrZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSB0YWJsZSAoc29ydGluZywgcGFnaW5nLFxuXHQgKiBhbmQgZmlsdGVyaW5nKSBieSBhZGRpbmcgYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSB0byB0aGUgcmVxdWlyZWQgZWxlbWVudHMuIFRoaXNcblx0ICogYWxsb3dzIHlvdSB0byB0YWIgdGhyb3VnaCB0aGUgY29udHJvbHMgYW5kIHByZXNzIHRoZSBlbnRlciBrZXkgdG8gYWN0aXZhdGUgdGhlbS5cblx0ICogVGhlIHRhYmluZGV4IGlzIGRlZmF1bHQgMCwgbWVhbmluZyB0aGF0IHRoZSB0YWIgZm9sbG93cyB0aGUgZmxvdyBvZiB0aGUgZG9jdW1lbnQuXG5cdCAqIFlvdSBjYW4gb3ZlcnJ1bGUgdGhpcyB1c2luZyB0aGlzIHBhcmFtZXRlciBpZiB5b3Ugd2lzaC4gVXNlIGEgdmFsdWUgb2YgLTEgdG9cblx0ICogZGlzYWJsZSBidWlsdC1pbiBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuXHQgKi9cblx0XCJpVGFiSW5kZXhcIjogMCxcblxuXG5cdC8qKlxuXHQgKiBDbGFzc2VzIHRoYXQgRGF0YVRhYmxlcyBhc3NpZ25zIHRvIHRoZSB2YXJpb3VzIGNvbXBvbmVudHMgYW5kIGZlYXR1cmVzXG5cdCAqIHRoYXQgaXQgYWRkcyB0byB0aGUgSFRNTCB0YWJsZS4gVGhpcyBhbGxvd3MgY2xhc3NlcyB0byBiZSBjb25maWd1cmVkXG5cdCAqIGR1cmluZyBpbml0aWFsaXNhdGlvbiBpbiBhZGRpdGlvbiB0byB0aHJvdWdoIHRoZSBzdGF0aWNcblx0ICoge0BsaW5rIERhdGFUYWJsZS5leHQub1N0ZENsYXNzZXN9IG9iamVjdCkuXG5cdCAqL1xuXHRcIm9DbGFzc2VzXCI6IHt9LFxuXG5cblx0LyoqXG5cdCAqIEFsbCBzdHJpbmdzIHRoYXQgRGF0YVRhYmxlcyB1c2VzIGluIHRoZSB1c2VyIGludGVyZmFjZSB0aGF0IGl0IGNyZWF0ZXNcblx0ICogYXJlIGRlZmluZWQgaW4gdGhpcyBvYmplY3QsIGFsbG93aW5nIHlvdSB0byBtb2RpZmllZCB0aGVtIGluZGl2aWR1YWxseSBvclxuXHQgKiBjb21wbGV0ZWx5IHJlcGxhY2UgdGhlbSBhbGwgYXMgcmVxdWlyZWQuXG5cdCAqL1xuXHRcIm9MYW5ndWFnZVwiOiB7XG5cdFx0LyoqXG5cdFx0ICogU3RyaW5ncyB0aGF0IGFyZSB1c2VkIGZvciBXQUktQVJJQSBsYWJlbHMgYW5kIGNvbnRyb2xzIG9ubHkgKHRoZXNlIGFyZSBub3Rcblx0XHQgKiBhY3R1YWxseSB2aXNpYmxlIG9uIHRoZSBwYWdlLCBidXQgd2lsbCBiZSByZWFkIGJ5IHNjcmVlbnJlYWRlcnMsIGFuZCB0aHVzXG5cdFx0ICogbXVzdCBiZSBpbnRlcm5hdGlvbmFsaXNlZCBhcyB3ZWxsKS5cblx0XHQgKi9cblx0XHRcIm9BcmlhXCI6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBtYXkgYmUgc29ydGVkXG5cdFx0XHQgKi9cblx0XHRcdFwib3JkZXJhYmxlXCI6IFwiOiBBY3RpdmF0ZSB0byBzb3J0XCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgYmVpbmcgc29ydGVkXG5cdFx0XHQgKi9cblx0XHRcdFwib3JkZXJhYmxlUmV2ZXJzZVwiOiBcIjogQWN0aXZhdGUgdG8gaW52ZXJ0IHNvcnRpbmdcIixcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBUklBIGxhYmVsIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRhYmxlIGhlYWRlcnMgd2hlbiB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSBiZWluZyBcblx0XHRcdCAqIHNvcnRlZCBhbmQgbmV4dCBzdGVwIGlzIHRvIHJlbW92ZSBzb3J0aW5nXG5cdFx0XHQgKi9cblx0XHRcdFwib3JkZXJhYmxlUmVtb3ZlXCI6IFwiOiBBY3RpdmF0ZSB0byByZW1vdmUgc29ydGluZ1wiLFxuXG5cdFx0XHRwYWdpbmF0ZToge1xuXHRcdFx0XHRmaXJzdDogJ0ZpcnN0Jyxcblx0XHRcdFx0bGFzdDogJ0xhc3QnLFxuXHRcdFx0XHRuZXh0OiAnTmV4dCcsXG5cdFx0XHRcdHByZXZpb3VzOiAnUHJldmlvdXMnLFxuXHRcdFx0XHRudW1iZXI6ICcnXG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBhZ2luYXRpb24gc3RyaW5nIHVzZWQgYnkgRGF0YVRhYmxlcyBmb3IgdGhlIGJ1aWx0LWluIHBhZ2luYXRpb25cblx0XHQgKiBjb250cm9sIHR5cGVzLlxuXHRcdCAqL1xuXHRcdFwib1BhZ2luYXRlXCI6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogTGFiZWwgYW5kIGNoYXJhY3RlciBmb3IgZmlyc3QgcGFnZSBidXR0b24gKMKrKVxuXHRcdFx0ICovXG5cdFx0XHRcInNGaXJzdFwiOiBcIlxcdTAwQUJcIixcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBMYXN0IHBhZ2UgYnV0dG9uICjCuylcblx0XHRcdCAqL1xuXHRcdFx0XCJzTGFzdFwiOiBcIlxcdTAwQkJcIixcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBOZXh0IHBhZ2UgYnV0dG9uICjigLopXG5cdFx0XHQgKi9cblx0XHRcdFwic05leHRcIjogXCJcXHUyMDNBXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUHJldmlvdXMgcGFnZSBidXR0b24gKOKAuSlcblx0XHRcdCAqL1xuXHRcdFx0XCJzUHJldmlvdXNcIjogXCJcXHUyMDM5XCIsXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBsdXJhbCBvYmplY3QgZm9yIHRoZSBkYXRhIHR5cGUgdGhlIHRhYmxlIGlzIHNob3dpbmdcblx0XHQgKi9cblx0XHRlbnRyaWVzOiB7XG5cdFx0XHRfOiBcImVudHJpZXNcIixcblx0XHRcdDE6IFwiZW50cnlcIlxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQYWdlIGxlbmd0aCBvcHRpb25zXG5cdFx0ICovXG5cdFx0bGVuZ3RoTGFiZWxzOiB7XG5cdFx0XHQnLTEnOiAnQWxsJ1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIHN0cmluZyBpcyBzaG93biBpbiBwcmVmZXJlbmNlIHRvIGB6ZXJvUmVjb3Jkc2Agd2hlbiB0aGUgdGFibGUgaXNcblx0XHQgKiBlbXB0eSBvZiBkYXRhIChyZWdhcmRsZXNzIG9mIGZpbHRlcmluZykuIE5vdGUgdGhhdCB0aGlzIGlzIGFuIG9wdGlvbmFsXG5cdFx0ICogcGFyYW1ldGVyIC0gaWYgaXQgaXMgbm90IGdpdmVuLCB0aGUgdmFsdWUgb2YgYHplcm9SZWNvcmRzYCB3aWxsIGJlIHVzZWRcblx0XHQgKiBpbnN0ZWFkIChlaXRoZXIgdGhlIGRlZmF1bHQgb3IgZ2l2ZW4gdmFsdWUpLlxuXHRcdCAqL1xuXHRcdFwic0VtcHR5VGFibGVcIjogXCJObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVwiLFxuXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIHN0cmluZyBnaXZlcyBpbmZvcm1hdGlvbiB0byB0aGUgZW5kIHVzZXIgYWJvdXQgdGhlIGluZm9ybWF0aW9uXG5cdFx0ICogdGhhdCBpcyBjdXJyZW50IG9uIGRpc3BsYXkgb24gdGhlIHBhZ2UuIFRoZSBmb2xsb3dpbmcgdG9rZW5zIGNhbiBiZVxuXHRcdCAqIHVzZWQgaW4gdGhlIHN0cmluZyBhbmQgd2lsbCBiZSBkeW5hbWljYWxseSByZXBsYWNlZCBhcyB0aGUgdGFibGVcblx0XHQgKiBkaXNwbGF5IHVwZGF0ZXMuIFRoaXMgdG9rZW5zIGNhbiBiZSBwbGFjZWQgYW55d2hlcmUgaW4gdGhlIHN0cmluZywgb3Jcblx0XHQgKiByZW1vdmVkIGFzIG5lZWRlZCBieSB0aGUgbGFuZ3VhZ2UgcmVxdWlyZXM6XG5cdFx0ICpcblx0XHQgKiAqIGBcXF9TVEFSVFxcX2AgLSBEaXNwbGF5IGluZGV4IG9mIHRoZSBmaXJzdCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuXHRcdCAqICogYFxcX0VORFxcX2AgLSBEaXNwbGF5IGluZGV4IG9mIHRoZSBsYXN0IHJlY29yZCBvbiB0aGUgY3VycmVudCBwYWdlXG5cdFx0ICogKiBgXFxfVE9UQUxcXF9gIC0gTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHRhYmxlIGFmdGVyIGZpbHRlcmluZ1xuXHRcdCAqICogYFxcX01BWFxcX2AgLSBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgdGFibGUgd2l0aG91dCBmaWx0ZXJpbmdcblx0XHQgKiAqIGBcXF9QQUdFXFxfYCAtIEN1cnJlbnQgcGFnZSBudW1iZXJcblx0XHQgKiAqIGBcXF9QQUdFU1xcX2AgLSBUb3RhbCBudW1iZXIgb2YgcGFnZXMgb2YgZGF0YSBpbiB0aGUgdGFibGVcblx0XHQgKi9cblx0XHRcInNJbmZvXCI6IFwiU2hvd2luZyBfU1RBUlRfIHRvIF9FTkRfIG9mIF9UT1RBTF8gX0VOVFJJRVMtVE9UQUxfXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIERpc3BsYXkgaW5mb3JtYXRpb24gc3RyaW5nIGZvciB3aGVuIHRoZSB0YWJsZSBpcyBlbXB0eS4gVHlwaWNhbGx5IHRoZVxuXHRcdCAqIGZvcm1hdCBvZiB0aGlzIHN0cmluZyBzaG91bGQgbWF0Y2ggYGluZm9gLlxuXHRcdCAqL1xuXHRcdFwic0luZm9FbXB0eVwiOiBcIlNob3dpbmcgMCB0byAwIG9mIDAgX0VOVFJJRVMtVE9UQUxfXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gYSB1c2VyIGZpbHRlcnMgdGhlIGluZm9ybWF0aW9uIGluIGEgdGFibGUsIHRoaXMgc3RyaW5nIGlzIGFwcGVuZGVkXG5cdFx0ICogdG8gdGhlIGluZm9ybWF0aW9uIChgaW5mb2ApIHRvIGdpdmUgYW4gaWRlYSBvZiBob3cgc3Ryb25nIHRoZSBmaWx0ZXJpbmdcblx0XHQgKiBpcy4gVGhlIHZhcmlhYmxlIF9NQVhfIGlzIGR5bmFtaWNhbGx5IHVwZGF0ZWQuXG5cdFx0ICovXG5cdFx0XCJzSW5mb0ZpbHRlcmVkXCI6IFwiKGZpbHRlcmVkIGZyb20gX01BWF8gdG90YWwgX0VOVFJJRVMtTUFYXylcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogSWYgY2FuIGJlIHVzZWZ1bCB0byBhcHBlbmQgZXh0cmEgaW5mb3JtYXRpb24gdG8gdGhlIGluZm8gc3RyaW5nIGF0IHRpbWVzLFxuXHRcdCAqIGFuZCB0aGlzIHZhcmlhYmxlIGRvZXMgZXhhY3RseSB0aGF0LiBUaGlzIGluZm9ybWF0aW9uIHdpbGwgYmUgYXBwZW5kZWQgdG9cblx0XHQgKiB0aGUgYGluZm9gIChgaW5mb0VtcHR5YCBhbmQgYGluZm9GaWx0ZXJlZGAgaW4gd2hhdGV2ZXIgY29tYmluYXRpb24gdGhleSBhcmVcblx0XHQgKiBiZWluZyB1c2VkKSBhdCBhbGwgdGltZXMuXG5cdFx0ICovXG5cdFx0XCJzSW5mb1Bvc3RGaXhcIjogXCJcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBkZWNpbWFsIHBsYWNlIG9wZXJhdG9yIGlzIGEgbGl0dGxlIGRpZmZlcmVudCBmcm9tIHRoZSBvdGhlclxuXHRcdCAqIGxhbmd1YWdlIG9wdGlvbnMgc2luY2UgRGF0YVRhYmxlcyBkb2Vzbid0IG91dHB1dCBmbG9hdGluZyBwb2ludFxuXHRcdCAqIG51bWJlcnMsIHNvIGl0IHdvbid0IGV2ZXIgdXNlIHRoaXMgZm9yIGRpc3BsYXkgb2YgYSBudW1iZXIuIFJhdGhlcixcblx0XHQgKiB3aGF0IHRoaXMgcGFyYW1ldGVyIGRvZXMgaXMgbW9kaWZ5IHRoZSBzb3J0IG1ldGhvZHMgb2YgdGhlIHRhYmxlIHNvXG5cdFx0ICogdGhhdCBudW1iZXJzIHdoaWNoIGFyZSBpbiBhIGZvcm1hdCB3aGljaCBoYXMgYSBjaGFyYWN0ZXIgb3RoZXIgdGhhblxuXHRcdCAqIGEgcGVyaW9kIChgLmApIGFzIGEgZGVjaW1hbCBwbGFjZSB3aWxsIGJlIHNvcnRlZCBudW1lcmljYWxseS5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBudW1iZXJzIHdpdGggZGlmZmVyZW50IGRlY2ltYWwgcGxhY2VzIGNhbm5vdCBiZSBzaG93biBpblxuXHRcdCAqIHRoZSBzYW1lIHRhYmxlIGFuZCBzdGlsbCBiZSBzb3J0YWJsZSwgdGhlIHRhYmxlIG11c3QgYmUgY29uc2lzdGVudC5cblx0XHQgKiBIb3dldmVyLCBtdWx0aXBsZSBkaWZmZXJlbnQgdGFibGVzIG9uIHRoZSBwYWdlIGNhbiB1c2UgZGlmZmVyZW50XG5cdFx0ICogZGVjaW1hbCBwbGFjZSBjaGFyYWN0ZXJzLlxuXHRcdCAqL1xuXHRcdFwic0RlY2ltYWxcIjogXCJcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogRGF0YVRhYmxlcyBoYXMgYSBidWlsZCBpbiBudW1iZXIgZm9ybWF0dGVyIChgZm9ybWF0TnVtYmVyYCkgd2hpY2ggaXNcblx0XHQgKiB1c2VkIHRvIGZvcm1hdCBsYXJnZSBudW1iZXJzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRhYmxlIGluZm9ybWF0aW9uLlxuXHRcdCAqIEJ5IGRlZmF1bHQgYSBjb21tYSBpcyB1c2VkLCBidXQgdGhpcyBjYW4gYmUgdHJpdmlhbGx5IGNoYW5nZWQgdG8gYW55XG5cdFx0ICogY2hhcmFjdGVyIHlvdSB3aXNoIHdpdGggdGhpcyBwYXJhbWV0ZXIuXG5cdFx0ICovXG5cdFx0XCJzVGhvdXNhbmRzXCI6IFwiLFwiLFxuXG5cblx0XHQvKipcblx0XHQgKiBEZXRhaWwgdGhlIGFjdGlvbiB0aGF0IHdpbGwgYmUgdGFrZW4gd2hlbiB0aGUgZHJvcCBkb3duIG1lbnUgZm9yIHRoZVxuXHRcdCAqIHBhZ2luYXRpb24gbGVuZ3RoIG9wdGlvbiBpcyBjaGFuZ2VkLiBUaGUgJ19NRU5VXycgdmFyaWFibGUgaXMgcmVwbGFjZWRcblx0XHQgKiB3aXRoIGEgZGVmYXVsdCBzZWxlY3QgbGlzdCBvZiAxMCwgMjUsIDUwIGFuZCAxMDAsIGFuZCBjYW4gYmUgcmVwbGFjZWRcblx0XHQgKiB3aXRoIGEgY3VzdG9tIHNlbGVjdCBib3ggaWYgcmVxdWlyZWQuXG5cdFx0ICovXG5cdFx0XCJzTGVuZ3RoTWVudVwiOiBcIl9NRU5VXyBfRU5UUklFU18gcGVyIHBhZ2VcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogV2hlbiB1c2luZyBBamF4IHNvdXJjZWQgZGF0YSBhbmQgZHVyaW5nIHRoZSBmaXJzdCBkcmF3IHdoZW4gRGF0YVRhYmxlcyBpc1xuXHRcdCAqIGdhdGhlcmluZyB0aGUgZGF0YSwgdGhpcyBtZXNzYWdlIGlzIHNob3duIGluIGFuIGVtcHR5IHJvdyBpbiB0aGUgdGFibGUgdG9cblx0XHQgKiBpbmRpY2F0ZSB0byB0aGUgZW5kIHVzZXIgdGhlIHRoZSBkYXRhIGlzIGJlaW5nIGxvYWRlZC4gTm90ZSB0aGF0IHRoaXNcblx0XHQgKiBwYXJhbWV0ZXIgaXMgbm90IHVzZWQgd2hlbiBsb2FkaW5nIGRhdGEgYnkgc2VydmVyLXNpZGUgcHJvY2Vzc2luZywganVzdFxuXHRcdCAqIEFqYXggc291cmNlZCBkYXRhIHdpdGggY2xpZW50LXNpZGUgcHJvY2Vzc2luZy5cblx0XHQgKi9cblx0XHRcInNMb2FkaW5nUmVjb3Jkc1wiOiBcIkxvYWRpbmcuLi5cIixcblxuXG5cdFx0LyoqXG5cdFx0ICogVGV4dCB3aGljaCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgdGFibGUgaXMgcHJvY2Vzc2luZyBhIHVzZXIgYWN0aW9uXG5cdFx0ICogKHVzdWFsbHkgYSBzb3J0IGNvbW1hbmQgb3Igc2ltaWxhcikuXG5cdFx0ICovXG5cdFx0XCJzUHJvY2Vzc2luZ1wiOiBcIlwiLFxuXG5cblx0XHQvKipcblx0XHQgKiBEZXRhaWxzIHRoZSBhY3Rpb25zIHRoYXQgd2lsbCBiZSB0YWtlbiB3aGVuIHRoZSB1c2VyIHR5cGVzIGludG8gdGhlXG5cdFx0ICogZmlsdGVyaW5nIGlucHV0IHRleHQgYm94LiBUaGUgdmFyaWFibGUgXCJfSU5QVVRfXCIsIGlmIHVzZWQgaW4gdGhlIHN0cmluZyxcblx0XHQgKiBpcyByZXBsYWNlZCB3aXRoIHRoZSBIVE1MIHRleHQgYm94IGZvciB0aGUgZmlsdGVyaW5nIGlucHV0IGFsbG93aW5nXG5cdFx0ICogY29udHJvbCBvdmVyIHdoZXJlIGl0IGFwcGVhcnMgaW4gdGhlIHN0cmluZy4gSWYgXCJfSU5QVVRfXCIgaXMgbm90IGdpdmVuXG5cdFx0ICogdGhlbiB0aGUgaW5wdXQgYm94IGlzIGFwcGVuZGVkIHRvIHRoZSBzdHJpbmcgYXV0b21hdGljYWxseS5cblx0XHQgKi9cblx0XHRcInNTZWFyY2hcIjogXCJTZWFyY2g6XCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIEFzc2lnbiBhIGBwbGFjZWhvbGRlcmAgYXR0cmlidXRlIHRvIHRoZSBzZWFyY2ggYGlucHV0YCBlbGVtZW50XG5cdFx0ICogIEB0eXBlIHN0cmluZ1xuXHRcdCAqICBAZGVmYXVsdCBcblx0XHQgKlxuXHRcdCAqICBAZHRvcHQgTGFuZ3VhZ2Vcblx0XHQgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnNlYXJjaFBsYWNlaG9sZGVyXG5cdFx0ICovXG5cdFx0XCJzU2VhcmNoUGxhY2Vob2xkZXJcIjogXCJcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogQWxsIG9mIHRoZSBsYW5ndWFnZSBpbmZvcm1hdGlvbiBjYW4gYmUgc3RvcmVkIGluIGEgZmlsZSBvbiB0aGVcblx0XHQgKiBzZXJ2ZXItc2lkZSwgd2hpY2ggRGF0YVRhYmxlcyB3aWxsIGxvb2sgdXAgaWYgdGhpcyBwYXJhbWV0ZXIgaXMgcGFzc2VkLlxuXHRcdCAqIEl0IG11c3Qgc3RvcmUgdGhlIFVSTCBvZiB0aGUgbGFuZ3VhZ2UgZmlsZSwgd2hpY2ggaXMgaW4gYSBKU09OIGZvcm1hdCxcblx0XHQgKiBhbmQgdGhlIG9iamVjdCBoYXMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyB0aGUgb0xhbmd1YWdlIG9iamVjdCBpbiB0aGVcblx0XHQgKiBpbml0aWFsaXNlciBvYmplY3QgKGkuZS4gdGhlIGFib3ZlIHBhcmFtZXRlcnMpLiBQbGVhc2UgcmVmZXIgdG8gb25lIG9mXG5cdFx0ICogdGhlIGV4YW1wbGUgbGFuZ3VhZ2UgZmlsZXMgdG8gc2VlIGhvdyB0aGlzIHdvcmtzIGluIGFjdGlvbi5cblx0XHQgKi9cblx0XHRcInNVcmxcIjogXCJcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogVGV4dCBzaG93biBpbnNpZGUgdGhlIHRhYmxlIHJlY29yZHMgd2hlbiB0aGUgaXMgbm8gaW5mb3JtYXRpb24gdG8gYmVcblx0XHQgKiBkaXNwbGF5ZWQgYWZ0ZXIgZmlsdGVyaW5nLiBgZW1wdHlUYWJsZWAgaXMgc2hvd24gd2hlbiB0aGVyZSBpcyBzaW1wbHkgbm9cblx0XHQgKiBpbmZvcm1hdGlvbiBpbiB0aGUgdGFibGUgYXQgYWxsIChyZWdhcmRsZXNzIG9mIGZpbHRlcmluZykuXG5cdFx0ICovXG5cdFx0XCJzWmVyb1JlY29yZHNcIjogXCJObyBtYXRjaGluZyByZWNvcmRzIGZvdW5kXCJcblx0fSxcblxuXG5cdC8qKiBUaGUgaW5pdGlhbCBkYXRhIG9yZGVyIGlzIHJldmVyc2VkIHdoZW4gYGRlc2NgIG9yZGVyaW5nICovXG5cdG9yZGVyRGVzY1JldmVyc2U6IHRydWUsXG5cblxuXHQvKipcblx0ICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBoYXZlIGRlZmluZSB0aGUgZ2xvYmFsIGZpbHRlcmluZyBzdGF0ZSBhdFxuXHQgKiBpbml0aWFsaXNhdGlvbiB0aW1lLiBBcyBhbiBvYmplY3QgdGhlIGBzZWFyY2hgIHBhcmFtZXRlciBtdXN0IGJlXG5cdCAqIGRlZmluZWQsIGJ1dCBhbGwgb3RoZXIgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIFdoZW4gYHJlZ2V4YCBpcyB0cnVlLFxuXHQgKiB0aGUgc2VhcmNoIHN0cmluZyB3aWxsIGJlIHRyZWF0ZWQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIHdoZW4gZmFsc2Vcblx0ICogKGRlZmF1bHQpIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHN0cmFpZ2h0IHN0cmluZy4gV2hlbiBgc21hcnRgXG5cdCAqIERhdGFUYWJsZXMgd2lsbCB1c2UgaXQncyBzbWFydCBmaWx0ZXJpbmcgbWV0aG9kcyAodG8gd29yZCBtYXRjaCBhdFxuXHQgKiBhbnkgcG9pbnQgaW4gdGhlIGRhdGEpLCB3aGVuIGZhbHNlIHRoaXMgd2lsbCBub3QgYmUgZG9uZS5cblx0ICovXG5cdFwib1NlYXJjaFwiOiAkLmV4dGVuZCgge30sIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCApLFxuXG5cblx0LyoqXG5cdCAqIFRhYmxlIGFuZCBjb250cm9sIGxheW91dC4gVGhpcyByZXBsYWNlcyB0aGUgbGVnYWN5IGBkb21gIG9wdGlvbi5cblx0ICovXG5cdGxheW91dDoge1xuXHRcdHRvcFN0YXJ0OiAncGFnZUxlbmd0aCcsXG5cdFx0dG9wRW5kOiAnc2VhcmNoJyxcblx0XHRib3R0b21TdGFydDogJ2luZm8nLFxuXHRcdGJvdHRvbUVuZDogJ3BhZ2luZydcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBMZWdhY3kgRE9NIGxheW91dCBvcHRpb25cblx0ICovXG5cdFwic0RvbVwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFNlYXJjaCBkZWxheSBvcHRpb24uIFRoaXMgd2lsbCB0aHJvdHRsZSBmdWxsIHRhYmxlIHNlYXJjaGVzIHRoYXQgdXNlIHRoZVxuXHQgKiBEYXRhVGFibGVzIHByb3ZpZGVkIHNlYXJjaCBpbnB1dCBlbGVtZW50IChpdCBkb2VzIG5vdCBlZmZlY3QgY2FsbHMgdG9cblx0ICogYGR0LWFwaSBzZWFyY2goKWAsIHByb3ZpZGluZyBhIGRlbGF5IGJlZm9yZSB0aGUgc2VhcmNoIGlzIG1hZGUuXG5cdCAqL1xuXHRcInNlYXJjaERlbGF5XCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBmZWF0dXJlcyBzaXggZGlmZmVyZW50IGJ1aWx0LWluIG9wdGlvbnMgZm9yIHRoZSBidXR0b25zIHRvXG5cdCAqIGRpc3BsYXkgZm9yIHBhZ2luYXRpb24gY29udHJvbDpcblx0ICpcblx0ICogKiBgbnVtYmVyc2AgLSBQYWdlIG51bWJlciBidXR0b25zIG9ubHlcblx0ICogKiBgc2ltcGxlYCAtICdQcmV2aW91cycgYW5kICdOZXh0JyBidXR0b25zIG9ubHlcblx0ICogKiAnc2ltcGxlX251bWJlcnNgIC0gJ1ByZXZpb3VzJyBhbmQgJ05leHQnIGJ1dHRvbnMsIHBsdXMgcGFnZSBudW1iZXJzXG5cdCAqICogYGZ1bGxgIC0gJ0ZpcnN0JywgJ1ByZXZpb3VzJywgJ05leHQnIGFuZCAnTGFzdCcgYnV0dG9uc1xuXHQgKiAqIGBmdWxsX251bWJlcnNgIC0gJ0ZpcnN0JywgJ1ByZXZpb3VzJywgJ05leHQnIGFuZCAnTGFzdCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0ICogKiBgZmlyc3RfbGFzdF9udW1iZXJzYCAtICdGaXJzdCcgYW5kICdMYXN0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuXHQgKi9cblx0XCJzUGFnaW5hdGlvblR5cGVcIjogXCJcIixcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgaG9yaXpvbnRhbCBzY3JvbGxpbmcuIFdoZW4gYSB0YWJsZSBpcyB0b28gd2lkZSB0byBmaXQgaW50byBhXG5cdCAqIGNlcnRhaW4gbGF5b3V0LCBvciB5b3UgaGF2ZSBhIGxhcmdlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSB0YWJsZSwgeW91XG5cdCAqIGNhbiBlbmFibGUgeC1zY3JvbGxpbmcgdG8gc2hvdyB0aGUgdGFibGUgaW4gYSB2aWV3cG9ydCwgd2hpY2ggY2FuIGJlXG5cdCAqIHNjcm9sbGVkLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBgdHJ1ZWAgd2hpY2ggd2lsbCBhbGxvdyB0aGUgdGFibGUgdG9cblx0ICogc2Nyb2xsIGhvcml6b250YWxseSB3aGVuIG5lZWRlZCwgb3IgYW55IENTUyB1bml0LCBvciBhIG51bWJlciAoaW4gd2hpY2hcblx0ICogY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbCBtZWFzdXJlbWVudCkuIFNldHRpbmcgYXMgc2ltcGx5IGB0cnVlYFxuXHQgKiBpcyByZWNvbW1lbmRlZC5cblx0ICovXG5cdFwic1Njcm9sbFhcIjogXCJcIixcblxuXG5cdC8qKlxuXHQgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGZvcmNlIGEgRGF0YVRhYmxlIHRvIHVzZSBtb3JlIHdpZHRoIHRoYW4gaXRcblx0ICogbWlnaHQgb3RoZXJ3aXNlIGRvIHdoZW4geC1zY3JvbGxpbmcgaXMgZW5hYmxlZC4gRm9yIGV4YW1wbGUgaWYgeW91IGhhdmUgYVxuXHQgKiB0YWJsZSB3aGljaCByZXF1aXJlcyB0byBiZSB3ZWxsIHNwYWNlZCwgdGhpcyBwYXJhbWV0ZXIgaXMgdXNlZnVsIGZvclxuXHQgKiBcIm92ZXItc2l6aW5nXCIgdGhlIHRhYmxlLCBhbmQgdGh1cyBmb3JjaW5nIHNjcm9sbGluZy4gVGhpcyBwcm9wZXJ0eSBjYW4gYnlcblx0ICogYW55IENTUyB1bml0LCBvciBhIG51bWJlciAoaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbFxuXHQgKiBtZWFzdXJlbWVudCkuXG5cdCAqL1xuXHRcInNTY3JvbGxYSW5uZXJcIjogXCJcIixcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgdmVydGljYWwgc2Nyb2xsaW5nLiBWZXJ0aWNhbCBzY3JvbGxpbmcgd2lsbCBjb25zdHJhaW4gdGhlIERhdGFUYWJsZVxuXHQgKiB0byB0aGUgZ2l2ZW4gaGVpZ2h0LCBhbmQgZW5hYmxlIHNjcm9sbGluZyBmb3IgYW55IGRhdGEgd2hpY2ggb3ZlcmZsb3dzIHRoZVxuXHQgKiBjdXJyZW50IHZpZXdwb3J0LiBUaGlzIGNhbiBiZSB1c2VkIGFzIGFuIGFsdGVybmF0aXZlIHRvIHBhZ2luZyB0byBkaXNwbGF5XG5cdCAqIGEgbG90IG9mIGRhdGEgaW4gYSBzbWFsbCBhcmVhIChhbHRob3VnaCBwYWdpbmcgYW5kIHNjcm9sbGluZyBjYW4gYm90aCBiZVxuXHQgKiBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUpLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyXG5cdCAqIChpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHBpeGVsIG1lYXN1cmVtZW50KS5cblx0ICovXG5cdFwic1Njcm9sbFlcIjogXCJcIixcblxuXG5cdC8qKlxuXHQgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cblx0ICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuXHQgKlxuXHQgKiBTZXQgdGhlIEhUVFAgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBtYWtlIHRoZSBBamF4IGNhbGwgZm9yIHNlcnZlci1zaWRlXG5cdCAqIHByb2Nlc3Npbmcgb3IgQWpheCBzb3VyY2VkIGRhdGEuXG5cdCAqL1xuXHRcInNTZXJ2ZXJNZXRob2RcIjogXCJHRVRcIixcblxuXG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIG1ha2VzIHVzZSBvZiByZW5kZXJlcnMgd2hlbiBkaXNwbGF5aW5nIEhUTUwgZWxlbWVudHMgZm9yXG5cdCAqIGEgdGFibGUuIFRoZXNlIHJlbmRlcmVycyBjYW4gYmUgYWRkZWQgb3IgbW9kaWZpZWQgYnkgcGx1Zy1pbnMgdG9cblx0ICogZ2VuZXJhdGUgc3VpdGFibGUgbWFyay11cCBmb3IgYSBzaXRlLiBGb3IgZXhhbXBsZSB0aGUgQm9vdHN0cmFwXG5cdCAqIGludGVncmF0aW9uIHBsdWctaW4gZm9yIERhdGFUYWJsZXMgdXNlcyBhIHBhZ2luZyBidXR0b24gcmVuZGVyZXIgdG9cblx0ICogZGlzcGxheSBwYWdpbmF0aW9uIGJ1dHRvbnMgaW4gdGhlIG1hcmstdXAgcmVxdWlyZWQgYnkgQm9vdHN0cmFwLlxuXHQgKlxuXHQgKiBGb3IgZnVydGhlciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVuZGVyZXJzIGF2YWlsYWJsZSBzZWVcblx0ICogRGF0YVRhYmxlLmV4dC5yZW5kZXJlclxuXHQgKi9cblx0XCJyZW5kZXJlclwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgZGF0YSBwcm9wZXJ0eSBuYW1lIHRoYXQgRGF0YVRhYmxlcyBzaG91bGQgdXNlIHRvIGdldCBhIHJvdydzIGlkXG5cdCAqIHRvIHNldCBhcyB0aGUgYGlkYCBwcm9wZXJ0eSBpbiB0aGUgbm9kZS5cblx0ICovXG5cdFwicm93SWRcIjogXCJEVF9Sb3dJZFwiLFxuXG5cblx0LyoqXG5cdCAqIENhcHRpb24gdmFsdWVcblx0ICovXG5cdFwiY2FwdGlvblwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIEZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gdXNlIHRoZSBkYXRhIGZyb20gdGhlIERPTSBmb3IgdGhlIGZpcnN0IGRyYXdcblx0ICovXG5cdGlEZWZlckxvYWRpbmc6IG51bGwsXG5cblx0LyoqIEV2ZW50IGxpc3RlbmVycyAqL1xuXHRvbjogbnVsbFxufTtcblxuX2ZuSHVuZ2FyaWFuTWFwKCBEYXRhVGFibGUuZGVmYXVsdHMgKTtcblxuXG5cbi8qXG4gKiBEZXZlbG9wZXIgbm90ZSAtIFNlZSBub3RlIGluIG1vZGVsLmRlZmF1bHRzLmpzIGFib3V0IHRoZSB1c2Ugb2YgSHVuZ2FyaWFuXG4gKiBub3RhdGlvbiBhbmQgY2FtZWwgY2FzZS5cbiAqL1xuXG4vKipcbiAqIENvbHVtbiBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHRvIERhdGFUYWJsZXMgYXQgaW5pdGlhbGlzYXRpb24gdGltZS5cbiAqICBAbmFtZXNwYWNlXG4gKi9cbkRhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4gPSB7XG5cdC8qKlxuXHQgKiBEZWZpbmUgd2hpY2ggY29sdW1uKHMpIGFuIG9yZGVyIHdpbGwgb2NjdXIgb24gZm9yIHRoaXMgY29sdW1uLiBUaGlzXG5cdCAqIGFsbG93cyBhIGNvbHVtbidzIG9yZGVyaW5nIHRvIHRha2UgbXVsdGlwbGUgY29sdW1ucyBpbnRvIGFjY291bnQgd2hlblxuXHQgKiBkb2luZyBhIHNvcnQgb3IgdXNlIHRoZSBkYXRhIGZyb20gYSBkaWZmZXJlbnQgY29sdW1uLiBGb3IgZXhhbXBsZSBmaXJzdFxuXHQgKiBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnMgbWFrZSBzZW5zZSB0byBkbyBhIG11bHRpLWNvbHVtbiBzb3J0IG92ZXIgdGhlXG5cdCAqIHR3byBjb2x1bW5zLlxuXHQgKi9cblx0XCJhRGF0YVNvcnRcIjogbnVsbCxcblx0XCJpRGF0YVNvcnRcIjogLTEsXG5cblx0YXJpYVRpdGxlOiAnJyxcblxuXG5cdC8qKlxuXHQgKiBZb3UgY2FuIGNvbnRyb2wgdGhlIGRlZmF1bHQgb3JkZXJpbmcgZGlyZWN0aW9uLCBhbmQgZXZlbiBhbHRlciB0aGVcblx0ICogYmVoYXZpb3VyIG9mIHRoZSBzb3J0IGhhbmRsZXIgKGkuZS4gb25seSBhbGxvdyBhc2NlbmRpbmcgb3JkZXJpbmcgZXRjKVxuXHQgKiB1c2luZyB0aGlzIHBhcmFtZXRlci5cblx0ICovXG5cdFwiYXNTb3J0aW5nXCI6IFsgJ2FzYycsICdkZXNjJywgJycgXSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb24gdGhlIGRhdGEgaW4gdGhpcyBjb2x1bW4uXG5cdCAqL1xuXHRcImJTZWFyY2hhYmxlXCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgb3JkZXJpbmcgb24gdGhpcyBjb2x1bW4uXG5cdCAqL1xuXHRcImJTb3J0YWJsZVwiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBkaXNwbGF5IG9mIHRoaXMgY29sdW1uLlxuXHQgKi9cblx0XCJiVmlzaWJsZVwiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxuXHQgKiBldGMpIG9yIHByb2Nlc3NlZCBmb3IgaW5wdXQgKERPTSBzb3VyY2UpLiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgY29tcGxpbWVudCB0byBtUmVuZGVyXG5cdCAqIGFsbG93aW5nIHlvdSB0byBtb2RpZnkgdGhlIERPTSBlbGVtZW50IChhZGQgYmFja2dyb3VuZCBjb2xvdXIgZm9yIGV4YW1wbGUpIHdoZW4gdGhlXG5cdCAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxuXHQgKi9cblx0XCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byByZWFkIGRhdGEgZnJvbSBhbnkgZGF0YSBzb3VyY2UgcHJvcGVydHksXG5cdCAqIGluY2x1ZGluZyBkZWVwbHkgbmVzdGVkIG9iamVjdHMgLyBwcm9wZXJ0aWVzLiBgZGF0YWAgY2FuIGJlIGdpdmVuIGluIGFcblx0ICogbnVtYmVyIG9mIGRpZmZlcmVudCB3YXlzIHdoaWNoIGVmZmVjdCBpdHMgYmVoYXZpb3VyOlxuXHQgKlxuXHQgKiAqIGBpbnRlZ2VyYCAtIHRyZWF0ZWQgYXMgYW4gYXJyYXkgaW5kZXggZm9yIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBpcyB0aGVcblx0ICogICBkZWZhdWx0IHRoYXQgRGF0YVRhYmxlcyB1c2VzIChpbmNyZW1lbnRhbGx5IGluY3JlYXNlZCBmb3IgZWFjaCBjb2x1bW4pLlxuXHQgKiAqIGBzdHJpbmdgIC0gcmVhZCBhbiBvYmplY3QgcHJvcGVydHkgZnJvbSB0aGUgZGF0YSBzb3VyY2UuIFRoZXJlIGFyZVxuXHQgKiAgIHRocmVlICdzcGVjaWFsJyBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHN0cmluZyB0byBhbHRlciBob3dcblx0ICogICBEYXRhVGFibGVzIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIHNvdXJjZSBvYmplY3Q6XG5cdCAqICAgICogYC5gIC0gRG90dGVkIEphdmFzY3JpcHQgbm90YXRpb24uIEp1c3QgYXMgeW91IHVzZSBhIGAuYCBpblxuXHQgKiAgICAgIEphdmFzY3JpcHQgdG8gcmVhZCBmcm9tIG5lc3RlZCBvYmplY3RzLCBzbyB0byBjYW4gdGhlIG9wdGlvbnNcblx0ICogICAgICBzcGVjaWZpZWQgaW4gYGRhdGFgLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIudmVyc2lvbmAgb3Jcblx0ICogICAgICBgYnJvd3Nlci5uYW1lYC4gSWYgeW91ciBvYmplY3QgcGFyYW1ldGVyIG5hbWUgY29udGFpbnMgYSBwZXJpb2QsIHVzZVxuXHQgKiAgICAgIGBcXFxcYCB0byBlc2NhcGUgaXQgLSBpLmUuIGBmaXJzdFxcXFwubmFtZWAuXG5cdCAqICAgICogYFtdYCAtIEFycmF5IG5vdGF0aW9uLiBEYXRhVGFibGVzIGNhbiBhdXRvbWF0aWNhbGx5IGNvbWJpbmUgZGF0YVxuXHQgKiAgICAgIGZyb20gYW5kIGFycmF5IHNvdXJjZSwgam9pbmluZyB0aGUgZGF0YSB3aXRoIHRoZSBjaGFyYWN0ZXJzIHByb3ZpZGVkXG5cdCAqICAgICAgYmV0d2VlbiB0aGUgdHdvIGJyYWNrZXRzLiBGb3IgZXhhbXBsZTogYG5hbWVbLCBdYCB3b3VsZCBwcm92aWRlIGFcblx0ICogICAgICBjb21tYS1zcGFjZSBzZXBhcmF0ZWQgbGlzdCBmcm9tIHRoZSBzb3VyY2UgYXJyYXkuIElmIG5vIGNoYXJhY3RlcnNcblx0ICogICAgICBhcmUgcHJvdmlkZWQgYmV0d2VlbiB0aGUgYnJhY2tldHMsIHRoZSBvcmlnaW5hbCBhcnJheSBzb3VyY2UgaXNcblx0ICogICAgICByZXR1cm5lZC5cblx0ICogICAgKiBgKClgIC0gRnVuY3Rpb24gbm90YXRpb24uIEFkZGluZyBgKClgIHRvIHRoZSBlbmQgb2YgYSBwYXJhbWV0ZXIgd2lsbFxuXHQgKiAgICAgIGV4ZWN1dGUgYSBmdW5jdGlvbiBvZiB0aGUgbmFtZSBnaXZlbi4gRm9yIGV4YW1wbGU6IGBicm93c2VyKClgIGZvciBhXG5cdCAqICAgICAgc2ltcGxlIGZ1bmN0aW9uIG9uIHRoZSBkYXRhIHNvdXJjZSwgYGJyb3dzZXIudmVyc2lvbigpYCBmb3IgYVxuXHQgKiAgICAgIGZ1bmN0aW9uIGluIGEgbmVzdGVkIHByb3BlcnR5IG9yIGV2ZW4gYGJyb3dzZXIoKS52ZXJzaW9uYCB0byBnZXQgYW5cblx0ICogICAgICBvYmplY3QgcHJvcGVydHkgaWYgdGhlIGZ1bmN0aW9uIGNhbGxlZCByZXR1cm5zIGFuIG9iamVjdC4gTm90ZSB0aGF0XG5cdCAqICAgICAgZnVuY3Rpb24gbm90YXRpb24gaXMgcmVjb21tZW5kZWQgZm9yIHVzZSBpbiBgcmVuZGVyYCByYXRoZXIgdGhhblxuXHQgKiAgICAgIGBkYXRhYCBhcyBpdCBpcyBtdWNoIHNpbXBsZXIgdG8gdXNlIGFzIGEgcmVuZGVyZXIuXG5cdCAqICogYG51bGxgIC0gdXNlIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyByYXRoZXIgdGhhbiBwbHVja2luZ1xuXHQgKiAgIGRhdGEgZGlyZWN0bHkgZnJvbSBpdC4gVGhpcyBhY3Rpb24gaGFzIGVmZmVjdHMgb24gdHdvIG90aGVyXG5cdCAqICAgaW5pdGlhbGlzYXRpb24gb3B0aW9uczpcblx0ICogICAgKiBgZGVmYXVsdENvbnRlbnRgIC0gV2hlbiBudWxsIGlzIGdpdmVuIGFzIHRoZSBgZGF0YWAgb3B0aW9uIGFuZFxuXHQgKiAgICAgIGBkZWZhdWx0Q29udGVudGAgaXMgc3BlY2lmaWVkIGZvciB0aGUgY29sdW1uLCB0aGUgdmFsdWUgZGVmaW5lZCBieVxuXHQgKiAgICAgIGBkZWZhdWx0Q29udGVudGAgd2lsbCBiZSB1c2VkIGZvciB0aGUgY2VsbC5cblx0ICogICAgKiBgcmVuZGVyYCAtIFdoZW4gbnVsbCBpcyB1c2VkIGZvciB0aGUgYGRhdGFgIG9wdGlvbiBhbmQgdGhlIGByZW5kZXJgXG5cdCAqICAgICAgb3B0aW9uIGlzIHNwZWNpZmllZCBmb3IgdGhlIGNvbHVtbiwgdGhlIHdob2xlIGRhdGEgc291cmNlIGZvciB0aGVcblx0ICogICAgICByb3cgaXMgdXNlZCBmb3IgdGhlIHJlbmRlcmVyLlxuXHQgKiAqIGBmdW5jdGlvbmAgLSB0aGUgZnVuY3Rpb24gZ2l2ZW4gd2lsbCBiZSBleGVjdXRlZCB3aGVuZXZlciBEYXRhVGFibGVzXG5cdCAqICAgbmVlZHMgdG8gc2V0IG9yIGdldCB0aGUgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFRoZSBmdW5jdGlvblxuXHQgKiAgIHRha2VzIHRocmVlIHBhcmFtZXRlcnM6XG5cdCAqICAgICogUGFyYW1ldGVyczpcblx0ICogICAgICAqIGB7YXJyYXl8b2JqZWN0fWAgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgcm93XG5cdCAqICAgICAgKiBge3N0cmluZ31gIFRoZSB0eXBlIGNhbGwgZGF0YSByZXF1ZXN0ZWQgLSB0aGlzIHdpbGwgYmUgJ3NldCcgd2hlblxuXHQgKiAgICAgICAgc2V0dGluZyBkYXRhIG9yICdmaWx0ZXInLCAnZGlzcGxheScsICd0eXBlJywgJ3NvcnQnIG9yIHVuZGVmaW5lZFxuXHQgKiAgICAgICAgd2hlbiBnYXRoZXJpbmcgZGF0YS4gTm90ZSB0aGF0IHdoZW4gYHVuZGVmaW5lZGAgaXMgZ2l2ZW4gZm9yIHRoZVxuXHQgKiAgICAgICAgdHlwZSBEYXRhVGFibGVzIGV4cGVjdHMgdG8gZ2V0IHRoZSByYXcgZGF0YSBmb3IgdGhlIG9iamVjdCBiYWNrPFxuXHQgKiAgICAgICogYHsqfWAgRGF0YSB0byBzZXQgd2hlbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyAnc2V0Jy5cblx0ICogICAgKiBSZXR1cm46XG5cdCAqICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uIGlzIG5vdCByZXF1aXJlZCB3aGVuICdzZXQnIGlzXG5cdCAqICAgICAgICB0aGUgdHlwZSBvZiBjYWxsLCBidXQgb3RoZXJ3aXNlIHRoZSByZXR1cm4gaXMgd2hhdCB3aWxsIGJlIHVzZWRcblx0ICogICAgICAgIGZvciB0aGUgZGF0YSByZXF1ZXN0ZWQuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBgZGF0YWAgaXMgYSBnZXR0ZXIgYW5kIHNldHRlciBvcHRpb24uIElmIHlvdSBqdXN0IHJlcXVpcmVcblx0ICogZm9ybWF0dGluZyBvZiBkYXRhIGZvciBvdXRwdXQsIHlvdSB3aWxsIGxpa2VseSB3YW50IHRvIHVzZSBgcmVuZGVyYCB3aGljaFxuXHQgKiBpcyBzaW1wbHkgYSBnZXR0ZXIgYW5kIHRodXMgc2ltcGxlciB0byB1c2UuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBwcmlvciB0byBEYXRhVGFibGVzIDEuOS4yIGBkYXRhYCB3YXMgY2FsbGVkIGBtRGF0YVByb3BgLiBUaGVcblx0ICogbmFtZSBjaGFuZ2UgcmVmbGVjdHMgdGhlIGZsZXhpYmlsaXR5IG9mIHRoaXMgcHJvcGVydHkgYW5kIGlzIGNvbnNpc3RlbnRcblx0ICogd2l0aCB0aGUgbmFtaW5nIG9mIG1SZW5kZXIuIElmICdtRGF0YVByb3AnIGlzIGdpdmVuLCB0aGVuIGl0IHdpbGwgc3RpbGxcblx0ICogYmUgdXNlZCBieSBEYXRhVGFibGVzLCBhcyBpdCBhdXRvbWF0aWNhbGx5IG1hcHMgdGhlIG9sZCBuYW1lIHRvIHRoZSBuZXdcblx0ICogaWYgcmVxdWlyZWQuXG5cdCAqL1xuXHRcIm1EYXRhXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogVGhpcyBwcm9wZXJ0eSBpcyB0aGUgcmVuZGVyaW5nIHBhcnRuZXIgdG8gYGRhdGFgIGFuZCBpdCBpcyBzdWdnZXN0ZWQgdGhhdFxuXHQgKiB3aGVuIHlvdSB3YW50IHRvIG1hbmlwdWxhdGUgZGF0YSBmb3IgZGlzcGxheSAoaW5jbHVkaW5nIGZpbHRlcmluZyxcblx0ICogc29ydGluZyBldGMpIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIHVuZGVybHlpbmcgZGF0YSBmb3IgdGhlIHRhYmxlLCB1c2UgdGhpc1xuXHQgKiBwcm9wZXJ0eS4gYHJlbmRlcmAgY2FuIGJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIHRoZSByZWFkIG9ubHkgY29tcGFuaW9uIHRvXG5cdCAqIGBkYXRhYCB3aGljaCBpcyByZWFkIC8gd3JpdGUgKHRoZW4gYXMgc3VjaCBtb3JlIGNvbXBsZXgpLiBMaWtlIGBkYXRhYFxuXHQgKiB0aGlzIG9wdGlvbiBjYW4gYmUgZ2l2ZW4gaW4gYSBudW1iZXIgb2YgZGlmZmVyZW50IHdheXMgdG8gZWZmZWN0IGl0c1xuXHQgKiBiZWhhdmlvdXI6XG5cdCAqXG5cdCAqICogYGludGVnZXJgIC0gdHJlYXRlZCBhcyBhbiBhcnJheSBpbmRleCBmb3IgdGhlIGRhdGEgc291cmNlLiBUaGlzIGlzIHRoZVxuXHQgKiAgIGRlZmF1bHQgdGhhdCBEYXRhVGFibGVzIHVzZXMgKGluY3JlbWVudGFsbHkgaW5jcmVhc2VkIGZvciBlYWNoIGNvbHVtbikuXG5cdCAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXG5cdCAqICAgdGhyZWUgJ3NwZWNpYWwnIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgc3RyaW5nIHRvIGFsdGVyIGhvd1xuXHQgKiAgIERhdGFUYWJsZXMgcmVhZHMgdGhlIGRhdGEgZnJvbSB0aGUgc291cmNlIG9iamVjdDpcblx0ICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXG5cdCAqICAgICAgSmF2YXNjcmlwdCB0byByZWFkIGZyb20gbmVzdGVkIG9iamVjdHMsIHNvIHRvIGNhbiB0aGUgb3B0aW9uc1xuXHQgKiAgICAgIHNwZWNpZmllZCBpbiBgZGF0YWAuIEZvciBleGFtcGxlOiBgYnJvd3Nlci52ZXJzaW9uYCBvclxuXHQgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXG5cdCAqICAgICAgYFxcXFxgIHRvIGVzY2FwZSBpdCAtIGkuZS4gYGZpcnN0XFxcXC5uYW1lYC5cblx0ICogICAgKiBgW11gIC0gQXJyYXkgbm90YXRpb24uIERhdGFUYWJsZXMgY2FuIGF1dG9tYXRpY2FsbHkgY29tYmluZSBkYXRhXG5cdCAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcblx0ICogICAgICBiZXR3ZWVuIHRoZSB0d28gYnJhY2tldHMuIEZvciBleGFtcGxlOiBgbmFtZVssIF1gIHdvdWxkIHByb3ZpZGUgYVxuXHQgKiAgICAgIGNvbW1hLXNwYWNlIHNlcGFyYXRlZCBsaXN0IGZyb20gdGhlIHNvdXJjZSBhcnJheS4gSWYgbm8gY2hhcmFjdGVyc1xuXHQgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xuXHQgKiAgICAgIHJldHVybmVkLlxuXHQgKiAgICAqIGAoKWAgLSBGdW5jdGlvbiBub3RhdGlvbi4gQWRkaW5nIGAoKWAgdG8gdGhlIGVuZCBvZiBhIHBhcmFtZXRlciB3aWxsXG5cdCAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcblx0ICogICAgICBzaW1wbGUgZnVuY3Rpb24gb24gdGhlIGRhdGEgc291cmNlLCBgYnJvd3Nlci52ZXJzaW9uKClgIGZvciBhXG5cdCAqICAgICAgZnVuY3Rpb24gaW4gYSBuZXN0ZWQgcHJvcGVydHkgb3IgZXZlbiBgYnJvd3NlcigpLnZlcnNpb25gIHRvIGdldCBhblxuXHQgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LlxuXHQgKiAqIGBvYmplY3RgIC0gdXNlIGRpZmZlcmVudCBkYXRhIGZvciB0aGUgZGlmZmVyZW50IGRhdGEgdHlwZXMgcmVxdWVzdGVkIGJ5XG5cdCAqICAgRGF0YVRhYmxlcyAoJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnIG9yICdzb3J0JykuIFRoZSBwcm9wZXJ0eSBuYW1lc1xuXHQgKiAgIG9mIHRoZSBvYmplY3QgaXMgdGhlIGRhdGEgdHlwZSB0aGUgcHJvcGVydHkgcmVmZXJzIHRvIGFuZCB0aGUgdmFsdWUgY2FuXG5cdCAqICAgZGVmaW5lZCB1c2luZyBhbiBpbnRlZ2VyLCBzdHJpbmcgb3IgZnVuY3Rpb24gdXNpbmcgdGhlIHNhbWUgcnVsZXMgYXNcblx0ICogICBgcmVuZGVyYCBub3JtYWxseSBkb2VzLiBOb3RlIHRoYXQgYW4gYF9gIG9wdGlvbiBfbXVzdF8gYmUgc3BlY2lmaWVkLlxuXHQgKiAgIFRoaXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHlvdSBoYXZlbid0IHNwZWNpZmllZCBhIHZhbHVlIGZvclxuXHQgKiAgIHRoZSBkYXRhIHR5cGUgcmVxdWVzdGVkIGJ5IERhdGFUYWJsZXMuXG5cdCAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcblx0ICogICBuZWVkcyB0byBzZXQgb3IgZ2V0IHRoZSBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gVGhlIGZ1bmN0aW9uXG5cdCAqICAgdGFrZXMgdGhyZWUgcGFyYW1ldGVyczpcblx0ICogICAgKiBQYXJhbWV0ZXJzOlxuXHQgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGRhdGEgc291cmNlIGZvciB0aGUgcm93IChiYXNlZCBvbiBgZGF0YWApXG5cdCAqICAgICAgKiB7c3RyaW5nfSBUaGUgdHlwZSBjYWxsIGRhdGEgcmVxdWVzdGVkIC0gdGhpcyB3aWxsIGJlICdmaWx0ZXInLFxuXHQgKiAgICAgICAgJ2Rpc3BsYXknLCAndHlwZScgb3IgJ3NvcnQnLlxuXHQgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGZ1bGwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgKG5vdCBiYXNlZCBvblxuXHQgKiAgICAgICAgYGRhdGFgKVxuXHQgKiAgICAqIFJldHVybjpcblx0ICogICAgICAqIFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24gaXMgd2hhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZVxuXHQgKiAgICAgICAgZGF0YSByZXF1ZXN0ZWQuXG5cdCAqL1xuXHRcIm1SZW5kZXJcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBDaGFuZ2UgdGhlIGNlbGwgdHlwZSBjcmVhdGVkIGZvciB0aGUgY29sdW1uIC0gZWl0aGVyIFREIGNlbGxzIG9yIFRIIGNlbGxzLiBUaGlzXG5cdCAqIGNhbiBiZSB1c2VmdWwgYXMgVEggY2VsbHMgaGF2ZSBzZW1hbnRpYyBtZWFuaW5nIGluIHRoZSB0YWJsZSBib2R5LCBhbGxvd2luZyB0aGVtXG5cdCAqIHRvIGFjdCBhcyBhIGhlYWRlciBmb3IgYSByb3cgKHlvdSBtYXkgd2lzaCB0byBhZGQgc2NvcGU9J3JvdycgdG8gdGhlIFRIIGVsZW1lbnRzKS5cblx0ICovXG5cdFwic0NlbGxUeXBlXCI6IFwidGRcIixcblxuXG5cdC8qKlxuXHQgKiBDbGFzcyB0byBnaXZlIHRvIGVhY2ggY2VsbCBpbiB0aGlzIGNvbHVtbi5cblx0ICovXG5cdFwic0NsYXNzXCI6IFwiXCIsXG5cblx0LyoqXG5cdCAqIFdoZW4gRGF0YVRhYmxlcyBjYWxjdWxhdGVzIHRoZSBjb2x1bW4gd2lkdGhzIHRvIGFzc2lnbiB0byBlYWNoIGNvbHVtbixcblx0ICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxuXHQgKiB0ZW1wb3JhcnkgdGFibGUgYW5kIHJlYWRzIHRoZSB3aWR0aHMgZnJvbSB0aGF0LiBUaGUgcHJvYmxlbSB3aXRoIHRoaXNcblx0ICogaXMgdGhhdCBcIm1tbVwiIGlzIG11Y2ggd2lkZXIgdGhlbiBcImlpaWlcIiwgYnV0IHRoZSBsYXR0ZXIgaXMgYSBsb25nZXJcblx0ICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xuXHQgKiBpdCBpbnRvIGFuIERPTSBvYmplY3QgYW5kIG1lYXN1cmluZyB0aGF0IGlzIGhvcnJpYmx5KCEpIHNsb3cpLiBUaHVzIGFzXG5cdCAqIGEgXCJ3b3JrIGFyb3VuZFwiIHdlIHByb3ZpZGUgdGhpcyBvcHRpb24uIEl0IHdpbGwgYXBwZW5kIGl0cyB2YWx1ZSB0byB0aGVcblx0ICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cblx0ICogR2VuZXJhbGx5IHlvdSBzaG91bGRuJ3QgbmVlZCB0aGlzIVxuXHQgKi9cblx0XCJzQ29udGVudFBhZGRpbmdcIjogXCJcIixcblxuXG5cdC8qKlxuXHQgKiBBbGxvd3MgYSBkZWZhdWx0IHZhbHVlIHRvIGJlIGdpdmVuIGZvciBhIGNvbHVtbidzIGRhdGEsIGFuZCB3aWxsIGJlIHVzZWRcblx0ICogd2hlbmV2ZXIgYSBudWxsIGRhdGEgc291cmNlIGlzIGVuY291bnRlcmVkICh0aGlzIGNhbiBiZSBiZWNhdXNlIGBkYXRhYFxuXHQgKiBpcyBzZXQgdG8gbnVsbCwgb3IgYmVjYXVzZSB0aGUgZGF0YSBzb3VyY2UgaXRzZWxmIGlzIG51bGwpLlxuXHQgKi9cblx0XCJzRGVmYXVsdENvbnRlbnRcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHVzZWQgaW4gRGF0YVRhYmxlcycgc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gSXQgY2FuXG5cdCAqIGJlIGV4Y2VwdGlvbmFsbHkgdXNlZnVsIHRvIGtub3cgd2hhdCBjb2x1bW5zIGFyZSBiZWluZyBkaXNwbGF5ZWQgb24gdGhlXG5cdCAqIGNsaWVudCBzaWRlLCBhbmQgdG8gbWFwIHRoZXNlIHRvIGRhdGFiYXNlIGZpZWxkcy4gV2hlbiBkZWZpbmVkLCB0aGUgbmFtZXNcblx0ICogYWxzbyBhbGxvdyBEYXRhVGFibGVzIHRvIHJlb3JkZXIgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VydmVyIGlmIGl0IGNvbWVzXG5cdCAqIGJhY2sgaW4gYW4gdW5leHBlY3RlZCBvcmRlciAoaS5lLiBpZiB5b3Ugc3dpdGNoIHlvdXIgY29sdW1ucyBhcm91bmQgb24gdGhlXG5cdCAqIGNsaWVudC1zaWRlLCB5b3VyIHNlcnZlci1zaWRlIGNvZGUgZG9lcyBub3QgYWxzbyBuZWVkIHVwZGF0aW5nKS5cblx0ICovXG5cdFwic05hbWVcIjogXCJcIixcblxuXG5cdC8qKlxuXHQgKiBEZWZpbmVzIGEgZGF0YSBzb3VyY2UgdHlwZSBmb3IgdGhlIG9yZGVyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlYWRcblx0ICogcmVhbC10aW1lIGluZm9ybWF0aW9uIGZyb20gdGhlIHRhYmxlICh1cGRhdGluZyB0aGUgaW50ZXJuYWxseSBjYWNoZWRcblx0ICogdmVyc2lvbikgcHJpb3IgdG8gb3JkZXJpbmcuIFRoaXMgYWxsb3dzIG9yZGVyaW5nIHRvIG9jY3VyIG9uIHVzZXJcblx0ICogZWRpdGFibGUgZWxlbWVudHMgc3VjaCBhcyBmb3JtIGlucHV0cy5cblx0ICovXG5cdFwic1NvcnREYXRhVHlwZVwiOiBcInN0ZFwiLFxuXG5cblx0LyoqXG5cdCAqIFRoZSB0aXRsZSBvZiB0aGlzIGNvbHVtbi5cblx0ICovXG5cdFwic1RpdGxlXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogVGhlIHR5cGUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGhvdyB0aGUgZGF0YSBmb3IgdGhpcyBjb2x1bW4gd2lsbCBiZVxuXHQgKiBvcmRlcmVkLiBGb3VyIHR5cGVzIChzdHJpbmcsIG51bWVyaWMsIGRhdGUgYW5kIGh0bWwgKHdoaWNoIHdpbGwgc3RyaXBcblx0ICogSFRNTCB0YWdzIGJlZm9yZSBvcmRlcmluZykpIGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlLiBOb3RlIHRoYXQgb25seSBkYXRlXG5cdCAqIGZvcm1hdHMgdW5kZXJzdG9vZCBieSBKYXZhc2NyaXB0J3MgRGF0ZSgpIG9iamVjdCB3aWxsIGJlIGFjY2VwdGVkIGFzIHR5cGVcblx0ICogZGF0ZS4gRm9yIGV4YW1wbGU6IFwiTWFyIDI2LCAyMDA4IDU6MDMgUE1cIi4gTWF5IHRha2UgdGhlIHZhbHVlczogJ3N0cmluZycsXG5cdCAqICdudW1lcmljJywgJ2RhdGUnIG9yICdodG1sJyAoYnkgZGVmYXVsdCkuIEZ1cnRoZXIgdHlwZXMgY2FuIGJlIGFkZGluZ1xuXHQgKiB0aHJvdWdoIHBsdWctaW5zLlxuXHQgKi9cblx0XCJzVHlwZVwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIERlZmluaW5nIHRoZSB3aWR0aCBvZiB0aGUgY29sdW1uLCB0aGlzIHBhcmFtZXRlciBtYXkgdGFrZSBhbnkgQ1NTIHZhbHVlXG5cdCAqICgzZW0sIDIwcHggZXRjKS4gRGF0YVRhYmxlcyBhcHBsaWVzICdzbWFydCcgd2lkdGhzIHRvIGNvbHVtbnMgd2hpY2ggaGF2ZSBub3Rcblx0ICogYmVlbiBnaXZlbiBhIHNwZWNpZmljIHdpZHRoIHRocm91Z2ggdGhpcyBpbnRlcmZhY2UgZW5zdXJpbmcgdGhhdCB0aGUgdGFibGVcblx0ICogcmVtYWlucyByZWFkYWJsZS5cblx0ICovXG5cdFwic1dpZHRoXCI6IG51bGxcbn07XG5cbl9mbkh1bmdhcmlhbk1hcCggRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbiApO1xuXG5cblxuLyoqXG4gKiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCAtIHRoaXMgaG9sZHMgYWxsIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIGFcbiAqIGdpdmVuIHRhYmxlLCBpbmNsdWRpbmcgY29uZmlndXJhdGlvbiwgZGF0YSBhbmQgY3VycmVudCBhcHBsaWNhdGlvbiBvZiB0aGVcbiAqIHRhYmxlIG9wdGlvbnMuIERhdGFUYWJsZXMgZG9lcyBub3QgaGF2ZSBhIHNpbmdsZSBpbnN0YW5jZSBmb3IgZWFjaCBEYXRhVGFibGVcbiAqIHdpdGggdGhlIHNldHRpbmdzIGF0dGFjaGVkIHRvIHRoYXQgaW5zdGFuY2UsIGJ1dCByYXRoZXIgaW5zdGFuY2VzIG9mIHRoZVxuICogRGF0YVRhYmxlIFwiY2xhc3NcIiBhcmUgY3JlYXRlZCBvbi10aGUtZmx5IGFzIG5lZWRlZCAodHlwaWNhbGx5IGJ5IGFcbiAqICQoKS5kYXRhVGFibGUoKSBjYWxsKSBhbmQgdGhlIHNldHRpbmdzIG9iamVjdCBpcyB0aGVuIGFwcGxpZWQgdG8gdGhhdFxuICogaW5zdGFuY2UuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgb2JqZWN0IGlzIHJlbGF0ZWQgdG8ge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30gYnV0IHRoaXNcbiAqIG9uZSBpcyB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBmb3IgRGF0YVRhYmxlcydzIGNhY2hlIG9mIGNvbHVtbnMuIEl0IHNob3VsZFxuICogTk9UIGJlIG1hbmlwdWxhdGVkIG91dHNpZGUgb2YgRGF0YVRhYmxlcy4gQW55IGNvbmZpZ3VyYXRpb24gc2hvdWxkIGJlIGRvbmVcbiAqIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXG4gKi9cbkRhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzID0ge1xuXHQvKipcblx0ICogUHJpbWFyeSBmZWF0dXJlcyBvZiBEYXRhVGFibGVzIGFuZCB0aGVpciBlbmFibGVtZW50IHN0YXRlLlxuXHQgKi9cblx0XCJvRmVhdHVyZXNcIjoge1xuXG5cdFx0LyoqXG5cdFx0ICogRmxhZyB0byBzYXkgaWYgRGF0YVRhYmxlcyBzaG91bGQgYXV0b21hdGljYWxseSB0cnkgdG8gY2FsY3VsYXRlIHRoZVxuXHRcdCAqIG9wdGltdW0gdGFibGUgYW5kIGNvbHVtbnMgd2lkdGhzICh0cnVlKSBvciBub3QgKGZhbHNlKS5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJiQXV0b1dpZHRoXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBEZWxheSB0aGUgY3JlYXRpb24gb2YgVFIgYW5kIFREIGVsZW1lbnRzIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5XG5cdFx0ICogbmVlZGVkIGJ5IGEgZHJpdmVuIHBhZ2UgZHJhdy4gVGhpcyBjYW4gZ2l2ZSBhIHNpZ25pZmljYW50IHNwZWVkXG5cdFx0ICogaW5jcmVhc2UgZm9yIEFqYXggc291cmNlIGFuZCBKYXZhc2NyaXB0IHNvdXJjZSBkYXRhLCBidXQgbWFrZXMgbm9cblx0XHQgKiBkaWZmZXJlbmNlIGF0IGFsbCBmb3IgRE9NIGFuZCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRhYmxlcy5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJiRGVmZXJSZW5kZXJcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSBmaWx0ZXJpbmcgb24gdGhlIHRhYmxlIG9yIG5vdC4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgZGlzYWJsZWRcblx0XHQgKiB0aGVuIHRoZXJlIGlzIG5vIGZpbHRlcmluZyBhdCBhbGwgb24gdGhlIHRhYmxlLCBpbmNsdWRpbmcgZm5GaWx0ZXIuXG5cdFx0ICogVG8ganVzdCByZW1vdmUgdGhlIGZpbHRlcmluZyBpbnB1dCB1c2Ugc0RvbSBhbmQgcmVtb3ZlIHRoZSAnZicgb3B0aW9uLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcImJGaWx0ZXJcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFVzZWQgb25seSBmb3IgY29tcGF0aWJsaXR5IHdpdGggRFQxXG5cdFx0ICogQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRcImJJbmZvXCI6IHRydWUsXG5cblx0XHQvKipcblx0XHQgKiBVc2VkIG9ubHkgZm9yIGNvbXBhdGlibGl0eSB3aXRoIERUMVxuXHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0ICovXG5cdFx0XCJiTGVuZ3RoQ2hhbmdlXCI6IHRydWUsXG5cblx0XHQvKipcblx0XHQgKiBQYWdpbmF0aW9uIGVuYWJsZWQgb3Igbm90LiBOb3RlIHRoYXQgaWYgdGhpcyBpcyBkaXNhYmxlZCB0aGVuIGxlbmd0aFxuXHRcdCAqIGNoYW5naW5nIG11c3QgYWxzbyBiZSBkaXNhYmxlZC5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJiUGFnaW5hdGVcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFByb2Nlc3NpbmcgaW5kaWNhdG9yIGVuYWJsZSBmbGFnIHdoZW5ldmVyIERhdGFUYWJsZXMgaXMgZW5hY3RpbmcgYVxuXHRcdCAqIHVzZXIgcmVxdWVzdCAtIHR5cGljYWxseSBhbiBBamF4IHJlcXVlc3QgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwiYlByb2Nlc3NpbmdcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgZW5hYmxlZCBmbGFnIC0gd2hlbiBlbmFibGVkIERhdGFUYWJsZXMgd2lsbFxuXHRcdCAqIGdldCBhbGwgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgZm9yIGV2ZXJ5IGRyYXcgLSB0aGVyZSBpcyBubyBmaWx0ZXJpbmcsXG5cdFx0ICogc29ydGluZyBvciBwYWdpbmcgZG9uZSBvbiB0aGUgY2xpZW50LXNpZGUuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwiYlNlcnZlclNpZGVcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFNvcnRpbmcgZW5hYmxlbWVudCBmbGFnLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcImJTb3J0XCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBNdWx0aS1jb2x1bW4gc29ydGluZ1xuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcImJTb3J0TXVsdGlcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIEFwcGx5IGEgY2xhc3MgdG8gdGhlIGNvbHVtbnMgd2hpY2ggYXJlIGJlaW5nIHNvcnRlZCB0byBwcm92aWRlIGFcblx0XHQgKiB2aXN1YWwgaGlnaGxpZ2h0IG9yIG5vdC4gVGhpcyBjYW4gc2xvdyB0aGluZ3MgZG93biB3aGVuIGVuYWJsZWQgc2luY2Vcblx0XHQgKiB0aGVyZSBpcyBhIGxvdCBvZiBET00gaW50ZXJhY3Rpb24uXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwiYlNvcnRDbGFzc2VzXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBTdGF0ZSBzYXZpbmcgZW5hYmxlbWVudCBmbGFnLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcImJTdGF0ZVNhdmVcIjogbnVsbFxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIFNjcm9sbGluZyBzZXR0aW5ncyBmb3IgYSB0YWJsZS5cblx0ICovXG5cdFwib1Njcm9sbFwiOiB7XG5cdFx0LyoqXG5cdFx0ICogV2hlbiB0aGUgdGFibGUgaXMgc2hvcnRlciBpbiBoZWlnaHQgdGhhbiBzU2Nyb2xsWSwgY29sbGFwc2UgdGhlXG5cdFx0ICogdGFibGUgY29udGFpbmVyIGRvd24gdG8gdGhlIGhlaWdodCBvZiB0aGUgdGFibGUgKHdoZW4gdHJ1ZSkuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwiYkNvbGxhcHNlXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBXaWR0aCBvZiB0aGUgc2Nyb2xsYmFyIGZvciB0aGUgd2ViLWJyb3dzZXIncyBwbGF0Zm9ybS4gQ2FsY3VsYXRlZFxuXHRcdCAqIGR1cmluZyB0YWJsZSBpbml0aWFsaXNhdGlvbi5cblx0XHQgKi9cblx0XHRcImlCYXJXaWR0aFwiOiAwLFxuXG5cdFx0LyoqXG5cdFx0ICogVmlld3BvcnQgd2lkdGggZm9yIGhvcml6b250YWwgc2Nyb2xsaW5nLiBIb3Jpem9udGFsIHNjcm9sbGluZyBpc1xuXHRcdCAqIGRpc2FibGVkIGlmIGFuIGVtcHR5IHN0cmluZy5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJzWFwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogV2lkdGggdG8gZXhwYW5kIHRoZSB0YWJsZSB0byB3aGVuIHVzaW5nIHgtc2Nyb2xsaW5nLiBUeXBpY2FsbHkgeW91XG5cdFx0ICogc2hvdWxkIG5vdCBuZWVkIHRvIHVzZSB0aGlzLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKiAgQGRlcHJlY2F0ZWRcblx0XHQgKi9cblx0XHRcInNYSW5uZXJcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFZpZXdwb3J0IGhlaWdodCBmb3IgdmVydGljYWwgc2Nyb2xsaW5nLiBWZXJ0aWNhbCBzY3JvbGxpbmcgaXMgZGlzYWJsZWRcblx0XHQgKiBpZiBhbiBlbXB0eSBzdHJpbmcuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwic1lcIjogbnVsbFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBMYW5ndWFnZSBpbmZvcm1hdGlvbiBmb3IgdGhlIHRhYmxlLlxuXHQgKi9cblx0XCJvTGFuZ3VhZ2VcIjoge1xuXHRcdC8qKlxuXHRcdCAqIEluZm9ybWF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uLiBTZWVcblx0XHQgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmZuSW5mb0NhbGxiYWNrfVxuXHRcdCAqL1xuXHRcdFwiZm5JbmZvQ2FsbGJhY2tcIjogbnVsbFxuXHR9LFxuXG5cdC8qKlxuXHQgKiBCcm93c2VyIHN1cHBvcnQgcGFyYW1ldGVyc1xuXHQgKi9cblx0XCJvQnJvd3NlclwiOiB7XG5cdFx0LyoqXG5cdFx0ICogRGV0ZXJtaW5lIGlmIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaXMgb24gdGhlIHJpZ2h0IG9yIGxlZnQgb2YgdGhlXG5cdFx0ICogc2Nyb2xsaW5nIGNvbnRhaW5lciAtIG5lZWRlZCBmb3IgcnRsIGxhbmd1YWdlIGxheW91dCwgYWx0aG91Z2ggbm90XG5cdFx0ICogYWxsIGJyb3dzZXJzIG1vdmUgdGhlIHNjcm9sbGJhciAoU2FmYXJpKS5cblx0XHQgKi9cblx0XHRcImJTY3JvbGxiYXJMZWZ0XCI6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0ICogQnJvd3NlciBzY3JvbGxiYXIgd2lkdGhcblx0XHQgKi9cblx0XHRcImJhcldpZHRoXCI6IDBcblx0fSxcblxuXG5cdFwiYWpheFwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIEFycmF5IHJlZmVyZW5jaW5nIHRoZSBub2RlcyB3aGljaCBhcmUgdXNlZCBmb3IgdGhlIGZlYXR1cmVzLiBUaGVcblx0ICogcGFyYW1ldGVycyBvZiB0aGlzIG9iamVjdCBtYXRjaCB3aGF0IGlzIGFsbG93ZWQgYnkgc0RvbSAtIGkuZS5cblx0ICogICA8dWw+XG5cdCAqICAgICA8bGk+J2wnIC0gTGVuZ3RoIGNoYW5naW5nPC9saT5cblx0ICogICAgIDxsaT4nZicgLSBGaWx0ZXJpbmcgaW5wdXQ8L2xpPlxuXHQgKiAgICAgPGxpPid0JyAtIFRoZSB0YWJsZSE8L2xpPlxuXHQgKiAgICAgPGxpPidpJyAtIEluZm9ybWF0aW9uPC9saT5cblx0ICogICAgIDxsaT4ncCcgLSBQYWdpbmF0aW9uPC9saT5cblx0ICogICAgIDxsaT4ncicgLSBwUm9jZXNzaW5nPC9saT5cblx0ICogICA8L3VsPlxuXHQgKi9cblx0XCJhYW5GZWF0dXJlc1wiOiBbXSxcblxuXHQvKipcblx0ICogU3RvcmUgZGF0YSBpbmZvcm1hdGlvbiAtIHNlZSB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vUm93fSBmb3IgZGV0YWlsZWRcblx0ICogaW5mb3JtYXRpb24uXG5cdCAqL1xuXHRcImFvRGF0YVwiOiBbXSxcblxuXHQvKipcblx0ICogQXJyYXkgb2YgaW5kZXhlcyB3aGljaCBhcmUgaW4gdGhlIGN1cnJlbnQgZGlzcGxheSAoYWZ0ZXIgZmlsdGVyaW5nIGV0Yylcblx0ICovXG5cdFwiYWlEaXNwbGF5XCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBpbmRleGVzIGZvciBkaXNwbGF5IC0gbm8gZmlsdGVyaW5nXG5cdCAqL1xuXHRcImFpRGlzcGxheU1hc3RlclwiOiBbXSxcblxuXHQvKipcblx0ICogTWFwIG9mIHJvdyBpZHMgdG8gZGF0YSBpbmRleGVzXG5cdCAqL1xuXHRcImFJZHNcIjoge30sXG5cblx0LyoqXG5cdCAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggY29sdW1uIHRoYXQgaXMgaW4gdXNlXG5cdCAqL1xuXHRcImFvQ29sdW1uc1wiOiBbXSxcblxuXHQvKipcblx0ICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlJ3MgaGVhZGVyXG5cdCAqL1xuXHRcImFvSGVhZGVyXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUncyBmb290ZXJcblx0ICovXG5cdFwiYW9Gb290ZXJcIjogW10sXG5cblx0LyoqXG5cdCAqIFN0b3JlIHRoZSBhcHBsaWVkIGdsb2JhbCBzZWFyY2ggaW5mb3JtYXRpb24gaW4gY2FzZSB3ZSB3YW50IHRvIGZvcmNlIGFcblx0ICogcmVzZWFyY2ggb3IgY29tcGFyZSB0aGUgb2xkIHNlYXJjaCB0byBhIG5ldyBvbmUuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqL1xuXHRcIm9QcmV2aW91c1NlYXJjaFwiOiB7fSxcblxuXHQvKipcblx0ICogU3RvcmUgZm9yIG5hbWVkIHNlYXJjaGVzXG5cdCAqL1xuXHRzZWFyY2hGaXhlZDoge30sXG5cblx0LyoqXG5cdCAqIFN0b3JlIHRoZSBhcHBsaWVkIHNlYXJjaCBmb3IgZWFjaCBjb2x1bW4gLSBzZWVcblx0ICoge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaH0gZm9yIHRoZSBmb3JtYXQgdGhhdCBpcyB1c2VkIGZvciB0aGVcblx0ICogZmlsdGVyaW5nIGluZm9ybWF0aW9uIGZvciBlYWNoIGNvbHVtbi5cblx0ICovXG5cdFwiYW9QcmVTZWFyY2hDb2xzXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBTb3J0aW5nIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgdGFibGUuIE5vdGUgdGhhdCB0aGUgaW5uZXIgYXJyYXlzIGFyZVxuXHQgKiB1c2VkIGluIHRoZSBmb2xsb3dpbmcgbWFubmVyOlxuXHQgKiA8dWw+XG5cdCAqICAgPGxpPkluZGV4IDAgLSBjb2x1bW4gbnVtYmVyPC9saT5cblx0ICogICA8bGk+SW5kZXggMSAtIGN1cnJlbnQgc29ydGluZyBkaXJlY3Rpb248L2xpPlxuXHQgKiA8L3VsPlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKi9cblx0XCJhYVNvcnRpbmdcIjogbnVsbCxcblxuXHQvKipcblx0ICogU29ydGluZyB0aGF0IGlzIGFsd2F5cyBhcHBsaWVkIHRvIHRoZSB0YWJsZSAoaS5lLiBwcmVmaXhlZCBpbiBmcm9udCBvZlxuXHQgKiBhYVNvcnRpbmcpLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKi9cblx0XCJhYVNvcnRpbmdGaXhlZFwiOiBbXSxcblxuXHQvKipcblx0ICogSWYgcmVzdG9yaW5nIGEgdGFibGUgLSB3ZSBzaG91bGQgcmVzdG9yZSBpdHMgd2lkdGhcblx0ICovXG5cdFwic0Rlc3Ryb3lXaWR0aFwiOiAwLFxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayBmdW5jdGlvbnMgYXJyYXkgZm9yIGV2ZXJ5IHRpbWUgYSByb3cgaXMgaW5zZXJ0ZWQgKGkuZS4gb24gYSBkcmF3KS5cblx0ICovXG5cdFwiYW9Sb3dDYWxsYmFja1wiOiBbXSxcblxuXHQvKipcblx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgaGVhZGVyIG9uIGVhY2ggZHJhdy5cblx0ICovXG5cdFwiYW9IZWFkZXJDYWxsYmFja1wiOiBbXSxcblxuXHQvKipcblx0ICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHRoZSBmb290ZXIgb24gZWFjaCBkcmF3LlxuXHQgKi9cblx0XCJhb0Zvb3RlckNhbGxiYWNrXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIGRyYXcgY2FsbGJhY2sgZnVuY3Rpb25zXG5cdCAqL1xuXHRcImFvRHJhd0NhbGxiYWNrXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHJvdyBjcmVhdGVkIGZ1bmN0aW9uXG5cdCAqL1xuXHRcImFvUm93Q3JlYXRlZENhbGxiYWNrXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayBmdW5jdGlvbnMgZm9yIGp1c3QgYmVmb3JlIHRoZSB0YWJsZSBpcyByZWRyYXduLiBBIHJldHVybiBvZlxuXHQgKiBmYWxzZSB3aWxsIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3LlxuXHQgKi9cblx0XCJhb1ByZURyYXdDYWxsYmFja1wiOiBbXSxcblxuXHQvKipcblx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciB3aGVuIHRoZSB0YWJsZSBoYXMgYmVlbiBpbml0aWFsaXNlZC5cblx0ICovXG5cdFwiYW9Jbml0Q29tcGxldGVcIjogW10sXG5cblxuXHQvKipcblx0ICogQ2FsbGJhY2tzIGZvciBtb2RpZnlpbmcgdGhlIHNldHRpbmdzIHRvIGJlIHN0b3JlZCBmb3Igc3RhdGUgc2F2aW5nLCBwcmlvciB0b1xuXHQgKiBzYXZpbmcgc3RhdGUuXG5cdCAqL1xuXHRcImFvU3RhdGVTYXZlUGFyYW1zXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBDYWxsYmFja3MgZm9yIG1vZGlmeWluZyB0aGUgc2V0dGluZ3MgdGhhdCBoYXZlIGJlZW4gc3RvcmVkIGZvciBzdGF0ZSBzYXZpbmdcblx0ICogcHJpb3IgdG8gdXNpbmcgdGhlIHN0b3JlZCB2YWx1ZXMgdG8gcmVzdG9yZSB0aGUgc3RhdGUuXG5cdCAqL1xuXHRcImFvU3RhdGVMb2FkUGFyYW1zXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBDYWxsYmFja3MgZm9yIG9wZXJhdGluZyBvbiB0aGUgc2V0dGluZ3Mgb2JqZWN0IG9uY2UgdGhlIHNhdmVkIHN0YXRlIGhhcyBiZWVuXG5cdCAqIGxvYWRlZFxuXHQgKi9cblx0XCJhb1N0YXRlTG9hZGVkXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBDYWNoZSB0aGUgdGFibGUgSUQgZm9yIHF1aWNrIGFjY2Vzc1xuXHQgKi9cblx0XCJzVGFibGVJZFwiOiBcIlwiLFxuXG5cdC8qKlxuXHQgKiBUaGUgVEFCTEUgbm9kZSBmb3IgdGhlIG1haW4gdGFibGVcblx0ICovXG5cdFwiblRhYmxlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRoZWFkIGVsZW1lbnRcblx0ICovXG5cdFwiblRIZWFkXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRmb290IGVsZW1lbnQgLSBpZiBpdCBleGlzdHNcblx0ICovXG5cdFwiblRGb290XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRib2R5IGVsZW1lbnRcblx0ICovXG5cdFwiblRCb2R5XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIENhY2hlIHRoZSB3cmFwcGVyIG5vZGUgKGNvbnRhaW5zIGFsbCBEYXRhVGFibGVzIGNvbnRyb2xsZWQgZWxlbWVudHMpXG5cdCAqL1xuXHRcIm5UYWJsZVdyYXBwZXJcIjogbnVsbCxcblxuXHQvKipcblx0ICogSW5kaWNhdGUgaWYgYWxsIHJlcXVpcmVkIGluZm9ybWF0aW9uIGhhcyBiZWVuIHJlYWQgaW5cblx0ICovXG5cdFwiYkluaXRpYWxpc2VkXCI6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBJbmZvcm1hdGlvbiBhYm91dCBvcGVuIHJvd3MuIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheSBoYXMgdGhlIHBhcmFtZXRlcnNcblx0ICogJ25UcicgYW5kICduUGFyZW50J1xuXHQgKi9cblx0XCJhb09wZW5Sb3dzXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBEaWN0YXRlIHRoZSBwb3NpdGlvbmluZyBvZiBEYXRhVGFibGVzJyBjb250cm9sIGVsZW1lbnRzIC0gc2VlXG5cdCAqIHtAbGluayBEYXRhVGFibGUubW9kZWwub0luaXQuc0RvbX0uXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqL1xuXHRcInNEb21cIjogbnVsbCxcblxuXHQvKipcblx0ICogU2VhcmNoIGRlbGF5IChpbiBtUylcblx0ICovXG5cdFwic2VhcmNoRGVsYXlcIjogbnVsbCxcblxuXHQvKipcblx0ICogV2hpY2ggdHlwZSBvZiBwYWdpbmF0aW9uIHNob3VsZCBiZSB1c2VkLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKi9cblx0XCJzUGFnaW5hdGlvblR5cGVcIjogXCJ0d29fYnV0dG9uXCIsXG5cblx0LyoqXG5cdCAqIE51bWJlciBvZiBwYWdpbmcgY29udHJvbHMgb24gdGhlIHBhZ2UuIE9ubHkgdXNlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0ICovXG5cdHBhZ2luZ0NvbnRyb2xzOiAwLFxuXG5cdC8qKlxuXHQgKiBUaGUgc3RhdGUgZHVyYXRpb24gKGZvciBgc3RhdGVTYXZlYCkgaW4gc2Vjb25kcy5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICovXG5cdFwiaVN0YXRlRHVyYXRpb25cIjogMCxcblxuXHQvKipcblx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBzdGF0ZSBzYXZpbmcuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhblxuXHQgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG5cdCAqICAgPHVsPlxuXHQgKiAgICAgPGxpPmZ1bmN0aW9uOmZuIC0gZnVuY3Rpb24gdG8gY2FsbC4gVGFrZXMgdHdvIHBhcmFtZXRlcnMsIG9TZXR0aW5nc1xuXHQgKiAgICAgICBhbmQgdGhlIEpTT04gc3RyaW5nIHRvIHNhdmUgdGhhdCBoYXMgYmVlbiB0aHVzIGZhciBjcmVhdGVkLiBSZXR1cm5zXG5cdCAqICAgICAgIGEgSlNPTiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgaW50byBhIGpzb24gb2JqZWN0XG5cdCAqICAgICAgIChpLmUuICdcInBhcmFtXCI6IFsgMCwgMSwgMl0nKTwvbGk+XG5cdCAqICAgICA8bGk+c3RyaW5nOnNOYW1lIC0gbmFtZSBvZiBjYWxsYmFjazwvbGk+XG5cdCAqICAgPC91bD5cblx0ICovXG5cdFwiYW9TdGF0ZVNhdmVcIjogW10sXG5cblx0LyoqXG5cdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igc3RhdGUgbG9hZGluZy4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuXG5cdCAqIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcblx0ICogICA8dWw+XG5cdCAqICAgICA8bGk+ZnVuY3Rpb246Zm4gLSBmdW5jdGlvbiB0byBjYWxsLiBUYWtlcyB0d28gcGFyYW1ldGVycywgb1NldHRpbmdzXG5cdCAqICAgICAgIGFuZCB0aGUgb2JqZWN0IHN0b3JlZC4gTWF5IHJldHVybiBmYWxzZSB0byBjYW5jZWwgc3RhdGUgbG9hZGluZzwvbGk+XG5cdCAqICAgICA8bGk+c3RyaW5nOnNOYW1lIC0gbmFtZSBvZiBjYWxsYmFjazwvbGk+XG5cdCAqICAgPC91bD5cblx0ICovXG5cdFwiYW9TdGF0ZUxvYWRcIjogW10sXG5cblx0LyoqXG5cdCAqIFN0YXRlIHRoYXQgd2FzIHNhdmVkLiBVc2VmdWwgZm9yIGJhY2sgcmVmZXJlbmNlXG5cdCAqL1xuXHRcIm9TYXZlZFN0YXRlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFN0YXRlIHRoYXQgd2FzIGxvYWRlZC4gVXNlZnVsIGZvciBiYWNrIHJlZmVyZW5jZVxuXHQgKi9cblx0XCJvTG9hZGVkU3RhdGVcIjogbnVsbCxcblxuXHQvKipcblx0ICogTm90ZSBpZiBkcmF3IHNob3VsZCBiZSBibG9ja2VkIHdoaWxlIGdldHRpbmcgZGF0YVxuXHQgKi9cblx0XCJiQWpheERhdGFHZXRcIjogdHJ1ZSxcblxuXHQvKipcblx0ICogVGhlIGxhc3QgalF1ZXJ5IFhIUiBvYmplY3QgdGhhdCB3YXMgdXNlZCBmb3Igc2VydmVyLXNpZGUgZGF0YSBnYXRoZXJpbmcuXG5cdCAqIFRoaXMgY2FuIGJlIHVzZWQgZm9yIHdvcmtpbmcgd2l0aCB0aGUgWEhSIGluZm9ybWF0aW9uIGluIG9uZSBvZiB0aGVcblx0ICogY2FsbGJhY2tzXG5cdCAqL1xuXHRcImpxWEhSXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuXHQgKi9cblx0XCJqc29uXCI6IHVuZGVmaW5lZCxcblxuXHQvKipcblx0ICogRGF0YSBzdWJtaXR0ZWQgYXMgcGFydCBvZiB0aGUgbGFzdCBBamF4IHJlcXVlc3Rcblx0ICovXG5cdFwib0FqYXhEYXRhXCI6IHVuZGVmaW5lZCxcblxuXHQvKipcblx0ICogU2VuZCB0aGUgWEhSIEhUVFAgbWV0aG9kIC0gR0VUIG9yIFBPU1QgKGNvdWxkIGJlIFBVVCBvciBERUxFVEUgaWZcblx0ICogcmVxdWlyZWQpLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKi9cblx0XCJzU2VydmVyTWV0aG9kXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZvcm1hdCBudW1iZXJzIGZvciBkaXNwbGF5LlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKi9cblx0XCJmbkZvcm1hdE51bWJlclwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBMaXN0IG9mIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIHVzZXIgc2VsZWN0YWJsZSBsZW5ndGggbWVudS5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICovXG5cdFwiYUxlbmd0aE1lbnVcIjogbnVsbCxcblxuXHQvKipcblx0ICogQ291bnRlciBmb3IgdGhlIGRyYXdzIHRoYXQgdGhlIHRhYmxlIGRvZXMuIEFsc28gdXNlZCBhcyBhIHRyYWNrZXIgZm9yXG5cdCAqIHNlcnZlci1zaWRlIHByb2Nlc3Npbmdcblx0ICovXG5cdFwiaURyYXdcIjogMCxcblxuXHQvKipcblx0ICogSW5kaWNhdGUgaWYgYSByZWRyYXcgaXMgYmVpbmcgZG9uZSAtIHVzZWZ1bCBmb3IgQWpheFxuXHQgKi9cblx0XCJiRHJhd2luZ1wiOiBmYWxzZSxcblxuXHQvKipcblx0ICogRHJhdyBpbmRleCAoaURyYXcpIG9mIHRoZSBsYXN0IGVycm9yIHdoZW4gcGFyc2luZyB0aGUgcmV0dXJuZWQgZGF0YVxuXHQgKi9cblx0XCJpRHJhd0Vycm9yXCI6IC0xLFxuXG5cdC8qKlxuXHQgKiBQYWdpbmcgZGlzcGxheSBsZW5ndGhcblx0ICovXG5cdFwiX2lEaXNwbGF5TGVuZ3RoXCI6IDEwLFxuXG5cdC8qKlxuXHQgKiBQYWdpbmcgc3RhcnQgcG9pbnQgLSBhaURpc3BsYXkgaW5kZXhcblx0ICovXG5cdFwiX2lEaXNwbGF5U3RhcnRcIjogMCxcblxuXHQvKipcblx0ICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSByZXN1bHQgc2V0XG5cdCAqIChpLmUuIGJlZm9yZSBmaWx0ZXJpbmcpLCBVc2UgZm5SZWNvcmRzVG90YWwgcmF0aGVyIHRoYW5cblx0ICogdGhpcyBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmVnYXJkbGVzcyBvZlxuXHQgKiB0aGUgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBzZXR0aW5nLlxuXHQgKi9cblx0XCJfaVJlY29yZHNUb3RhbFwiOiAwLFxuXG5cdC8qKlxuXHQgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGN1cnJlbnQgZGlzcGxheSBzZXRcblx0ICogKGkuZS4gYWZ0ZXIgZmlsdGVyaW5nKS4gVXNlIGZuUmVjb3Jkc0Rpc3BsYXkgcmF0aGVyIHRoYW5cblx0ICogdGhpcyBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmVnYXJkbGVzcyBvZlxuXHQgKiB0aGUgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBzZXR0aW5nLlxuXHQgKi9cblx0XCJfaVJlY29yZHNEaXNwbGF5XCI6IDAsXG5cblx0LyoqXG5cdCAqIFRoZSBjbGFzc2VzIHRvIHVzZSBmb3IgdGhlIHRhYmxlXG5cdCAqL1xuXHRcIm9DbGFzc2VzXCI6IHt9LFxuXG5cdC8qKlxuXHQgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuXHQgKiBjYWxsYmFjayBpZiBmaWx0ZXJpbmcgaGFzIGJlZW4gZG9uZSBpbiB0aGUgZHJhdy4gRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Zcblx0ICogZXZlbnRzLlxuXHQgKiAgQGRlcHJlY2F0ZWRcblx0ICovXG5cdFwiYkZpbHRlcmVkXCI6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuXHQgKiBjYWxsYmFjayBpZiBzb3J0aW5nIGhhcyBiZWVuIGRvbmUgaW4gdGhlIGRyYXcuIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mXG5cdCAqIGV2ZW50cy5cblx0ICogIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRcImJTb3J0ZWRcIjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIEluZGljYXRlIHRoYXQgaWYgbXVsdGlwbGUgcm93cyBhcmUgaW4gdGhlIGhlYWRlciBhbmQgdGhlcmUgaXMgbW9yZSB0aGFuXG5cdCAqIG9uZSB1bmlxdWUgY2VsbCBwZXIgY29sdW1uLiBSZXBsYWNlZCBieSB0aXRsZVJvd1xuXHQgKi9cblx0XCJiU29ydENlbGxzVG9wXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpc2F0aW9uIG9iamVjdCB0aGF0IGlzIHVzZWQgZm9yIHRoZSB0YWJsZVxuXHQgKi9cblx0XCJvSW5pdFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBEZXN0cm95IGNhbGxiYWNrIGZ1bmN0aW9ucyAtIGZvciBwbHVnLWlucyB0byBhdHRhY2ggdGhlbXNlbHZlcyB0byB0aGVcblx0ICogZGVzdHJveSBzbyB0aGV5IGNhbiBjbGVhbiB1cCBtYXJrdXAgYW5kIGV2ZW50cy5cblx0ICovXG5cdFwiYW9EZXN0cm95Q2FsbGJhY2tcIjogW10sXG5cblxuXHQvKipcblx0ICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBiZWZvcmUgZmlsdGVyaW5nXG5cdCAqL1xuXHRcImZuUmVjb3Jkc1RvdGFsXCI6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRyZXR1cm4gX2ZuRGF0YVNvdXJjZSggdGhpcyApID09ICdzc3AnID9cblx0XHRcdHRoaXMuX2lSZWNvcmRzVG90YWwgKiAxIDpcblx0XHRcdHRoaXMuYWlEaXNwbGF5TWFzdGVyLmxlbmd0aDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBhZnRlciBmaWx0ZXJpbmdcblx0ICovXG5cdFwiZm5SZWNvcmRzRGlzcGxheVwiOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIF9mbkRhdGFTb3VyY2UoIHRoaXMgKSA9PSAnc3NwJyA/XG5cdFx0XHR0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKiAxIDpcblx0XHRcdHRoaXMuYWlEaXNwbGF5Lmxlbmd0aDtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBkaXNwbGF5IGVuZCBwb2ludCAtIGFpRGlzcGxheSBpbmRleFxuXHQgKi9cblx0XCJmbkRpc3BsYXlFbmRcIjogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhclxuXHRcdFx0bGVuICAgICAgPSB0aGlzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRcdHN0YXJ0ICAgID0gdGhpcy5faURpc3BsYXlTdGFydCxcblx0XHRcdGNhbGMgICAgID0gc3RhcnQgKyBsZW4sXG5cdFx0XHRyZWNvcmRzICA9IHRoaXMuYWlEaXNwbGF5Lmxlbmd0aCxcblx0XHRcdGZlYXR1cmVzID0gdGhpcy5vRmVhdHVyZXMsXG5cdFx0XHRwYWdpbmF0ZSA9IGZlYXR1cmVzLmJQYWdpbmF0ZTtcblxuXHRcdGlmICggZmVhdHVyZXMuYlNlcnZlclNpZGUgKSB7XG5cdFx0XHRyZXR1cm4gcGFnaW5hdGUgPT09IGZhbHNlIHx8IGxlbiA9PT0gLTEgP1xuXHRcdFx0XHRzdGFydCArIHJlY29yZHMgOlxuXHRcdFx0XHRNYXRoLm1pbiggc3RhcnQrbGVuLCB0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gISBwYWdpbmF0ZSB8fCBjYWxjPnJlY29yZHMgfHwgbGVuPT09LTEgP1xuXHRcdFx0XHRyZWNvcmRzIDpcblx0XHRcdFx0Y2FsYztcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoZSBEYXRhVGFibGVzIG9iamVjdCBmb3IgdGhpcyB0YWJsZVxuXHQgKi9cblx0XCJvSW5zdGFuY2VcIjogbnVsbCxcblxuXHQvKipcblx0ICogVW5pcXVlIGlkZW50aWZpZXIgZm9yIGVhY2ggaW5zdGFuY2Ugb2YgdGhlIERhdGFUYWJsZXMgb2JqZWN0LiBJZiB0aGVyZVxuXHQgKiBpcyBhbiBJRCBvbiB0aGUgdGFibGUgbm9kZSwgdGhlbiBpdCB0YWtlcyB0aGF0IHZhbHVlLCBvdGhlcndpc2UgYW5cblx0ICogaW5jcmVtZW50aW5nIGludGVybmFsIGNvdW50ZXIgaXMgdXNlZC5cblx0ICovXG5cdFwic0luc3RhbmNlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIHRhYmluZGV4IGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGlzIGFkZGVkIHRvIERhdGFUYWJsZXMgY29udHJvbCBlbGVtZW50cywgYWxsb3dpbmdcblx0ICoga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgYW5kIGl0cyBjb250cm9scy5cblx0ICovXG5cdFwiaVRhYkluZGV4XCI6IDAsXG5cblx0LyoqXG5cdCAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xuXHQgKi9cblx0XCJuU2Nyb2xsSGVhZFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBESVYgY29udGFpbmVyIGZvciB0aGUgZm9vdGVyIHNjcm9sbGluZyB0YWJsZSBpZiBzY3JvbGxpbmdcblx0ICovXG5cdFwiblNjcm9sbEZvb3RcIjogbnVsbCxcblxuXHQvKipcblx0ICogTGFzdCBhcHBsaWVkIHNvcnRcblx0ICovXG5cdFwiYUxhc3RTb3J0XCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBTdG9yZWQgcGx1Zy1pbiBpbnN0YW5jZXNcblx0ICovXG5cdFwib1BsdWdpbnNcIjoge30sXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIHVzZWQgdG8gZ2V0IGEgcm93J3MgaWQgZnJvbSB0aGUgcm93J3MgZGF0YVxuXHQgKi9cblx0XCJyb3dJZEZuXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIERhdGEgbG9jYXRpb24gd2hlcmUgdG8gc3RvcmUgYSByb3cncyBpZFxuXHQgKi9cblx0XCJyb3dJZFwiOiBudWxsLFxuXG5cdGNhcHRpb246ICcnLFxuXG5cdGNhcHRpb25Ob2RlOiBudWxsLFxuXG5cdGNvbGdyb3VwOiBudWxsLFxuXG5cdC8qKiBEZWxheSBsb2FkaW5nIG9mIGRhdGEgKi9cblx0ZGVmZXJMb2FkaW5nOiBudWxsLFxuXG5cdC8qKiBBbGxvdyBhdXRvIHR5cGUgZGV0ZWN0aW9uICovXG5cdHR5cGVEZXRlY3Q6IHRydWUsXG5cblx0LyoqIFJlc2l6ZU9ic2VydmVyIGZvciB0aGUgY29udGFpbmVyIGRpdiAqL1xuXHRyZXNpemVPYnNlcnZlcjogbnVsbCxcblxuXHQvKiogS2VlcCBhIHJlY29yZCBvZiB0aGUgbGFzdCBzaXplIG9mIHRoZSBjb250YWluZXIsIHNvIHdlIGNhbiBza2lwIGR1cGxpY2F0ZXMgKi9cblx0Y29udGFpbmVyV2lkdGg6IC0xLFxuXG5cdC8qKiBSZXZlcnNlIHRoZSBpbml0aWFsIG9yZGVyIG9mIHRoZSBkYXRhIHNldCBvbiBkZXNjIG9yZGVyaW5nICovXG5cdG9yZGVyRGVzY1JldmVyc2U6IG51bGwsXG5cblx0LyoqIFNob3cgLyBoaWRlIG9yZGVyaW5nIGluZGljYXRvcnMgaW4gaGVhZGVycyAqL1xuXHRvcmRlckluZGljYXRvcnM6IHRydWUsXG5cblx0LyoqIERlZmF1bHQgb3JkZXJpbmcgbGlzdGVuZXIgKi9cblx0b3JkZXJIYW5kbGVyOiB0cnVlLFxuXG5cdC8qKiBUaXRsZSByb3cgaW5kaWNhdG9yICovXG5cdHRpdGxlUm93OiBudWxsXG59O1xuXG4vKipcbiAqIEV4dGVuc2lvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMgdGhhdCBpcyB1c2VkIHRvIHByb3ZpZGUgYWxsIGV4dGVuc2lvblxuICogb3B0aW9ucy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGUuZXh0YCBvYmplY3QgaXMgYXZhaWxhYmxlIHRocm91Z2hcbiAqIGBqUXVlcnkuZm4uZGF0YVRhYmxlLmV4dGAgd2hlcmUgaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZCBtYW5pcHVsYXRlZC4gSXQgaXNcbiAqIGFsc28gYWxpYXNlZCB0byBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgZm9yIGhpc3RvcmljIHJlYXNvbnMuXG4gKiAgQG5hbWVzcGFjZVxuICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMuZXh0XG4gKi9cblxuXG52YXIgZXh0UGFnaW5hdGlvbiA9IERhdGFUYWJsZS5leHQucGFnZXI7XG5cbi8vIFBhZ2luZyBidXR0b25zIGNvbmZpZ3VyYXRpb25cbiQuZXh0ZW5kKCBleHRQYWdpbmF0aW9uLCB7XG5cdHNpbXBsZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBbICdwcmV2aW91cycsICduZXh0JyBdO1xuXHR9LFxuXG5cdGZ1bGw6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gWyAnZmlyc3QnLCAncHJldmlvdXMnLCAnbmV4dCcsICdsYXN0JyBdO1xuXHR9LFxuXG5cdG51bWJlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gWyAnbnVtYmVycycgXTtcblx0fSxcblxuXHRzaW1wbGVfbnVtYmVyczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBbICdwcmV2aW91cycsICdudW1iZXJzJywgJ25leHQnIF07XG5cdH0sXG5cblx0ZnVsbF9udW1iZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFsgJ2ZpcnN0JywgJ3ByZXZpb3VzJywgJ251bWJlcnMnLCAnbmV4dCcsICdsYXN0JyBdO1xuXHR9LFxuXG5cdGZpcnN0X2xhc3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gWydmaXJzdCcsICdsYXN0J107XG5cdH0sXG5cblx0Zmlyc3RfbGFzdF9udW1iZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFsnZmlyc3QnLCAnbnVtYmVycycsICdsYXN0J107XG5cdH0sXG5cblx0Ly8gRm9yIHRlc3RpbmcgYW5kIHBsdWctaW5zIHRvIHVzZVxuXHRfbnVtYmVyczogX3BhZ2luZ051bWJlcnMsXG5cblx0Ly8gTnVtYmVyIG9mIG51bWJlciBidXR0b25zIC0gbGVnYWN5LCB1c2UgYG51bWJlcnNgIG9wdGlvbiBmb3IgcGFnaW5nIGZlYXR1cmVcblx0bnVtYmVyc19sZW5ndGg6IDdcbn0gKTtcblxuXG4kLmV4dGVuZCggdHJ1ZSwgRGF0YVRhYmxlLmV4dC5yZW5kZXJlciwge1xuXHRwYWdpbmdCdXR0b246IHtcblx0XHRfOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGJ1dHRvblR5cGUsIGNvbnRlbnQsIGFjdGl2ZSwgZGlzYWJsZWQpIHtcblx0XHRcdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXMucGFnaW5nO1xuXHRcdFx0dmFyIGJ0bkNsYXNzZXMgPSBbY2xhc3Nlcy5idXR0b25dO1xuXHRcdFx0dmFyIGJ0bjtcblxuXHRcdFx0aWYgKGFjdGl2ZSkge1xuXHRcdFx0XHRidG5DbGFzc2VzLnB1c2goY2xhc3Nlcy5hY3RpdmUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGlzYWJsZWQpIHtcblx0XHRcdFx0YnRuQ2xhc3Nlcy5wdXNoKGNsYXNzZXMuZGlzYWJsZWQpXG5cdFx0XHR9XG5cblx0XHRcdGlmIChidXR0b25UeXBlID09PSAnZWxsaXBzaXMnKSB7XG5cdFx0XHRcdGJ0biA9ICQoJzxzcGFuIGNsYXNzPVwiZWxsaXBzaXNcIj48L3NwYW4+JykuaHRtbChjb250ZW50KVswXTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRidG4gPSAkKCc8YnV0dG9uPicsIHtcblx0XHRcdFx0XHRjbGFzczogYnRuQ2xhc3Nlcy5qb2luKCcgJyksXG5cdFx0XHRcdFx0cm9sZTogJ2xpbmsnLFxuXHRcdFx0XHRcdHR5cGU6ICdidXR0b24nXG5cdFx0XHRcdH0pLmh0bWwoY29udGVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRpc3BsYXk6IGJ0bixcblx0XHRcdFx0Y2xpY2tlcjogYnRuXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHBhZ2luZ0NvbnRhaW5lcjoge1xuXHRcdF86IGZ1bmN0aW9uIChzZXR0aW5ncywgYnV0dG9ucykge1xuXHRcdFx0Ly8gTm8gd3JhcHBpbmcgZWxlbWVudCAtIGp1c3QgYXBwZW5kIGRpcmVjdGx5IHRvIHRoZSBob3N0XG5cdFx0XHRyZXR1cm4gYnV0dG9ucztcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gQ29tbW9uIGZ1bmN0aW9uIHRvIHJlbW92ZSBuZXcgbGluZXMsIHN0cmlwIEhUTUwgYW5kIGRpYWNyaXRpYyBjb250cm9sXG52YXIgX2ZpbHRlclN0cmluZyA9IGZ1bmN0aW9uIChzdHJpcEh0bWwsIG5vcm1hbGl6ZSkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKHN0cikge1xuXHRcdGlmIChfZW1wdHkoc3RyKSB8fCB0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9XG5cblx0XHRzdHIgPSBzdHIucmVwbGFjZSggX3JlX25ld19saW5lcywgXCIgXCIgKTtcblxuXHRcdGlmIChzdHJpcEh0bWwpIHtcblx0XHRcdHN0ciA9IF9zdHJpcEh0bWwoc3RyKTtcblx0XHR9XG5cblx0XHRpZiAobm9ybWFsaXplKSB7XG5cdFx0XHRzdHIgPSBfbm9ybWFsaXplKHN0ciwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHI7XG5cdH07XG59XG5cbi8qXG4gKiBQdWJsaWMgaGVscGVyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlbid0IHVzZWQgaW50ZXJuYWxseSBieSBEYXRhVGFibGVzLCBvclxuICogY2FsbGVkIGJ5IGFueSBvZiB0aGUgb3B0aW9ucyBwYXNzZWQgaW50byBEYXRhVGFibGVzLCBidXQgdGhleSBjYW4gYmUgdXNlZFxuICogZXh0ZXJuYWxseSBieSBkZXZlbG9wZXJzIHdvcmtpbmcgd2l0aCBEYXRhVGFibGVzLiBUaGV5IGFyZSBoZWxwZXIgZnVuY3Rpb25zXG4gKiB0byBtYWtlIHdvcmtpbmcgd2l0aCBEYXRhVGFibGVzIGEgbGl0dGxlIGJpdCBlYXNpZXIuXG4gKi9cblxuLyoqXG4gKiBDb21tb24gbG9naWMgZm9yIG1vbWVudCwgbHV4b24gb3IgYSBkYXRlIGFjdGlvbi5cbiAqXG4gKiBIYXBwZW5zIGFmdGVyIF9fbWxkT2JqLCBzbyBkb24ndCBuZWVkIHRvIGNhbGwgYHJlc29sdmVXaW5kb3dzTGlic2AgYWdhaW5cbiAqL1xuZnVuY3Rpb24gX19tbGQoIGR0TGliLCBtb21lbnRGbiwgbHV4b25GbiwgZGF0ZUZuLCBhcmcxICkge1xuXHRpZiAoX19tb21lbnQpIHtcblx0XHRyZXR1cm4gZHRMaWJbbW9tZW50Rm5dKCBhcmcxICk7XG5cdH1cblx0ZWxzZSBpZiAoX19sdXhvbikge1xuXHRcdHJldHVybiBkdExpYltsdXhvbkZuXSggYXJnMSApO1xuXHR9XG5cdFxuXHRyZXR1cm4gZGF0ZUZuID8gZHRMaWJbZGF0ZUZuXSggYXJnMSApIDogZHRMaWI7XG59XG5cblxudmFyIF9fbWxXYXJuaW5nID0gZmFsc2U7XG52YXIgX19sdXhvbjsgLy8gQ2FuIGJlIGFzc2lnbmVkIGluIERhdGVUYWJsZS51c2UoKVxudmFyIF9fbW9tZW50OyAvLyBDYW4gYmUgYXNzaWduZWQgaW4gRGF0ZVRhYmxlLnVzZSgpXG5cbi8qKlxuICogXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVXaW5kb3dMaWJzKCkge1xuXHRpZiAod2luZG93Lmx1eG9uICYmICEgX19sdXhvbikge1xuXHRcdF9fbHV4b24gPSB3aW5kb3cubHV4b247XG5cdH1cblx0XG5cdGlmICh3aW5kb3cubW9tZW50ICYmICEgX19tb21lbnQpIHtcblx0XHRfX21vbWVudCA9IHdpbmRvdy5tb21lbnQ7XG5cdH1cbn1cblxuZnVuY3Rpb24gX19tbGRPYmogKGQsIGZvcm1hdCwgbG9jYWxlKSB7XG5cdHZhciBkdDtcblxuXHRyZXNvbHZlV2luZG93TGlicygpO1xuXG5cdGlmIChfX21vbWVudCkge1xuXHRcdGR0ID0gX19tb21lbnQudXRjKCBkLCBmb3JtYXQsIGxvY2FsZSwgdHJ1ZSApO1xuXG5cdFx0aWYgKCEgZHQuaXNWYWxpZCgpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoX19sdXhvbikge1xuXHRcdGR0ID0gZm9ybWF0ICYmIHR5cGVvZiBkID09PSAnc3RyaW5nJ1xuXHRcdFx0PyBfX2x1eG9uLkRhdGVUaW1lLmZyb21Gb3JtYXQoIGQsIGZvcm1hdCApXG5cdFx0XHQ6IF9fbHV4b24uRGF0ZVRpbWUuZnJvbUlTTyggZCApO1xuXG5cdFx0aWYgKCEgZHQuaXNWYWxpZCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0ZHQgPSBkdC5zZXRMb2NhbGUobG9jYWxlKTtcblx0fVxuXHRlbHNlIGlmICghIGZvcm1hdCkge1xuXHRcdC8vIE5vIGZvcm1hdCBnaXZlbiwgbXVzdCBiZSBJU09cblx0XHRkdCA9IG5ldyBEYXRlKGQpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGlmICghIF9fbWxXYXJuaW5nKSB7XG5cdFx0XHRhbGVydCgnRGF0YVRhYmxlcyB3YXJuaW5nOiBGb3JtYXR0ZWQgZGF0ZSB3aXRob3V0IE1vbWVudC5qcyBvciBMdXhvbiAtIGh0dHBzOi8vZGF0YXRhYmxlcy5uZXQvdG4vMTcnKTtcblx0XHR9XG5cblx0XHRfX21sV2FybmluZyA9IHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZHQ7XG59XG5cbi8vIFdyYXBwZXIgZm9yIGRhdGUsIGRhdGV0aW1lIGFuZCB0aW1lIHdoaWNoIGFsbCBvcGVyYXRlIHRoZSBzYW1lIHdheSB3aXRoIHRoZSBleGNlcHRpb24gb2Zcbi8vIHRoZSBvdXRwdXQgc3RyaW5nIGZvciBhdXRvIGxvY2FsZSBzdXBwb3J0XG5mdW5jdGlvbiBfX21sSGVscGVyIChsb2NhbGVTdHJpbmcpIHtcblx0cmV0dXJuIGZ1bmN0aW9uICggZnJvbSwgdG8sIGxvY2FsZSwgZGVmICkge1xuXHRcdC8vIEx1eG9uIGFuZCBNb21lbnQgc3VwcG9ydFxuXHRcdC8vIEFyZ3VtZW50IHNoaWZ0aW5nXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0bG9jYWxlID0gJ2VuJztcblx0XHRcdHRvID0gbnVsbDsgLy8gbWVhbnMgdG9Mb2NhbGVTdHJpbmdcblx0XHRcdGZyb20gPSBudWxsOyAvLyBtZWFucyBpc284NjAxXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0bG9jYWxlID0gJ2VuJztcblx0XHRcdHRvID0gZnJvbTtcblx0XHRcdGZyb20gPSBudWxsO1xuXHRcdH1cblx0XHRlbHNlIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMiApIHtcblx0XHRcdGxvY2FsZSA9IHRvO1xuXHRcdFx0dG8gPSBmcm9tO1xuXHRcdFx0ZnJvbSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIHR5cGVOYW1lID0gJ2RhdGV0aW1lJyArICh0byA/ICctJyArIHRvIDogJycpO1xuXG5cdFx0Ly8gQWRkIHR5cGUgZGV0ZWN0aW9uIGFuZCBzb3J0aW5nIHNwZWNpZmljIHRvIHRoaXMgZGF0ZSBmb3JtYXQgLSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gaWRlbnRpZnlcblx0XHQvLyBkYXRlIHR5cGUgY29sdW1ucyBhcyBzdWNoLCByYXRoZXIgdGhhbiBhcyBudW1iZXJzIGluIGV4dGVuc2lvbnMuIEhlbmNlIHRoZSBuZWVkIGZvciB0aGlzLlxuXHRcdGlmICghIERhdGFUYWJsZS5leHQudHlwZS5vcmRlclt0eXBlTmFtZSArICctcHJlJ10pIHtcblx0XHRcdERhdGFUYWJsZS50eXBlKHR5cGVOYW1lLCB7XG5cdFx0XHRcdGRldGVjdDogZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHQvLyBUaGUgcmVuZGVyZXIgd2lsbCBnaXZlIHRoZSB2YWx1ZSB0byB0eXBlIGRldGVjdCBhcyB0aGUgdHlwZSFcblx0XHRcdFx0XHRyZXR1cm4gZCA9PT0gdHlwZU5hbWUgPyB0eXBlTmFtZSA6IGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRvcmRlcjoge1xuXHRcdFx0XHRcdHByZTogZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHRcdC8vIFRoZSByZW5kZXJlciBnaXZlcyB1cyBNb21lbnQsIEx1eG9uIG9yIERhdGUgb2JlY3RzIGZvciB0aGUgc29ydGluZywgYWxsIG9mIHdoaWNoIGhhdmUgYVxuXHRcdFx0XHRcdFx0Ly8gYHZhbHVlT2ZgIHdoaWNoIGdpdmVzIG1pbGxpc2Vjb25kcyBlcG9jaFxuXHRcdFx0XHRcdFx0cmV0dXJuIGQudmFsdWVPZigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0Y2xhc3NOYW1lOiAnZHQtcmlnaHQnXG5cdFx0XHR9KTtcblx0XHR9XG5cdFxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGQsIHR5cGUgKSB7XG5cdFx0XHQvLyBBbGxvdyBmb3IgYSBkZWZhdWx0IHZhbHVlXG5cdFx0XHRpZiAoZCA9PT0gbnVsbCB8fCBkID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKGRlZiA9PT0gJy0tbm93Jykge1xuXHRcdFx0XHRcdC8vIFdlIHRyZWF0IGV2ZXJ5dGhpbmcgYXMgVVRDIGZ1cnRoZXIgZG93biwgc28gbm8gY2hhbmdlcyBhcmVcblx0XHRcdFx0XHQvLyBtYWRlLCBhcyBzdWNoIG5lZWQgdG8gZ2V0IHRoZSBsb2NhbCBkYXRlIC8gdGltZSBhcyBpZiBpdCB3ZXJlXG5cdFx0XHRcdFx0Ly8gVVRDXG5cdFx0XHRcdFx0dmFyIGxvY2FsID0gbmV3IERhdGUoKTtcblx0XHRcdFx0XHRkID0gbmV3IERhdGUoIERhdGUuVVRDKFxuXHRcdFx0XHRcdFx0bG9jYWwuZ2V0RnVsbFllYXIoKSwgbG9jYWwuZ2V0TW9udGgoKSwgbG9jYWwuZ2V0RGF0ZSgpLFxuXHRcdFx0XHRcdFx0bG9jYWwuZ2V0SG91cnMoKSwgbG9jYWwuZ2V0TWludXRlcygpLCBsb2NhbC5nZXRTZWNvbmRzKClcblx0XHRcdFx0XHQpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZCA9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlID09PSAndHlwZScpIHtcblx0XHRcdFx0Ly8gVHlwaW5nIHVzZXMgdGhlIHR5cGUgbmFtZSBmb3IgZmFzdCBtYXRjaGluZ1xuXHRcdFx0XHRyZXR1cm4gdHlwZU5hbWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkID09PSAnJykge1xuXHRcdFx0XHRyZXR1cm4gdHlwZSAhPT0gJ3NvcnQnXG5cdFx0XHRcdFx0PyAnJ1xuXHRcdFx0XHRcdDogX19tbGRPYmooJzAwMDAtMDEtMDEgMDA6MDA6MDAnLCBudWxsLCBsb2NhbGUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG9ydGN1dC4gSWYgYGZyb21gIGFuZCBgdG9gIGFyZSB0aGUgc2FtZSwgd2UgYXJlIHVzaW5nIHRoZSByZW5kZXJlciB0b1xuXHRcdFx0Ly8gZm9ybWF0IGZvciBvcmRlcmluZywgbm90IGRpc3BsYXkgLSBpdHMgYWxyZWFkeSBpbiB0aGUgZGlzcGxheSBmb3JtYXQuXG5cdFx0XHRpZiAoIHRvICE9PSBudWxsICYmIGZyb20gPT09IHRvICYmIHR5cGUgIT09ICdzb3J0JyAmJiB0eXBlICE9PSAndHlwZScgJiYgISAoZCBpbnN0YW5jZW9mIERhdGUpICkge1xuXHRcdFx0XHRyZXR1cm4gZDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGR0ID0gX19tbGRPYmooZCwgZnJvbSwgbG9jYWxlKTtcblxuXHRcdFx0aWYgKGR0ID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZSA9PT0gJ3NvcnQnKSB7XG5cdFx0XHRcdHJldHVybiBkdDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGZvcm1hdHRlZCA9IHRvID09PSBudWxsXG5cdFx0XHRcdD8gX19tbGQoZHQsICd0b0RhdGUnLCAndG9KU0RhdGUnLCAnJylbbG9jYWxlU3RyaW5nXSgpXG5cdFx0XHRcdDogX19tbGQoZHQsICdmb3JtYXQnLCAndG9Gb3JtYXQnLCAndG9JU09TdHJpbmcnLCB0byk7XG5cblx0XHRcdC8vIFhTUyBwcm90ZWN0aW9uXG5cdFx0XHRyZXR1cm4gdHlwZSA9PT0gJ2Rpc3BsYXknID9cblx0XHRcdFx0X2VzY2FwZUh0bWwoIGZvcm1hdHRlZCApIDpcblx0XHRcdFx0Zm9ybWF0dGVkO1xuXHRcdH07XG5cdH1cbn1cblxuLy8gQmFzZWQgb24gbG9jYWxlLCBkZXRlcm1pbmUgc3RhbmRhcmQgbnVtYmVyIGZvcm1hdHRpbmdcbi8vIEZhbGxiYWNrIGZvciBsZWdhY3kgYnJvd3NlcnMgaXMgVVMgRW5nbGlzaFxudmFyIF9fdGhvdXNhbmRzID0gJywnO1xudmFyIF9fZGVjaW1hbCA9ICcuJztcblxuaWYgKHdpbmRvdy5JbnRsICE9PSB1bmRlZmluZWQpIHtcblx0dHJ5IHtcblx0XHR2YXIgbnVtID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KCkuZm9ybWF0VG9QYXJ0cygxMDAwMDAuMSk7XG5cdFxuXHRcdGZvciAodmFyIGk9MCA7IGk8bnVtLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0aWYgKG51bVtpXS50eXBlID09PSAnZ3JvdXAnKSB7XG5cdFx0XHRcdF9fdGhvdXNhbmRzID0gbnVtW2ldLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAobnVtW2ldLnR5cGUgPT09ICdkZWNpbWFsJykge1xuXHRcdFx0XHRfX2RlY2ltYWwgPSBudW1baV0udmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdGNhdGNoIChlKSB7XG5cdFx0Ly8gbm9vcFxuXHR9XG59XG5cbi8vIEZvcm1hdHRlZCBkYXRlIHRpbWUgZGV0ZWN0aW9uIC0gdXNlIGJ5IGRlY2xhcmluZyB0aGUgZm9ybWF0cyB5b3UgYXJlIGdvaW5nIHRvIHVzZVxuRGF0YVRhYmxlLmRhdGV0aW1lID0gZnVuY3Rpb24gKCBmb3JtYXQsIGxvY2FsZSApIHtcblx0dmFyIHR5cGVOYW1lID0gJ2RhdGV0aW1lLScgKyBmb3JtYXQ7XG5cblx0aWYgKCEgbG9jYWxlKSB7XG5cdFx0bG9jYWxlID0gJ2VuJztcblx0fVxuXG5cdGlmICghIERhdGFUYWJsZS5leHQudHlwZS5vcmRlclt0eXBlTmFtZV0pIHtcblx0XHREYXRhVGFibGUudHlwZSh0eXBlTmFtZSwge1xuXHRcdFx0ZGV0ZWN0OiBmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHR2YXIgZHQgPSBfX21sZE9iaihkLCBmb3JtYXQsIGxvY2FsZSk7XG5cdFx0XHRcdHJldHVybiBkID09PSAnJyB8fCBkdCA/IHR5cGVOYW1lIDogZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0b3JkZXI6IHtcblx0XHRcdFx0cHJlOiBmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRcdHJldHVybiBfX21sZE9iaihkLCBmb3JtYXQsIGxvY2FsZSkgfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGNsYXNzTmFtZTogJ2R0LXJpZ2h0J1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogSGVscGVycyBmb3IgYGNvbHVtbnMucmVuZGVyYC5cbiAqXG4gKiBUaGUgb3B0aW9ucyBkZWZpbmVkIGhlcmUgY2FuIGJlIHVzZWQgd2l0aCB0aGUgYGNvbHVtbnMucmVuZGVyYCBpbml0aWFsaXNhdGlvblxuICogb3B0aW9uIHRvIHByb3ZpZGUgYSBkaXNwbGF5IHJlbmRlcmVyLiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZDpcbiAqXG4gKiAqIGBtb21lbnRgIC0gVXNlcyB0aGUgTW9tZW50SlMgbGlicmFyeSB0byBjb252ZXJ0IGZyb20gYSBnaXZlbiBmb3JtYXQgaW50byBhbm90aGVyLlxuICogVGhpcyByZW5kZXJlciBoYXMgdGhyZWUgb3ZlcmxvYWRzOlxuICogICAqIDEgcGFyYW1ldGVyOlxuICogICAgICogYHN0cmluZ2AgLSBGb3JtYXQgdG8gY29udmVydCB0byAoYXNzdW1lcyBpbnB1dCBpcyBJU084NjAxIGFuZCBsb2NhbGUgaXMgYGVuYClcbiAqICAgKiAyIHBhcmFtZXRlcnM6XG4gKiAgICAgKiBgc3RyaW5nYCAtIEZvcm1hdCB0byBjb252ZXJ0IGZyb21cbiAqICAgICAqIGBzdHJpbmdgIC0gRm9ybWF0IHRvIGNvbnZlcnQgdG8uIEFzc3VtZXMgYGVuYCBsb2NhbGVcbiAqICAgKiAzIHBhcmFtZXRlcnM6XG4gKiAgICAgKiBgc3RyaW5nYCAtIEZvcm1hdCB0byBjb252ZXJ0IGZyb21cbiAqICAgICAqIGBzdHJpbmdgIC0gRm9ybWF0IHRvIGNvbnZlcnQgdG9cbiAqICAgICAqIGBzdHJpbmdgIC0gTG9jYWxlXG4gKiAqIGBudW1iZXJgIC0gV2lsbCBmb3JtYXQgbnVtZXJpYyBkYXRhIChkZWZpbmVkIGJ5IGBjb2x1bW5zLmRhdGFgKSBmb3JcbiAqICAgZGlzcGxheSwgcmV0YWluaW5nIHRoZSBvcmlnaW5hbCB1bmZvcm1hdHRlZCBkYXRhIGZvciBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcuXG4gKiAgIEl0IHRha2VzIDUgcGFyYW1ldGVyczpcbiAqICAgKiBgc3RyaW5nYCAtIFRob3VzYW5kcyBncm91cGluZyBzZXBhcmF0b3JcbiAqICAgKiBgc3RyaW5nYCAtIERlY2ltYWwgcG9pbnQgaW5kaWNhdG9yXG4gKiAgICogYGludGVnZXJgIC0gTnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIHNob3dcbiAqICAgKiBgc3RyaW5nYCAob3B0aW9uYWwpIC0gUHJlZml4LlxuICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQb3N0Zml4ICgvc3VmZml4KS5cbiAqICogYHRleHRgIC0gRXNjYXBlIEhUTUwgdG8gaGVscCBwcmV2ZW50IFhTUyBhdHRhY2tzLiBJdCBoYXMgbm8gb3B0aW9uYWxcbiAqICAgcGFyYW1ldGVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBDb2x1bW4gZGVmaW5pdGlvbiB1c2luZyB0aGUgbnVtYmVyIHJlbmRlcmVyXG4gKiAgIHtcbiAqICAgICBkYXRhOiBcInNhbGFyeVwiLFxuICogICAgIHJlbmRlcjogJC5mbi5kYXRhVGFibGUucmVuZGVyLm51bWJlciggJ1xcJycsICcuJywgMCwgJyQnIClcbiAqICAgfVxuICpcbiAqIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLnJlbmRlciA9IHtcblx0ZGF0ZTogX19tbEhlbHBlcigndG9Mb2NhbGVEYXRlU3RyaW5nJyksXG5cdGRhdGV0aW1lOiBfX21sSGVscGVyKCd0b0xvY2FsZVN0cmluZycpLFxuXHR0aW1lOiBfX21sSGVscGVyKCd0b0xvY2FsZVRpbWVTdHJpbmcnKSxcblx0bnVtYmVyOiBmdW5jdGlvbiAoIHRob3VzYW5kcywgZGVjaW1hbCwgcHJlY2lzaW9uLCBwcmVmaXgsIHBvc3RmaXggKSB7XG5cdFx0Ly8gQXV0byBsb2NhbGUgZGV0ZWN0aW9uXG5cdFx0aWYgKHRob3VzYW5kcyA9PT0gbnVsbCB8fCB0aG91c2FuZHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhvdXNhbmRzID0gX190aG91c2FuZHM7XG5cdFx0fVxuXG5cdFx0aWYgKGRlY2ltYWwgPT09IG51bGwgfHwgZGVjaW1hbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkZWNpbWFsID0gX19kZWNpbWFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRkaXNwbGF5OiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGQgIT09ICdudW1iZXInICYmIHR5cGVvZiBkICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRyZXR1cm4gZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkID09PSAnJyB8fCBkID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbmVnYXRpdmUgPSBkIDwgMCA/ICctJyA6ICcnO1xuXHRcdFx0XHR2YXIgZmxvID0gcGFyc2VGbG9hdCggZCApO1xuXHRcdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMoZmxvKTtcblxuXHRcdFx0XHQvLyBTY2llbnRpZmljIG5vdGF0aW9uIGZvciBsYXJnZSBhbmQgc21hbGwgbnVtYmVyc1xuXHRcdFx0XHRpZiAoYWJzID49IDEwMDAwMDAwMDAwMCB8fCAoYWJzIDwgMC4wMDAxICYmIGFicyAhPT0gMCkgKSB7XG5cdFx0XHRcdFx0dmFyIGV4cCA9IGZsby50b0V4cG9uZW50aWFsKHByZWNpc2lvbikuc3BsaXQoL2VcXCs/Lyk7XG5cdFx0XHRcdFx0cmV0dXJuIGV4cFswXSArICcgeCAxMDxzdXA+JyArIGV4cFsxXSArICc8L3N1cD4nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgTmFOIHRoZW4gdGhlcmUgaXNuJ3QgbXVjaCBmb3JtYXR0aW5nIHRoYXQgd2UgY2FuIGRvIC0ganVzdFxuXHRcdFx0XHQvLyByZXR1cm4gaW1tZWRpYXRlbHksIGVzY2FwaW5nIGFueSBIVE1MICh0aGlzIHdhcyBzdXBwb3NlZCB0b1xuXHRcdFx0XHQvLyBiZSBhIG51bWJlciBhZnRlciBhbGwpXG5cdFx0XHRcdGlmICggaXNOYU4oIGZsbyApICkge1xuXHRcdFx0XHRcdHJldHVybiBfZXNjYXBlSHRtbCggZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmxvID0gZmxvLnRvRml4ZWQoIHByZWNpc2lvbiApO1xuXHRcdFx0XHRkID0gTWF0aC5hYnMoIGZsbyApO1xuXG5cdFx0XHRcdHZhciBpbnRQYXJ0ID0gcGFyc2VJbnQoIGQsIDEwICk7XG5cdFx0XHRcdHZhciBmbG9hdFBhcnQgPSBwcmVjaXNpb24gP1xuXHRcdFx0XHRcdGRlY2ltYWwrKGQgLSBpbnRQYXJ0KS50b0ZpeGVkKCBwcmVjaXNpb24gKS5zdWJzdHJpbmcoIDIgKTpcblx0XHRcdFx0XHQnJztcblxuXHRcdFx0XHQvLyBJZiB6ZXJvLCB0aGVuIGNhbid0IGhhdmUgYSBuZWdhdGl2ZSBwcmVmaXhcblx0XHRcdFx0aWYgKGludFBhcnQgPT09IDAgJiYgcGFyc2VGbG9hdChmbG9hdFBhcnQpID09PSAwKSB7XG5cdFx0XHRcdFx0bmVnYXRpdmUgPSAnJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBuZWdhdGl2ZSArIChwcmVmaXh8fCcnKSArXG5cdFx0XHRcdFx0aW50UGFydC50b1N0cmluZygpLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHQvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgdGhvdXNhbmRzXG5cdFx0XHRcdFx0KSArXG5cdFx0XHRcdFx0ZmxvYXRQYXJ0ICtcblx0XHRcdFx0XHQocG9zdGZpeHx8JycpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRkaXNwbGF5OiBfZXNjYXBlSHRtbCxcblx0XHRcdGZpbHRlcjogX2VzY2FwZUh0bWxcblx0XHR9O1xuXHR9XG59O1xuXG5cbnZhciBfZXh0VHlwZXMgPSBEYXRhVGFibGUuZXh0LnR5cGU7XG5cbi8vIEdldCAvIHNldCB0eXBlXG5EYXRhVGFibGUudHlwZSA9IGZ1bmN0aW9uIChuYW1lLCBwcm9wLCB2YWwpIHtcblx0aWYgKCEgcHJvcCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRjbGFzc05hbWU6IF9leHRUeXBlcy5jbGFzc05hbWVbbmFtZV0sXG5cdFx0XHRkZXRlY3Q6IF9leHRUeXBlcy5kZXRlY3QuZmluZChmdW5jdGlvbiAoZm4pIHtcblx0XHRcdFx0cmV0dXJuIGZuLl9uYW1lID09PSBuYW1lO1xuXHRcdFx0fSksXG5cdFx0XHRvcmRlcjoge1xuXHRcdFx0XHRwcmU6IF9leHRUeXBlcy5vcmRlcltuYW1lICsgJy1wcmUnXSxcblx0XHRcdFx0YXNjOiBfZXh0VHlwZXMub3JkZXJbbmFtZSArICctYXNjJ10sXG5cdFx0XHRcdGRlc2M6IF9leHRUeXBlcy5vcmRlcltuYW1lICsgJy1kZXNjJ11cblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IF9leHRUeXBlcy5yZW5kZXJbbmFtZV0sXG5cdFx0XHRzZWFyY2g6IF9leHRUeXBlcy5zZWFyY2hbbmFtZV1cblx0XHR9O1xuXHR9XG5cblx0dmFyIHNldFByb3AgPSBmdW5jdGlvbihwcm9wLCBwcm9wVmFsKSB7XG5cdFx0X2V4dFR5cGVzW3Byb3BdW25hbWVdID0gcHJvcFZhbDtcblx0fTtcblx0dmFyIHNldERldGVjdCA9IGZ1bmN0aW9uIChkZXRlY3QpIHtcblx0XHQvLyBgZGV0ZWN0YCBjYW4gYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QgLSB3ZSBzZXQgYSBuYW1lXG5cdFx0Ly8gcHJvcGVydHkgZm9yIGVpdGhlciAtIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGRldGVjdGlvblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXRlY3QsIFwiX25hbWVcIiwge3ZhbHVlOiBuYW1lfSk7XG5cblx0XHR2YXIgaWR4ID0gX2V4dFR5cGVzLmRldGVjdC5maW5kSW5kZXgoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHJldHVybiBpdGVtLl9uYW1lID09PSBuYW1lO1xuXHRcdH0pO1xuXG5cdFx0aWYgKGlkeCA9PT0gLTEpIHtcblx0XHRcdF9leHRUeXBlcy5kZXRlY3QudW5zaGlmdChkZXRlY3QpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdF9leHRUeXBlcy5kZXRlY3Quc3BsaWNlKGlkeCwgMSwgZGV0ZWN0KTtcblx0XHR9XG5cdH07XG5cdHZhciBzZXRPcmRlciA9IGZ1bmN0aW9uIChvYmopIHtcblx0XHRfZXh0VHlwZXMub3JkZXJbbmFtZSArICctcHJlJ10gPSBvYmoucHJlOyAvLyBjYW4gYmUgdW5kZWZpbmVkXG5cdFx0X2V4dFR5cGVzLm9yZGVyW25hbWUgKyAnLWFzYyddID0gb2JqLmFzYzsgLy8gY2FuIGJlIHVuZGVmaW5lZFxuXHRcdF9leHRUeXBlcy5vcmRlcltuYW1lICsgJy1kZXNjJ10gPSBvYmouZGVzYzsgLy8gY2FuIGJlIHVuZGVmaW5lZFxuXHR9O1xuXG5cdC8vIHByb3AgaXMgb3B0aW9uYWxcblx0aWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFsID0gcHJvcDtcblx0XHRwcm9wID0gbnVsbDtcblx0fVxuXG5cdGlmIChwcm9wID09PSAnY2xhc3NOYW1lJykge1xuXHRcdHNldFByb3AoJ2NsYXNzTmFtZScsIHZhbCk7XG5cdH1cblx0ZWxzZSBpZiAocHJvcCA9PT0gJ2RldGVjdCcpIHtcblx0XHRzZXREZXRlY3QodmFsKTtcblx0fVxuXHRlbHNlIGlmIChwcm9wID09PSAnb3JkZXInKSB7XG5cdFx0c2V0T3JkZXIodmFsKTtcblx0fVxuXHRlbHNlIGlmIChwcm9wID09PSAncmVuZGVyJykge1xuXHRcdHNldFByb3AoJ3JlbmRlcicsIHZhbCk7XG5cdH1cblx0ZWxzZSBpZiAocHJvcCA9PT0gJ3NlYXJjaCcpIHtcblx0XHRzZXRQcm9wKCdzZWFyY2gnLCB2YWwpO1xuXHR9XG5cdGVsc2UgaWYgKCEgcHJvcCkge1xuXHRcdGlmICh2YWwuY2xhc3NOYW1lKSB7XG5cdFx0XHRzZXRQcm9wKCdjbGFzc05hbWUnLCB2YWwuY2xhc3NOYW1lKTtcblx0XHR9XG5cblx0XHRpZiAodmFsLmRldGVjdCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzZXREZXRlY3QodmFsLmRldGVjdCk7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbC5vcmRlcikge1xuXHRcdFx0c2V0T3JkZXIodmFsLm9yZGVyKTtcblx0XHR9XG5cblx0XHRpZiAodmFsLnJlbmRlciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzZXRQcm9wKCdyZW5kZXInLCB2YWwucmVuZGVyKTtcblx0XHR9XG5cblx0XHRpZiAodmFsLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzZXRQcm9wKCdzZWFyY2gnLCB2YWwuc2VhcmNoKTtcblx0XHR9XG5cdH1cbn1cblxuLy8gR2V0IGEgbGlzdCBvZiB0eXBlc1xuRGF0YVRhYmxlLnR5cGVzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gX2V4dFR5cGVzLmRldGVjdC5tYXAoZnVuY3Rpb24gKGZuKSB7XG5cdFx0cmV0dXJuIGZuLl9uYW1lO1xuXHR9KTtcbn07XG5cbnZhciBfX2RpYWNyaXRpY1NvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuXHRhID0gYSAhPT0gbnVsbCAmJiBhICE9PSB1bmRlZmluZWQgPyBhLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA6ICcnO1xuXHRiID0gYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgPyBiLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA6ICcnO1xuXG5cdC8vIENoZWNrZWQgZm9yIGBuYXZpZ2F0b3IubGFuZ3VhZ2VzYCBzdXBwb3J0IGluIGBvbmVPZmAgc28gdGhpcyBjb2RlIGNhbid0IGV4ZWN1dGUgaW4gb2xkXG5cdC8vIFNhZmFyaSBhbmQgdGh1cyBjYW4gZGlzYWJsZSB0aGlzIGNoZWNrXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG5cdHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYiwgbmF2aWdhdG9yLmxhbmd1YWdlc1swXSB8fCBuYXZpZ2F0b3IubGFuZ3VhZ2UsIHtcblx0XHRudW1lcmljOiB0cnVlLFxuXHRcdGlnbm9yZVB1bmN0dWF0aW9uOiB0cnVlLFxuXHR9KTtcbn1cblxudmFyIF9fZGlhY3JpdGljSHRtbFNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuXHRhID0gX3N0cmlwSHRtbChhKTtcblx0YiA9IF9zdHJpcEh0bWwoYik7XG5cblx0cmV0dXJuIF9fZGlhY3JpdGljU29ydChhLCBiKTtcbn1cblxuLy9cbi8vIEJ1aWx0IGluIGRhdGEgdHlwZXNcbi8vXG5cbkRhdGFUYWJsZS50eXBlKCdzdHJpbmcnLCB7XG5cdGRldGVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAnc3RyaW5nJztcblx0fSxcblx0b3JkZXI6IHtcblx0XHRwcmU6IGZ1bmN0aW9uICggYSApIHtcblx0XHRcdC8vIFRoaXMgaXMgYSBsaXR0bGUgY29tcGxleCwgYnV0IGZhc3RlciB0aGFuIGFsd2F5cyBjYWxsaW5nIHRvU3RyaW5nLFxuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdG9zdHJpbmctdi1jaGVja1xuXHRcdFx0cmV0dXJuIF9lbXB0eShhKSAmJiB0eXBlb2YgYSAhPT0gJ2Jvb2xlYW4nID9cblx0XHRcdFx0JycgOlxuXHRcdFx0XHR0eXBlb2YgYSA9PT0gJ3N0cmluZycgP1xuXHRcdFx0XHRcdGEudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0ISBhLnRvU3RyaW5nID9cblx0XHRcdFx0XHRcdCcnIDpcblx0XHRcdFx0XHRcdGEudG9TdHJpbmcoKTtcblx0XHR9XG5cdH0sXG5cdHNlYXJjaDogX2ZpbHRlclN0cmluZyhmYWxzZSwgdHJ1ZSlcbn0pO1xuXG5EYXRhVGFibGUudHlwZSgnc3RyaW5nLXV0ZjgnLCB7XG5cdGRldGVjdDoge1xuXHRcdGFsbE9mOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHQvLyBBdCBsZWFzdCBvbmUgZGF0YSBwb2ludCBtdXN0IGNvbnRhaW4gYSBub24tQVNDSUkgY2hhcmFjdGVyXG5cdFx0XHQvLyBUaGlzIGxpbmUgd2lsbCBhbHNvIGNoZWNrIGlmIG5hdmlnYXRvci5sYW5ndWFnZXMgaXMgc3VwcG9ydGVkIG9yIG5vdC4gSWYgbm90IChTYWZhcmkgMTAuMC0pXG5cdFx0XHQvLyB0aGlzIGRhdGEgdHlwZSB3b24ndCBiZSBzdXBwb3J0ZWQuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuXHRcdFx0cmV0dXJuICEgX2VtcHR5KCBkICkgJiYgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5tYXRjaCgvW15cXHgwMC1cXHg3Rl0vKTtcblx0XHR9XG5cdH0sXG5cdG9yZGVyOiB7XG5cdFx0YXNjOiBfX2RpYWNyaXRpY1NvcnQsXG5cdFx0ZGVzYzogZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBfX2RpYWNyaXRpY1NvcnQoYSwgYikgKiAtMTtcblx0XHR9XG5cdH0sXG5cdHNlYXJjaDogX2ZpbHRlclN0cmluZyhmYWxzZSwgdHJ1ZSlcbn0pO1xuXG5cbkRhdGFUYWJsZS50eXBlKCdodG1sJywge1xuXHRkZXRlY3Q6IHtcblx0XHRhbGxPZjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eSggZCApIHx8ICh0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5pbmRleE9mKCc8JykgIT09IC0xKTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHQvLyBBdCBsZWFzdCBvbmUgZGF0YSBwb2ludCBtdXN0IGNvbnRhaW4gYSBgPGBcblx0XHRcdHJldHVybiAhIF9lbXB0eSggZCApICYmIHR5cGVvZiBkID09PSAnc3RyaW5nJyAmJiBkLmluZGV4T2YoJzwnKSAhPT0gLTE7XG5cdFx0fVxuXHR9LFxuXHRvcmRlcjoge1xuXHRcdHByZTogZnVuY3Rpb24gKCBhICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eShhKSA/XG5cdFx0XHRcdCcnIDpcblx0XHRcdFx0YS5yZXBsYWNlID9cblx0XHRcdFx0XHRfc3RyaXBIdG1sKGEpLnRyaW0oKS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHRhKycnO1xuXHRcdH1cblx0fSxcblx0c2VhcmNoOiBfZmlsdGVyU3RyaW5nKHRydWUsIHRydWUpXG59KTtcblxuXG5EYXRhVGFibGUudHlwZSgnaHRtbC11dGY4Jywge1xuXHRkZXRlY3Q6IHtcblx0XHRhbGxPZjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0cmV0dXJuIF9lbXB0eSggZCApIHx8ICh0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5pbmRleE9mKCc8JykgIT09IC0xKTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHQvLyBBdCBsZWFzdCBvbmUgZGF0YSBwb2ludCBtdXN0IGNvbnRhaW4gYSBgPGAgYW5kIGEgbm9uLUFTQ0lJIGNoYXJhY3RlclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcblx0XHRcdHJldHVybiBuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmXG5cdFx0XHRcdCEgX2VtcHR5KCBkICkgJiZcblx0XHRcdFx0dHlwZW9mIGQgPT09ICdzdHJpbmcnICYmXG5cdFx0XHRcdGQuaW5kZXhPZignPCcpICE9PSAtMSAmJlxuXHRcdFx0XHR0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5tYXRjaCgvW15cXHgwMC1cXHg3Rl0vKTtcblx0XHR9XG5cdH0sXG5cdG9yZGVyOiB7XG5cdFx0YXNjOiBfX2RpYWNyaXRpY0h0bWxTb3J0LFxuXHRcdGRlc2M6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gX19kaWFjcml0aWNIdG1sU29ydChhLCBiKSAqIC0xO1xuXHRcdH1cblx0fSxcblx0c2VhcmNoOiBfZmlsdGVyU3RyaW5nKHRydWUsIHRydWUpXG59KTtcblxuXG5EYXRhVGFibGUudHlwZSgnZGF0ZScsIHtcblx0Y2xhc3NOYW1lOiAnZHQtdHlwZS1kYXRlJyxcblx0ZGV0ZWN0OiB7XG5cdFx0YWxsT2Y6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdC8vIFY4IHRyaWVzIF92ZXJ5XyBoYXJkIHRvIG1ha2UgYSBzdHJpbmcgcGFzc2VkIGludG8gYERhdGUucGFyc2UoKWBcblx0XHRcdC8vIHZhbGlkLCBzbyB3ZSBuZWVkIHRvIHVzZSBhIHJlZ2V4IHRvIHJlc3RyaWN0IGRhdGUgZm9ybWF0cy4gVXNlIGFcblx0XHRcdC8vIHBsdWctaW4gZm9yIGFueXRoaW5nIG90aGVyIHRoYW4gSVNPODYwMSBzdHlsZSBzdHJpbmdzXG5cdFx0XHRpZiAoIGQgJiYgIShkIGluc3RhbmNlb2YgRGF0ZSkgJiYgISBfcmVfZGF0ZS50ZXN0KGQpICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHZhciBwYXJzZWQgPSBEYXRlLnBhcnNlKGQpO1xuXHRcdFx0cmV0dXJuIChwYXJzZWQgIT09IG51bGwgJiYgIWlzTmFOKHBhcnNlZCkpIHx8IF9lbXB0eShkKTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHQvLyBBdCBsZWFzdCBvbmUgZW50cnkgbXVzdCBiZSBhIGRhdGUgb3IgYSBzdHJpbmcgd2l0aCBhIGRhdGVcblx0XHRcdHJldHVybiAoZCBpbnN0YW5jZW9mIERhdGUpIHx8ICh0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgX3JlX2RhdGUudGVzdChkKSk7XG5cdFx0fVxuXHR9LFxuXHRvcmRlcjoge1xuXHRcdHByZTogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0dmFyIHRzID0gRGF0ZS5wYXJzZSggZCApO1xuXHRcdFx0cmV0dXJuIGlzTmFOKHRzKSA/IC1JbmZpbml0eSA6IHRzO1xuXHRcdH1cblx0fVxufSk7XG5cblxuRGF0YVRhYmxlLnR5cGUoJ2h0bWwtbnVtLWZtdCcsIHtcblx0Y2xhc3NOYW1lOiAnZHQtdHlwZS1udW1lcmljJyxcblx0ZGV0ZWN0OiB7XG5cdFx0YWxsT2Y6IGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKSB7XG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaHRtbE51bWVyaWMoIGQsIGRlY2ltYWwsIHRydWUsIGZhbHNlICk7XG5cdFx0fSxcblx0XHRvbmVPZjogZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XG5cdFx0XHQvLyBBdCBsZWFzdCBvbmUgZGF0YSBwb2ludCBtdXN0IGNvbnRhaW4gYSBudW1lcmljIHZhbHVlXG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaHRtbE51bWVyaWMoIGQsIGRlY2ltYWwsIHRydWUsIGZhbHNlICk7XG5cdFx0fVxuXHR9LFxuXHRvcmRlcjoge1xuXHRcdHByZTogZnVuY3Rpb24gKCBkLCBzICkge1xuXHRcdFx0dmFyIGRwID0gcy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZHAsIF9yZV9odG1sLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHR9XG5cdH0sXG5cdHNlYXJjaDogX2ZpbHRlclN0cmluZyh0cnVlLCB0cnVlKVxufSk7XG5cblxuRGF0YVRhYmxlLnR5cGUoJ2h0bWwtbnVtJywge1xuXHRjbGFzc05hbWU6ICdkdC10eXBlLW51bWVyaWMnLFxuXHRkZXRlY3Q6IHtcblx0XHRhbGxPZjogZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9odG1sTnVtZXJpYyggZCwgZGVjaW1hbCwgZmFsc2UsIHRydWUgKTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcblx0XHRcdC8vIEF0IGxlYXN0IG9uZSBkYXRhIHBvaW50IG11c3QgY29udGFpbiBhIG51bWVyaWMgdmFsdWVcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9odG1sTnVtZXJpYyggZCwgZGVjaW1hbCwgZmFsc2UsIGZhbHNlICk7XG5cdFx0fVxuXHR9LFxuXHRvcmRlcjoge1xuXHRcdHByZTogZnVuY3Rpb24gKCBkLCBzICkge1xuXHRcdFx0dmFyIGRwID0gcy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZHAsIF9yZV9odG1sICk7XG5cdFx0fVxuXHR9LFxuXHRzZWFyY2g6IF9maWx0ZXJTdHJpbmcodHJ1ZSwgdHJ1ZSlcbn0pO1xuXG5cbkRhdGFUYWJsZS50eXBlKCdudW0tZm10Jywge1xuXHRjbGFzc05hbWU6ICdkdC10eXBlLW51bWVyaWMnLFxuXHRkZXRlY3Q6IHtcblx0XHRhbGxPZjogZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9pc051bWJlciggZCwgZGVjaW1hbCwgdHJ1ZSwgdHJ1ZSApO1xuXHRcdH0sXG5cdFx0b25lT2Y6IGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xuXHRcdFx0Ly8gQXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQgbXVzdCBjb250YWluIGEgbnVtZXJpYyB2YWx1ZVxuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsLCB0cnVlLCBmYWxzZSApO1xuXHRcdH1cblx0fSxcblx0b3JkZXI6IHtcblx0XHRwcmU6IGZ1bmN0aW9uICggZCwgcyApIHtcblx0XHRcdHZhciBkcCA9IHMub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRwLCBfcmVfZm9ybWF0dGVkX251bWVyaWMgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cbkRhdGFUYWJsZS50eXBlKCdudW0nLCB7XG5cdGNsYXNzTmFtZTogJ2R0LXR5cGUtbnVtZXJpYycsXG5cdGRldGVjdDoge1xuXHRcdGFsbE9mOiBmdW5jdGlvbiAoIGQsIHNldHRpbmdzICkge1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsLCBmYWxzZSwgdHJ1ZSApO1xuXHRcdH0sXG5cdFx0b25lT2Y6IGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xuXHRcdFx0Ly8gQXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQgbXVzdCBjb250YWluIGEgbnVtZXJpYyB2YWx1ZVxuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2lzTnVtYmVyKCBkLCBkZWNpbWFsLCBmYWxzZSwgZmFsc2UgKTtcblx0XHR9XG5cdH0sXG5cdG9yZGVyOiB7XG5cdFx0cHJlOiBmdW5jdGlvbiAoZCwgcykge1xuXHRcdFx0dmFyIGRwID0gcy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX19udW1lcmljUmVwbGFjZSggZCwgZHAgKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cblxuXG52YXIgX19udW1lcmljUmVwbGFjZSA9IGZ1bmN0aW9uICggZCwgZGVjaW1hbFBsYWNlLCByZTEsIHJlMiApIHtcblx0aWYgKCBkICE9PSAwICYmICghZCB8fCBkID09PSAnLScpICkge1xuXHRcdHJldHVybiAtSW5maW5pdHk7XG5cdH1cblx0XG5cdHZhciB0eXBlID0gdHlwZW9mIGQ7XG5cblx0aWYgKHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdiaWdpbnQnKSB7XG5cdFx0cmV0dXJuIGQ7XG5cdH1cblxuXHQvLyBJZiBhIGRlY2ltYWwgcGxhY2Ugb3RoZXIgdGhhbiBgLmAgaXMgdXNlZCwgaXQgbmVlZHMgdG8gYmUgZ2l2ZW4gdG8gdGhlXG5cdC8vIGZ1bmN0aW9uIHNvIHdlIGNhbiBkZXRlY3QgaXQgYW5kIHJlcGxhY2Ugd2l0aCBhIGAuYCB3aGljaCBpcyB0aGUgb25seVxuXHQvLyBkZWNpbWFsIHBsYWNlIEphdmFzY3JpcHQgcmVjb2duaXNlcyAtIGl0IGlzIG5vdCBsb2NhbGUgYXdhcmUuXG5cdGlmICggZGVjaW1hbFBsYWNlICkge1xuXHRcdGQgPSBfbnVtVG9EZWNpbWFsKCBkLCBkZWNpbWFsUGxhY2UgKTtcblx0fVxuXG5cdGlmICggZC5yZXBsYWNlICkge1xuXHRcdGlmICggcmUxICkge1xuXHRcdFx0ZCA9IGQucmVwbGFjZSggcmUxLCAnJyApO1xuXHRcdH1cblxuXHRcdGlmICggcmUyICkge1xuXHRcdFx0ZCA9IGQucmVwbGFjZSggcmUyLCAnJyApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkICogMTtcbn07XG5cblxuJC5leHRlbmQoIHRydWUsIERhdGFUYWJsZS5leHQucmVuZGVyZXIsIHtcblx0Zm9vdGVyOiB7XG5cdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY2xhc3NlcyApIHtcblx0XHRcdGNlbGwuYWRkQ2xhc3MoY2xhc3Nlcy50Zm9vdC5jZWxsKTtcblx0XHR9XG5cdH0sXG5cblx0aGVhZGVyOiB7XG5cdFx0XzogZnVuY3Rpb24gKCBzZXR0aW5ncywgY2VsbCwgY2xhc3NlcyApIHtcblx0XHRcdGNlbGwuYWRkQ2xhc3MoY2xhc3Nlcy50aGVhZC5jZWxsKTtcblxuXHRcdFx0aWYgKCEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0KSB7XG5cdFx0XHRcdGNlbGwuYWRkQ2xhc3MoY2xhc3Nlcy5vcmRlci5ub25lKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHRpdGxlUm93ID0gc2V0dGluZ3MudGl0bGVSb3c7XG5cdFx0XHR2YXIgaGVhZGVyUm93cyA9IGNlbGwuY2xvc2VzdCgndGhlYWQnKS5maW5kKCd0cicpO1xuXHRcdFx0dmFyIHJvd0lkeCA9IGNlbGwucGFyZW50KCkuaW5kZXgoKTtcblxuXHRcdFx0Ly8gQ29uZGl0aW9ucyB0byBub3QgYXBwbHkgdGhlIG9yZGVyaW5nIGljb25zXG5cdFx0XHRpZiAoXG5cdFx0XHRcdC8vIENlbGxzIGFuZCByb3dzIHdoaWNoIGhhdmUgdGhlIGF0dHJpYnV0ZSB0byBkaXNhYmxlIHRoZSBpY29uc1xuXHRcdFx0XHRjZWxsLmF0dHIoJ2RhdGEtZHQtb3JkZXInKSA9PT0gJ2Rpc2FibGUnIHx8XG5cdFx0XHRcdGNlbGwucGFyZW50KCkuYXR0cignZGF0YS1kdC1vcmRlcicpID09PSAnZGlzYWJsZScgfHxcblxuXHRcdFx0XHQvLyB0aXRsZVJvdyBzdXBwb3J0LCBmb3IgZGVmaW5pbmcgYSBzcGVjaWZpYyByb3cgaW4gdGhlIGhlYWRlclxuXHRcdFx0XHQodGl0bGVSb3cgPT09IHRydWUgJiYgcm93SWR4ICE9PSAwKSB8fFxuXHRcdFx0XHQodGl0bGVSb3cgPT09IGZhbHNlICYmIHJvd0lkeCAhPT0gaGVhZGVyUm93cy5sZW5ndGggLSAxKSB8fFxuXHRcdFx0XHQodHlwZW9mIHRpdGxlUm93ID09PSAnbnVtYmVyJyAmJiByb3dJZHggIT09IHRpdGxlUm93KVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gYWRkaXRpb25hbCBtYXJrLXVwIHJlcXVpcmVkXG5cdFx0XHQvLyBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIHVwZGF0ZSBvbiBzb3J0IC0gbm90ZSB0aGF0IHVzaW5nIHRoZVxuXHRcdFx0Ly8gYERUYCBuYW1lc3BhY2Ugd2lsbCBhbGxvdyB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBvbiBkZXN0cm95LCB3aGlsZSB0aGUgYGR0YCBuYW1lc3BhY2VkIGV2ZW50IGlzIHRoZSBvbmUgd2UgYXJlXG5cdFx0XHQvLyBsaXN0ZW5pbmcgZm9yXG5cdFx0XHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdvcmRlci5kdC5EVCBjb2x1bW4tdmlzaWJpbGl0eS5kdC5EVCcsIGZ1bmN0aW9uICggZSwgY3R4LCBjb2x1bW4gKSB7XG5cdFx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHsgLy8gbmVlZCB0byBjaGVjayB0aGlzIHRoaXMgaXMgdGhlIGhvc3Rcblx0XHRcdFx0XHRyZXR1cm47ICAgICAgICAgICAgICAgLy8gdGFibGUsIG5vdCBhIG5lc3RlZCBvbmVcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBzb3J0aW5nID0gY3R4LnNvcnREZXRhaWxzO1xuXG5cdFx0XHRcdGlmICghIHNvcnRpbmcpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb3JkZXJlZENvbHVtbnMgPSBfcGx1Y2soc29ydGluZywgJ2NvbCcpO1xuXG5cdFx0XHRcdC8vIFRoaXMgaGFuZGxlciBpcyBvbmx5IG5lZWRlZCBvbiBjb2x1bW4gdmlzaWJpbGl0eSBpZiB0aGUgY29sdW1uIGlzIHBhcnQgb2YgdGhlXG5cdFx0XHRcdC8vIG9yZGVyaW5nLiBJZiBpdCBpc24ndCwgdGhlbiB3ZSBjYW4gYmFpbCBvdXQgdG8gc2F2ZSBwZXJmb3JtYW5jZS4gSXQgY291bGQgYmUgYVxuXHRcdFx0XHQvLyBzZXBhcmF0ZSBldmVudCBoYW5kbGVyLCBidXQgdGhpcyBpcyBhIGJhbGFuY2UgYmV0d2VlbiBjb2RlIHJldXNlIC8gc2l6ZSBhbmQgcGVyZm9ybWFuY2Vcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coZSwgZS5uYW1lLCBjb2x1bW4sIG9yZGVyZWRDb2x1bW5zLCBvcmRlcmVkQ29sdW1ucy5pbmNsdWRlcyhjb2x1bW4pKVxuXHRcdFx0XHRpZiAoZS50eXBlID09PSAnY29sdW1uLXZpc2liaWxpdHknICYmICEgb3JkZXJlZENvbHVtbnMuaW5jbHVkZXMoY29sdW1uKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBpO1xuXHRcdFx0XHR2YXIgb3JkZXJDbGFzc2VzID0gY2xhc3Nlcy5vcmRlcjtcblx0XHRcdFx0dmFyIGNvbHVtbnMgPSBjdHguYXBpLmNvbHVtbnMoIGNlbGwgKTtcblx0XHRcdFx0dmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5zLmZsYXR0ZW4oKVswXV07XG5cdFx0XHRcdHZhciBvcmRlcmFibGUgPSBjb2x1bW5zLm9yZGVyYWJsZSgpLmluY2x1ZGVzKHRydWUpO1xuXHRcdFx0XHR2YXIgYXJpYVR5cGUgPSAnJztcblx0XHRcdFx0dmFyIGluZGV4ZXMgPSBjb2x1bW5zLmluZGV4ZXMoKTtcblx0XHRcdFx0dmFyIHNvcnREaXJzID0gY29sdW1ucy5vcmRlcmFibGUodHJ1ZSkuZmxhdHRlbigpO1xuXHRcdFx0XHR2YXIgdGFiSW5kZXggPSBzZXR0aW5ncy5pVGFiSW5kZXg7XG5cdFx0XHRcdHZhciBjYW5PcmRlciA9IGN0eC5vcmRlckhhbmRsZXIgJiYgb3JkZXJhYmxlO1xuXG5cdFx0XHRcdGNlbGxcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdFx0XHRvcmRlckNsYXNzZXMuaXNBc2MgKycgJytcblx0XHRcdFx0XHRcdG9yZGVyQ2xhc3Nlcy5pc0Rlc2Ncblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LnRvZ2dsZUNsYXNzKCBvcmRlckNsYXNzZXMubm9uZSwgISBvcmRlcmFibGUgKVxuXHRcdFx0XHRcdC50b2dnbGVDbGFzcyggb3JkZXJDbGFzc2VzLmNhbkFzYywgY2FuT3JkZXIgJiYgc29ydERpcnMuaW5jbHVkZXMoJ2FzYycpIClcblx0XHRcdFx0XHQudG9nZ2xlQ2xhc3MoIG9yZGVyQ2xhc3Nlcy5jYW5EZXNjLCBjYW5PcmRlciAmJiBzb3J0RGlycy5pbmNsdWRlcygnZGVzYycpICk7XG5cblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIGFsbCBvZiB0aGUgY29sdW1ucyB0aGF0IHRoaXMgY2VsbCBjb3ZlcnMgYXJlIGluY2x1ZGVkIGluIHRoZVxuXHRcdFx0XHQvLyBjdXJyZW50IG9yZGVyaW5nXG5cdFx0XHRcdHZhciBpc09yZGVyaW5nID0gdHJ1ZTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoaT0wOyBpPGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoISBvcmRlcmVkQ29sdW1ucy5pbmNsdWRlcyhpbmRleGVzW2ldKSkge1xuXHRcdFx0XHRcdFx0aXNPcmRlcmluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaXNPcmRlcmluZyApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIG9yZGVyaW5nIGRpcmVjdGlvbiBmb3IgdGhlIGNvbHVtbnMgdW5kZXIgdGhpcyBjZWxsXG5cdFx0XHRcdFx0Ly8gTm90ZSB0aGF0IGl0IGlzIHBvc3NpYmxlIGZvciBhIGNlbGwgdG8gYmUgYXNjIGFuZCBkZXNjIHNvcnRpbmdcblx0XHRcdFx0XHQvLyAoY29sdW1uIHNwYW5uaW5nIGNlbGxzKVxuXHRcdFx0XHRcdHZhciBvcmRlckRpcnMgPSBjb2x1bW5zLm9yZGVyKCk7XG5cblx0XHRcdFx0XHRjZWxsLmFkZENsYXNzKFxuXHRcdFx0XHRcdFx0b3JkZXJEaXJzLmluY2x1ZGVzKCdhc2MnKSA/IG9yZGVyQ2xhc3Nlcy5pc0FzYyA6ICcnICtcblx0XHRcdFx0XHRcdG9yZGVyRGlycy5pbmNsdWRlcygnZGVzYycpID8gb3JkZXJDbGFzc2VzLmlzRGVzYyA6ICcnXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIGZpcnN0IHZpc2libGUgY29sdW1uIHRoYXQgaGFzIG9yZGVyaW5nIGFwcGxpZWQgdG8gaXQgLSBpdCBnZXQnc1xuXHRcdFx0XHQvLyB0aGUgYXJpYSBpbmZvcm1hdGlvbiwgYXMgdGhlIEFSSUEgc3BlYyBzYXlzIHRoYXQgb25seSBvbmUgY29sdW1uIHNob3VsZFxuXHRcdFx0XHQvLyBiZSBtYXJrZWQgd2l0aCBhcmlhLXNvcnRcblx0XHRcdFx0dmFyIGZpcnN0VmlzID0gLTE7IC8vIGNvbHVtbiBpbmRleFxuXG5cdFx0XHRcdGZvciAoaT0wOyBpPG9yZGVyZWRDb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKHNldHRpbmdzLmFvQ29sdW1uc1tvcmRlcmVkQ29sdW1uc1tpXV0uYlZpc2libGUpIHtcblx0XHRcdFx0XHRcdGZpcnN0VmlzID0gb3JkZXJlZENvbHVtbnNbaV07XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaW5kZXhlc1swXSA9PSBmaXJzdFZpcykge1xuXHRcdFx0XHRcdHZhciBmaXJzdFNvcnQgPSBzb3J0aW5nWzBdO1xuXHRcdFx0XHRcdHZhciBzb3J0T3JkZXIgPSBjb2wuYXNTb3J0aW5nO1xuXG5cdFx0XHRcdFx0Y2VsbC5hdHRyKCdhcmlhLXNvcnQnLCBmaXJzdFNvcnQuZGlyID09PSAnYXNjJyA/ICdhc2NlbmRpbmcnIDogJ2Rlc2NlbmRpbmcnKTtcblxuXHRcdFx0XHRcdC8vIERldGVybWluZSBpZiB0aGUgbmV4dCBjbGljayB3aWxsIHJlbW92ZSBzb3J0aW5nIG9yIGNoYW5nZSB0aGUgc29ydFxuXHRcdFx0XHRcdGFyaWFUeXBlID0gISBzb3J0T3JkZXJbZmlyc3RTb3J0LmluZGV4ICsgMV0gPyAnUmVtb3ZlJyA6ICdSZXZlcnNlJztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjZWxsLnJlbW92ZUF0dHIoJ2FyaWEtc29ydCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWFrZSB0aGUgaGVhZGVycyB0YWItYWJsZSBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvblxuXHRcdFx0XHRpZiAob3JkZXJhYmxlKSB7XG5cdFx0XHRcdFx0dmFyIG9yZGVyU3BhbiA9IGNlbGwuZmluZCgnLmR0LWNvbHVtbi1vcmRlcicpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdG9yZGVyU3BhblxuXHRcdFx0XHRcdFx0LmF0dHIoJ3JvbGUnLCAnYnV0dG9uJylcblx0XHRcdFx0XHRcdC5hdHRyKCdhcmlhLWxhYmVsJywgb3JkZXJhYmxlXG5cdFx0XHRcdFx0XHRcdD8gY29sLmFyaWFUaXRsZSArIGN0eC5hcGkuaTE4bignb0FyaWEub3JkZXJhYmxlJyArIGFyaWFUeXBlKVxuXHRcdFx0XHRcdFx0XHQ6IGNvbC5hcmlhVGl0bGVcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAodGFiSW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRvcmRlclNwYW4uYXR0cigndGFiaW5kZXgnLCB0YWJJbmRleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9LFxuXG5cdGxheW91dDoge1xuXHRcdF86IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbnRhaW5lciwgaXRlbXMgKSB7XG5cdFx0XHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzLmxheW91dDtcblx0XHRcdHZhciByb3cgPSAkKCc8ZGl2Lz4nKVxuXHRcdFx0XHQuYXR0cignaWQnLCBpdGVtcy5pZCB8fCBudWxsKVxuXHRcdFx0XHQuYWRkQ2xhc3MoaXRlbXMuY2xhc3NOYW1lIHx8IGNsYXNzZXMucm93KVxuXHRcdFx0XHQuYXBwZW5kVG8oIGNvbnRhaW5lciApO1xuXG5cdFx0XHREYXRhVGFibGUuZXh0LnJlbmRlcmVyLmxheW91dC5fZm9yTGF5b3V0Um93KGl0ZW1zLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcblx0XHRcdFx0aWYgKGtleSA9PT0gJ2lkJyB8fCBrZXkgPT09ICdjbGFzc05hbWUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGtsYXNzID0gJyc7XG5cblx0XHRcdFx0aWYgKHZhbC50YWJsZSkge1xuXHRcdFx0XHRcdHJvdy5hZGRDbGFzcyhjbGFzc2VzLnRhYmxlUm93KTtcblx0XHRcdFx0XHRrbGFzcyArPSBjbGFzc2VzLnRhYmxlQ2VsbCArICcgJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChrZXkgPT09ICdzdGFydCcpIHtcblx0XHRcdFx0XHRrbGFzcyArPSBjbGFzc2VzLnN0YXJ0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGtleSA9PT0gJ2VuZCcpIHtcblx0XHRcdFx0XHRrbGFzcyArPSBjbGFzc2VzLmVuZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRrbGFzcyArPSBjbGFzc2VzLmZ1bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRcdGlkOiB2YWwuaWQgfHwgbnVsbCxcblx0XHRcdFx0XHRcdFwiY2xhc3NcIjogdmFsLmNsYXNzTmFtZVxuXHRcdFx0XHRcdFx0XHQ/IHZhbC5jbGFzc05hbWVcblx0XHRcdFx0XHRcdFx0OiBjbGFzc2VzLmNlbGwgKyAnICcgKyBrbGFzc1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFwcGVuZCggdmFsLmNvbnRlbnRzIClcblx0XHRcdFx0XHQuYXBwZW5kVG8oIHJvdyApO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8vIFNoYXJlZCBmb3IgdXNlIGJ5IHRoZSBzdHlsaW5nIGZyYW1ld29ya3Ncblx0XHRfZm9yTGF5b3V0Um93OiBmdW5jdGlvbiAoaXRlbXMsIGZuKSB7XG5cdFx0XHQvLyBBcyB3ZSBhcmUgaW5zZXJ0aW5nIGRvbSBlbGVtZW50cywgd2UgbmVlZCBzdGFydCAvIGVuZCBpbiBhXG5cdFx0XHQvLyBzcGVjaWZpYyBvcmRlciwgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIGZvciBzb3J0aW5nIHRoZSBsYXlvdXRcblx0XHRcdC8vIGtleXMuXG5cdFx0XHR2YXIgbGF5b3V0RW51bSA9IGZ1bmN0aW9uICh4KSB7XG5cdFx0XHRcdHN3aXRjaCAoeCkge1xuXHRcdFx0XHRcdGNhc2UgJyc6IHJldHVybiAwO1xuXHRcdFx0XHRcdGNhc2UgJ3N0YXJ0JzogcmV0dXJuIDE7XG5cdFx0XHRcdFx0Y2FzZSAnZW5kJzogcmV0dXJuIDI7XG5cdFx0XHRcdFx0ZGVmYXVsdDogcmV0dXJuIDM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdE9iamVjdFxuXHRcdFx0XHQua2V5cyhpdGVtcylcblx0XHRcdFx0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0XHRyZXR1cm4gbGF5b3V0RW51bShhKSAtIGxheW91dEVudW0oYik7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRmbihrZXksIGl0ZW1zW2tleV0pO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5EYXRhVGFibGUuZmVhdHVyZSA9IHt9O1xuXG4vLyBUaGlyZCBwYXJhbWV0ZXIgaXMgaW50ZXJuYWwgb25seSFcbkRhdGFUYWJsZS5mZWF0dXJlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKCBuYW1lLCBjYiwgbGVnYWN5ICkge1xuXHREYXRhVGFibGUuZXh0LmZlYXR1cmVzWyBuYW1lIF0gPSBjYjtcblxuXHRpZiAobGVnYWN5KSB7XG5cdFx0X2V4dC5mZWF0dXJlLnB1c2goe1xuXHRcdFx0Y0ZlYXR1cmU6IGxlZ2FjeSxcblx0XHRcdGZuSW5pdDogY2Jcblx0XHR9KTtcblx0fVxufTtcblxuZnVuY3Rpb24gX2RpdlByb3AoZWwsIHByb3AsIHZhbCkge1xuXHRpZiAodmFsKSB7XG5cdFx0ZWxbcHJvcF0gPSB2YWw7XG5cdH1cbn1cblxuRGF0YVRhYmxlLmZlYXR1cmUucmVnaXN0ZXIoICdkaXYnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBvcHRzICkge1xuXHR2YXIgbiA9ICQoJzxkaXY+JylbMF07XG5cblx0aWYgKG9wdHMpIHtcblx0XHRfZGl2UHJvcChuLCAnY2xhc3NOYW1lJywgb3B0cy5jbGFzc05hbWUpO1xuXHRcdF9kaXZQcm9wKG4sICdpZCcsIG9wdHMuaWQpO1xuXHRcdF9kaXZQcm9wKG4sICdpbm5lckhUTUwnLCBvcHRzLmh0bWwpO1xuXHRcdF9kaXZQcm9wKG4sICd0ZXh0Q29udGVudCcsIG9wdHMudGV4dCk7XG5cdH1cblxuXHRyZXR1cm4gbjtcbn0gKTtcblxuRGF0YVRhYmxlLmZlYXR1cmUucmVnaXN0ZXIoICdpbmZvJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cyApIHtcblx0Ly8gRm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgbGVnYWN5IGBpbmZvYCB0b3AgbGV2ZWwgb3B0aW9uXG5cdGlmICghIHNldHRpbmdzLm9GZWF0dXJlcy5iSW5mbykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyXG5cdFx0bGFuZyAgPSBzZXR0aW5ncy5vTGFuZ3VhZ2UsXG5cdFx0dGlkID0gc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0biA9ICQoJzxkaXYvPicsIHtcblx0XHRcdCdjbGFzcyc6IHNldHRpbmdzLm9DbGFzc2VzLmluZm8uY29udGFpbmVyLFxuXHRcdH0gKTtcblxuXHRvcHRzID0gJC5leHRlbmQoe1xuXHRcdGNhbGxiYWNrOiBsYW5nLmZuSW5mb0NhbGxiYWNrLFxuXHRcdGVtcHR5OiBsYW5nLnNJbmZvRW1wdHksXG5cdFx0cG9zdGZpeDogbGFuZy5zSW5mb1Bvc3RGaXgsXG5cdFx0c2VhcmNoOiBsYW5nLnNJbmZvRmlsdGVyZWQsXG5cdFx0dGV4dDogbGFuZy5zSW5mbyxcblx0fSwgb3B0cyk7XG5cblxuXHQvLyBVcGRhdGUgZGlzcGxheSBvbiBlYWNoIGRyYXdcblx0c2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaChmdW5jdGlvbiAocykge1xuXHRcdF9mblVwZGF0ZUluZm8ocywgb3B0cywgbik7XG5cdH0pO1xuXG5cdC8vIEZvciB0aGUgZmlyc3QgaW5mbyBkaXNwbGF5IGluIHRoZSB0YWJsZSwgd2UgYWRkIGEgY2FsbGJhY2sgYW5kIGFyaWEgaW5mb3JtYXRpb24uXG5cdGlmICghIHNldHRpbmdzLl9pbmZvRWwpIHtcblx0XHRuLmF0dHIoe1xuXHRcdFx0J2FyaWEtbGl2ZSc6ICdwb2xpdGUnLFxuXHRcdFx0aWQ6IHRpZCsnX2luZm8nLFxuXHRcdFx0cm9sZTogJ3N0YXR1cydcblx0XHR9KTtcblxuXHRcdC8vIFRhYmxlIGlzIGRlc2NyaWJlZCBieSBvdXIgaW5mbyBkaXZcblx0XHQkKHNldHRpbmdzLm5UYWJsZSkuYXR0ciggJ2FyaWEtZGVzY3JpYmVkYnknLCB0aWQrJ19pbmZvJyApO1xuXG5cdFx0c2V0dGluZ3MuX2luZm9FbCA9IG47XG5cdH1cblxuXHRyZXR1cm4gbjtcbn0sICdpJyApO1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgaW5mb3JtYXRpb24gZWxlbWVudHMgaW4gdGhlIGRpc3BsYXlcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuVXBkYXRlSW5mbyAoIHNldHRpbmdzLCBvcHRzLCBub2RlIClcbntcblx0dmFyXG5cdFx0c3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCsxLFxuXHRcdGVuZCAgID0gc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0bWF4ICAgPSBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpLFxuXHRcdHRvdGFsID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdG91dCAgID0gdG90YWxcblx0XHRcdD8gb3B0cy50ZXh0XG5cdFx0XHQ6IG9wdHMuZW1wdHk7XG5cblx0aWYgKCB0b3RhbCAhPT0gbWF4ICkge1xuXHRcdC8vIFJlY29yZCBzZXQgYWZ0ZXIgZmlsdGVyaW5nXG5cdFx0b3V0ICs9ICcgJyArIG9wdHMuc2VhcmNoO1xuXHR9XG5cblx0Ly8gQ29udmVydCB0aGUgbWFjcm9zXG5cdG91dCArPSBvcHRzLnBvc3RmaXg7XG5cdG91dCA9IF9mbk1hY3Jvcyggc2V0dGluZ3MsIG91dCApO1xuXG5cdGlmICggb3B0cy5jYWxsYmFjayApIHtcblx0XHRvdXQgPSBvcHRzLmNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSxcblx0XHRcdHNldHRpbmdzLCBzdGFydCwgZW5kLCBtYXgsIHRvdGFsLCBvdXRcblx0XHQpO1xuXHR9XG5cblx0bm9kZS5odG1sKCBvdXQgKTtcblxuXHRfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsIG51bGwsICdpbmZvJywgW3NldHRpbmdzLCBub2RlWzBdLCBvdXRdKTtcbn1cblxudmFyIF9fc2VhcmNoQ291bnRlciA9IDA7XG5cbi8vIG9wdHNcbi8vIC0gdGV4dFxuLy8gLSBwbGFjZWhvbGRlclxuRGF0YVRhYmxlLmZlYXR1cmUucmVnaXN0ZXIoICdzZWFyY2gnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBvcHRzICkge1xuXHQvLyBEb24ndCBzaG93IHRoZSBpbnB1dCBpZiBmaWx0ZXJpbmcgaXNuJ3QgYXZhaWxhYmxlIG9uIHRoZSB0YWJsZVxuXHRpZiAoISBzZXR0aW5ncy5vRmVhdHVyZXMuYkZpbHRlcikge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcy5zZWFyY2g7XG5cdHZhciB0YWJsZUlkID0gc2V0dGluZ3Muc1RhYmxlSWQ7XG5cdHZhciBsYW5ndWFnZSA9IHNldHRpbmdzLm9MYW5ndWFnZTtcblx0dmFyIHByZXZpb3VzU2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoO1xuXHR2YXIgaW5wdXQgPSAnPGlucHV0IHR5cGU9XCJzZWFyY2hcIiBjbGFzcz1cIicrY2xhc3Nlcy5pbnB1dCsnXCIvPic7XG5cblx0b3B0cyA9ICQuZXh0ZW5kKHtcblx0XHRwbGFjZWhvbGRlcjogbGFuZ3VhZ2Uuc1NlYXJjaFBsYWNlaG9sZGVyLFxuXHRcdHByb2Nlc3Npbmc6IGZhbHNlLFxuXHRcdHRleHQ6IGxhbmd1YWdlLnNTZWFyY2hcblx0fSwgb3B0cyk7XG5cblx0Ly8gVGhlIF9JTlBVVF8gaXMgb3B0aW9uYWwgLSBpcyBhcHBlbmRlZCBpZiBub3QgcHJlc2VudFxuXHRpZiAob3B0cy50ZXh0LmluZGV4T2YoJ19JTlBVVF8nKSA9PT0gLTEpIHtcblx0XHRvcHRzLnRleHQgKz0gJ19JTlBVVF8nO1xuXHR9XG5cblx0b3B0cy50ZXh0ID0gX2ZuTWFjcm9zKHNldHRpbmdzLCBvcHRzLnRleHQpO1xuXG5cdC8vIFdlIGNhbiBwdXQgdGhlIDxpbnB1dD4gb3V0c2lkZSBvZiB0aGUgbGFiZWwgaWYgaXQgaXMgYXQgdGhlIHN0YXJ0IG9yIGVuZFxuXHQvLyB3aGljaCBoZWxwcyBpbXByb3ZlIGFjY2Vzc2FiaWxpdHkgKG5vdCBhbGwgc2NyZWVuIHJlYWRlcnMgbGlrZSBpbXBsaWNpdFxuXHQvLyBmb3IgZWxlbWVudHMpLlxuXHR2YXIgZW5kID0gb3B0cy50ZXh0Lm1hdGNoKC9fSU5QVVRfJC8pO1xuXHR2YXIgc3RhcnQgPSBvcHRzLnRleHQubWF0Y2goL15fSU5QVVRfLyk7XG5cdHZhciByZW1vdmVkID0gb3B0cy50ZXh0LnJlcGxhY2UoL19JTlBVVF8vLCAnJyk7XG5cdHZhciBzdHIgPSAnPGxhYmVsPicgKyBvcHRzLnRleHQgKyAnPC9sYWJlbD4nO1xuXG5cdGlmIChzdGFydCkge1xuXHRcdHN0ciA9ICdfSU5QVVRfPGxhYmVsPicgKyByZW1vdmVkICsgJzwvbGFiZWw+Jztcblx0fVxuXHRlbHNlIGlmIChlbmQpIHtcblx0XHRzdHIgPSAnPGxhYmVsPicgKyByZW1vdmVkICsgJzwvbGFiZWw+X0lOUFVUXyc7XG5cdH1cblxuXHR2YXIgZmlsdGVyID0gJCgnPGRpdj4nKVxuXHRcdC5hZGRDbGFzcyhjbGFzc2VzLmNvbnRhaW5lcilcblx0XHQuYXBwZW5kKHN0ci5yZXBsYWNlKC9fSU5QVVRfLywgaW5wdXQpKTtcblxuXHQvLyBhZGQgZm9yIGFuZCBpZCB0byBsYWJlbCBhbmQgaW5wdXRcblx0ZmlsdGVyLmZpbmQoJ2xhYmVsJykuYXR0cignZm9yJywgJ2R0LXNlYXJjaC0nICsgX19zZWFyY2hDb3VudGVyKTtcblx0ZmlsdGVyLmZpbmQoJ2lucHV0JykuYXR0cignaWQnLCAnZHQtc2VhcmNoLScgKyBfX3NlYXJjaENvdW50ZXIpO1xuXHRfX3NlYXJjaENvdW50ZXIrKztcblxuXHR2YXIgc2VhcmNoRm4gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2YWwgPSB0aGlzLnZhbHVlO1xuXG5cdFx0aWYocHJldmlvdXNTZWFyY2gucmV0dXJuICYmIGV2ZW50LmtleSAhPT0gXCJFbnRlclwiKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogTm93IGRvIHRoZSBmaWx0ZXIgKi9cblx0XHRpZiAoIHZhbCAhPSBwcmV2aW91c1NlYXJjaC5zZWFyY2ggKSB7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nUnVuKHNldHRpbmdzLCBvcHRzLnByb2Nlc3NpbmcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cHJldmlvdXNTZWFyY2guc2VhcmNoID0gdmFsO1xuXHRcdFxuXHRcdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsIHByZXZpb3VzU2VhcmNoICk7XG5cdFx0XG5cdFx0XHRcdC8vIE5lZWQgdG8gcmVkcmF3LCB3aXRob3V0IHJlc29ydGluZ1xuXHRcdFx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IDA7XG5cdFx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cblx0dmFyIHNlYXJjaERlbGF5ID0gc2V0dGluZ3Muc2VhcmNoRGVsYXkgIT09IG51bGwgP1xuXHRcdHNldHRpbmdzLnNlYXJjaERlbGF5IDpcblx0XHQwO1xuXG5cdHZhciBqcUZpbHRlciA9ICQoJ2lucHV0JywgZmlsdGVyKVxuXHRcdC52YWwoIHByZXZpb3VzU2VhcmNoLnNlYXJjaCApXG5cdFx0LmF0dHIoICdwbGFjZWhvbGRlcicsIG9wdHMucGxhY2Vob2xkZXIgKVxuXHRcdC5vbihcblx0XHRcdCdrZXl1cC5EVCBzZWFyY2guRFQgaW5wdXQuRFQgcGFzdGUuRFQgY3V0LkRUJyxcblx0XHRcdHNlYXJjaERlbGF5ID9cblx0XHRcdFx0RGF0YVRhYmxlLnV0aWwuZGVib3VuY2UoIHNlYXJjaEZuLCBzZWFyY2hEZWxheSApIDpcblx0XHRcdFx0c2VhcmNoRm5cblx0XHQpXG5cdFx0Lm9uKCAnbW91c2V1cC5EVCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdC8vIEVkZ2UgZml4ISBFZGdlIDE3IGRvZXMgbm90IHRyaWdnZXIgYW55dGhpbmcgb3RoZXIgdGhhbiBtb3VzZSBldmVudHMgd2hlbiBjbGlja2luZ1xuXHRcdFx0Ly8gb24gdGhlIGNsZWFyIGljb24gKEVkZ2UgYnVnIDE3NTg0NTE1KS4gVGhpcyBpcyBzYWZlIGluIG90aGVyIGJyb3dzZXJzIGFzIGBzZWFyY2hGbmBcblx0XHRcdC8vIGNoZWNrcyB0aGUgdmFsdWUgdG8gc2VlIGlmIGl0IGhhcyBjaGFuZ2VkLiBJbiBvdGhlciBicm93c2VycyBpdCB3b24ndCBoYXZlLlxuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWFyY2hGbi5jYWxsKGpxRmlsdGVyWzBdLCBlKTtcblx0XHRcdH0sIDEwKTtcblx0XHR9IClcblx0XHQub24oICdrZXlwcmVzcy5EVCcsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdC8qIFByZXZlbnQgZm9ybSBzdWJtaXNzaW9uICovXG5cdFx0XHRpZiAoIGUua2V5Q29kZSA9PSAxMyApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gKVxuXHRcdC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgdGFibGVJZCk7XG5cblx0Ly8gVXBkYXRlIHRoZSBpbnB1dCBlbGVtZW50cyB3aGVuZXZlciB0aGUgdGFibGUgaXMgZmlsdGVyZWRcblx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnc2VhcmNoLmR0LkRUJywgZnVuY3Rpb24gKCBldiwgcyApIHtcblx0XHRpZiAoIHNldHRpbmdzID09PSBzICYmIGpxRmlsdGVyWzBdICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICkge1xuXHRcdFx0anFGaWx0ZXIudmFsKCB0eXBlb2YgcHJldmlvdXNTZWFyY2guc2VhcmNoICE9PSAnZnVuY3Rpb24nXG5cdFx0XHRcdD8gcHJldmlvdXNTZWFyY2guc2VhcmNoXG5cdFx0XHRcdDogJydcblx0XHRcdCk7XG5cdFx0fVxuXHR9ICk7XG5cblx0cmV0dXJuIGZpbHRlcjtcbn0sICdmJyApO1xuXG4vLyBvcHRzXG4vLyAtIHR5cGUgLSBidXR0b24gY29uZmlndXJhdGlvblxuLy8gLSBidXR0b25zIC0gbnVtYmVyIG9mIGJ1dHRvbnMgdG8gc2hvdyAtIG11c3QgYmUgb2RkXG5EYXRhVGFibGUuZmVhdHVyZS5yZWdpc3RlciggJ3BhZ2luZycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIG9wdHMgKSB7XG5cdC8vIERvbid0IHNob3cgdGhlIHBhZ2luZyBpbnB1dCBpZiB0aGUgdGFibGUgZG9lc24ndCBoYXZlIHBhZ2luZyBlbmFibGVkXG5cdGlmICghIHNldHRpbmdzLm9GZWF0dXJlcy5iUGFnaW5hdGUpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdG9wdHMgPSAkLmV4dGVuZCh7XG5cdFx0YnV0dG9uczogRGF0YVRhYmxlLmV4dC5wYWdlci5udW1iZXJzX2xlbmd0aCxcblx0XHR0eXBlOiBzZXR0aW5ncy5zUGFnaW5hdGlvblR5cGUsXG5cdFx0Ym91bmRhcnlOdW1iZXJzOiB0cnVlLFxuXHRcdGZpcnN0TGFzdDogdHJ1ZSxcblx0XHRwcmV2aW91c05leHQ6IHRydWUsXG5cdFx0bnVtYmVyczogdHJ1ZVxuXHR9LCBvcHRzKTtcblxuXHR2YXIgaG9zdCA9ICQoJzxkaXYvPicpXG5cdFx0LmFkZENsYXNzKHNldHRpbmdzLm9DbGFzc2VzLnBhZ2luZy5jb250YWluZXIgKyAob3B0cy50eXBlID8gJyBwYWdpbmdfJyArIG9wdHMudHlwZSA6ICcnKSlcblx0XHQuYXBwZW5kKFxuXHRcdFx0JCgnPG5hdj4nKVxuXHRcdFx0XHQuYXR0cignYXJpYS1sYWJlbCcsICdwYWdpbmF0aW9uJylcblx0XHRcdFx0LmFkZENsYXNzKHNldHRpbmdzLm9DbGFzc2VzLnBhZ2luZy5uYXYpXG5cdFx0KTtcblx0dmFyIGRyYXcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0X3BhZ2luZ0RyYXcoc2V0dGluZ3MsIGhvc3QuY2hpbGRyZW4oKSwgb3B0cyk7XG5cdH07XG5cblx0c2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaChkcmF3KTtcblxuXHQvLyBSZXNwb25zaXZlIHJlZHJhdyBvZiBwYWdpbmcgY29udHJvbFxuXHQkKHNldHRpbmdzLm5UYWJsZSkub24oJ2NvbHVtbi1zaXppbmcuZHQuRFQnLCBkcmF3KTtcblxuXHRyZXR1cm4gaG9zdDtcbn0sICdwJyApO1xuXG4vKipcbiAqIER5bmFtaWNhbGx5IGNyZWF0ZSB0aGUgYnV0dG9uIHR5cGUgYXJyYXkgYmFzZWQgb24gdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIFRoaXMgd2lsbCBvbmx5IGhhcHBlbiBpZiB0aGUgcGFnaW5nIHR5cGUgaXMgbm90IGRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIF9wYWdpbmdEeW5hbWljKG9wdHMpIHtcblx0dmFyIG91dCA9IFtdO1xuXG5cdGlmIChvcHRzLm51bWJlcnMpIHtcblx0XHRvdXQucHVzaCgnbnVtYmVycycpO1xuXHR9XG5cblx0aWYgKG9wdHMucHJldmlvdXNOZXh0KSB7XG5cdFx0b3V0LnVuc2hpZnQoJ3ByZXZpb3VzJyk7XG5cdFx0b3V0LnB1c2goJ25leHQnKTtcblx0fVxuXG5cdGlmIChvcHRzLmZpcnN0TGFzdCkge1xuXHRcdG91dC51bnNoaWZ0KCdmaXJzdCcpO1xuXHRcdG91dC5wdXNoKCdsYXN0Jyk7XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBfcGFnaW5nRHJhdyhzZXR0aW5ncywgaG9zdCwgb3B0cykge1xuXHRpZiAoISBzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhclxuXHRcdHBsdWdpbiA9IG9wdHMudHlwZVxuXHRcdFx0PyBEYXRhVGFibGUuZXh0LnBhZ2VyWyBvcHRzLnR5cGUgXVxuXHRcdFx0OiBfcGFnaW5nRHluYW1pYyxcblx0XHRhcmlhID0gc2V0dGluZ3Mub0xhbmd1YWdlLm9BcmlhLnBhZ2luYXRlIHx8IHt9LFxuXHRcdHN0YXJ0ICAgICAgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRsZW4gICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdHZpc1JlY29yZHMgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXG5cdFx0YWxsICAgICAgICA9IGxlbiA9PT0gLTEsXG5cdFx0cGFnZSA9IGFsbCA/IDAgOiBNYXRoLmNlaWwoIHN0YXJ0IC8gbGVuICksXG5cdFx0cGFnZXMgPSBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXNSZWNvcmRzIC8gbGVuICksXG5cdFx0YnV0dG9ucyA9IFtdLFxuXHRcdGJ1dHRvbkVscyA9IFtdLFxuXHRcdGJ1dHRvbnNOZXN0ZWQgPSBwbHVnaW4ob3B0cylcblx0XHRcdC5tYXAoZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsID09PSAnbnVtYmVycydcblx0XHRcdFx0XHQ/IF9wYWdpbmdOdW1iZXJzKHBhZ2UsIHBhZ2VzLCBvcHRzLmJ1dHRvbnMsIG9wdHMuYm91bmRhcnlOdW1iZXJzKVxuXHRcdFx0XHRcdDogdmFsO1xuXHRcdFx0fSk7XG5cblx0Ly8gLmZsYXQoKSB3b3VsZCBiZSBiZXR0ZXIsIGJ1dCBub3Qgc3VwcG9ydGVkIGluIG9sZCBTYWZhcmlcblx0YnV0dG9ucyA9IGJ1dHRvbnMuY29uY2F0LmFwcGx5KGJ1dHRvbnMsIGJ1dHRvbnNOZXN0ZWQpO1xuXG5cdGZvciAodmFyIGk9MCA7IGk8YnV0dG9ucy5sZW5ndGggOyBpKyspIHtcblx0XHR2YXIgYnV0dG9uID0gYnV0dG9uc1tpXTtcblxuXHRcdHZhciBidG5JbmZvID0gX3BhZ2luZ0J1dHRvbkluZm8oc2V0dGluZ3MsIGJ1dHRvbiwgcGFnZSwgcGFnZXMpO1xuXHRcdHZhciBidG4gPSBfZm5SZW5kZXJlciggc2V0dGluZ3MsICdwYWdpbmdCdXR0b24nICkoXG5cdFx0XHRzZXR0aW5ncyxcblx0XHRcdGJ1dHRvbixcblx0XHRcdGJ0bkluZm8uZGlzcGxheSxcblx0XHRcdGJ0bkluZm8uYWN0aXZlLFxuXHRcdFx0YnRuSW5mby5kaXNhYmxlZFxuXHRcdCk7XG5cblx0XHR2YXIgYXJpYUxhYmVsID0gdHlwZW9mIGJ1dHRvbiA9PT0gJ3N0cmluZydcblx0XHRcdD8gYXJpYVsgYnV0dG9uIF1cblx0XHRcdDogYXJpYS5udW1iZXJcblx0XHRcdFx0PyBhcmlhLm51bWJlciArIChidXR0b24rMSlcblx0XHRcdFx0OiBudWxsO1xuXG5cdFx0Ly8gQ29tbW9uIGF0dHJpYnV0ZXNcblx0XHQkKGJ0bi5jbGlja2VyKS5hdHRyKHtcblx0XHRcdCdhcmlhLWNvbnRyb2xzJzogc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0XHQnYXJpYS1kaXNhYmxlZCc6IGJ0bkluZm8uZGlzYWJsZWQgPyAndHJ1ZScgOiBudWxsLFxuXHRcdFx0J2FyaWEtY3VycmVudCc6IGJ0bkluZm8uYWN0aXZlID8gJ3BhZ2UnIDogbnVsbCxcblx0XHRcdCdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLFxuXHRcdFx0J2RhdGEtZHQtaWR4JzogYnV0dG9uLFxuXHRcdFx0J3RhYkluZGV4JzogYnRuSW5mby5kaXNhYmxlZFxuXHRcdFx0XHQ/IC0xXG5cdFx0XHRcdDogc2V0dGluZ3MuaVRhYkluZGV4ICYmIGJ0bi5jbGlja2VyWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdzcGFuJ1xuXHRcdFx0XHRcdD8gc2V0dGluZ3MuaVRhYkluZGV4XG5cdFx0XHRcdFx0OiBudWxsLCAvLyBgMGAgZG9lc24ndCBuZWVkIGEgdGFiSW5kZXggc2luY2UgaXQgaXMgdGhlIGRlZmF1bHRcblx0XHR9KTtcblxuXHRcdGlmICh0eXBlb2YgYnV0dG9uICE9PSAnbnVtYmVyJykge1xuXHRcdFx0JChidG4uY2xpY2tlcikuYWRkQ2xhc3MoYnV0dG9uKTtcblx0XHR9XG5cblx0XHRfZm5CaW5kQWN0aW9uKFxuXHRcdFx0YnRuLmNsaWNrZXIsIHthY3Rpb246IGJ1dHRvbn0sIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdF9mblBhZ2VDaGFuZ2UoIHNldHRpbmdzLCBlLmRhdGEuYWN0aW9uLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGJ1dHRvbkVscy5wdXNoKGJ0bi5kaXNwbGF5KTtcblx0fVxuXG5cdHZhciB3cmFwcGVkID0gX2ZuUmVuZGVyZXIoc2V0dGluZ3MsICdwYWdpbmdDb250YWluZXInKShcblx0XHRzZXR0aW5ncywgYnV0dG9uRWxzXG5cdCk7XG5cblx0dmFyIGFjdGl2ZUVsID0gaG9zdC5maW5kKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmRhdGEoJ2R0LWlkeCcpO1xuXG5cdGhvc3QuZW1wdHkoKS5hcHBlbmQod3JhcHBlZCk7XG5cblx0aWYgKCBhY3RpdmVFbCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGhvc3QuZmluZCggJ1tkYXRhLWR0LWlkeD0nK2FjdGl2ZUVsKyddJyApLnRyaWdnZXIoJ2ZvY3VzJyk7XG5cdH1cblxuXHQvLyBSZXNwb25zaXZlIC0gY2hlY2sgaWYgdGhlIGJ1dHRvbnMgYXJlIG92ZXIgdHdvIGxpbmVzIGJhc2VkIG9uIHRoZVxuXHQvLyBoZWlnaHQgb2YgdGhlIGJ1dHRvbnMgYW5kIHRoZSBjb250YWluZXIuXG5cdGlmIChidXR0b25FbHMubGVuZ3RoKSB7XG5cdFx0dmFyIG91dGVySGVpZ2h0ID0gJChidXR0b25FbHNbMF0pLm91dGVySGVpZ2h0KCk7XG5cdFxuXHRcdGlmIChcblx0XHRcdG9wdHMuYnV0dG9ucyA+IDEgJiYgLy8gcHJldmVudCBpbmZpbml0ZVxuXHRcdFx0b3V0ZXJIZWlnaHQgPiAwICYmIC8vIHdpbGwgYmUgMCBpZiBoaWRkZW5cblx0XHRcdCQoaG9zdCkuaGVpZ2h0KCkgPj0gKG91dGVySGVpZ2h0ICogMikgLSAxMFxuXHRcdCkge1xuXHRcdFx0X3BhZ2luZ0RyYXcoc2V0dGluZ3MsIGhvc3QsICQuZXh0ZW5kKHt9LCBvcHRzLCB7IGJ1dHRvbnM6IG9wdHMuYnV0dG9ucyAtIDIgfSkpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEdldCBwcm9wZXJ0aWVzIGZvciBhIGJ1dHRvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBwYWdpbmcgc3RhdGUgb2YgdGhlIHRhYmxlXG4gKlxuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEVCBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gYnV0dG9uIFRoZSBidXR0b24gdHlwZSBpbiBxdWVzdGlvblxuICogQHBhcmFtIHsqfSBwYWdlIFRhYmxlJ3MgY3VycmVudCBwYWdlXG4gKiBAcGFyYW0geyp9IHBhZ2VzIE51bWJlciBvZiBwYWdlc1xuICogQHJldHVybnMgSW5mbyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gX3BhZ2luZ0J1dHRvbkluZm8oc2V0dGluZ3MsIGJ1dHRvbiwgcGFnZSwgcGFnZXMpIHtcblx0dmFyIGxhbmcgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub1BhZ2luYXRlO1xuXHR2YXIgbyA9IHtcblx0XHRkaXNwbGF5OiAnJyxcblx0XHRhY3RpdmU6IGZhbHNlLFxuXHRcdGRpc2FibGVkOiBmYWxzZVxuXHR9O1xuXG5cdHN3aXRjaCAoIGJ1dHRvbiApIHtcblx0XHRjYXNlICdlbGxpcHNpcyc6XG5cdFx0XHRvLmRpc3BsYXkgPSAnJiN4MjAyNjsnO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdmaXJzdCc6XG5cdFx0XHRvLmRpc3BsYXkgPSBsYW5nLnNGaXJzdDtcblxuXHRcdFx0aWYgKHBhZ2UgPT09IDApIHtcblx0XHRcdFx0by5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ3ByZXZpb3VzJzpcblx0XHRcdG8uZGlzcGxheSA9IGxhbmcuc1ByZXZpb3VzO1xuXG5cdFx0XHRpZiAoIHBhZ2UgPT09IDAgKSB7XG5cdFx0XHRcdG8uZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICduZXh0Jzpcblx0XHRcdG8uZGlzcGxheSA9IGxhbmcuc05leHQ7XG5cblx0XHRcdGlmICggcGFnZXMgPT09IDAgfHwgcGFnZSA9PT0gcGFnZXMtMSApIHtcblx0XHRcdFx0by5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2xhc3QnOlxuXHRcdFx0by5kaXNwbGF5ID0gbGFuZy5zTGFzdDtcblxuXHRcdFx0aWYgKCBwYWdlcyA9PT0gMCB8fCBwYWdlID09PSBwYWdlcy0xICkge1xuXHRcdFx0XHRvLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGlmICggdHlwZW9mIGJ1dHRvbiA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHRcdG8uZGlzcGxheSA9IHNldHRpbmdzLmZuRm9ybWF0TnVtYmVyKCBidXR0b24gKyAxICk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocGFnZSA9PT0gYnV0dG9uKSB7XG5cdFx0XHRcdFx0by5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdHJldHVybiBvO1xufVxuXG4vKipcbiAqIENvbXB1dGUgd2hhdCBudW1iZXIgYnV0dG9ucyB0byBzaG93IGluIHRoZSBwYWdpbmcgY29udHJvbFxuICpcbiAqIEBwYXJhbSB7Kn0gcGFnZSBDdXJyZW50IHBhZ2VcbiAqIEBwYXJhbSB7Kn0gcGFnZXMgVG90YWwgbnVtYmVyIG9mIHBhZ2VzXG4gKiBAcGFyYW0geyp9IGJ1dHRvbnMgVGFyZ2V0IG51bWJlciBvZiBudW1iZXIgYnV0dG9uc1xuICogQHBhcmFtIHtib29sZWFufSBhZGRGaXJzdExhc3QgSW5kaWNhdGUgaWYgcGFnZSAxIGFuZCBlbmQgc2hvdWxkIGJlIGluY2x1ZGVkXG4gKiBAcmV0dXJucyBCdXR0b25zIHRvIHNob3dcbiAqL1xuZnVuY3Rpb24gX3BhZ2luZ051bWJlcnMgKCBwYWdlLCBwYWdlcywgYnV0dG9ucywgYWRkRmlyc3RMYXN0ICkge1xuXHR2YXJcblx0XHRudW1iZXJzID0gW10sXG5cdFx0aGFsZiA9IE1hdGguZmxvb3IoYnV0dG9ucyAvIDIpLFxuXHRcdGJlZm9yZSA9IGFkZEZpcnN0TGFzdCA/IDIgOiAxLFxuXHRcdGFmdGVyID0gYWRkRmlyc3RMYXN0ID8gMSA6IDA7XG5cblx0aWYgKCBwYWdlcyA8PSBidXR0b25zICkge1xuXHRcdG51bWJlcnMgPSBfcmFuZ2UoMCwgcGFnZXMpO1xuXHR9XG5cdGVsc2UgaWYgKGJ1dHRvbnMgPT09IDEpIHtcblx0XHQvLyBTaW5nbGUgYnV0dG9uIC0gY3VycmVudCBwYWdlIG9ubHlcblx0XHRudW1iZXJzID0gW3BhZ2VdO1xuXHR9XG5cdGVsc2UgaWYgKGJ1dHRvbnMgPT09IDMpIHtcblx0XHQvLyBTcGVjaWFsIGxvZ2ljIGZvciBqdXN0IHRocmVlIGJ1dHRvbnNcblx0XHRpZiAocGFnZSA8PSAxKSB7XG5cdFx0XHRudW1iZXJzID0gWzAsIDEsICdlbGxpcHNpcyddO1xuXHRcdH1cblx0XHRlbHNlIGlmIChwYWdlID49IHBhZ2VzIC0gMikge1xuXHRcdFx0bnVtYmVycyA9IF9yYW5nZShwYWdlcy0yLCBwYWdlcyk7XG5cdFx0XHRudW1iZXJzLnVuc2hpZnQoJ2VsbGlwc2lzJyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bnVtYmVycyA9IFsnZWxsaXBzaXMnLCBwYWdlLCAnZWxsaXBzaXMnXTtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIHBhZ2UgPD0gaGFsZiApIHtcblx0XHRudW1iZXJzID0gX3JhbmdlKDAsIGJ1dHRvbnMtYmVmb3JlKTtcblx0XHRudW1iZXJzLnB1c2goJ2VsbGlwc2lzJyk7XG5cblx0XHRpZiAoYWRkRmlyc3RMYXN0KSB7XG5cdFx0XHRudW1iZXJzLnB1c2gocGFnZXMtMSk7XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKCBwYWdlID49IHBhZ2VzIC0gMSAtIGhhbGYgKSB7XG5cdFx0bnVtYmVycyA9IF9yYW5nZShwYWdlcy0oYnV0dG9ucy1iZWZvcmUpLCBwYWdlcyk7XG5cdFx0bnVtYmVycy51bnNoaWZ0KCdlbGxpcHNpcycpO1xuXG5cdFx0aWYgKGFkZEZpcnN0TGFzdCkge1xuXHRcdFx0bnVtYmVycy51bnNoaWZ0KDApO1xuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHRudW1iZXJzID0gX3JhbmdlKHBhZ2UtaGFsZitiZWZvcmUsIHBhZ2UraGFsZi1hZnRlcik7XG5cdFx0bnVtYmVycy5wdXNoKCdlbGxpcHNpcycpO1xuXHRcdG51bWJlcnMudW5zaGlmdCgnZWxsaXBzaXMnKTtcblxuXHRcdGlmIChhZGRGaXJzdExhc3QpIHtcblx0XHRcdG51bWJlcnMucHVzaChwYWdlcy0xKTtcblx0XHRcdG51bWJlcnMudW5zaGlmdCgwKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbnVtYmVycztcbn1cblxudmFyIF9fbGVuZ3RoQ291bnRlciA9IDA7XG5cbi8vIG9wdHNcbi8vIC0gbWVudVxuLy8gLSB0ZXh0XG5EYXRhVGFibGUuZmVhdHVyZS5yZWdpc3RlciggJ3BhZ2VMZW5ndGgnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBvcHRzICkge1xuXHR2YXIgZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXM7XG5cblx0Ly8gRm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgbGVnYWN5IGBwYWdlTGVuZ3RoYCB0b3AgbGV2ZWwgb3B0aW9uXG5cdGlmICghIGZlYXR1cmVzLmJQYWdpbmF0ZSB8fCAhIGZlYXR1cmVzLmJMZW5ndGhDaGFuZ2UpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdG9wdHMgPSAkLmV4dGVuZCh7XG5cdFx0bWVudTogc2V0dGluZ3MuYUxlbmd0aE1lbnUsXG5cdFx0dGV4dDogc2V0dGluZ3Mub0xhbmd1YWdlLnNMZW5ndGhNZW51XG5cdH0sIG9wdHMpO1xuXG5cdHZhclxuXHRcdGNsYXNzZXMgID0gc2V0dGluZ3Mub0NsYXNzZXMubGVuZ3RoLFxuXHRcdHRhYmxlSWQgID0gc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0bWVudSAgICAgPSBvcHRzLm1lbnUsXG5cdFx0bGVuZ3RocyAgPSBbXSxcblx0XHRsYW5ndWFnZSA9IFtdLFxuXHRcdGk7XG5cblx0Ly8gT3B0aW9ucyBjYW4gYmUgZ2l2ZW4gaW4gYSBudW1iZXIgb2Ygd2F5c1xuXHRpZiAoQXJyYXkuaXNBcnJheSggbWVudVswXSApKSB7XG5cdFx0Ly8gT2xkIDEueCBzdHlsZSAtIDJEIGFycmF5XG5cdFx0bGVuZ3RocyA9IG1lbnVbMF07XG5cdFx0bGFuZ3VhZ2UgPSBtZW51WzFdO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGZvciAoIGk9MCA7IGk8bWVudS5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHQvLyBBbiBvYmplY3Qgd2l0aCBkaWZmZXJlbnQgbGFiZWwgYW5kIHZhbHVlXG5cdFx0XHRpZiAoJC5pc1BsYWluT2JqZWN0KG1lbnVbaV0pKSB7XG5cdFx0XHRcdGxlbmd0aHMucHVzaChtZW51W2ldLnZhbHVlKTtcblx0XHRcdFx0bGFuZ3VhZ2UucHVzaChtZW51W2ldLmxhYmVsKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBPciBqdXN0IGEgbnVtYmVyIHRvIGRpc3BsYXkgYW5kIHVzZVxuXHRcdFx0XHRsZW5ndGhzLnB1c2gobWVudVtpXSk7XG5cdFx0XHRcdGxhbmd1YWdlLnB1c2gobWVudVtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gV2UgY2FuIHB1dCB0aGUgPHNlbGVjdD4gb3V0c2lkZSBvZiB0aGUgbGFiZWwgaWYgaXQgaXMgYXQgdGhlIHN0YXJ0IG9yXG5cdC8vIGVuZCB3aGljaCBoZWxwcyBpbXByb3ZlIGFjY2Vzc2FiaWxpdHkgKG5vdCBhbGwgc2NyZWVuIHJlYWRlcnMgbGlrZVxuXHQvLyBpbXBsaWNpdCBmb3IgZWxlbWVudHMpLlxuXHR2YXIgZW5kID0gb3B0cy50ZXh0Lm1hdGNoKC9fTUVOVV8kLyk7XG5cdHZhciBzdGFydCA9IG9wdHMudGV4dC5tYXRjaCgvXl9NRU5VXy8pO1xuXHR2YXIgcmVtb3ZlZCA9IG9wdHMudGV4dC5yZXBsYWNlKC9fTUVOVV8vLCAnJyk7XG5cdHZhciBzdHIgPSAnPGxhYmVsPicgKyBvcHRzLnRleHQgKyAnPC9sYWJlbD4nO1xuXG5cdGlmIChzdGFydCkge1xuXHRcdHN0ciA9ICdfTUVOVV88bGFiZWw+JyArIHJlbW92ZWQgKyAnPC9sYWJlbD4nO1xuXHR9XG5cdGVsc2UgaWYgKGVuZCkge1xuXHRcdHN0ciA9ICc8bGFiZWw+JyArIHJlbW92ZWQgKyAnPC9sYWJlbD5fTUVOVV8nO1xuXHR9XG5cblx0Ly8gV3JhcHBlciBlbGVtZW50IC0gdXNlIGEgc3BhbiBhcyBhIGhvbGRlciBmb3Igd2hlcmUgdGhlIHNlbGVjdCB3aWxsIGdvXG5cdHZhciB0bXBJZCA9ICd0bXAtJyArICgrbmV3IERhdGUoKSlcblx0dmFyIGRpdiA9ICQoJzxkaXYvPicpXG5cdFx0LmFkZENsYXNzKCBjbGFzc2VzLmNvbnRhaW5lciApXG5cdFx0LmFwcGVuZChcblx0XHRcdHN0ci5yZXBsYWNlKCAnX01FTlVfJywgJzxzcGFuIGlkPVwiJyt0bXBJZCsnXCI+PC9zcGFuPicgKVxuXHRcdCk7XG5cblx0Ly8gU2F2ZSB0ZXh0IG5vZGUgY29udGVudCBmb3IgbWFjcm8gdXBkYXRpbmdcblx0dmFyIHRleHROb2RlcyA9IFtdO1xuXHRBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkaXYuZmluZCgnbGFiZWwnKVswXS5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuXHRcdGlmIChlbC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRcdHRleHROb2Rlcy5wdXNoKHtcblx0XHRcdFx0ZWw6IGVsLFxuXHRcdFx0XHR0ZXh0OiBlbC50ZXh0Q29udGVudFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBVcGRhdGUgdGhlIGxhYmVsIHRleHQgaW4gY2FzZSBpdCBoYXMgYW4gZW50cmllcyB2YWx1ZVxuXHR2YXIgdXBkYXRlRW50cmllcyA9IGZ1bmN0aW9uIChsZW4pIHtcblx0XHR0ZXh0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0bm9kZS5lbC50ZXh0Q29udGVudCA9IF9mbk1hY3JvcyhzZXR0aW5ncywgbm9kZS50ZXh0LCBsZW4pO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gTmV4dCwgdGhlIHNlbGVjdCBpdHNlbGYsIGFsb25nIHdpdGggdGhlIG9wdGlvbnNcblx0dmFyIHNlbGVjdCA9ICQoJzxzZWxlY3QvPicsIHtcblx0XHQnYXJpYS1jb250cm9scyc6IHRhYmxlSWQsXG5cdFx0J2NsYXNzJzogICAgICAgICBjbGFzc2VzLnNlbGVjdFxuXHR9ICk7XG5cblx0Zm9yICggaT0wIDsgaTxsZW5ndGhzLmxlbmd0aCA7IGkrKyApIHtcblx0XHQvLyBBdHRlbXB0IHRvIGxvb2sgdXAgdGhlIGxlbmd0aCBmcm9tIHRoZSBpMThuIG9wdGlvbnNcblx0XHR2YXIgbGFiZWwgPSBzZXR0aW5ncy5hcGkuaTE4bignbGVuZ3RoTGFiZWxzLicgKyBsZW5ndGhzW2ldLCBudWxsKTtcblxuXHRcdGlmIChsYWJlbCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gSWYgbm90IHByZXNlbnQsIGZhbGxiYWNrIHRvIG9sZCBzdHlsZVxuXHRcdFx0bGFiZWwgPSB0eXBlb2YgbGFuZ3VhZ2VbaV0gPT09ICdudW1iZXInID9cblx0XHRcdFx0c2V0dGluZ3MuZm5Gb3JtYXROdW1iZXIoIGxhbmd1YWdlW2ldICkgOlxuXHRcdFx0XHRsYW5ndWFnZVtpXTtcblx0XHR9XG5cblx0XHRzZWxlY3RbMF1bIGkgXSA9IG5ldyBPcHRpb24obGFiZWwsIGxlbmd0aHNbaV0pO1xuXHR9XG5cblx0Ly8gYWRkIGZvciBhbmQgaWQgdG8gbGFiZWwgYW5kIGlucHV0XG5cdGRpdi5maW5kKCdsYWJlbCcpLmF0dHIoJ2ZvcicsICdkdC1sZW5ndGgtJyArIF9fbGVuZ3RoQ291bnRlcik7XG5cdHNlbGVjdC5hdHRyKCdpZCcsICdkdC1sZW5ndGgtJyArIF9fbGVuZ3RoQ291bnRlcik7XG5cdF9fbGVuZ3RoQ291bnRlcisrO1xuXG5cdC8vIFN3YXAgaW4gdGhlIHNlbGVjdCBsaXN0XG5cdGRpdi5maW5kKCcjJyArIHRtcElkKS5yZXBsYWNlV2l0aChzZWxlY3QpO1xuXG5cdC8vIENhbid0IHVzZSBgc2VsZWN0YCB2YXJpYWJsZSBhcyB1c2VyIG1pZ2h0IHByb3ZpZGUgdGhlaXIgb3duIGFuZCB0aGVcblx0Ly8gcmVmZXJlbmNlIGlzIGJyb2tlbiBieSB0aGUgdXNlIG9mIG91dGVySFRNTFxuXHQkKCdzZWxlY3QnLCBkaXYpXG5cdFx0LnZhbCggc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIClcblx0XHQub24oICdjaGFuZ2UuRFQnLCBmdW5jdGlvbigpIHtcblx0XHRcdF9mbkxlbmd0aENoYW5nZSggc2V0dGluZ3MsICQodGhpcykudmFsKCkgKTtcblx0XHRcdF9mbkRyYXcoIHNldHRpbmdzICk7XG5cdFx0fSApO1xuXG5cdC8vIFVwZGF0ZSBub2RlIHZhbHVlIHdoZW5ldmVyIGFueXRoaW5nIGNoYW5nZXMgdGhlIHRhYmxlJ3MgbGVuZ3RoXG5cdCQoc2V0dGluZ3MublRhYmxlKS5vbiggJ2xlbmd0aC5kdC5EVCcsIGZ1bmN0aW9uIChlLCBzLCBsZW4pIHtcblx0XHRpZiAoIHNldHRpbmdzID09PSBzICkge1xuXHRcdFx0JCgnc2VsZWN0JywgZGl2KS52YWwoIGxlbiApO1xuXG5cdFx0XHQvLyBSZXNvbHZlIHBsdXJhbHMgaW4gdGhlIHRleHQgZm9yIHRoZSBuZXcgbGVuZ3RoXG5cdFx0XHR1cGRhdGVFbnRyaWVzKGxlbik7XG5cdFx0fVxuXHR9ICk7XG5cblx0dXBkYXRlRW50cmllcyhzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgpO1xuXG5cdHJldHVybiBkaXY7XG59LCAnbCcgKTtcblxuLy8galF1ZXJ5IGFjY2Vzc1xuJC5mbi5kYXRhVGFibGUgPSBEYXRhVGFibGU7XG5cbi8vIFByb3ZpZGUgYWNjZXNzIHRvIHRoZSBob3N0IGpRdWVyeSBvYmplY3QgKGNpcmN1bGFyIHJlZmVyZW5jZSlcbkRhdGFUYWJsZS4kID0gJDtcblxuLy8gTGVnYWN5IGFsaWFzZXNcbiQuZm4uZGF0YVRhYmxlU2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG4kLmZuLmRhdGFUYWJsZUV4dCA9IERhdGFUYWJsZS5leHQ7XG5cbi8vIFdpdGggYSBjYXBpdGFsIGBEYCB3ZSByZXR1cm4gYSBEYXRhVGFibGVzIEFQSSBpbnN0YW5jZSByYXRoZXIgdGhhbiBhXG4vLyBqUXVlcnkgb2JqZWN0XG4kLmZuLkRhdGFUYWJsZSA9IGZ1bmN0aW9uICggb3B0cyApIHtcblx0cmV0dXJuICQodGhpcykuZGF0YVRhYmxlKCBvcHRzICkuYXBpKCk7XG59O1xuXG4vLyBBbGwgcHJvcGVydGllcyB0aGF0IGFyZSBhdmFpbGFibGUgdG8gJC5mbi5kYXRhVGFibGUgc2hvdWxkIGFsc28gYmVcbi8vIGF2YWlsYWJsZSBvbiAkLmZuLkRhdGFUYWJsZVxuJC5lYWNoKCBEYXRhVGFibGUsIGZ1bmN0aW9uICggcHJvcCwgdmFsICkge1xuXHQkLmZuLkRhdGFUYWJsZVsgcHJvcCBdID0gdmFsO1xufSApO1xuXG5leHBvcnQgZGVmYXVsdCBEYXRhVGFibGU7XG4iXSwibmFtZXMiOlsialF1ZXJ5IiwiJCIsIkRhdGFUYWJsZSIsInNlbGVjdG9yIiwib3B0aW9ucyIsImZhY3RvcnkiLCJfdGhhdCIsImVtcHR5SW5pdCIsInVuZGVmaW5lZCIsImxlbiIsImxlbmd0aCIsImFwaSIsIl9BcGkiLCJlYWNoIiwibyIsIm9Jbml0IiwiX2ZuRXh0ZW5kIiwiaSIsImlMZW4iLCJzSWQiLCJnZXRBdHRyaWJ1dGUiLCJkZWZhdWx0cyIsIiR0aGlzIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsIl9mbkxvZyIsIm9uIiwiX2ZuTGlzdGVuZXIiLCJ0cmlnZ2VyIiwiX2ZuQ29tcGF0T3B0cyIsIl9mbkNvbXBhdENvbHMiLCJjb2x1bW4iLCJfZm5DYW1lbFRvSHVuZ2FyaWFuIiwiZXh0ZW5kIiwiZGF0YSIsImFsbFNldHRpbmdzIiwic2V0dGluZ3MiLCJzIiwiblRhYmxlIiwiblRIZWFkIiwicGFyZW50Tm9kZSIsIm5URm9vdCIsImJSZXRyaWV2ZSIsImJEZXN0cm95Iiwib0luc3RhbmNlIiwiQXBpIiwiZGVzdHJveSIsInNUYWJsZUlkIiwiaWQiLCJzcGxpY2UiLCJleHQiLCJfdW5pcXVlIiwib1NldHRpbmdzIiwibW9kZWxzIiwic3R5bGUiLCJ3aWR0aCIsImNvbGdyb3VwIiwicHJlcGVuZFRvIiwiZmFzdERhdGEiLCJyb3ciLCJ0eXBlIiwiX2ZuR2V0Q2VsbERhdGEiLCJwdXNoIiwiZGF0YVRhYmxlIiwiYUxlbmd0aE1lbnUiLCJpRGlzcGxheUxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsImlzUGxhaW5PYmplY3QiLCJ2YWx1ZSIsIl9mbk1hcCIsIm9GZWF0dXJlcyIsIm9TY3JvbGwiLCJvTGFuZ3VhZ2UiLCJfZm5DYWxsYmFja1JlZyIsImZuRHJhd0NhbGxiYWNrIiwiZm5TdGF0ZVNhdmVQYXJhbXMiLCJmblN0YXRlTG9hZFBhcmFtcyIsImZuU3RhdGVMb2FkZWQiLCJmblJvd0NhbGxiYWNrIiwiZm5DcmVhdGVkUm93IiwiZm5IZWFkZXJDYWxsYmFjayIsImZuRm9vdGVyQ2FsbGJhY2siLCJmbkluaXRDb21wbGV0ZSIsImZuUHJlRHJhd0NhbGxiYWNrIiwicm93SWRGbiIsIl9mbkdldE9iamVjdERhdGFGbiIsInJvd0lkIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJfZm5Ccm93c2VyRGV0ZWN0Iiwib0NsYXNzZXMiLCJjbGFzc2VzIiwiYWRkQ2xhc3MiLCJ0YWJsZSIsImJQYWdpbmF0ZSIsImlEaXNwbGF5U3RhcnQiLCJpSW5pdERpc3BsYXlTdGFydCIsIl9pRGlzcGxheVN0YXJ0IiwiZGVmZXIiLCJpRGVmZXJMb2FkaW5nIiwiZGVmZXJMb2FkaW5nIiwidG1wIiwiX2lSZWNvcmRzRGlzcGxheSIsIl9pUmVjb3Jkc1RvdGFsIiwiY29sdW1uc0luaXQiLCJ0aGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5pdEhlYWRlckxheW91dCIsIl9mbkRldGVjdEhlYWRlciIsImFvQ29sdW1ucyIsIl9mbkFkZENvbHVtbiIsIl9mbkFwcGx5Q29sdW1uRGVmcyIsImFvQ29sdW1uRGVmcyIsImlDb2wiLCJvRGVmIiwiX2ZuQ29sdW1uT3B0aW9ucyIsInJvd09uZSIsImNoaWxkcmVuIiwiZmluZCIsImVxIiwiYSIsImNlbGwiLCJuYW1lIiwiY29sIiwibURhdGEiLCJzb3J0IiwiZmlsdGVyIiwiXyIsIl9pc0FycmF5SG9zdCIsIl9mblNhdmVTdGF0ZSIsImZlYXR1cmVzIiwiYlN0YXRlU2F2ZSIsImFhU29ydGluZyIsInNvcnRpbmciLCJhc1NvcnRpbmciLCJfZm5Tb3J0aW5nQ2xhc3NlcyIsImJTb3J0ZWQiLCJfZm5EYXRhU291cmNlIiwiYkRlZmVyUmVuZGVyIiwiY2FwdGlvbiIsImFwcGVuZFRvIiwiaHRtbCIsIl9jYXB0aW9uU2lkZSIsImNzcyIsImNhcHRpb25Ob2RlIiwidGJvZHkiLCJpbnNlcnRBZnRlciIsIm5UQm9keSIsInRmb290IiwiYWlEaXNwbGF5IiwiYWlEaXNwbGF5TWFzdGVyIiwic2xpY2UiLCJiSW5pdGlhbGlzZWQiLCJzVXJsIiwiYWpheCIsImRhdGFUeXBlIiwidXJsIiwic3VjY2VzcyIsImpzb24iLCJfZm5DYWxsYmFja0ZpcmUiLCJfZm5Jbml0aWFsaXNlIiwiZXJyb3IiLCJfZXh0IiwiYnVpbGRlciIsImJ1dHRvbnMiLCJjY0NvbnRlbnQiLCJlcnJNb2RlIiwiZmVhdHVyZSIsInNlYXJjaCIsImxlZ2FjeSIsInBhZ2VyIiwicmVuZGVyZXIiLCJwYWdlQnV0dG9uIiwiaGVhZGVyIiwib3JkZXIiLCJjbGFzc05hbWUiLCJkZXRlY3QiLCJyZW5kZXIiLCJmblZlcnNpb25DaGVjayIsImlBcGlJbmRleCIsInNWZXJzaW9uIiwidmVyc2lvbiIsImFmbkZpbHRlcmluZyIsImFUeXBlcyIsIm9mblNlYXJjaCIsIm9Tb3J0IiwiYWZuU29ydERhdGEiLCJhb0ZlYXR1cmVzIiwib1N0ZENsYXNzZXMiLCJvUGFnaW5hdGlvbiIsImNvbnRhaW5lciIsImVtcHR5IiwiaW5mbyIsImxheW91dCIsInRhYmxlUm93IiwidGFibGVDZWxsIiwic3RhcnQiLCJlbmQiLCJmdWxsIiwic2VsZWN0IiwiY2FuQXNjIiwiY2FuRGVzYyIsImlzQXNjIiwiaXNEZXNjIiwibm9uZSIsInBvc2l0aW9uIiwicHJvY2Vzc2luZyIsInNjcm9sbGluZyIsImJvZHkiLCJmb290ZXIiLCJzZWxmIiwiaW5uZXIiLCJpbnB1dCIsInBhZ2luZyIsImFjdGl2ZSIsImJ1dHRvbiIsImRpc2FibGVkIiwibmF2IiwiX2FwaV9yZWdpc3RlciIsIl9hcGlfcmVnaXN0ZXJQbHVyYWwiLCJfcmVfZGljIiwiX3JlX25ld19saW5lcyIsIl9yZV9odG1sIiwiX21heF9zdHJfbGVuIiwiTWF0aCIsInBvdyIsIl9yZV9kYXRlIiwiX3JlX2VzY2FwZV9yZWdleCIsIlJlZ0V4cCIsImpvaW4iLCJfcmVfZm9ybWF0dGVkX251bWVyaWMiLCJfZW1wdHkiLCJkIiwiX2ludFZhbCIsImludGVnZXIiLCJwYXJzZUludCIsImlzTmFOIiwiaXNGaW5pdGUiLCJfbnVtVG9EZWNpbWFsIiwibnVtIiwiZGVjaW1hbFBvaW50IiwiX2ZuRXNjYXBlUmVnZXgiLCJyZXBsYWNlIiwiX2lzTnVtYmVyIiwiZm9ybWF0dGVkIiwiYWxsb3dFbXB0eSIsInN0clR5cGUiLCJwYXJzZUZsb2F0IiwiX2lzSHRtbCIsIl9odG1sTnVtZXJpYyIsIm1hdGNoIiwiX3N0cmlwSHRtbCIsIl9wbHVjayIsInByb3AiLCJwcm9wMiIsIm91dCIsImllbiIsIl9wbHVja19vcmRlciIsIl9yYW5nZSIsIl9yZW1vdmVFbXB0eSIsIkVycm9yIiwicHJldmlvdXMiLCJfZXNjYXBlSHRtbCIsIl9ub3JtYWxpemUiLCJzdHIiLCJib3RoIiwicmVzIiwibm9ybWFsaXplIiwiX2FyZUFsbFVuaXF1ZSIsInNyYyIsInNvcnRlZCIsImxhc3QiLCJmcm9tIiwiU2V0IiwidmFsIiwiaiIsImsiLCJhZ2FpbiIsIl9mbGF0dGVuIiwiX2FkZENsYXNzIiwiZWwiLCJzcGxpdCIsIm4iLCJjbGFzc0xpc3QiLCJhZGQiLCJ1dGlsIiwiZGlhY3JpdGljcyIsIm1peGVkIiwiZGVib3VuY2UiLCJmbiIsInRpbWVvdXQiLCJ0aW1lciIsInRoYXQiLCJhcmdzIiwiYXJndW1lbnRzIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImFwcGx5IiwidGhyb3R0bGUiLCJmcmVxIiwiZnJlcXVlbmN5Iiwibm93IiwiRGF0ZSIsImVzY2FwZVJlZ2V4Iiwic2V0Iiwic291cmNlIiwibWV0YSIsImluZGV4T2YiLCJzZXREYXRhIiwiX2ZuU3BsaXRPYmpOb3RhdGlvbiIsImIiLCJhTGFzdCIsImFycmF5Tm90YXRpb24iLCJmdW5jTm90YXRpb24iLCJpbm5lclNyYyIsIl9fcmVBcnJheSIsIl9fcmVGbiIsImpMZW4iLCJnZXQiLCJ0IiwiZmV0Y2hEYXRhIiwic3Vic3RyaW5nIiwic3RyaXBIdG1sIiwiZXNjYXBlSHRtbCIsInVuaXF1ZSIsIl9mbkh1bmdhcmlhbk1hcCIsImh1bmdhcmlhbiIsIm5ld0tleSIsIm1hcCIsIl9odW5nYXJpYW5NYXAiLCJ1c2VyIiwiZm9yY2UiLCJodW5nYXJpYW5LZXkiLCJjaGFyQXQiLCJfZm5Db21wYXRNYXAiLCJrbmV3Iiwib2xkIiwiaW5pdCIsInNTY3JvbGxYIiwic2Nyb2xsWCIsImJTb3J0Iiwib3JkZXJJbmRpY2F0b3JzIiwiaW5kaWNhdG9ycyIsIm9yZGVySGFuZGxlciIsImhhbmRsZXIiLCJiU29ydENlbGxzVG9wIiwidGl0bGVSb3ciLCJzZWFyY2hDb2xzIiwiYW9TZWFyY2hDb2xzIiwib1NlYXJjaCIsInNlcnZlclNpZGUiLCJzZWFyY2hEZWxheSIsImRhdGFTb3J0IiwiYURhdGFTb3J0IiwiX19icm93c2VyIiwiYnJvd3NlciIsInRvcCIsImxlZnQiLCJ3aW5kb3ciLCJwYWdlWE9mZnNldCIsImhlaWdodCIsIm92ZXJmbG93IiwiYXBwZW5kIiwib3V0ZXIiLCJiYXJXaWR0aCIsIm9mZnNldFdpZHRoIiwiY2xpZW50V2lkdGgiLCJiU2Nyb2xsYmFyTGVmdCIsInJvdW5kIiwib2Zmc2V0IiwicmVtb3ZlIiwib0Jyb3dzZXIiLCJpQmFyV2lkdGgiLCJvRGVmYXVsdHMiLCJvQ29sIiwib0NvbHVtbiIsImlkeCIsInNlYXJjaEZpeGVkIiwiY29sRWwiLCJhdHRyIiwiYW9QcmVTZWFyY2hDb2xzIiwib09wdGlvbnMiLCJtRGF0YVByb3AiLCJzVHlwZSIsIl9zTWFudWFsVHlwZSIsInNDbGFzcyIsIm9yaWdDbGFzcyIsImlEYXRhU29ydCIsIm1EYXRhU3JjIiwibVJlbmRlciIsImNvcHkiLCJzaGlmdCIsIl9yZW5kZXIiLCJhdHRyVGVzdCIsIl9iQXR0clNyYyIsIl9zZXR0ZXIiLCJmbkdldERhdGEiLCJyb3dEYXRhIiwiaW5uZXJEYXRhIiwiZm5TZXREYXRhIiwiX2ZuU2V0T2JqZWN0RGF0YUZuIiwiX3Jvd1JlYWRPYmplY3QiLCJiU29ydGFibGUiLCJfZm5BZGp1c3RDb2x1bW5TaXppbmciLCJfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMiLCJfZm5Db2x1bW5TaXplcyIsInNjcm9sbCIsInNZIiwic1giLCJfZm5TY3JvbGxEcmF3IiwiY29scyIsIl9mbkNvbHVtbnNTdW1XaWR0aCIsIl9mblZpc2libGVUb0NvbHVtbkluZGV4IiwiaU1hdGNoIiwiYWlWaXMiLCJfZm5HZXRDb2x1bW5zIiwiX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUiLCJpUG9zIiwiX2ZuVmlzYmxlQ29sdW1ucyIsImFvSGVhZGVyIiwiY29sdW1ucyIsInZpcyIsImJWaXNpYmxlIiwic1BhcmFtIiwiX3R5cGVSZXN1bHQiLCJ0eXBlRGV0ZWN0IiwiX25hbWUiLCJfZm5Db2x1bW5UeXBlcyIsImFvRGF0YSIsInR5cGVzIiwiamVuIiwia2VuIiwiZGV0ZWN0ZWRUeXBlIiwiY2FjaGUiLCJvbmVPZiIsImFsbE9mIiwib25lIiwiYXV0b0NsYXNzIiwiX2NvbHVtbkF1dG9DbGFzcyIsImFvRm9vdGVyIiwiX2NvbHVtbkF1dG9SZW5kZXIiLCJjb2xJZHgiLCJuVHIiLCJkaXNwbGF5IiwiZGlzcGxheURhdGEiLCJfZm5Xcml0ZUNlbGwiLCJhbkNlbGxzIiwiYW9Db2xEZWZzIiwiYW9Db2xzIiwiaGVhZGVyTGF5b3V0Iiwia0xlbiIsImRlZiIsInNOYW1lIiwiYVRhcmdldHMiLCJ0YXJnZXQiLCJ0YXJnZXRzIiwiaXMiLCJvcmlnaW5hbCIsImluY1Zpc2libGUiLCJfZm5Db2x1bW5zRnJvbUhlYWRlciIsInN1bSIsInVuaXQiLCJkZWZpbmVkV2lkdGgiLCJzV2lkdGhPcmlnIiwic1dpZHRoIiwibWF0Y2hlZCIsImNsb3Nlc3QiLCJfZm5BZGREYXRhIiwiZGF0YUluIiwidHIiLCJ0ZHMiLCJyb3dJZHgiLCJyb3dNb2RlbCIsIm9Sb3ciLCJfYURhdGEiLCJhSWRzIiwiX2ZuQ3JlYXRlVHIiLCJfZm5BZGRUciIsInRycyIsIl9mbkdldFJvd0VsZW1lbnRzIiwiY2VsbHMiLCJkcmF3IiwiaURyYXciLCJkZWZhdWx0Q29udGVudCIsInNEZWZhdWx0Q29udGVudCIsImNlbGxEYXRhIiwiaW5uZXJIVE1MIiwiaURyYXdFcnJvciIsImNhbGwiLCJmb21hdHRlcnMiLCJfZm5TZXRDZWxsRGF0YSIsInRkIiwicGFydHMiLCJfZm5HZXREYXRhTWFzdGVyIiwiX2ZuQ2xlYXJUYWJsZSIsIl9mbkludmFsaWRhdGUiLCJfYVNvcnREYXRhIiwiX2FGaWx0ZXJEYXRhIiwiX2ZuR2V0Um93RGlzcGxheSIsIm1heExlblN0cmluZyIsIl9mblJvd0F0dHJpYnV0ZXMiLCJmaXJzdENoaWxkIiwiY29udGVudHMiLCJvYmplY3RSZWFkIiwic2V0dGVyIiwiY2VsbFByb2Nlc3MiLCJ0cmltIiwidG9VcHBlckNhc2UiLCJuZXh0U2libGluZyIsInJvd05vZGUiLCJyb3dNb2RhbCIsImlSb3ciLCJuVHJJbiIsImFuVGRzIiwiblRkIiwiY3JlYXRlIiwidHJDbGFzcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIl9EVF9Sb3dJbmRleCIsInNDZWxsVHlwZSIsIl9EVF9DZWxsSW5kZXgiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwiZm5DcmVhdGVkQ2VsbCIsIkRUX1Jvd0NsYXNzIiwiX19yb3djIiwiY29uY2F0IiwicmVtb3ZlQ2xhc3MiLCJEVF9Sb3dBdHRyIiwiRFRfUm93RGF0YSIsIl9mbkJ1aWxkSGVhZCIsInNpZGUiLCJ0aXRsZVByb3AiLCJjZWxsQ291bnQiLCJjb2xTcGFuIiwiZGV0ZWN0ZWQiLCJfZm5SZW5kZXJlciIsIl9mbkhlYWRlckxheW91dCIsImluY0NvbHVtbnMiLCJsb2NhbCIsInN0cnVjdHVyZSIsImNvbHVtbkNvdW50Iiwicm93c3BhbiIsImNvbHNwYW4iLCJpbmNsdWRlcyIsInRpdGxlU3BhbiIsInRpdGxlIiwiX2ZuRHJhd0hlYWQiLCJwb2ludCIsIl9mbkRyYXciLCJhamF4Q29tcGxldGUiLCJfZm5TdGFydCIsImFQcmVEcmF3IiwiX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkiLCJhblJvd3MiLCJpUm93Q291bnQiLCJiU2VydmVyU2lkZSIsImlEaXNwbGF5RW5kIiwiZm5EaXNwbGF5RW5kIiwiYkRyYXdpbmciLCJiRGVzdHJveWluZyIsIl9lbXB0eVJvdyIsIl9mbkFqYXhVcGRhdGUiLCJpU3RhcnQiLCJpRW5kIiwiaURhdGFJbmRleCIsIm5Sb3ciLCJyZXBsYWNlQ2hpbGRyZW4iLCJkZXRhY2giLCJuVGFibGVXcmFwcGVyIiwidG9nZ2xlQ2xhc3MiLCJiRmlsdGVyZWQiLCJfZm5SZURyYXciLCJob2xkUG9zaXRpb24iLCJyZWNvbXB1dGUiLCJiRmlsdGVyIiwiX2ZuU29ydCIsIl9mbkZpbHRlckNvbXBsZXRlIiwib1ByZXZpb3VzU2VhcmNoIiwiX2RyYXdIb2xkIiwib0xhbmciLCJ6ZXJvIiwic1plcm9SZWNvcmRzIiwiZGF0YVNyYyIsInNMb2FkaW5nUmVjb3JkcyIsInNFbXB0eVRhYmxlIiwiZm5SZWNvcmRzVG90YWwiLCJfbGF5b3V0SXRlbXMiLCJhbGlnbiIsIml0ZW1zIiwicm93Q2VsbCIsInJvd0NsYXNzIiwib3B0cyIsIl9sYXlvdXRHZXRSb3ciLCJyb3dzIiwicm93TnVtIiwiX2xheW91dEFycmF5IiwicG9zIiwib3JkZXIxIiwib3JkZXIyIiwicmV0IiwicmV2ZXJzZSIsIl9sYXlvdXRSZXNvbHZlIiwiZ2V0RmVhdHVyZSIsInJlc29sdmUiLCJpdGVtIiwibGluZSIsIm5vZGUiLCJpbnN0IiwiX2ZuQWRkT3B0aW9uc0h0bWwiLCJpbnNlcnQiLCJpbnNlcnRCZWZvcmUiLCJzRG9tIiwiX2ZuTGF5b3V0RG9tIiwiYm90dG9tIiwiX2ZuRmVhdHVyZUh0bWxUYWJsZSIsIl9wcm9jZXNzaW5nSHRtbCIsImRvbSIsImZlYXR1cmVOb2RlIiwib3B0aW9uIiwibmV3Tm9kZSIsIm5leHQiLCJwYXJlbnQiLCJjRmVhdHVyZSIsImZuSW5pdCIsIndyaXRlIiwibCIsInNoaWZ0ZWQiLCJpc0hlYWRlciIsImpxQ2VsbCIsImNvbHVtbkRlZiIsInNUaXRsZSIsImF1dG9UaXRsZSIsImFyaWFUaXRsZSIsImNoaWxkTm9kZXMiLCJoZWFkZXJGb290ZXIiLCJzZXRBdHRyaWJ1dGUiLCJmblJlY29yZHNEaXNwbGF5IiwiX2ZuQnVpbGRBamF4IiwiYWpheERhdGEiLCJpbnN0YW5jZSIsImNhbGxiYWNrIiwic3RhdHVzIiwianFYSFIiLCJfZm5BamF4RGF0YVNyYyIsInNFcnJvciIsIkpTT04iLCJwYXJzZSIsImUiLCJuZXdEYXRhIiwiYmFzZUFqYXgiLCJzU2VydmVyTWV0aG9kIiwieGhyIiwicmVhZHlTdGF0ZSIsIm9BamF4RGF0YSIsInN1Ym1pdEFzIiwic3RyaW5naWZ5IiwiX2ZuQWpheFBhcmFtZXRlcnMiLCJfZm5BamF4VXBkYXRlRHJhdyIsInByZVNlYXJjaCIsInByZUNvbFNlYXJjaCIsImNvbERhdGEiLCJzZWFyY2hhYmxlIiwiYlNlYXJjaGFibGUiLCJvcmRlcmFibGUiLCJyZWdleCIsImZpeGVkIiwidGVybSIsInRvU3RyaW5nIiwiX2ZuU29ydEZsYXR0ZW4iLCJkaXIiLCJfaURpc3BsYXlMZW5ndGgiLCJfZm5BamF4RGF0YVNyY1BhcmFtIiwicmVjb3Jkc1RvdGFsIiwicmVjb3Jkc0ZpbHRlcmVkIiwiX2ZuSW5pdENvbXBsZXRlIiwiZGF0YVByb3AiLCJhYURhdGEiLCJwYXJhbSIsImNvbHVtbnNTZWFyY2giLCJfZm5GaWx0ZXJEYXRhIiwiX2ZuRmlsdGVyIiwiX2ZuRmlsdGVyQ3VzdG9tIiwiZmlsdGVycyIsImRpc3BsYXlSb3dzIiwiX2ZuQXJyYXlBcHBseSIsInNlYXJjaFJvd3MiLCJzZWFyY2hGdW5jIiwicnBTZWFyY2giLCJfZm5GaWx0ZXJDcmVhdGVTZWFyY2giLCJfc0ZpbHRlclJvdyIsInRlc3QiLCJpbk9wdHMiLCJub3QiLCJib3VuZGFyeSIsImNhc2VJbnNlbnNpdGl2ZSIsImV4YWN0Iiwic21hcnQiLCJ3b3JkIiwibmVnYXRpdmUiLCJtIiwiX19maWx0ZXJfZGl2IiwiX19maWx0ZXJfZGl2X3RleHRDb250ZW50IiwidGV4dENvbnRlbnQiLCJmaWx0ZXJEYXRhIiwid2FzSW52YWxpZGF0ZWQiLCJpbm5lclRleHQiLCJfZm5Mb2FkU3RhdGUiLCJpQWpheFN0YXJ0IiwiX2ZuU29ydEluaXQiLCJfY29sR3JvdXAiLCJhRGF0YSIsIl9iSW5pdENvbXBsZXRlIiwiX2ZuTGVuZ3RoQ2hhbmdlIiwiX2ZuTGVuZ3RoT3ZlcmZsb3ciLCJfZm5QYWdlQ2hhbmdlIiwiYWN0aW9uIiwicmVkcmF3IiwicmVjb3JkcyIsImZsb29yIiwiY2hhbmdlZCIsImJQcm9jZXNzaW5nIiwic1Byb2Nlc3NpbmciLCJzaG93IiwiX2ZuUHJvY2Vzc2luZ1J1biIsImVuYWJsZSIsInJ1biIsInNjcm9sbFkiLCJjYXB0aW9uU2lkZSIsImhlYWRlckNsb25lIiwiY2xvbmVOb2RlIiwiZm9vdGVyQ2xvbmUiLCJfZGl2Iiwic2l6ZSIsIl9mblN0cmluZ1RvQ3NzIiwic2Nyb2xsZXIiLCJib3JkZXIiLCJzWElubmVyIiwicmVtb3ZlQXR0ciIsInNjcm9sbEhlYWQiLCJzY3JvbGxCb2R5Iiwic2Nyb2xsRm9vdCIsInNjcm9sbExlZnQiLCJiQ29sbGFwc2UiLCJuU2Nyb2xsSGVhZCIsIm5TY3JvbGxCb2R5IiwiblNjcm9sbEZvb3QiLCJhb0RyYXdDYWxsYmFjayIsImRpdkhlYWRlciIsImRpdkhlYWRlcklubmVyIiwiZGl2SGVhZGVyVGFibGUiLCJkaXZCb2R5RWwiLCJkaXZCb2R5IiwiZGl2Rm9vdGVyIiwiZGl2Rm9vdGVySW5uZXIiLCJkaXZGb290ZXJUYWJsZSIsImhlYWRlckNvcHkiLCJmb290ZXJDb3B5Iiwic2Nyb2xsQmFyVmlzIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY2xvbmUiLCJmaXJzdFRyIiwiY29sU2l6ZXMiLCJvdXRlcldpZHRoIiwiY29sV2lkdGgiLCJtaW5XaWR0aCIsIndyYXBBbGwiLCJpc1Njcm9sbGluZyIsInBhZGRpbmdTaWRlIiwic2Nyb2xsVG9wIiwiYkF1dG9XaWR0aCIsInNjcm9sbFhJbm5lciIsInZpc2libGVDb2x1bW5zIiwidGFibGVXaWR0aEF0dHIiLCJ0YWJsZUNvbnRhaW5lciIsImNvbHVtbklkeCIsInN0eWxlV2lkdGgiLCJjb250YWluZXJXaWR0aCIsIl9mbldyYXBwZXJXaWR0aCIsInZpc2libGUiLCJ0bXBUYWJsZSIsIm1hcmdpbiIsInBhZGRpbmciLCJsb25nZXN0IiwiX2ZuR2V0TWF4TGVuU3RyaW5nIiwidGV4dCIsInNDb250ZW50UGFkZGluZyIsImNyZWF0ZVRleHROb2RlIiwiaG9sZGVyIiwicmlnaHQiLCJ0b3RhbCIsImJvZHlDZWxscyIsImJvdW5kaW5nIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiX3Jlc3pFdnQiLCJyZXNpemUiLCJuZXdXaWR0aCIsIlJlc2l6ZU9ic2VydmVyIiwiZmlyc3QiLCJyZXNpemVyIiwicmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwic0luc3RhbmNlIiwibWF4IiwibWF4TGVuIiwiY2VsbFN0cmluZyIsIm5vZGVUeXBlIiwiaGVhZGVyUm93cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJub3RTZWxlY3RvciIsIl9mblNvcnRBdHRhY2hMaXN0ZW5lciIsIl9mblNvcnRSZXNvbHZlIiwiX2ZuQmluZEFjdGlvbiIsIl9mblNvcnRBZGQiLCJzaGlmdEtleSIsIl9mblNvcnREaXNwbGF5IiwibWFzdGVyIiwibWFzdGVyTWFwIiwibmVzdGVkU29ydCIsInoiLCJhU29ydCIsImV4dFNvcnQiLCJzcmNDb2wiLCJhYVNvcnRpbmdGaXhlZCIsImZpeGVkT2JqIiwicHJlIiwicG9zdCIsIl9pZHgiLCJpbmRleCIsImZvcm1hdHRlciIsInNvcnRlciIsImFpT3JpZyIsInNvcnRDb2wiLCJkaXNwbGF5TWFzdGVyIiwiX2ZuU29ydERhdGEiLCJvcmRlckRlc2NSZXZlcnNlIiwieCIsInkiLCJkYXRhQSIsImRhdGFCIiwic29ydERldGFpbHMiLCJhZGRJbmRleCIsIm5leHRTb3J0SWR4IiwiYlNvcnRNdWx0aSIsInNvcnRJZHgiLCJvbGRTb3J0IiwiYUxhc3RTb3J0Iiwic29ydENsYXNzIiwiYlNvcnRDbGFzc2VzIiwiY3VzdG9tU29ydCIsInNTb3J0RGF0YVR5cGUiLCJjdXN0b21EYXRhIiwiX2JMb2FkaW5nU3RhdGUiLCJzdGF0ZSIsInRpbWUiLCJvU2F2ZWRTdGF0ZSIsImZuU3RhdGVTYXZlQ2FsbGJhY2siLCJsb2FkZWQiLCJfZm5JbXBsZW1lbnRTdGF0ZSIsImZuU3RhdGVMb2FkQ2FsbGJhY2siLCJjdXJyZW50TmFtZXMiLCJkdXJhdGlvbiIsImlTdGF0ZUR1cmF0aW9uIiwiYWJTdGF0ZUxvYWQiLCJvTG9hZGVkU3RhdGUiLCJwYWdlIiwiaW5jb21pbmciLCJhZGp1c3QiLCJsZXZlbCIsIm1zZyIsInRuIiwic0Vyck1vZGUiLCJhbGVydCIsImNvbnNvbGUiLCJsb2ciLCJtYXBwZWROYW1lIiwiZXh0ZW5kZXIiLCJicmVha1JlZnMiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIndoaWNoIiwicHJldmVudERlZmF1bHQiLCJzdG9yZSIsImNhbGxiYWNrQXJyIiwiZXZlbnROYW1lIiwiYnViYmxlcyIsIkV2ZW50IiwiZHQiLCJwYXJlbnRzIiwicmVzdWx0IiwiaG9zdCIsIl9mbk1hY3JvcyIsImVudHJpZXMiLCJmbkZvcm1hdE51bWJlciIsImFsbCIsImNlaWwiLCJpMThuIiwiYXJyIiwiX19hcGlTdHJ1Y3QiLCJfX2FycmF5UHJvdG8iLCJfdG9TZXR0aW5ncyIsImpxIiwidGFibGVzIiwidG9BcnJheSIsInYiLCJjb250ZXh0IiwiY3R4U2V0dGluZ3MiLCJhbnkiLCJjb3VudCIsImZsYXR0ZW4iLCJjdHgiLCJpdGVyYXRvciIsImFsd2F5c05ldyIsImFwaUluc3QiLCJfc2VsZWN0b3Jfcm93X2luZGV4ZXMiLCJhcGlTZWxlY3RvciIsImxhc3RJbmRleE9mIiwicGx1Y2siLCJwb3AiLCJyZWR1Y2UiLCJyZWR1Y2VSaWdodCIsInRvJCIsInRvSlF1ZXJ5IiwidW5zaGlmdCIsIl9hcGlfc2NvcGUiLCJzY29wZSIsInN0cnVjIiwibWV0aG9kRXh0IiwiX2FwaV9maW5kIiwib2JqIiwiX19kdF93cmFwcGVyIiwic3RydWN0IiwicHJvcEV4dCIsInJlZ2lzdGVyIiwiaGVpciIsIm1ldGhvZCIsInJlZ2lzdGVyUGx1cmFsIiwicGx1cmFsTmFtZSIsInNpbmd1bGFyTmFtZSIsIl9fdGFibGVfc2VsZWN0b3IiLCJzZWwiLCJub2RlcyIsImluZGV4ZXMiLCJvcmRlcmVkSW5kZXhlcyIsInByZXBlbmQiLCJ2aXNSZWNvcmRzIiwiX19yZWxvYWQiLCJhYm9ydCIsInJlc2V0UGFnaW5nIiwiX3NlbGVjdG9yX3J1biIsInNlbGVjdEZuIiwic2VsZWN0b3JUeXBlIiwiX3NlbGVjdG9yX29wdHMiLCJjb2x1bW5PcmRlciIsIl9zZWxlY3Rvcl9maXJzdCIsImRpc3BsYXlGaWx0ZXJlZCIsImRpc3BsYXlGaWx0ZXJlZE1hcCIsIm9yZGVyZWQiLCJfX3Jvd19zZWxlY3RvciIsInNlbEludCIsImNlbGxJZHgiLCJyb3dPYmoiLCJyIiwiaGFzaCIsIm5ld1Jvd3MiLCJtb2RSb3dzIiwiaWRGbiIsImlkcyIsIl9kZXRhaWxzU2hvdyIsImNoaWxkUm93cyIsIl9fZGV0YWlsc19zdGF0ZV9sb2FkIiwiZXZlcnkiLCJfX2RldGFpbHNfYWRkIiwia2xhc3MiLCJhZGRSb3ciLCJjcmVhdGVkIiwiX2RldGFpbHMiLCJfX2RldGFpbHNfc3RhdGUiLCJfX2RldGFpbHNfcmVtb3ZlIiwiX19kZXRhaWxzX2Rpc3BsYXkiLCJfX2RldGFpbHNfZXZlbnRzIiwibmFtZXNwYWNlIiwiZHJhd0V2ZW50IiwiY29sdmlzRXZlbnQiLCJkZXN0cm95RXZlbnQiLCJvZmYiLCJfZW1wIiwiX2NoaWxkX29iaiIsIl9jaGlsZF9tdGgiLCJjaGlsZCIsIl9fcmVfY29sdW1uX3NlbGVjdG9yIiwiX19jb2x1bW5EYXRhIiwicjEiLCJyMiIsIl9fY29sdW1uX2hlYWRlciIsIl9fY29sdW1uX2hlYWRlcl9jZWxscyIsIl9fY29sdW1uX3NlbGVjdG9yIiwibmFtZXMiLCJ0aXRsZXMiLCJ2aXNDb2x1bW5zIiwianFSZXN1bHQiLCJzZWxlY3RlZCIsIl9fc2V0Q29sdW1uVmlzIiwic3BhbiIsImNhbGMiLCJ3aWR0aHMiLCJ2aXNJZHgiLCJfX2NlbGxfc2VsZWN0b3IiLCJhbGxDZWxscyIsImZuU2VsZWN0b3IiLCJyb3dTZWxlY3RvciIsImNvbHVtblNlbGVjdG9yIiwiaW50ZXJuYWxPcHRzIiwiY2VsbHNOb09wdHMiLCJjb2x1bW5WaXNpYmxlIiwicmVzb2x2ZWQiLCJkaXJlY3Rpb25zIiwiY2FzZUluc2VuIiwiaWdub3JlVGltZSIsInNldE11dGF0ZSIsIl9fYm9vdHN0cmFwIiwiX19mb3VuZGF0aW9uIiwidXNlIiwiYXJnMSIsImFyZzIiLCJtb2R1bGUiLCJEYXRlVGltZSIsIl9fbHV4b24iLCJfX21vbWVudCIsImJvb3RzdHJhcCIsIkZvdW5kYXRpb24iLCJqcXVlcnkiLCJGaXhlZE9mZnNldFpvbmUiLCJpc01vbWVudCIsIk1vZGFsIiwiTkFNRSIsIlJldmVhbCIsInJvb3QiLCJ2ZXJzaW9uQ2hlY2siLCJ2ZXJzaW9uMiIsImFUaGlzIiwiYVRoYXQiLCJpVGhpcyIsImlUaGF0IiwiaXNEYXRhVGFibGUiLCJoZWFkIiwiZm9vdCIsImNhbWVsVG9IdW5nYXJpYW4iLCJqcVJvd3MiLCJqcVRhYmxlIiwianFUYm9keSIsImpxV3JhcHBlciIsIm9yZGVyQ2xhc3NlcyIsImRpc2Nvbm5lY3QiLCJjbGVhbkhlYWRlciIsIm9yaWciLCJyZW1vdmVkTWV0aG9kIiwic0Rlc3Ryb3lXaWR0aCIsImNvdW50ZXIiLCJzZWxlY3RlZElkeCIsInRhYmxlSWR4IiwidG9rZW4iLCJwbHVyYWwiLCJ0b0Zvcm1hdCIsInNUaG91c2FuZHMiLCJzZXNzaW9uU3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwic2V0SXRlbSIsInBhZ2luYXRlIiwibnVtYmVyIiwibGVuZ3RoTGFiZWxzIiwidG9wU3RhcnQiLCJ0b3BFbmQiLCJib3R0b21TdGFydCIsImJvdHRvbUVuZCIsInBhZ2luZ0NvbnRyb2xzIiwibWluIiwiZXh0UGFnaW5hdGlvbiIsInNpbXBsZSIsIm51bWJlcnMiLCJzaW1wbGVfbnVtYmVycyIsImZ1bGxfbnVtYmVycyIsImZpcnN0X2xhc3QiLCJmaXJzdF9sYXN0X251bWJlcnMiLCJfbnVtYmVycyIsIl9wYWdpbmdOdW1iZXJzIiwibnVtYmVyc19sZW5ndGgiLCJwYWdpbmdCdXR0b24iLCJidXR0b25UeXBlIiwiY29udGVudCIsImJ0bkNsYXNzZXMiLCJidG4iLCJjbGFzcyIsInJvbGUiLCJjbGlja2VyIiwicGFnaW5nQ29udGFpbmVyIiwiX2ZpbHRlclN0cmluZyIsIl9fbWxkIiwiZHRMaWIiLCJtb21lbnRGbiIsImx1eG9uRm4iLCJkYXRlRm4iLCJfX21sV2FybmluZyIsInJlc29sdmVXaW5kb3dMaWJzIiwibHV4b24iLCJtb21lbnQiLCJfX21sZE9iaiIsImZvcm1hdCIsImxvY2FsZSIsInV0YyIsImlzVmFsaWQiLCJmcm9tRm9ybWF0IiwiZnJvbUlTTyIsInNldExvY2FsZSIsIl9fbWxIZWxwZXIiLCJsb2NhbGVTdHJpbmciLCJ0byIsInR5cGVOYW1lIiwidmFsdWVPZiIsIlVUQyIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsIl9fdGhvdXNhbmRzIiwiX19kZWNpbWFsIiwiSW50bCIsIk51bWJlckZvcm1hdCIsImZvcm1hdFRvUGFydHMiLCJkYXRldGltZSIsImRhdGUiLCJ0aG91c2FuZHMiLCJkZWNpbWFsIiwicHJlY2lzaW9uIiwicHJlZml4IiwicG9zdGZpeCIsImZsbyIsImFicyIsImV4cCIsInRvRXhwb25lbnRpYWwiLCJ0b0ZpeGVkIiwiaW50UGFydCIsImZsb2F0UGFydCIsIl9leHRUeXBlcyIsImFzYyIsImRlc2MiLCJzZXRQcm9wIiwicHJvcFZhbCIsInNldERldGVjdCIsImRlZmluZVByb3BlcnR5IiwiZmluZEluZGV4Iiwic2V0T3JkZXIiLCJfX2RpYWNyaXRpY1NvcnQiLCJsb2NhbGVDb21wYXJlIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2VzIiwibGFuZ3VhZ2UiLCJudW1lcmljIiwiaWdub3JlUHVuY3R1YXRpb24iLCJfX2RpYWNyaXRpY0h0bWxTb3J0IiwicGFyc2VkIiwidHMiLCJJbmZpbml0eSIsInNEZWNpbWFsIiwiZHAiLCJfX251bWVyaWNSZXBsYWNlIiwiZGVjaW1hbFBsYWNlIiwicmUxIiwicmUyIiwib3JkZXJlZENvbHVtbnMiLCJhcmlhVHlwZSIsInNvcnREaXJzIiwidGFiSW5kZXgiLCJpVGFiSW5kZXgiLCJjYW5PcmRlciIsImlzT3JkZXJpbmciLCJvcmRlckRpcnMiLCJmaXJzdFZpcyIsImZpcnN0U29ydCIsInNvcnRPcmRlciIsIm9yZGVyU3BhbiIsIl9mb3JMYXlvdXRSb3ciLCJsYXlvdXRFbnVtIiwiY2IiLCJfZGl2UHJvcCIsImJJbmZvIiwibGFuZyIsInRpZCIsImZuSW5mb0NhbGxiYWNrIiwic0luZm9FbXB0eSIsInNJbmZvUG9zdEZpeCIsInNJbmZvRmlsdGVyZWQiLCJzSW5mbyIsIl9mblVwZGF0ZUluZm8iLCJfaW5mb0VsIiwiX19zZWFyY2hDb3VudGVyIiwidGFibGVJZCIsInByZXZpb3VzU2VhcmNoIiwicGxhY2Vob2xkZXIiLCJzU2VhcmNoUGxhY2Vob2xkZXIiLCJzU2VhcmNoIiwicmVtb3ZlZCIsInNlYXJjaEZuIiwiZXZlbnQiLCJyZXR1cm4iLCJqcUZpbHRlciIsImtleUNvZGUiLCJldiIsImFjdGl2ZUVsZW1lbnQiLCJzUGFnaW5hdGlvblR5cGUiLCJib3VuZGFyeU51bWJlcnMiLCJmaXJzdExhc3QiLCJwcmV2aW91c05leHQiLCJfcGFnaW5nRHJhdyIsIl9wYWdpbmdEeW5hbWljIiwicGx1Z2luIiwiYXJpYSIsIm9BcmlhIiwicGFnZXMiLCJidXR0b25FbHMiLCJidXR0b25zTmVzdGVkIiwiYnRuSW5mbyIsIl9wYWdpbmdCdXR0b25JbmZvIiwiYXJpYUxhYmVsIiwid3JhcHBlZCIsImFjdGl2ZUVsIiwib3V0ZXJIZWlnaHQiLCJvUGFnaW5hdGUiLCJzRmlyc3QiLCJzUHJldmlvdXMiLCJzTmV4dCIsInNMYXN0IiwiYWRkRmlyc3RMYXN0IiwiaGFsZiIsImJlZm9yZSIsImFmdGVyIiwiX19sZW5ndGhDb3VudGVyIiwiYkxlbmd0aENoYW5nZSIsIm1lbnUiLCJzTGVuZ3RoTWVudSIsImxlbmd0aHMiLCJsYWJlbCIsInRtcElkIiwiZGl2IiwidGV4dE5vZGVzIiwiTm9kZSIsIlRFWFRfTk9ERSIsInVwZGF0ZUVudHJpZXMiLCJPcHRpb24iLCJyZXBsYWNlV2l0aCIsImRhdGFUYWJsZVNldHRpbmdzIiwiZGF0YVRhYmxlRXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/datatables.net/js/dataTables.mjs\n");

/***/ })

};
;