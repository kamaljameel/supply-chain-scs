"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/datatables.net-select";
exports.ids = ["vendor-chunks/datatables.net-select"];
exports.modules = {

/***/ "(ssr)/./node_modules/datatables.net-select/js/dataTables.select.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/datatables.net-select/js/dataTables.select.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ \"(ssr)/./node_modules/jquery/dist/jquery.js\");\n/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net */ \"(ssr)/./node_modules/datatables.net/js/dataTables.mjs\");\n/*! Select for DataTables 3.0.0\n * Â© SpryMedia Ltd - datatables.net/license/mit\n */\n\n\n\n\n// Allow reassignment of the $ variable\nlet $ = jquery__WEBPACK_IMPORTED_MODULE_0__;\n\n\n// Version information for debugger\ndatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select = {};\n\ndatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select.classes = {\n\tcheckbox: 'dt-select-checkbox'\n};\n\ndatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select.version = '3.0.0';\n\ndatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select.init = function (dt) {\n\tvar ctx = dt.settings()[0];\n\n\tif (!datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].versionCheck('2')) {\n\t\tthrow 'Warning: Select requires DataTables 2 or newer';\n\t}\n\n\tif (ctx._select) {\n\t\treturn;\n\t}\n\n\tvar savedSelected = dt.state.loaded();\n\n\tvar selectAndSave = function (e, settings, data) {\n\t\tif (data === null || data.select === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Clear any currently selected rows, before restoring state\n\t\t// None will be selected on first initialisation\n\t\tif (dt.rows({ selected: true }).any()) {\n\t\t\tdt.rows().deselect();\n\t\t}\n\t\tif (data.select.rows !== undefined) {\n\t\t\tdt.rows(data.select.rows).select();\n\t\t}\n\n\t\tif (dt.columns({ selected: true }).any()) {\n\t\t\tdt.columns().deselect();\n\t\t}\n\t\tif (data.select.columns !== undefined) {\n\t\t\tdt.columns(data.select.columns).select();\n\t\t}\n\n\t\tif (dt.cells({ selected: true }).any()) {\n\t\t\tdt.cells().deselect();\n\t\t}\n\t\tif (data.select.cells !== undefined) {\n\t\t\tfor (var i = 0; i < data.select.cells.length; i++) {\n\t\t\t\tdt.cell(data.select.cells[i].row, data.select.cells[i].column).select();\n\t\t\t}\n\t\t}\n\n\t\tdt.state.save();\n\t};\n\n\tdt.on('stateSaveParams', function (e, settings, data) {\n\t\tdata.select = {};\n\t\tdata.select.rows = dt.rows({ selected: true }).ids(true).toArray();\n\t\tdata.select.columns = dt.columns({ selected: true })[0];\n\t\tdata.select.cells = dt.cells({ selected: true })[0].map(function (coords) {\n\t\t\treturn { row: dt.row(coords.row).id(true), column: coords.column };\n\t\t});\n\t})\n\t\t.on('stateLoadParams', selectAndSave)\n\t\t.one('init', function () {\n\t\t\tselectAndSave(undefined, undefined, savedSelected);\n\t\t});\n\n\tvar init = ctx.oInit.select;\n\tvar defaults = datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaults.select;\n\tvar opts = init === undefined ? defaults : init;\n\n\t// Set defaults\n\tvar items = 'row';\n\tvar style = 'api';\n\tvar blurable = false;\n\tvar toggleable = true;\n\tvar selectable = null;\n\tvar info = true;\n\tvar selector = 'td, th';\n\tvar className = 'selected';\n\tvar headerCheckbox = true;\n\tvar setStyle = false;\n\tvar keys = false;\n\n\tctx._select = {\n\t\tinfoEls: []\n\t};\n\n\t// Initialisation customisations\n\tif (opts === true) {\n\t\tstyle = 'os';\n\t\tsetStyle = true;\n\t}\n\telse if (typeof opts === 'string') {\n\t\tstyle = opts;\n\t\tsetStyle = true;\n\t}\n\telse if ($.isPlainObject(opts)) {\n\t\tif (opts.blurable !== undefined) {\n\t\t\tblurable = opts.blurable;\n\t\t}\n\n\t\tif (opts.toggleable !== undefined) {\n\t\t\ttoggleable = opts.toggleable;\n\t\t}\n\n\t\tif (opts.info !== undefined) {\n\t\t\tinfo = opts.info;\n\t\t}\n\n\t\tif (opts.items !== undefined) {\n\t\t\titems = opts.items;\n\t\t}\n\n\t\tif (opts.style !== undefined) {\n\t\t\tstyle = opts.style;\n\t\t\tsetStyle = true;\n\t\t}\n\t\telse {\n\t\t\tstyle = 'os';\n\t\t\tsetStyle = true;\n\t\t}\n\n\t\tif (opts.selector !== undefined) {\n\t\t\tselector = opts.selector;\n\t\t}\n\n\t\tif (opts.className !== undefined) {\n\t\t\tclassName = opts.className;\n\t\t}\n\n\t\tif (opts.headerCheckbox !== undefined) {\n\t\t\theaderCheckbox = opts.headerCheckbox;\n\t\t}\n\n\t\tif (opts.selectable !== undefined) {\n\t\t\tselectable = opts.selectable;\n\t\t}\n\n\t\tif (opts.keys !== undefined) {\n\t\t\tkeys = opts.keys;\n\t\t}\n\t}\n\n\tdt.select.selector(selector);\n\tdt.select.items(items);\n\tdt.select.style(style);\n\tdt.select.blurable(blurable);\n\tdt.select.toggleable(toggleable);\n\tdt.select.info(info);\n\tdt.select.keys(keys);\n\tdt.select.selectable(selectable);\n\tctx._select.className = className;\n\n\t// If the init options haven't enabled select, but there is a selectable\n\t// class name, then enable\n\tif (!setStyle && $(dt.table().node()).hasClass('selectable')) {\n\t\tdt.select.style('os');\n\t}\n\n\t// Insert a checkbox into the header if needed - might need to wait\n\t// for init complete\n\tif (headerCheckbox || headerCheckbox === 'select-page' || headerCheckbox === 'select-all') {\n\t\tdt.ready(function () {\n\t\t\tinitCheckboxHeader(dt, headerCheckbox);\n\t\t});\n\t}\n};\n\n/*\n\nSelect is a collection of API methods, event handlers, event emitters and\nbuttons (for the `Buttons` extension) for DataTables. It provides the following\nfeatures, with an overview of how they are implemented:\n\n## Selection of rows, columns and cells. Whether an item is selected or not is\n   stored in:\n\n* rows: a `_select_selected` property which contains a boolean value of the\n  DataTables' `aoData` object for each row\n* columns: a `_select_selected` property which contains a boolean value of the\n  DataTables' `aoColumns` object for each column\n* cells: a `_selected_cells` property which contains an array of boolean values\n  of the `aoData` object for each row. The array is the same length as the\n  columns array, with each element of it representing a cell.\n\nThis method of using boolean flags allows Select to operate when nodes have not\nbeen created for rows / cells (DataTables' defer rendering feature).\n\n## API methods\n\nA range of API methods are available for triggering selection and de-selection\nof rows. Methods are also available to configure the selection events that can\nbe triggered by an end user (such as which items are to be selected). To a large\nextent, these of API methods *is* Select. It is basically a collection of helper\nfunctions that can be used to select items in a DataTable.\n\nConfiguration of select is held in the object `_select` which is attached to the\nDataTables settings object on initialisation. Select being available on a table\nis not optional when Select is loaded, but its default is for selection only to\nbe available via the API - so the end user wouldn't be able to select rows\nwithout additional configuration.\n\nThe `_select` object contains the following properties:\n\n```\n{\n\titems:string       - Can be `rows`, `columns` or `cells`. Defines what item \n\t                     will be selected if the user is allowed to activate row\n\t                     selection using the mouse.\n\tstyle:string       - Can be `none`, `single`, `multi` or `os`. Defines the\n\t                     interaction style when selecting items\n\tblurable:boolean   - If row selection can be cleared by clicking outside of\n\t                     the table\n\ttoggleable:boolean - If row selection can be cancelled by repeated clicking\n\t                     on the row\n\tinfo:boolean       - If the selection summary should be shown in the table\n\t                     information elements\n\tinfoEls:element[]  - List of HTML elements with info elements for a table\n}\n```\n\nIn addition to the API methods, Select also extends the DataTables selector\noptions for rows, columns and cells adding a `selected` option to the selector\noptions object, allowing the developer to select only selected items or\nunselected items.\n\n## Mouse selection of items\n\nClicking on items can be used to select items. This is done by a simple event\nhandler that will select the items using the API methods.\n\n */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Local functions\n */\n\n/**\n * Add one or more cells to the selection when shift clicking in OS selection\n * style cell selection.\n *\n * Cell range is more complicated than row and column as we want to select\n * in the visible grid rather than by index in sequence. For example, if you\n * click first in cell 1-1 and then shift click in 2-2 - cells 1-2 and 2-1\n * should also be selected (and not 1-3, 1-4. etc)\n *\n * @param  {DataTable.Api} dt   DataTable\n * @param  {object}        idx  Cell index to select to\n * @param  {object}        last Cell index to select from\n * @private\n */\nfunction cellRange(dt, idx, last) {\n\tvar indexes;\n\tvar columnIndexes;\n\tvar rowIndexes;\n\tvar selectColumns = function (start, end) {\n\t\tif (start > end) {\n\t\t\tvar tmp = end;\n\t\t\tend = start;\n\t\t\tstart = tmp;\n\t\t}\n\n\t\tvar record = false;\n\t\treturn dt\n\t\t\t.columns(':visible')\n\t\t\t.indexes()\n\t\t\t.filter(function (i) {\n\t\t\t\tif (i === start) {\n\t\t\t\t\trecord = true;\n\t\t\t\t}\n\n\t\t\t\tif (i === end) {\n\t\t\t\t\t// not else if, as start might === end\n\t\t\t\t\trecord = false;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn record;\n\t\t\t});\n\t};\n\n\tvar selectRows = function (start, end) {\n\t\tvar indexes = dt.rows({ search: 'applied' }).indexes();\n\n\t\t// Which comes first - might need to swap\n\t\tif (indexes.indexOf(start) > indexes.indexOf(end)) {\n\t\t\tvar tmp = end;\n\t\t\tend = start;\n\t\t\tstart = tmp;\n\t\t}\n\n\t\tvar record = false;\n\t\treturn indexes.filter(function (i) {\n\t\t\tif (i === start) {\n\t\t\t\trecord = true;\n\t\t\t}\n\n\t\t\tif (i === end) {\n\t\t\t\trecord = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn record;\n\t\t});\n\t};\n\n\tif (!dt.cells({ selected: true }).any() && !last) {\n\t\t// select from the top left cell to this one\n\t\tcolumnIndexes = selectColumns(0, idx.column);\n\t\trowIndexes = selectRows(0, idx.row);\n\t}\n\telse {\n\t\t// Get column indexes between old and new\n\t\tcolumnIndexes = selectColumns(last.column, idx.column);\n\t\trowIndexes = selectRows(last.row, idx.row);\n\t}\n\n\tindexes = dt.cells(rowIndexes, columnIndexes).flatten();\n\n\tif (!dt.cells(idx, { selected: true }).any()) {\n\t\t// Select range\n\t\tdt.cells(indexes).select();\n\t}\n\telse {\n\t\t// Deselect range\n\t\tdt.cells(indexes).deselect();\n\t}\n}\n\n/**\n * Get the class\n * @returns \n */\nfunction checkboxClass(selector) {\n\tvar name = datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select.classes.checkbox;\n\n\treturn selector\n\t\t? name.replace(/ /g, '.')\n\t\t: name;\n}\n\n/**\n * Disable mouse selection by removing the selectors\n *\n * @param {DataTable.Api} dt DataTable to remove events from\n * @private\n */\nfunction disableMouseSelection(dt) {\n\tvar ctx = dt.settings()[0];\n\tvar selector = ctx._select.selector;\n\n\t$(dt.table().container())\n\t\t.off('mousedown.dtSelect', selector)\n\t\t.off('mouseup.dtSelect', selector)\n\t\t.off('click.dtSelect', selector);\n\n\t$('body').off('click.dtSelect' + _safeId(dt.table().node()));\n}\n\n/**\n * Attach mouse listeners to the table to allow mouse selection of items\n *\n * @param {DataTable.Api} dt DataTable to remove events from\n * @private\n */\nfunction enableMouseSelection(dt) {\n\tvar container = $(dt.table().container());\n\tvar ctx = dt.settings()[0];\n\tvar selector = ctx._select.selector;\n\tvar matchSelection;\n\n\tcontainer\n\t\t.on('mousedown.dtSelect', selector, function (e) {\n\t\t\t// Disallow text selection for shift clicking on the table so multi\n\t\t\t// element selection doesn't look terrible!\n\t\t\tif (e.shiftKey || e.metaKey || e.ctrlKey) {\n\t\t\t\tcontainer\n\t\t\t\t\t.css('-moz-user-select', 'none')\n\t\t\t\t\t.one('selectstart.dtSelect', selector, function () {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (window.getSelection) {\n\t\t\t\tmatchSelection = window.getSelection();\n\t\t\t}\n\t\t})\n\t\t.on('mouseup.dtSelect', selector, function () {\n\t\t\t// Allow text selection to occur again, Mozilla style (tested in FF\n\t\t\t// 35.0.1 - still required)\n\t\t\tcontainer.css('-moz-user-select', '');\n\t\t})\n\t\t.on('click.dtSelect', selector, function (e) {\n\t\t\tvar items = dt.select.items();\n\t\t\tvar idx;\n\n\t\t\t// If text was selected (click and drag), then we shouldn't change\n\t\t\t// the row's selected state\n\t\t\tif (matchSelection) {\n\t\t\t\tvar selection = window.getSelection();\n\n\t\t\t\t// If the element that contains the selection is not in the table, we can ignore it\n\t\t\t\t// This can happen if the developer selects text from the click event\n\t\t\t\tif (\n\t\t\t\t\t!selection.anchorNode ||\n\t\t\t\t\t$(selection.anchorNode).closest('table')[0] === dt.table().node()\n\t\t\t\t) {\n\t\t\t\t\tif (selection !== matchSelection) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ctx = dt.settings()[0];\n\t\t\tvar container = dt.table().container();\n\n\t\t\t// Ignore clicks inside a sub-table\n\t\t\tif ($(e.target).closest('div.dt-container')[0] != container) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cell = dt.cell($(e.target).closest('td, th'));\n\n\t\t\t// Check the cell actually belongs to the host DataTable (so child\n\t\t\t// rows, etc, are ignored)\n\t\t\tif (!cell.any()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar event = $.Event('user-select.dt');\n\t\t\teventTrigger(dt, event, [items, cell, e]);\n\n\t\t\tif (event.isDefaultPrevented()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cellIndex = cell.index();\n\t\t\tif (items === 'row') {\n\t\t\t\tidx = cellIndex.row;\n\t\t\t\ttypeSelect(e, dt, ctx, 'row', idx);\n\t\t\t}\n\t\t\telse if (items === 'column') {\n\t\t\t\tidx = cell.index().column;\n\t\t\t\ttypeSelect(e, dt, ctx, 'column', idx);\n\t\t\t}\n\t\t\telse if (items === 'cell') {\n\t\t\t\tidx = cell.index();\n\t\t\t\ttypeSelect(e, dt, ctx, 'cell', idx);\n\t\t\t}\n\n\t\t\tctx._select_lastCell = cellIndex;\n\t\t});\n\n\t// Blurable\n\t$('body').on('click.dtSelect' + _safeId(dt.table().node()), function (e) {\n\t\tif (ctx._select.blurable) {\n\t\t\t// If the click was inside the DataTables container, don't blur\n\t\t\tif ($(e.target).parents().filter(dt.table().container()).length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore elements which have been removed from the DOM (i.e. paging\n\t\t\t// buttons)\n\t\t\tif ($(e.target).parents('html').length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don't blur in Editor form\n\t\t\tif ($(e.target).parents('div.DTE').length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar event = $.Event('select-blur.dt');\n\t\t\teventTrigger(dt, event, [e.target, e]);\n\n\t\t\tif (event.isDefaultPrevented()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclear(ctx, true);\n\t\t}\n\t});\n}\n\n/**\n * Trigger an event on a DataTable\n *\n * @param {DataTable.Api} api      DataTable to trigger events on\n * @param  {boolean}      selected true if selected, false if deselected\n * @param  {string}       type     Item type acting on\n * @param  {boolean}      any      Require that there are values before\n *     triggering\n * @private\n */\nfunction eventTrigger(api, type, args, any) {\n\tif (any && !api.flatten().length) {\n\t\treturn;\n\t}\n\n\tif (typeof type === 'string') {\n\t\ttype = type + '.dt';\n\t}\n\n\targs.unshift(api);\n\n\t$(api.table().node()).trigger(type, args);\n}\n\n/**\n * Determine if a column is a checkbox column\n * @param {*} col DataTables column object\n * @returns \n */\nfunction isCheckboxColumn(col) {\n\treturn col.mRender && col.mRender._name === 'selectCheckbox';\n}\n\n/**\n * Update the information element of the DataTable showing information about the\n * items selected. This is done by adding tags to the existing text\n *\n * @param {DataTable.Api} api DataTable to update\n * @private\n */\nfunction info(api, node) {\n\tif (api.select.style() === 'api' || api.select.info() === false) {\n\t\treturn;\n\t}\n\n\tvar ctx = api.settings()[0];\n\tvar rowSetLength = ctx._select_set.length;\n\tvar rows = rowSetLength ? rowSetLength : api.rows({ selected: true }).count();\n\tvar columns = api.columns({ selected: true }).count();\n\tvar cells = api.cells({ selected: true }).count();\n\n\t// If subtractive selection, then we need to take the number of rows and\n\t// subtract those that have been deselected\n\tif (ctx._select_mode === 'subtractive') {\n\t\trows = api.page.info().recordsDisplay - rowSetLength;\n\t}\n\n\tvar add = function (el, name, num) {\n\t\tel.append(\n\t\t\t$('<span class=\"select-item\"/>').append(\n\t\t\t\tapi.i18n(\n\t\t\t\t\t'select.' + name + 's',\n\t\t\t\t\t{ _: '%d ' + name + 's selected', 0: '', 1: '1 ' + name + ' selected' },\n\t\t\t\t\tnum\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t};\n\n\tvar el = $(node);\n\tvar output = $('<span class=\"select-info\"/>');\n\n\tadd(output, 'row', rows);\n\tadd(output, 'column', columns);\n\tadd(output, 'cell', cells);\n\n\tvar existing = el.children('span.select-info');\n\n\tif (existing.length) {\n\t\texisting.remove();\n\t}\n\n\tif (output.text() !== '') {\n\t\tel.append(output);\n\t}\n}\n\n/**\n * Add a checkbox to the header for checkbox columns, allowing all rows to\n * be selected, deselected or just to show the state.\n *\n * @param {*} dt API\n * @param {*} headerCheckbox the header checkbox option\n */\nfunction initCheckboxHeader( dt, headerCheckbox ) {\n\tvar dtSettings = dt.settings()[0];\n\tvar dtInternalColumns = dtSettings.aoColumns;\n\n\t// Find any checkbox column(s)\n\tdt.columns().iterator('column', function (s, idx) {\n\t\tvar col = dtInternalColumns[idx];\n\n\t\t// Checkbox columns have a rendering function with a given name\n\t\tif (! isCheckboxColumn(col)) {\n\t\t\treturn;\n\t\t}\n\t\tvar header = dt.column(idx).header();\n\n\t\tif (! $('input', header).length) {\n\t\t\t// If no checkbox yet, insert one\n\t\t\tvar input = $('<input>')\n\t\t\t\t.attr({\n\t\t\t\t\tclass: checkboxClass(true),\n\t\t\t\t\ttype: 'checkbox',\n\t\t\t\t\t'aria-label': dt.i18n('select.aria.headerCheckbox') || 'Select all rows'\n\t\t\t\t})\n\t\t\t\t.appendTo(header)\n\t\t\t\t.on('change', function () {\n\t\t\t\t\tif (this.checked) {\n\t\t\t\t\t\tif (headerCheckbox == 'select-page') {\n\t\t\t\t\t\t\tdt.rows({page: 'current'}).select();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdt.rows({search: 'applied'}).select();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (headerCheckbox == 'select-page') {\n\t\t\t\t\t\t\tdt.rows({page: 'current', selected: true}).deselect();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdt.rows({selected: true}).deselect();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.on('click', function (e) {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t});\n\n\t\t\t// Update the header checkbox's state when the selection in the\n\t\t\t// table changes\n\t\t\tdt.on('draw select deselect', function (e, pass, type) {\n\t\t\t\tif (type === 'row' || ! type) {\n\t\t\t\t\tvar nums = headerCheckboxState(dt, headerCheckbox);\n\n\t\t\t\t\tif (nums.search && nums.search <= nums.count && nums.search === nums.available) {\n\t\t\t\t\t\tinput\n\t\t\t\t\t\t\t.prop('checked', true)\n\t\t\t\t\t\t\t.prop('indeterminate', false);\n\t\t\t\t\t}\n\t\t\t\t\telse if (nums.search === 0 && nums.count === 0) {\n\t\t\t\t\t\tinput\n\t\t\t\t\t\t\t.prop('checked', false)\n\t\t\t\t\t\t\t.prop('indeterminate', false);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tinput\n\t\t\t\t\t\t\t.prop('checked', false)\n\t\t\t\t\t\t\t.prop('indeterminate', true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nfunction keysSet(dt) {\n\tvar ctx = dt.settings()[0];\n\tvar flag = ctx._select.keys;\n\tvar namespace = 'dts-keys-' + ctx.sTableId;\n\n\tif (flag) {\n\t\t// Need a tabindex of the `tr` elements to make them focusable by the browser\n\t\t$(dt.rows({page: 'current'}).nodes()).attr('tabindex', 0);\n\n\t\tdt.on('draw.' + namespace, function () {\n\t\t\t$(dt.rows({page: 'current'}).nodes()).attr('tabindex', 0);\n\t\t});\n\n\t\t// Listen on document for tab, up and down\n\t\t$(document).on('keydown.' + namespace, function (e) {\n\t\t\tvar key = e.keyCode;\n\t\t\tvar active = document.activeElement;\n\n\t\t\t// Can't use e.key as it wasn't widely supported until 2017\n\t\t\t// 9 Tab\n\t\t\t// 13 Return\n\t\t\t// 32 Space\n\t\t\t// 38 ArrowUp\n\t\t\t// 40 ArrowDown\n\t\t\tif (! [9, 13, 32, 38, 40].includes(key)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar nodes = dt.rows({page: 'current'}).nodes().toArray();\n\t\t\tvar idx = nodes.indexOf(active);\n\t\t\tvar preventDefault = true;\n\n\t\t\t// Only take an action if a row has focus\n\t\t\tif (idx === -1) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (key === 9) {\n\t\t\t\t// Tab focus change\n\t\t\t\tif (e.shift === false && idx === nodes.length - 1) {\n\t\t\t\t\tkeysPageDown(dt);\n\t\t\t\t}\n\t\t\t\telse if (e.shift === true && idx === 0) {\n\t\t\t\t\tkeysPageUp(dt);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Browser will do it for us\n\t\t\t\t\tpreventDefault = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (key === 13 || key === 32) {\n\t\t\t\t// Row selection / deselection\n\t\t\t\tvar row = dt.row(active);\n\n\t\t\t\tif (row.selected()) {\n\t\t\t\t\trow.deselect();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trow.select();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (key === 38) {\n\t\t\t\t// Move up\n\t\t\t\tif (idx > 0) {\n\t\t\t\t\tnodes[idx-1].focus();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkeysPageUp(dt);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Move down\n\t\t\t\tif (idx < nodes.length -1) {\n\t\t\t\t\tnodes[idx+1].focus();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tkeysPageDown(dt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (preventDefault) {\n\t\t\t\te.stopPropagation();\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t});\n\t}\n\telse {\n\t\t// Stop the rows from being able to gain focus\n\t\t$(dt.rows().nodes()).removeAttr('tabindex');\n\n\t\t// Nuke events\n\t\tdt.off('draw.' + namespace);\n\t\t$(document).off('keydown.' + namespace);\n\t}\n}\n\n/**\n * Change to the next page and focus on the first row\n *\n * @param {DataTable.Api} dt DataTable instance\n */\nfunction keysPageDown(dt) {\n\t// Is there another page to turn to?\n\tvar info = dt.page.info();\n\n\tif (info.page < info.pages - 1) {\n\t\tdt\n\t\t\t.one('draw', function () {\n\t\t\t\tdt.row(':first-child').node().focus();\n\t\t\t})\n\t\t\t.page('next')\n\t\t\t.draw(false);\n\t}\n}\n\n/**\n * Change to the previous page and focus on the last row\n *\n * @param {DataTable.Api} dt DataTable instance\n */\nfunction keysPageUp(dt) {\n\t// Is there another page to turn to?\n\tvar info = dt.page.info();\n\n\tif (info.page > 0) {\n\t\tdt\n\t\t\t.one('draw', function () {\n\t\t\t\tdt.row(':last-child').node().focus();\n\t\t\t})\n\t\t\t.page('previous')\n\t\t\t.draw(false);\n\t}\n}\n\n/**\n * Determine the counts used to define the header checkbox's state\n *\n * @param {*} dt DT API\n * @param {*} headerCheckbox Configuration for what the header checkbox does\n * @returns Counts object\n */\nfunction headerCheckboxState(dt, headerCheckbox) {\n\tvar ctx = dt.settings()[0];\n\tvar selectable = ctx._select.selectable;\n\tvar available = 0;\n\tvar count = headerCheckbox == 'select-page'\n\t\t? dt.rows({page: 'current', selected: true}).count()\n\t\t: dt.rows({selected: true}).count();\n\tvar search = headerCheckbox == 'select-page'\n\t\t? dt.rows({page: 'current', selected: true}).count()\n\t\t: dt.rows({search: 'applied', selected: true}).count();\n\n\tif (! selectable) {\n\t\tavailable = headerCheckbox == 'select-page'\n\t\t\t? dt.rows({page: 'current'}).count()\n\t\t\t: dt.rows({search: 'applied'}).count();\t\n\t}\n\telse {\n\t\t// Need to count how many rows are actually selectable to know if all selectable\n\t\t// rows are selected or not\n\t\tvar indexes = headerCheckbox == 'select-page'\n\t\t\t? dt.rows({page: 'current'}).indexes()\n\t\t\t: dt.rows({search: 'applied'}).indexes();\n\n\t\tfor (var i=0 ; i<indexes.length ; i++) {\n\t\t\t// For speed I use the internal DataTables object.\n\t\t\tvar rowInternal = ctx.aoData[indexes[i]];\n\t\t\tvar result = selectable(rowInternal._aData, rowInternal.nTr, indexes[i]);\n\n\t\t\tif (result) {\n\t\t\t\tavailable++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tavailable: available,\n\t\tcount: count,\n\t\tsearch: search\n\t}\n}\n\n/**\n * Initialisation of a new table. Attach event handlers and callbacks to allow\n * Select to operate correctly.\n *\n * This will occur _after_ the initial DataTables initialisation, although\n * before Ajax data is rendered, if there is ajax data\n *\n * @param  {DataTable.settings} ctx Settings object to operate on\n * @private\n */\nfunction init(ctx) {\n\tvar api = new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx);\n\tctx._select_init = true;\n\n\t// When `additive` then `_select_set` contains a list of the row ids that\n\t// are selected. If `subtractive` then all rows are selected, except those\n\t// in `_select_set`, which is a list of ids.\n\tctx._select_mode = 'additive';\n\tctx._select_set = [];\n\n\t// Row callback so that classes can be added to rows and cells if the item\n\t// was selected before the element was created. This will happen with the\n\t// `deferRender` option enabled.\n\t//\n\t// This method of attaching to `aoRowCreatedCallback` is a hack until\n\t// DataTables has proper events for row manipulation If you are reviewing\n\t// this code to create your own plug-ins, please do not do this!\n\tctx.aoRowCreatedCallback.push(function (row, data, index) {\n\t\t\tvar i, ien;\n\t\t\tvar d = ctx.aoData[index];\n\t\t\tvar id = api.row(index).id();\n\n\t\t\t// Row\n\t\t\tif (\n\t\t\t\td._select_selected ||\n\t\t\t\t(ctx._select_mode === 'additive' && ctx._select_set.includes(id)) ||\n\t\t\t\t(ctx._select_mode === 'subtractive' && ! ctx._select_set.includes(id))\n\t\t\t) {\n\t\t\t\td._select_selected = true;\n\n\t\t\t\t$(row)\n\t\t\t\t\t.addClass(ctx._select.className)\n\t\t\t\t\t.find('input.' + checkboxClass(true)).prop('checked', true);\n\t\t\t}\n\n\t\t\t// Cells and columns - if separated out, we would need to do two\n\t\t\t// loops, so it makes sense to combine them into a single one\n\t\t\tfor (i = 0, ien = ctx.aoColumns.length; i < ien; i++) {\n\t\t\t\tif (\n\t\t\t\t\tctx.aoColumns[i]._select_selected ||\n\t\t\t\t\t(d._selected_cells && d._selected_cells[i])\n\t\t\t\t) {\n\t\t\t\t\t$(d.anCells[i]).addClass(ctx._select.className)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t);\n\n\t_cumulativeEvents(api);\n\n\t// Update the table information element with selected item summary\n\tapi.on('info.dt', function (e, ctx, node) {\n\t\t// Store the info node for updating on select / deselect\n\t\tif (!ctx._select.infoEls.includes(node)) {\n\t\t\tctx._select.infoEls.push(node);\n\t\t}\n\n\t\tinfo(api, node);\n\t});\n\n\tapi.on('select.dtSelect.dt deselect.dtSelect.dt', function () {\n\t\tctx._select.infoEls.forEach(function (el) {\n\t\t\tinfo(api, el);\n\t\t});\n\n\t\tapi.state.save();\n\t});\n\n\t// Clean up and release\n\tapi.on('destroy.dtSelect', function () {\n\t\t// Remove class directly rather than calling deselect - which would trigger events\n\t\t$(api.rows({ selected: true }).nodes()).removeClass(api.settings()[0]._select.className);\n\n\t\t$('input.' + checkboxClass(true), api.table().header()).remove();\n\n\t\tdisableMouseSelection(api);\n\t\tapi.off('.dtSelect');\n\t\t$('body').off('.dtSelect' + _safeId(api.table().node()));\n\t});\n}\n\n/**\n * Add one or more items (rows or columns) to the selection when shift clicking\n * in OS selection style\n *\n * @param  {DataTable.Api} dt   DataTable\n * @param  {string}        type Row or column range selector\n * @param  {object}        idx  Item index to select to\n * @param  {object}        last Item index to select from\n * @private\n */\nfunction rowColumnRange(dt, type, idx, last) {\n\t// Add a range of rows from the last selected row to this one\n\tvar indexes = dt[type + 's']({ search: 'applied' }).indexes();\n\tvar idx1 = indexes.indexOf(last);\n\tvar idx2 = indexes.indexOf(idx);\n\n\tif (!dt[type + 's']({ selected: true }).any() && idx1 === -1) {\n\t\t// select from top to here - slightly odd, but both Windows and Mac OS\n\t\t// do this\n\t\tindexes.splice(indexes.indexOf(idx) + 1, indexes.length);\n\t}\n\telse {\n\t\t// reverse so we can shift click 'up' as well as down\n\t\tif (idx1 > idx2) {\n\t\t\tvar tmp = idx2;\n\t\t\tidx2 = idx1;\n\t\t\tidx1 = tmp;\n\t\t}\n\n\t\tindexes.splice(idx2 + 1, indexes.length);\n\t\tindexes.splice(0, idx1);\n\t}\n\n\tif (!dt[type](idx, { selected: true }).any()) {\n\t\t// Select range\n\t\tdt[type + 's'](indexes).select();\n\t}\n\telse {\n\t\t// Deselect range - need to keep the clicked on row selected\n\t\tindexes.splice(indexes.indexOf(idx), 1);\n\t\tdt[type + 's'](indexes).deselect();\n\t}\n}\n\n/**\n * Clear all selected items\n *\n * @param  {DataTable.settings} ctx Settings object of the host DataTable\n * @param  {boolean} [force=false] Force the de-selection to happen, regardless\n *     of selection style\n * @private\n */\nfunction clear(ctx, force) {\n\tif (force || ctx._select.style === 'single') {\n\t\tvar api = new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx);\n\n\t\tapi.rows({ selected: true }).deselect();\n\t\tapi.columns({ selected: true }).deselect();\n\t\tapi.cells({ selected: true }).deselect();\n\t}\n}\n\n/**\n * Select items based on the current configuration for style and items.\n *\n * @param  {object}             e    Mouse event object\n * @param  {DataTables.Api}     dt   DataTable\n * @param  {DataTable.settings} ctx  Settings object of the host DataTable\n * @param  {string}             type Items to select\n * @param  {int|object}         idx  Index of the item to select\n * @private\n */\nfunction typeSelect(e, dt, ctx, type, idx) {\n\tvar style = dt.select.style();\n\tvar toggleable = dt.select.toggleable();\n\tvar isSelected = dt[type](idx, { selected: true }).any();\n\n\tif (isSelected && !toggleable) {\n\t\treturn;\n\t}\n\n\tif (style === 'os') {\n\t\tif (e.ctrlKey || e.metaKey) {\n\t\t\t// Add or remove from the selection\n\t\t\tdt[type](idx).select(!isSelected);\n\t\t}\n\t\telse if (e.shiftKey) {\n\t\t\tif (type === 'cell') {\n\t\t\t\tcellRange(dt, idx, ctx._select_lastCell || null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trowColumnRange(\n\t\t\t\t\tdt,\n\t\t\t\t\ttype,\n\t\t\t\t\tidx,\n\t\t\t\t\tctx._select_lastCell ? ctx._select_lastCell[type] : null\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No cmd or shift click - deselect if selected, or select\n\t\t\t// this row only\n\t\t\tvar selected = dt[type + 's']({ selected: true });\n\n\t\t\tif (isSelected && selected.flatten().length === 1) {\n\t\t\t\tdt[type](idx).deselect();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tselected.deselect();\n\t\t\t\tdt[type](idx).select();\n\t\t\t}\n\t\t}\n\t}\n\telse if (style == 'multi+shift') {\n\t\tif (e.shiftKey) {\n\t\t\tif (type === 'cell') {\n\t\t\t\tcellRange(dt, idx, ctx._select_lastCell || null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trowColumnRange(\n\t\t\t\t\tdt,\n\t\t\t\t\ttype,\n\t\t\t\t\tidx,\n\t\t\t\t\tctx._select_lastCell ? ctx._select_lastCell[type] : null\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdt[type](idx).select(!isSelected);\n\t\t}\n\t}\n\telse {\n\t\tdt[type](idx).select(!isSelected);\n\t}\n}\n\nfunction _safeId(node) {\n\treturn node.id.replace(/[^a-zA-Z0-9\\-\\_]/g, '-');\n}\n\n/**\n * Set up event handlers for cumulative selection\n *\n * @param {*} api DT API instance\n */\nfunction _cumulativeEvents(api) {\n\t// Add event listeners to add / remove from the _select_set\n\tapi.on('select', function (e, dt, type, indexes) {\n\t\t// Only support for rows at the moment\n\t\tif (type !== 'row') {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ctx = api.settings()[0];\n\n\t\tif (ctx._select_mode === 'additive') {\n\t\t\t// Add row to the selection list if it isn't already there\n\t\t\t_add(api, ctx._select_set, indexes);\n\t\t}\n\t\telse {\n\t\t\t// Subtractive - if a row is selected it should not in the list\n\t\t\t// as in subtractive mode the list gives the rows which are not\n\t\t\t// selected\n\t\t\t_remove(api, ctx._select_set, indexes);\n\t\t}\n\t});\n\n\tapi.on('deselect', function (e, dt, type, indexes) {\n\t\t// Only support for rows at the moment\n\t\tif (type !== 'row') {\n\t\t\treturn;\n\t\t}\n\n\t\tvar ctx = api.settings()[0];\n\n\t\tif (ctx._select_mode === 'additive') {\n\t\t\t// List is of those rows selected, so remove it\n\t\t\t_remove(api, ctx._select_set, indexes);\n\t\t}\n\t\telse {\n\t\t\t// List is of rows which are deselected, so add it!\n\t\t\t_add(api, ctx._select_set, indexes);\n\t\t}\n\t});\n}\n\nfunction _add(api, arr, indexes) {\n\tfor (var i=0 ; i<indexes.length ; i++) {\n\t\tvar id = api.row(indexes[i]).id();\n\n\t\tif (id && id !== 'undefined' && ! arr.includes(id)) {\n\t\t\tarr.push(id);\n\t\t}\n\t}\n}\n\nfunction _remove(api, arr, indexes) {\n\tfor (var i=0 ; i<indexes.length ; i++) {\n\t\tvar id = api.row(indexes[i]).id();\n\t\tvar idx = arr.indexOf(id);\n\n\t\tif (idx !== -1) {\n\t\t\tarr.splice(idx, 1);\n\t\t}\n\t}\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables selectors\n */\n\n// row and column are basically identical just assigned to different properties\n// and checking a different array, so we can dynamically create the functions to\n// reduce the code size\n$.each(\n\t[\n\t\t{ type: 'row', prop: 'aoData' },\n\t\t{ type: 'column', prop: 'aoColumns' }\n\t],\n\tfunction (i, o) {\n\t\tdatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ext.selector[o.type].push(function (settings, opts, indexes) {\n\t\t\tvar selected = opts.selected;\n\t\t\tvar data;\n\t\t\tvar out = [];\n\n\t\t\tif (selected !== true && selected !== false) {\n\t\t\t\treturn indexes;\n\t\t\t}\n\n\t\t\tfor (var i = 0, ien = indexes.length; i < ien; i++) {\n\t\t\t\tdata = settings[o.prop][indexes[i]];\n\n\t\t\t\tif (\n\t\t\t\t\tdata && (\n\t\t\t\t\t\t(selected === true && data._select_selected === true) ||\n\t\t\t\t\t\t(selected === false && !data._select_selected)\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tout.push(indexes[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t});\n\t}\n);\n\ndatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ext.selector.cell.push(function (settings, opts, cells) {\n\tvar selected = opts.selected;\n\tvar rowData;\n\tvar out = [];\n\n\tif (selected === undefined) {\n\t\treturn cells;\n\t}\n\n\tfor (var i = 0, ien = cells.length; i < ien; i++) {\n\t\trowData = settings.aoData[cells[i].row];\n\n\t\tif (\n\t\t\trowData && (\n\t\t\t\t(selected === true &&\n\t\t\t\t\trowData._selected_cells &&\n\t\t\t\t\trowData._selected_cells[cells[i].column] === true) ||\n\t\t\t\t(selected === false &&\n\t\t\t\t\t(!rowData._selected_cells || !rowData._selected_cells[cells[i].column]))\n\t\t\t)\n\t\t) {\n\t\t\tout.push(cells[i]);\n\t\t}\n\t}\n\n\treturn out;\n});\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables API\n *\n * For complete documentation, please refer to the docs/api directory or the\n * DataTables site\n */\n\n// Local variables to improve compression\nvar apiRegister = datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api.register;\nvar apiRegisterPlural = datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api.registerPlural;\n\napiRegister('select()', function () {\n\treturn this.iterator('table', function (ctx) {\n\t\tdatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select.init(new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx));\n\t});\n});\n\napiRegister('select.blurable()', function (flag) {\n\tif (flag === undefined) {\n\t\treturn this.context[0]._select.blurable;\n\t}\n\n\treturn this.iterator('table', function (ctx) {\n\t\tctx._select.blurable = flag;\n\t});\n});\n\napiRegister('select.toggleable()', function (flag) {\n\tif (flag === undefined) {\n\t\treturn this.context[0]._select.toggleable;\n\t}\n\n\treturn this.iterator('table', function (ctx) {\n\t\tctx._select.toggleable = flag;\n\t});\n});\n\napiRegister('select.info()', function (flag) {\n\tif (flag === undefined) {\n\t\treturn this.context[0]._select.info;\n\t}\n\n\treturn this.iterator('table', function (ctx) {\n\t\tctx._select.info = flag;\n\t});\n});\n\napiRegister('select.items()', function (items) {\n\tif (items === undefined) {\n\t\treturn this.context[0]._select.items;\n\t}\n\n\treturn this.iterator('table', function (ctx) {\n\t\tctx._select.items = items;\n\n\t\teventTrigger(new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx), 'selectItems', [items]);\n\t});\n});\n\napiRegister('select.keys()', function (flag) {\n\tif (flag === undefined) {\n\t\treturn this.context[0]._select.keys;\n\t}\n\n\treturn this.iterator('table', function (ctx) {\n\t\tif (!ctx._select) {\n\t\t\tdatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select.init(new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx));\n\t\t}\n\n\t\tctx._select.keys = flag;\n\n\t\tkeysSet(new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx));\n\t});\n});\n\n// Takes effect from the _next_ selection. None disables future selection, but\n// does not clear the current selection. Use the `deselect` methods for that\napiRegister('select.style()', function (style) {\n\tif (style === undefined) {\n\t\treturn this.context[0]._select.style;\n\t}\n\n\treturn this.iterator('table', function (ctx) {\n\t\tif (!ctx._select) {\n\t\t\tdatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select.init(new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx));\n\t\t}\n\n\t\tif (!ctx._select_init) {\n\t\t\tinit(ctx);\n\t\t}\n\n\t\tctx._select.style = style;\n\n\t\t// Add / remove mouse event handlers. They aren't required when only\n\t\t// API selection is available\n\t\tvar dt = new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx);\n\n\t\tif (style !== 'api') {\n\t\t\tdt.ready(function () {\n\t\t\t\tdisableMouseSelection(dt);\n\t\t\t\tenableMouseSelection(dt);\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tdisableMouseSelection(dt);\n\t\t}\n\n\t\teventTrigger(new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx), 'selectStyle', [style]);\n\t});\n});\n\napiRegister('select.selector()', function (selector) {\n\tif (selector === undefined) {\n\t\treturn this.context[0]._select.selector;\n\t}\n\n\treturn this.iterator('table', function (ctx) {\n\t\tvar dt = new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx);\n\t\tvar style = ctx._select.style;\n\n\t\tdisableMouseSelection(dt);\n\n\t\tctx._select.selector = selector;\n\n\t\tif (style && style !== 'api') {\n\t\t\tdt.ready(function () {\n\t\t\t\tdisableMouseSelection(dt);\n\t\t\t\tenableMouseSelection(dt);\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tdisableMouseSelection(dt);\n\t\t}\n\t});\n});\n\napiRegister('select.selectable()', function (set) {\n\tlet ctx = this.context[0];\n\n\tif (set) {\n\t\tctx._select.selectable = set;\n\t\treturn this;\n\t}\n\n\treturn ctx._select.selectable;\n});\n\napiRegister('select.last()', function (set) {\n\tlet ctx = this.context[0];\n\n\tif (set) {\n\t\tctx._select_lastCell = set;\n\t\treturn this;\n\t}\n\n\treturn ctx._select_lastCell;\n});\n\napiRegister('select.cumulative()', function (mode) {\n\tif (mode) {\n\t\treturn this.iterator('table', function (ctx) {\n\t\t\tif (ctx._select_mode === mode) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar dt = new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx);\n\n\t\t\t// Convert from the current mode, to the new\n\t\t\tif (mode === 'subtractive') {\n\t\t\t\t// For subtractive mode we track the row ids which are not selected\n\t\t\t\tvar unselected = dt.rows({selected: false}).ids().toArray();\n\n\t\t\t\tctx._select_mode = mode;\n\t\t\t\tctx._select_set.length = 0;\n\t\t\t\tctx._select_set.push.apply(ctx._select_set, unselected);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Switching to additive, so selected rows are to be used\n\t\t\t\tvar selected = dt.rows({selected: true}).ids().toArray();\n\n\t\t\t\tctx._select_mode = mode;\n\t\t\t\tctx._select_set.length = 0;\n\t\t\t\tctx._select_set.push.apply(ctx._select_set, selected);\n\t\t\t}\n\t\t}).draw(false);\n\t}\n\n\tlet ctx = this.context[0];\n\n\tif (ctx && ctx._select_set) {\n\t\treturn {\n\t\t\tmode: ctx._select_mode,\n\t\t\trows: ctx._select_set\n\t\t};\n\t}\n\n\treturn null;\n});\n\napiRegisterPlural('rows().select()', 'row().select()', function (select) {\n\tvar api = this;\n\tvar selectedIndexes = [];\n\n\tif (select === false) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator('row', function (ctx, idx) {\n\t\tclear(ctx);\n\n\t\t// There is a good amount of knowledge of DataTables internals in\n\t\t// this function. It _could_ be done without that, but it would hurt\n\t\t// performance (or DT would need new APIs for this work)\n\t\tvar dtData = ctx.aoData[idx];\n\t\tvar dtColumns = ctx.aoColumns;\n\n\t\tif (ctx._select.selectable) {\n\t\t\tvar result = ctx._select.selectable(dtData._aData, dtData.nTr, idx);\n\n\t\t\tif (result === false) {\n\t\t\t\t// Not selectable - do nothing\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t$(dtData.nTr).addClass(ctx._select.className);\n\t\tdtData._select_selected = true;\n\n\t\tselectedIndexes.push(idx);\n\n\t\tfor (var i=0 ; i<dtColumns.length ; i++) {\n\t\t\tvar col = dtColumns[i];\n\n\t\t\t// Regenerate the column type if not present\n\t\t\tif (col.sType === null) {\n\t\t\t\tapi.columns().types()\n\t\t\t}\n\t\t\t\n\t\t\tif (isCheckboxColumn(col)) {\n\t\t\t\tvar cells = dtData.anCells;\n\n\t\t\t\t// Make sure the checkbox shows the right state\n\t\t\t\tif (cells && cells[i]) {\n\t\t\t\t\t$('input.' + checkboxClass(true), cells[i]).prop('checked', true);\n\t\t\t\t}\n\n\t\t\t\t// Invalidate the sort data for this column, if not already done\n\t\t\t\tif (dtData._aSortData !== null) {\n\t\t\t\t\tdtData._aSortData[i] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tthis.iterator('table', function (ct) {\n\t\teventTrigger(api, 'select', ['row', selectedIndexes], true);\n\t});\n\n\treturn this;\n});\n\napiRegister('row().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (ctx && this.length && ctx.aoData[this[0]] && ctx.aoData[this[0]]._select_selected) {\n\t\treturn true;\n\t}\n\n\treturn false;\n});\n\napiRegister('row().focus()', function () {\n\tvar ctx = this.context[0];\n\n\tif (ctx && this.length && ctx.aoData[this[0]] && ctx.aoData[this[0]].nTr) {\n\t\tctx.aoData[this[0]].nTr.focus();\n\t}\n});\n\napiRegister('row().blur()', function () {\n\tvar ctx = this.context[0];\n\n\tif (ctx && this.length && ctx.aoData[this[0]] && ctx.aoData[this[0]].nTr) {\n\t\tctx.aoData[this[0]].nTr.blur();\n\t}\n});\n\napiRegisterPlural('columns().select()', 'column().select()', function (select) {\n\tvar api = this;\n\n\tif (select === false) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator('column', function (ctx, idx) {\n\t\tclear(ctx);\n\n\t\tctx.aoColumns[idx]._select_selected = true;\n\n\t\tvar column = new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx).column(idx);\n\n\t\t$(column.header()).addClass(ctx._select.className);\n\t\t$(column.footer()).addClass(ctx._select.className);\n\n\t\tcolumn.nodes().to$().addClass(ctx._select.className);\n\t});\n\n\tthis.iterator('table', function (ctx, i) {\n\t\teventTrigger(api, 'select', ['column', api[i]], true);\n\t});\n\n\treturn this;\n});\n\napiRegister('column().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (ctx && this.length && ctx.aoColumns[this[0]] && ctx.aoColumns[this[0]]._select_selected) {\n\t\treturn true;\n\t}\n\n\treturn false;\n});\n\napiRegisterPlural('cells().select()', 'cell().select()', function (select) {\n\tvar api = this;\n\n\tif (select === false) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator('cell', function (ctx, rowIdx, colIdx) {\n\t\tclear(ctx);\n\n\t\tvar data = ctx.aoData[rowIdx];\n\n\t\tif (data._selected_cells === undefined) {\n\t\t\tdata._selected_cells = [];\n\t\t}\n\n\t\tdata._selected_cells[colIdx] = true;\n\n\t\tif (data.anCells) {\n\t\t\t$(data.anCells[colIdx]).addClass(ctx._select.className);\n\t\t}\n\t});\n\n\tthis.iterator('table', function (ctx, i) {\n\t\teventTrigger(api, 'select', ['cell', api.cells(api[i]).indexes().toArray()], true);\n\t});\n\n\treturn this;\n});\n\napiRegister('cell().selected()', function () {\n\tvar ctx = this.context[0];\n\n\tif (ctx && this.length) {\n\t\tvar row = ctx.aoData[this[0][0].row];\n\n\t\tif (row && row._selected_cells && row._selected_cells[this[0][0].column]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n});\n\napiRegisterPlural('rows().deselect()', 'row().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator('row', function (ctx, idx) {\n\t\t// Like the select action, this has a lot of knowledge about DT internally\n\t\tvar dtData = ctx.aoData[idx];\n\t\tvar dtColumns = ctx.aoColumns;\n\n\t\t$(dtData.nTr).removeClass(ctx._select.className);\n\t\tdtData._select_selected = false;\n\t\tctx._select_lastCell = null;\n\n\t\tfor (var i=0 ; i<dtColumns.length ; i++) {\n\t\t\tvar col = dtColumns[i];\n\n\t\t\t// Regenerate the column type if not present\n\t\t\tif (col.sType === null) {\n\t\t\t\tapi.columns().types()\n\t\t\t}\n\t\t\t\n\t\t\tif (isCheckboxColumn(col)) {\n\t\t\t\tvar cells = dtData.anCells;\n\n\t\t\t\t// Make sure the checkbox shows the right state\n\t\t\t\tif (cells && cells[i]) {\n\t\t\t\t\t$('input.' + checkboxClass(true), dtData.anCells[i]).prop('checked', false);\n\t\t\t\t}\n\n\t\t\t\t// Invalidate the sort data for this column, if not already done\n\t\t\t\tif (dtData._aSortData !== null) {\n\t\t\t\t\tdtData._aSortData[i] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tthis.iterator('table', function (ctx, i) {\n\t\teventTrigger(api, 'deselect', ['row', api[i]], true);\n\t});\n\n\treturn this;\n});\n\napiRegisterPlural('columns().deselect()', 'column().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator('column', function (ctx, idx) {\n\t\tctx.aoColumns[idx]._select_selected = false;\n\n\t\tvar api = new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx);\n\t\tvar column = api.column(idx);\n\n\t\t$(column.header()).removeClass(ctx._select.className);\n\t\t$(column.footer()).removeClass(ctx._select.className);\n\n\t\t// Need to loop over each cell, rather than just using\n\t\t// `column().nodes()` as cells which are individually selected should\n\t\t// not have the `selected` class removed from them\n\t\tapi.cells(null, idx)\n\t\t\t.indexes()\n\t\t\t.each(function (cellIdx) {\n\t\t\t\tvar data = ctx.aoData[cellIdx.row];\n\t\t\t\tvar cellSelected = data._selected_cells;\n\n\t\t\t\tif (data.anCells && (!cellSelected || !cellSelected[cellIdx.column])) {\n\t\t\t\t\t$(data.anCells[cellIdx.column]).removeClass(ctx._select.className);\n\t\t\t\t}\n\t\t\t});\n\t});\n\n\tthis.iterator('table', function (ctx, i) {\n\t\teventTrigger(api, 'deselect', ['column', api[i]], true);\n\t});\n\n\treturn this;\n});\n\napiRegisterPlural('cells().deselect()', 'cell().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator('cell', function (ctx, rowIdx, colIdx) {\n\t\tvar data = ctx.aoData[rowIdx];\n\n\t\tif (data._selected_cells !== undefined) {\n\t\t\tdata._selected_cells[colIdx] = false;\n\t\t}\n\n\t\t// Remove class only if the cells exist, and the cell is not column\n\t\t// selected, in which case the class should remain (since it is selected\n\t\t// in the column)\n\t\tif (data.anCells && !ctx.aoColumns[colIdx]._select_selected) {\n\t\t\t$(data.anCells[colIdx]).removeClass(ctx._select.className);\n\t\t}\n\t});\n\n\tthis.iterator('table', function (ctx, i) {\n\t\teventTrigger(api, 'deselect', ['cell', api[i]], true);\n\t});\n\n\treturn this;\n});\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Buttons\n */\nfunction i18n(label, def) {\n\treturn function (dt) {\n\t\treturn dt.i18n('buttons.' + label, def);\n\t};\n}\n\n// Common events with suitable namespaces\nfunction namespacedEvents(config) {\n\tvar unique = config._eventNamespace;\n\n\treturn 'draw.dt.DT' + unique + ' select.dt.DT' + unique + ' deselect.dt.DT' + unique;\n}\n\nfunction enabled(dt, config) {\n\tif (config.limitTo.indexOf('rows') !== -1 && dt.rows({ selected: true }).any()) {\n\t\treturn true;\n\t}\n\n\tif (config.limitTo.indexOf('columns') !== -1 && dt.columns({ selected: true }).any()) {\n\t\treturn true;\n\t}\n\n\tif (config.limitTo.indexOf('cells') !== -1 && dt.cells({ selected: true }).any()) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvar _buttonNamespace = 0;\n\n$.extend(datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ext.buttons, {\n\tselected: {\n\t\ttext: i18n('selected', 'Selected'),\n\t\tclassName: 'buttons-selected',\n\t\tlimitTo: ['rows', 'columns', 'cells'],\n\t\tinit: function (dt, node, config) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select' + _buttonNamespace++;\n\n\t\t\t// .DT namespace listeners are removed by DataTables automatically\n\t\t\t// on table destroy\n\t\t\tdt.on(namespacedEvents(config), function () {\n\t\t\t\tthat.enable(enabled(dt, config));\n\t\t\t});\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function (dt, node, config) {\n\t\t\tdt.off(config._eventNamespace);\n\t\t}\n\t},\n\tselectedSingle: {\n\t\ttext: i18n('selectedSingle', 'Selected single'),\n\t\tclassName: 'buttons-selected-single',\n\t\tinit: function (dt, node, config) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select' + _buttonNamespace++;\n\n\t\t\tdt.on(namespacedEvents(config), function () {\n\t\t\t\tvar count =\n\t\t\t\t\tdt.rows({ selected: true }).flatten().length +\n\t\t\t\t\tdt.columns({ selected: true }).flatten().length +\n\t\t\t\t\tdt.cells({ selected: true }).flatten().length;\n\n\t\t\t\tthat.enable(count === 1);\n\t\t\t});\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function (dt, node, config) {\n\t\t\tdt.off(config._eventNamespace);\n\t\t}\n\t},\n\tselectAll: {\n\t\ttext: i18n('selectAll', 'Select all'),\n\t\tclassName: 'buttons-select-all',\n\t\taction: function (e, dt, node, config) {\n\t\t\tvar items = this.select.items();\n\t\t\tvar mod = config.selectorModifier;\n\t\t\t\n\t\t\tif (mod) {\n\t\t\t\tif (typeof mod === 'function') {\n\t\t\t\t\tmod = mod.call(dt, e, dt, node, config);\n\t\t\t\t}\n\n\t\t\t\tthis[items + 's'](mod).select();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis[items + 's']().select();\n\t\t\t}\n\t\t}\n\t\t// selectorModifier can be specified\n\t},\n\tselectNone: {\n\t\ttext: i18n('selectNone', 'Deselect all'),\n\t\tclassName: 'buttons-select-none',\n\t\taction: function () {\n\t\t\tclear(this.settings()[0], true);\n\t\t},\n\t\tinit: function (dt, node, config) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select' + _buttonNamespace++;\n\n\t\t\tdt.on(namespacedEvents(config), function () {\n\t\t\t\tvar count =\n\t\t\t\t\tdt.rows({ selected: true }).flatten().length +\n\t\t\t\t\tdt.columns({ selected: true }).flatten().length +\n\t\t\t\t\tdt.cells({ selected: true }).flatten().length;\n\n\t\t\t\tthat.enable(count > 0);\n\t\t\t});\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function (dt, node, config) {\n\t\t\tdt.off(config._eventNamespace);\n\t\t}\n\t},\n\tshowSelected: {\n\t\ttext: i18n('showSelected', 'Show only selected'),\n\t\tclassName: 'buttons-show-selected',\n\t\taction: function (e, dt) {\n\t\t\tif (dt.search.fixed('dt-select')) {\n\t\t\t\t// Remove existing function\n\t\t\t\tdt.search.fixed('dt-select', null);\n\n\t\t\t\tthis.active(false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Use a fixed filtering function to match on selected rows\n\t\t\t\t// This needs to reference the internal aoData since that is\n\t\t\t\t// where Select stores its reference for the selected state\n\t\t\t\tvar dataSrc = dt.settings()[0].aoData;\n\n\t\t\t\tdt.search.fixed('dt-select', function (text, data, idx) {\n\t\t\t\t\t// _select_selected is set by Select on the data object for the row\n\t\t\t\t\treturn dataSrc[idx]._select_selected;\n\t\t\t\t});\n\n\t\t\t\tthis.active(true);\n\t\t\t}\n\n\t\t\tdt.draw();\n\t\t}\n\t}\n});\n\n$.each(['Row', 'Column', 'Cell'], function (i, item) {\n\tvar lc = item.toLowerCase();\n\n\tdatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ext.buttons['select' + item + 's'] = {\n\t\ttext: i18n('select' + item + 's', 'Select ' + lc + 's'),\n\t\tclassName: 'buttons-select-' + lc + 's',\n\t\taction: function () {\n\t\t\tthis.select.items(lc);\n\t\t},\n\t\tinit: function (dt) {\n\t\t\tvar that = this;\n\n\t\t\tthis.active(dt.select.items() === lc);\n\n\t\t\tdt.on('selectItems.dt.DT', function (e, ctx, items) {\n\t\t\t\tthat.active(items === lc);\n\t\t\t});\n\t\t}\n\t};\n});\n\n// Note that DataTables 2.1 has more robust type detection, but we retain\n// backwards compatibility with 2.0 for the moment.\ndatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].type('select-checkbox', {\n\tclassName: 'dt-select',\n\tdetect: datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].versionCheck('2.1')\n\t\t? {\n\t\t\toneOf: function () {\n\t\t\t\treturn false; // no op\n\t\t\t},\n\t\t\tallOf: function () {\n\t\t\t\treturn false; // no op\n\t\t\t},\n\t\t\tinit: function (settings, col, idx) {\n\t\t\t\treturn isCheckboxColumn(col);\n\t\t\t}\n\t\t}\n\t\t: function (data) {\n\t\t\t// Rendering function will tell us if it is a checkbox type\n\t\t\treturn data === 'select-checkbox' ? data : false;\n\t\t},\n\torder: {\n\t\tpre: function (d) {\n\t\t\treturn d === 'X' ? -1 : 0;\n\t\t}\n\t}\n});\n\n$.extend(true, datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].defaults.oLanguage, {\n\tselect: {\n\t\taria: {\n\t\t\trowCheckbox: 'Select row'\n\t\t}\n\t}\n});\n\ndatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].render.select = function (valueProp, nameProp) {\n\tvar valueFn = valueProp ? datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].util.get(valueProp) : null;\n\tvar nameFn = nameProp ? datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].util.get(nameProp) : null;\n\n\tvar fn = function (data, type, row, meta) {\n\t\tvar dtRow = meta.settings.aoData[meta.row];\n\t\tvar selected = dtRow._select_selected;\n\t\tvar ariaLabel = meta.settings.oLanguage.select.aria.rowCheckbox;\n\t\tvar selectable = meta.settings._select.selectable;\n\n\t\tif (type === 'display') {\n\t\t\t// Check if the row is selectable before showing the checkbox\n\t\t\tif (selectable) {\n\t\t\t\tvar result = selectable(row, dtRow.nTr, meta.row);\n\t\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $('<input>')\n\t\t\t\t.attr({\n\t\t\t\t\t'aria-label': ariaLabel,\n\t\t\t\t\tclass: checkboxClass(),\n\t\t\t\t\tname: nameFn ? nameFn(row) : null,\n\t\t\t\t\ttype: 'checkbox',\n\t\t\t\t\tvalue: valueFn ? valueFn(row) : null,\n\t\t\t\t\tchecked: selected\n\t\t\t\t})\n\t\t\t\t.on('input', function (e) {\n\t\t\t\t\t// Let Select 100% control the state of the checkbox\n\t\t\t\t\te.preventDefault();\n\n\t\t\t\t\t// And make sure this checkbox matches it's row as it is possible\n\t\t\t\t\t// to check out of sync if this was clicked on to deselect a range\n\t\t\t\t\t// but remains selected itself\n\t\t\t\t\tthis.checked = $(this).closest('tr').hasClass('selected');\n\t\t\t\t})[0];\n\t\t}\n\t\telse if (type === 'type') {\n\t\t\treturn 'select-checkbox';\n\t\t}\n\t\telse if (type === 'filter') {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn selected ? 'X' : '';\n\t}\n\n\t// Workaround so uglify doesn't strip the function name. It is used\n\t// for the column type detection.\n\tfn._name = 'selectCheckbox';\n\n\treturn fn;\n}\n\n// Legacy checkbox ordering\ndatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ext.order['select-checkbox'] = function (settings, col) {\n\treturn this.api()\n\t\t.column(col, { order: 'index' })\n\t\t.nodes()\n\t\t.map(function (td) {\n\t\t\tif (settings._select.items === 'row') {\n\t\t\t\treturn $(td).parent().hasClass(settings._select.className).toString();\n\t\t\t}\n\t\t\telse if (settings._select.items === 'cell') {\n\t\t\t\treturn $(td).hasClass(settings._select.className).toString();\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n};\n\n$.fn.DataTable.select = datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select;\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Initialisation\n */\n\n// DataTables creation - we need this to run _before_ data is read in, but\n// for backwards compat. we also run again on preInit. If it happens twice\n// it will simply do nothing the second time around.\n$(document).on('i18n.dt.dtSelect preInit.dt.dtSelect', function (e, ctx) {\n\tif (e.namespace !== 'dt') {\n\t\treturn;\n\t}\n\n\tdatatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select.init(new datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Api(ctx));\n});\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtc2VsZWN0L2pzL2RhdGFUYWJsZXMuc2VsZWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRTRCO0FBQ1c7O0FBRXZDO0FBQ0EsUUFBUSxtQ0FBTTs7O0FBR2Q7QUFDQSxzREFBUzs7QUFFVCxzREFBUztBQUNUO0FBQ0E7O0FBRUEsc0RBQVM7O0FBRVQsc0RBQVM7QUFDVDs7QUFFQSxNQUFNLHNEQUFTO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DLHFDQUFxQyxnQkFBZ0I7QUFDckQsaUNBQWlDLGdCQUFnQjtBQUNqRCxZQUFZO0FBQ1osR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsZ0JBQWdCLHNEQUFTO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLGVBQWU7QUFDM0IsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSwwQkFBMEIsbUJBQW1COztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQVM7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVksY0FBYztBQUMxQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLHNEQUFTOztBQUU1QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHFCQUFxQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLHNEQUFTO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsc0RBQVMsaUJBQWlCLHNEQUFTO0FBQ3BDLENBQUM7OztBQUdELGlFQUFlLHNEQUFTLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtc2VsZWN0L2pzL2RhdGFUYWJsZXMuc2VsZWN0Lm1qcz8xMWVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBTZWxlY3QgZm9yIERhdGFUYWJsZXMgMy4wLjBcbiAqIMKpIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlL21pdFxuICovXG5cbmltcG9ydCBqUXVlcnkgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBEYXRhVGFibGUgZnJvbSAnZGF0YXRhYmxlcy5uZXQnO1xuXG4vLyBBbGxvdyByZWFzc2lnbm1lbnQgb2YgdGhlICQgdmFyaWFibGVcbmxldCAkID0galF1ZXJ5O1xuXG5cbi8vIFZlcnNpb24gaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2VyXG5EYXRhVGFibGUuc2VsZWN0ID0ge307XG5cbkRhdGFUYWJsZS5zZWxlY3QuY2xhc3NlcyA9IHtcblx0Y2hlY2tib3g6ICdkdC1zZWxlY3QtY2hlY2tib3gnXG59O1xuXG5EYXRhVGFibGUuc2VsZWN0LnZlcnNpb24gPSAnMy4wLjAnO1xuXG5EYXRhVGFibGUuc2VsZWN0LmluaXQgPSBmdW5jdGlvbiAoZHQpIHtcblx0dmFyIGN0eCA9IGR0LnNldHRpbmdzKClbMF07XG5cblx0aWYgKCFEYXRhVGFibGUudmVyc2lvbkNoZWNrKCcyJykpIHtcblx0XHR0aHJvdyAnV2FybmluZzogU2VsZWN0IHJlcXVpcmVzIERhdGFUYWJsZXMgMiBvciBuZXdlcic7XG5cdH1cblxuXHRpZiAoY3R4Ll9zZWxlY3QpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgc2F2ZWRTZWxlY3RlZCA9IGR0LnN0YXRlLmxvYWRlZCgpO1xuXG5cdHZhciBzZWxlY3RBbmRTYXZlID0gZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0aWYgKGRhdGEgPT09IG51bGwgfHwgZGF0YS5zZWxlY3QgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENsZWFyIGFueSBjdXJyZW50bHkgc2VsZWN0ZWQgcm93cywgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZVxuXHRcdC8vIE5vbmUgd2lsbCBiZSBzZWxlY3RlZCBvbiBmaXJzdCBpbml0aWFsaXNhdGlvblxuXHRcdGlmIChkdC5yb3dzKHsgc2VsZWN0ZWQ6IHRydWUgfSkuYW55KCkpIHtcblx0XHRcdGR0LnJvd3MoKS5kZXNlbGVjdCgpO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5zZWxlY3Qucm93cyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkdC5yb3dzKGRhdGEuc2VsZWN0LnJvd3MpLnNlbGVjdCgpO1xuXHRcdH1cblxuXHRcdGlmIChkdC5jb2x1bW5zKHsgc2VsZWN0ZWQ6IHRydWUgfSkuYW55KCkpIHtcblx0XHRcdGR0LmNvbHVtbnMoKS5kZXNlbGVjdCgpO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5zZWxlY3QuY29sdW1ucyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkdC5jb2x1bW5zKGRhdGEuc2VsZWN0LmNvbHVtbnMpLnNlbGVjdCgpO1xuXHRcdH1cblxuXHRcdGlmIChkdC5jZWxscyh7IHNlbGVjdGVkOiB0cnVlIH0pLmFueSgpKSB7XG5cdFx0XHRkdC5jZWxscygpLmRlc2VsZWN0KCk7XG5cdFx0fVxuXHRcdGlmIChkYXRhLnNlbGVjdC5jZWxscyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuc2VsZWN0LmNlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGR0LmNlbGwoZGF0YS5zZWxlY3QuY2VsbHNbaV0ucm93LCBkYXRhLnNlbGVjdC5jZWxsc1tpXS5jb2x1bW4pLnNlbGVjdCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGR0LnN0YXRlLnNhdmUoKTtcblx0fTtcblxuXHRkdC5vbignc3RhdGVTYXZlUGFyYW1zJywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0ZGF0YS5zZWxlY3QgPSB7fTtcblx0XHRkYXRhLnNlbGVjdC5yb3dzID0gZHQucm93cyh7IHNlbGVjdGVkOiB0cnVlIH0pLmlkcyh0cnVlKS50b0FycmF5KCk7XG5cdFx0ZGF0YS5zZWxlY3QuY29sdW1ucyA9IGR0LmNvbHVtbnMoeyBzZWxlY3RlZDogdHJ1ZSB9KVswXTtcblx0XHRkYXRhLnNlbGVjdC5jZWxscyA9IGR0LmNlbGxzKHsgc2VsZWN0ZWQ6IHRydWUgfSlbMF0ubWFwKGZ1bmN0aW9uIChjb29yZHMpIHtcblx0XHRcdHJldHVybiB7IHJvdzogZHQucm93KGNvb3Jkcy5yb3cpLmlkKHRydWUpLCBjb2x1bW46IGNvb3Jkcy5jb2x1bW4gfTtcblx0XHR9KTtcblx0fSlcblx0XHQub24oJ3N0YXRlTG9hZFBhcmFtcycsIHNlbGVjdEFuZFNhdmUpXG5cdFx0Lm9uZSgnaW5pdCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHNlbGVjdEFuZFNhdmUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHNhdmVkU2VsZWN0ZWQpO1xuXHRcdH0pO1xuXG5cdHZhciBpbml0ID0gY3R4Lm9Jbml0LnNlbGVjdDtcblx0dmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLnNlbGVjdDtcblx0dmFyIG9wdHMgPSBpbml0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0cyA6IGluaXQ7XG5cblx0Ly8gU2V0IGRlZmF1bHRzXG5cdHZhciBpdGVtcyA9ICdyb3cnO1xuXHR2YXIgc3R5bGUgPSAnYXBpJztcblx0dmFyIGJsdXJhYmxlID0gZmFsc2U7XG5cdHZhciB0b2dnbGVhYmxlID0gdHJ1ZTtcblx0dmFyIHNlbGVjdGFibGUgPSBudWxsO1xuXHR2YXIgaW5mbyA9IHRydWU7XG5cdHZhciBzZWxlY3RvciA9ICd0ZCwgdGgnO1xuXHR2YXIgY2xhc3NOYW1lID0gJ3NlbGVjdGVkJztcblx0dmFyIGhlYWRlckNoZWNrYm94ID0gdHJ1ZTtcblx0dmFyIHNldFN0eWxlID0gZmFsc2U7XG5cdHZhciBrZXlzID0gZmFsc2U7XG5cblx0Y3R4Ll9zZWxlY3QgPSB7XG5cdFx0aW5mb0VsczogW11cblx0fTtcblxuXHQvLyBJbml0aWFsaXNhdGlvbiBjdXN0b21pc2F0aW9uc1xuXHRpZiAob3B0cyA9PT0gdHJ1ZSkge1xuXHRcdHN0eWxlID0gJ29zJztcblx0XHRzZXRTdHlsZSA9IHRydWU7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG5cdFx0c3R5bGUgPSBvcHRzO1xuXHRcdHNldFN0eWxlID0gdHJ1ZTtcblx0fVxuXHRlbHNlIGlmICgkLmlzUGxhaW5PYmplY3Qob3B0cykpIHtcblx0XHRpZiAob3B0cy5ibHVyYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRibHVyYWJsZSA9IG9wdHMuYmx1cmFibGU7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdHMudG9nZ2xlYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0b2dnbGVhYmxlID0gb3B0cy50b2dnbGVhYmxlO1xuXHRcdH1cblxuXHRcdGlmIChvcHRzLmluZm8gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aW5mbyA9IG9wdHMuaW5mbztcblx0XHR9XG5cblx0XHRpZiAob3B0cy5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpdGVtcyA9IG9wdHMuaXRlbXM7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdHMuc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c3R5bGUgPSBvcHRzLnN0eWxlO1xuXHRcdFx0c2V0U3R5bGUgPSB0cnVlO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHN0eWxlID0gJ29zJztcblx0XHRcdHNldFN0eWxlID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAob3B0cy5zZWxlY3RvciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzZWxlY3RvciA9IG9wdHMuc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdHMuY2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGNsYXNzTmFtZSA9IG9wdHMuY2xhc3NOYW1lO1xuXHRcdH1cblxuXHRcdGlmIChvcHRzLmhlYWRlckNoZWNrYm94ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGhlYWRlckNoZWNrYm94ID0gb3B0cy5oZWFkZXJDaGVja2JveDtcblx0XHR9XG5cblx0XHRpZiAob3B0cy5zZWxlY3RhYmxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHNlbGVjdGFibGUgPSBvcHRzLnNlbGVjdGFibGU7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdHMua2V5cyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRrZXlzID0gb3B0cy5rZXlzO1xuXHRcdH1cblx0fVxuXG5cdGR0LnNlbGVjdC5zZWxlY3RvcihzZWxlY3Rvcik7XG5cdGR0LnNlbGVjdC5pdGVtcyhpdGVtcyk7XG5cdGR0LnNlbGVjdC5zdHlsZShzdHlsZSk7XG5cdGR0LnNlbGVjdC5ibHVyYWJsZShibHVyYWJsZSk7XG5cdGR0LnNlbGVjdC50b2dnbGVhYmxlKHRvZ2dsZWFibGUpO1xuXHRkdC5zZWxlY3QuaW5mbyhpbmZvKTtcblx0ZHQuc2VsZWN0LmtleXMoa2V5cyk7XG5cdGR0LnNlbGVjdC5zZWxlY3RhYmxlKHNlbGVjdGFibGUpO1xuXHRjdHguX3NlbGVjdC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG5cblx0Ly8gSWYgdGhlIGluaXQgb3B0aW9ucyBoYXZlbid0IGVuYWJsZWQgc2VsZWN0LCBidXQgdGhlcmUgaXMgYSBzZWxlY3RhYmxlXG5cdC8vIGNsYXNzIG5hbWUsIHRoZW4gZW5hYmxlXG5cdGlmICghc2V0U3R5bGUgJiYgJChkdC50YWJsZSgpLm5vZGUoKSkuaGFzQ2xhc3MoJ3NlbGVjdGFibGUnKSkge1xuXHRcdGR0LnNlbGVjdC5zdHlsZSgnb3MnKTtcblx0fVxuXG5cdC8vIEluc2VydCBhIGNoZWNrYm94IGludG8gdGhlIGhlYWRlciBpZiBuZWVkZWQgLSBtaWdodCBuZWVkIHRvIHdhaXRcblx0Ly8gZm9yIGluaXQgY29tcGxldGVcblx0aWYgKGhlYWRlckNoZWNrYm94IHx8IGhlYWRlckNoZWNrYm94ID09PSAnc2VsZWN0LXBhZ2UnIHx8IGhlYWRlckNoZWNrYm94ID09PSAnc2VsZWN0LWFsbCcpIHtcblx0XHRkdC5yZWFkeShmdW5jdGlvbiAoKSB7XG5cdFx0XHRpbml0Q2hlY2tib3hIZWFkZXIoZHQsIGhlYWRlckNoZWNrYm94KTtcblx0XHR9KTtcblx0fVxufTtcblxuLypcblxuU2VsZWN0IGlzIGEgY29sbGVjdGlvbiBvZiBBUEkgbWV0aG9kcywgZXZlbnQgaGFuZGxlcnMsIGV2ZW50IGVtaXR0ZXJzIGFuZFxuYnV0dG9ucyAoZm9yIHRoZSBgQnV0dG9uc2AgZXh0ZW5zaW9uKSBmb3IgRGF0YVRhYmxlcy4gSXQgcHJvdmlkZXMgdGhlIGZvbGxvd2luZ1xuZmVhdHVyZXMsIHdpdGggYW4gb3ZlcnZpZXcgb2YgaG93IHRoZXkgYXJlIGltcGxlbWVudGVkOlxuXG4jIyBTZWxlY3Rpb24gb2Ygcm93cywgY29sdW1ucyBhbmQgY2VsbHMuIFdoZXRoZXIgYW4gaXRlbSBpcyBzZWxlY3RlZCBvciBub3QgaXNcbiAgIHN0b3JlZCBpbjpcblxuKiByb3dzOiBhIGBfc2VsZWN0X3NlbGVjdGVkYCBwcm9wZXJ0eSB3aGljaCBjb250YWlucyBhIGJvb2xlYW4gdmFsdWUgb2YgdGhlXG4gIERhdGFUYWJsZXMnIGBhb0RhdGFgIG9iamVjdCBmb3IgZWFjaCByb3dcbiogY29sdW1uczogYSBgX3NlbGVjdF9zZWxlY3RlZGAgcHJvcGVydHkgd2hpY2ggY29udGFpbnMgYSBib29sZWFuIHZhbHVlIG9mIHRoZVxuICBEYXRhVGFibGVzJyBgYW9Db2x1bW5zYCBvYmplY3QgZm9yIGVhY2ggY29sdW1uXG4qIGNlbGxzOiBhIGBfc2VsZWN0ZWRfY2VsbHNgIHByb3BlcnR5IHdoaWNoIGNvbnRhaW5zIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzXG4gIG9mIHRoZSBgYW9EYXRhYCBvYmplY3QgZm9yIGVhY2ggcm93LiBUaGUgYXJyYXkgaXMgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZVxuICBjb2x1bW5zIGFycmF5LCB3aXRoIGVhY2ggZWxlbWVudCBvZiBpdCByZXByZXNlbnRpbmcgYSBjZWxsLlxuXG5UaGlzIG1ldGhvZCBvZiB1c2luZyBib29sZWFuIGZsYWdzIGFsbG93cyBTZWxlY3QgdG8gb3BlcmF0ZSB3aGVuIG5vZGVzIGhhdmUgbm90XG5iZWVuIGNyZWF0ZWQgZm9yIHJvd3MgLyBjZWxscyAoRGF0YVRhYmxlcycgZGVmZXIgcmVuZGVyaW5nIGZlYXR1cmUpLlxuXG4jIyBBUEkgbWV0aG9kc1xuXG5BIHJhbmdlIG9mIEFQSSBtZXRob2RzIGFyZSBhdmFpbGFibGUgZm9yIHRyaWdnZXJpbmcgc2VsZWN0aW9uIGFuZCBkZS1zZWxlY3Rpb25cbm9mIHJvd3MuIE1ldGhvZHMgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGNvbmZpZ3VyZSB0aGUgc2VsZWN0aW9uIGV2ZW50cyB0aGF0IGNhblxuYmUgdHJpZ2dlcmVkIGJ5IGFuIGVuZCB1c2VyIChzdWNoIGFzIHdoaWNoIGl0ZW1zIGFyZSB0byBiZSBzZWxlY3RlZCkuIFRvIGEgbGFyZ2VcbmV4dGVudCwgdGhlc2Ugb2YgQVBJIG1ldGhvZHMgKmlzKiBTZWxlY3QuIEl0IGlzIGJhc2ljYWxseSBhIGNvbGxlY3Rpb24gb2YgaGVscGVyXG5mdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBzZWxlY3QgaXRlbXMgaW4gYSBEYXRhVGFibGUuXG5cbkNvbmZpZ3VyYXRpb24gb2Ygc2VsZWN0IGlzIGhlbGQgaW4gdGhlIG9iamVjdCBgX3NlbGVjdGAgd2hpY2ggaXMgYXR0YWNoZWQgdG8gdGhlXG5EYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBvbiBpbml0aWFsaXNhdGlvbi4gU2VsZWN0IGJlaW5nIGF2YWlsYWJsZSBvbiBhIHRhYmxlXG5pcyBub3Qgb3B0aW9uYWwgd2hlbiBTZWxlY3QgaXMgbG9hZGVkLCBidXQgaXRzIGRlZmF1bHQgaXMgZm9yIHNlbGVjdGlvbiBvbmx5IHRvXG5iZSBhdmFpbGFibGUgdmlhIHRoZSBBUEkgLSBzbyB0aGUgZW5kIHVzZXIgd291bGRuJ3QgYmUgYWJsZSB0byBzZWxlY3Qgcm93c1xud2l0aG91dCBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24uXG5cblRoZSBgX3NlbGVjdGAgb2JqZWN0IGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblxuYGBgXG57XG5cdGl0ZW1zOnN0cmluZyAgICAgICAtIENhbiBiZSBgcm93c2AsIGBjb2x1bW5zYCBvciBgY2VsbHNgLiBEZWZpbmVzIHdoYXQgaXRlbSBcblx0ICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBzZWxlY3RlZCBpZiB0aGUgdXNlciBpcyBhbGxvd2VkIHRvIGFjdGl2YXRlIHJvd1xuXHQgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gdXNpbmcgdGhlIG1vdXNlLlxuXHRzdHlsZTpzdHJpbmcgICAgICAgLSBDYW4gYmUgYG5vbmVgLCBgc2luZ2xlYCwgYG11bHRpYCBvciBgb3NgLiBEZWZpbmVzIHRoZVxuXHQgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbiBzdHlsZSB3aGVuIHNlbGVjdGluZyBpdGVtc1xuXHRibHVyYWJsZTpib29sZWFuICAgLSBJZiByb3cgc2VsZWN0aW9uIGNhbiBiZSBjbGVhcmVkIGJ5IGNsaWNraW5nIG91dHNpZGUgb2Zcblx0ICAgICAgICAgICAgICAgICAgICAgdGhlIHRhYmxlXG5cdHRvZ2dsZWFibGU6Ym9vbGVhbiAtIElmIHJvdyBzZWxlY3Rpb24gY2FuIGJlIGNhbmNlbGxlZCBieSByZXBlYXRlZCBjbGlja2luZ1xuXHQgICAgICAgICAgICAgICAgICAgICBvbiB0aGUgcm93XG5cdGluZm86Ym9vbGVhbiAgICAgICAtIElmIHRoZSBzZWxlY3Rpb24gc3VtbWFyeSBzaG91bGQgYmUgc2hvd24gaW4gdGhlIHRhYmxlXG5cdCAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uIGVsZW1lbnRzXG5cdGluZm9FbHM6ZWxlbWVudFtdICAtIExpc3Qgb2YgSFRNTCBlbGVtZW50cyB3aXRoIGluZm8gZWxlbWVudHMgZm9yIGEgdGFibGVcbn1cbmBgYFxuXG5JbiBhZGRpdGlvbiB0byB0aGUgQVBJIG1ldGhvZHMsIFNlbGVjdCBhbHNvIGV4dGVuZHMgdGhlIERhdGFUYWJsZXMgc2VsZWN0b3Jcbm9wdGlvbnMgZm9yIHJvd3MsIGNvbHVtbnMgYW5kIGNlbGxzIGFkZGluZyBhIGBzZWxlY3RlZGAgb3B0aW9uIHRvIHRoZSBzZWxlY3Rvclxub3B0aW9ucyBvYmplY3QsIGFsbG93aW5nIHRoZSBkZXZlbG9wZXIgdG8gc2VsZWN0IG9ubHkgc2VsZWN0ZWQgaXRlbXMgb3JcbnVuc2VsZWN0ZWQgaXRlbXMuXG5cbiMjIE1vdXNlIHNlbGVjdGlvbiBvZiBpdGVtc1xuXG5DbGlja2luZyBvbiBpdGVtcyBjYW4gYmUgdXNlZCB0byBzZWxlY3QgaXRlbXMuIFRoaXMgaXMgZG9uZSBieSBhIHNpbXBsZSBldmVudFxuaGFuZGxlciB0aGF0IHdpbGwgc2VsZWN0IHRoZSBpdGVtcyB1c2luZyB0aGUgQVBJIG1ldGhvZHMuXG5cbiAqL1xuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogTG9jYWwgZnVuY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBBZGQgb25lIG9yIG1vcmUgY2VsbHMgdG8gdGhlIHNlbGVjdGlvbiB3aGVuIHNoaWZ0IGNsaWNraW5nIGluIE9TIHNlbGVjdGlvblxuICogc3R5bGUgY2VsbCBzZWxlY3Rpb24uXG4gKlxuICogQ2VsbCByYW5nZSBpcyBtb3JlIGNvbXBsaWNhdGVkIHRoYW4gcm93IGFuZCBjb2x1bW4gYXMgd2Ugd2FudCB0byBzZWxlY3RcbiAqIGluIHRoZSB2aXNpYmxlIGdyaWQgcmF0aGVyIHRoYW4gYnkgaW5kZXggaW4gc2VxdWVuY2UuIEZvciBleGFtcGxlLCBpZiB5b3VcbiAqIGNsaWNrIGZpcnN0IGluIGNlbGwgMS0xIGFuZCB0aGVuIHNoaWZ0IGNsaWNrIGluIDItMiAtIGNlbGxzIDEtMiBhbmQgMi0xXG4gKiBzaG91bGQgYWxzbyBiZSBzZWxlY3RlZCAoYW5kIG5vdCAxLTMsIDEtNC4gZXRjKVxuICpcbiAqIEBwYXJhbSAge0RhdGFUYWJsZS5BcGl9IGR0ICAgRGF0YVRhYmxlXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICBpZHggIENlbGwgaW5kZXggdG8gc2VsZWN0IHRvXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICBsYXN0IENlbGwgaW5kZXggdG8gc2VsZWN0IGZyb21cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNlbGxSYW5nZShkdCwgaWR4LCBsYXN0KSB7XG5cdHZhciBpbmRleGVzO1xuXHR2YXIgY29sdW1uSW5kZXhlcztcblx0dmFyIHJvd0luZGV4ZXM7XG5cdHZhciBzZWxlY3RDb2x1bW5zID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcblx0XHRpZiAoc3RhcnQgPiBlbmQpIHtcblx0XHRcdHZhciB0bXAgPSBlbmQ7XG5cdFx0XHRlbmQgPSBzdGFydDtcblx0XHRcdHN0YXJ0ID0gdG1wO1xuXHRcdH1cblxuXHRcdHZhciByZWNvcmQgPSBmYWxzZTtcblx0XHRyZXR1cm4gZHRcblx0XHRcdC5jb2x1bW5zKCc6dmlzaWJsZScpXG5cdFx0XHQuaW5kZXhlcygpXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdGlmIChpID09PSBzdGFydCkge1xuXHRcdFx0XHRcdHJlY29yZCA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaSA9PT0gZW5kKSB7XG5cdFx0XHRcdFx0Ly8gbm90IGVsc2UgaWYsIGFzIHN0YXJ0IG1pZ2h0ID09PSBlbmRcblx0XHRcdFx0XHRyZWNvcmQgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZWNvcmQ7XG5cdFx0XHR9KTtcblx0fTtcblxuXHR2YXIgc2VsZWN0Um93cyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG5cdFx0dmFyIGluZGV4ZXMgPSBkdC5yb3dzKHsgc2VhcmNoOiAnYXBwbGllZCcgfSkuaW5kZXhlcygpO1xuXG5cdFx0Ly8gV2hpY2ggY29tZXMgZmlyc3QgLSBtaWdodCBuZWVkIHRvIHN3YXBcblx0XHRpZiAoaW5kZXhlcy5pbmRleE9mKHN0YXJ0KSA+IGluZGV4ZXMuaW5kZXhPZihlbmQpKSB7XG5cdFx0XHR2YXIgdG1wID0gZW5kO1xuXHRcdFx0ZW5kID0gc3RhcnQ7XG5cdFx0XHRzdGFydCA9IHRtcDtcblx0XHR9XG5cblx0XHR2YXIgcmVjb3JkID0gZmFsc2U7XG5cdFx0cmV0dXJuIGluZGV4ZXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRpZiAoaSA9PT0gc3RhcnQpIHtcblx0XHRcdFx0cmVjb3JkID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGkgPT09IGVuZCkge1xuXHRcdFx0XHRyZWNvcmQgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZWNvcmQ7XG5cdFx0fSk7XG5cdH07XG5cblx0aWYgKCFkdC5jZWxscyh7IHNlbGVjdGVkOiB0cnVlIH0pLmFueSgpICYmICFsYXN0KSB7XG5cdFx0Ly8gc2VsZWN0IGZyb20gdGhlIHRvcCBsZWZ0IGNlbGwgdG8gdGhpcyBvbmVcblx0XHRjb2x1bW5JbmRleGVzID0gc2VsZWN0Q29sdW1ucygwLCBpZHguY29sdW1uKTtcblx0XHRyb3dJbmRleGVzID0gc2VsZWN0Um93cygwLCBpZHgucm93KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHZXQgY29sdW1uIGluZGV4ZXMgYmV0d2VlbiBvbGQgYW5kIG5ld1xuXHRcdGNvbHVtbkluZGV4ZXMgPSBzZWxlY3RDb2x1bW5zKGxhc3QuY29sdW1uLCBpZHguY29sdW1uKTtcblx0XHRyb3dJbmRleGVzID0gc2VsZWN0Um93cyhsYXN0LnJvdywgaWR4LnJvdyk7XG5cdH1cblxuXHRpbmRleGVzID0gZHQuY2VsbHMocm93SW5kZXhlcywgY29sdW1uSW5kZXhlcykuZmxhdHRlbigpO1xuXG5cdGlmICghZHQuY2VsbHMoaWR4LCB7IHNlbGVjdGVkOiB0cnVlIH0pLmFueSgpKSB7XG5cdFx0Ly8gU2VsZWN0IHJhbmdlXG5cdFx0ZHQuY2VsbHMoaW5kZXhlcykuc2VsZWN0KCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gRGVzZWxlY3QgcmFuZ2Vcblx0XHRkdC5jZWxscyhpbmRleGVzKS5kZXNlbGVjdCgpO1xuXHR9XG59XG5cbi8qKlxuICogR2V0IHRoZSBjbGFzc1xuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIGNoZWNrYm94Q2xhc3Moc2VsZWN0b3IpIHtcblx0dmFyIG5hbWUgPSBEYXRhVGFibGUuc2VsZWN0LmNsYXNzZXMuY2hlY2tib3g7XG5cblx0cmV0dXJuIHNlbGVjdG9yXG5cdFx0PyBuYW1lLnJlcGxhY2UoLyAvZywgJy4nKVxuXHRcdDogbmFtZTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlIG1vdXNlIHNlbGVjdGlvbiBieSByZW1vdmluZyB0aGUgc2VsZWN0b3JzXG4gKlxuICogQHBhcmFtIHtEYXRhVGFibGUuQXBpfSBkdCBEYXRhVGFibGUgdG8gcmVtb3ZlIGV2ZW50cyBmcm9tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkaXNhYmxlTW91c2VTZWxlY3Rpb24oZHQpIHtcblx0dmFyIGN0eCA9IGR0LnNldHRpbmdzKClbMF07XG5cdHZhciBzZWxlY3RvciA9IGN0eC5fc2VsZWN0LnNlbGVjdG9yO1xuXG5cdCQoZHQudGFibGUoKS5jb250YWluZXIoKSlcblx0XHQub2ZmKCdtb3VzZWRvd24uZHRTZWxlY3QnLCBzZWxlY3Rvcilcblx0XHQub2ZmKCdtb3VzZXVwLmR0U2VsZWN0Jywgc2VsZWN0b3IpXG5cdFx0Lm9mZignY2xpY2suZHRTZWxlY3QnLCBzZWxlY3Rvcik7XG5cblx0JCgnYm9keScpLm9mZignY2xpY2suZHRTZWxlY3QnICsgX3NhZmVJZChkdC50YWJsZSgpLm5vZGUoKSkpO1xufVxuXG4vKipcbiAqIEF0dGFjaCBtb3VzZSBsaXN0ZW5lcnMgdG8gdGhlIHRhYmxlIHRvIGFsbG93IG1vdXNlIHNlbGVjdGlvbiBvZiBpdGVtc1xuICpcbiAqIEBwYXJhbSB7RGF0YVRhYmxlLkFwaX0gZHQgRGF0YVRhYmxlIHRvIHJlbW92ZSBldmVudHMgZnJvbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5hYmxlTW91c2VTZWxlY3Rpb24oZHQpIHtcblx0dmFyIGNvbnRhaW5lciA9ICQoZHQudGFibGUoKS5jb250YWluZXIoKSk7XG5cdHZhciBjdHggPSBkdC5zZXR0aW5ncygpWzBdO1xuXHR2YXIgc2VsZWN0b3IgPSBjdHguX3NlbGVjdC5zZWxlY3Rvcjtcblx0dmFyIG1hdGNoU2VsZWN0aW9uO1xuXG5cdGNvbnRhaW5lclxuXHRcdC5vbignbW91c2Vkb3duLmR0U2VsZWN0Jywgc2VsZWN0b3IsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHQvLyBEaXNhbGxvdyB0ZXh0IHNlbGVjdGlvbiBmb3Igc2hpZnQgY2xpY2tpbmcgb24gdGhlIHRhYmxlIHNvIG11bHRpXG5cdFx0XHQvLyBlbGVtZW50IHNlbGVjdGlvbiBkb2Vzbid0IGxvb2sgdGVycmlibGUhXG5cdFx0XHRpZiAoZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5KSB7XG5cdFx0XHRcdGNvbnRhaW5lclxuXHRcdFx0XHRcdC5jc3MoJy1tb3otdXNlci1zZWxlY3QnLCAnbm9uZScpXG5cdFx0XHRcdFx0Lm9uZSgnc2VsZWN0c3RhcnQuZHRTZWxlY3QnLCBzZWxlY3RvciwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuXHRcdFx0XHRtYXRjaFNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdH1cblx0XHR9KVxuXHRcdC5vbignbW91c2V1cC5kdFNlbGVjdCcsIHNlbGVjdG9yLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHQvLyBBbGxvdyB0ZXh0IHNlbGVjdGlvbiB0byBvY2N1ciBhZ2FpbiwgTW96aWxsYSBzdHlsZSAodGVzdGVkIGluIEZGXG5cdFx0XHQvLyAzNS4wLjEgLSBzdGlsbCByZXF1aXJlZClcblx0XHRcdGNvbnRhaW5lci5jc3MoJy1tb3otdXNlci1zZWxlY3QnLCAnJyk7XG5cdFx0fSlcblx0XHQub24oJ2NsaWNrLmR0U2VsZWN0Jywgc2VsZWN0b3IsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSBkdC5zZWxlY3QuaXRlbXMoKTtcblx0XHRcdHZhciBpZHg7XG5cblx0XHRcdC8vIElmIHRleHQgd2FzIHNlbGVjdGVkIChjbGljayBhbmQgZHJhZyksIHRoZW4gd2Ugc2hvdWxkbid0IGNoYW5nZVxuXHRcdFx0Ly8gdGhlIHJvdydzIHNlbGVjdGVkIHN0YXRlXG5cdFx0XHRpZiAobWF0Y2hTZWxlY3Rpb24pIHtcblx0XHRcdFx0dmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBzZWxlY3Rpb24gaXMgbm90IGluIHRoZSB0YWJsZSwgd2UgY2FuIGlnbm9yZSBpdFxuXHRcdFx0XHQvLyBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGRldmVsb3BlciBzZWxlY3RzIHRleHQgZnJvbSB0aGUgY2xpY2sgZXZlbnRcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCFzZWxlY3Rpb24uYW5jaG9yTm9kZSB8fFxuXHRcdFx0XHRcdCQoc2VsZWN0aW9uLmFuY2hvck5vZGUpLmNsb3Nlc3QoJ3RhYmxlJylbMF0gPT09IGR0LnRhYmxlKCkubm9kZSgpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGlmIChzZWxlY3Rpb24gIT09IG1hdGNoU2VsZWN0aW9uKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjdHggPSBkdC5zZXR0aW5ncygpWzBdO1xuXHRcdFx0dmFyIGNvbnRhaW5lciA9IGR0LnRhYmxlKCkuY29udGFpbmVyKCk7XG5cblx0XHRcdC8vIElnbm9yZSBjbGlja3MgaW5zaWRlIGEgc3ViLXRhYmxlXG5cdFx0XHRpZiAoJChlLnRhcmdldCkuY2xvc2VzdCgnZGl2LmR0LWNvbnRhaW5lcicpWzBdICE9IGNvbnRhaW5lcikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjZWxsID0gZHQuY2VsbCgkKGUudGFyZ2V0KS5jbG9zZXN0KCd0ZCwgdGgnKSk7XG5cblx0XHRcdC8vIENoZWNrIHRoZSBjZWxsIGFjdHVhbGx5IGJlbG9uZ3MgdG8gdGhlIGhvc3QgRGF0YVRhYmxlIChzbyBjaGlsZFxuXHRcdFx0Ly8gcm93cywgZXRjLCBhcmUgaWdub3JlZClcblx0XHRcdGlmICghY2VsbC5hbnkoKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBldmVudCA9ICQuRXZlbnQoJ3VzZXItc2VsZWN0LmR0Jyk7XG5cdFx0XHRldmVudFRyaWdnZXIoZHQsIGV2ZW50LCBbaXRlbXMsIGNlbGwsIGVdKTtcblxuXHRcdFx0aWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNlbGxJbmRleCA9IGNlbGwuaW5kZXgoKTtcblx0XHRcdGlmIChpdGVtcyA9PT0gJ3JvdycpIHtcblx0XHRcdFx0aWR4ID0gY2VsbEluZGV4LnJvdztcblx0XHRcdFx0dHlwZVNlbGVjdChlLCBkdCwgY3R4LCAncm93JywgaWR4KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGl0ZW1zID09PSAnY29sdW1uJykge1xuXHRcdFx0XHRpZHggPSBjZWxsLmluZGV4KCkuY29sdW1uO1xuXHRcdFx0XHR0eXBlU2VsZWN0KGUsIGR0LCBjdHgsICdjb2x1bW4nLCBpZHgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoaXRlbXMgPT09ICdjZWxsJykge1xuXHRcdFx0XHRpZHggPSBjZWxsLmluZGV4KCk7XG5cdFx0XHRcdHR5cGVTZWxlY3QoZSwgZHQsIGN0eCwgJ2NlbGwnLCBpZHgpO1xuXHRcdFx0fVxuXG5cdFx0XHRjdHguX3NlbGVjdF9sYXN0Q2VsbCA9IGNlbGxJbmRleDtcblx0XHR9KTtcblxuXHQvLyBCbHVyYWJsZVxuXHQkKCdib2R5Jykub24oJ2NsaWNrLmR0U2VsZWN0JyArIF9zYWZlSWQoZHQudGFibGUoKS5ub2RlKCkpLCBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChjdHguX3NlbGVjdC5ibHVyYWJsZSkge1xuXHRcdFx0Ly8gSWYgdGhlIGNsaWNrIHdhcyBpbnNpZGUgdGhlIERhdGFUYWJsZXMgY29udGFpbmVyLCBkb24ndCBibHVyXG5cdFx0XHRpZiAoJChlLnRhcmdldCkucGFyZW50cygpLmZpbHRlcihkdC50YWJsZSgpLmNvbnRhaW5lcigpKS5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZ25vcmUgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgRE9NIChpLmUuIHBhZ2luZ1xuXHRcdFx0Ly8gYnV0dG9ucylcblx0XHRcdGlmICgkKGUudGFyZ2V0KS5wYXJlbnRzKCdodG1sJykubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRG9uJ3QgYmx1ciBpbiBFZGl0b3IgZm9ybVxuXHRcdFx0aWYgKCQoZS50YXJnZXQpLnBhcmVudHMoJ2Rpdi5EVEUnKS5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KCdzZWxlY3QtYmx1ci5kdCcpO1xuXHRcdFx0ZXZlbnRUcmlnZ2VyKGR0LCBldmVudCwgW2UudGFyZ2V0LCBlXSk7XG5cblx0XHRcdGlmIChldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNsZWFyKGN0eCwgdHJ1ZSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGFuIGV2ZW50IG9uIGEgRGF0YVRhYmxlXG4gKlxuICogQHBhcmFtIHtEYXRhVGFibGUuQXBpfSBhcGkgICAgICBEYXRhVGFibGUgdG8gdHJpZ2dlciBldmVudHMgb25cbiAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgc2VsZWN0ZWQgdHJ1ZSBpZiBzZWxlY3RlZCwgZmFsc2UgaWYgZGVzZWxlY3RlZFxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICB0eXBlICAgICBJdGVtIHR5cGUgYWN0aW5nIG9uXG4gKiBAcGFyYW0gIHtib29sZWFufSAgICAgIGFueSAgICAgIFJlcXVpcmUgdGhhdCB0aGVyZSBhcmUgdmFsdWVzIGJlZm9yZVxuICogICAgIHRyaWdnZXJpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV2ZW50VHJpZ2dlcihhcGksIHR5cGUsIGFyZ3MsIGFueSkge1xuXHRpZiAoYW55ICYmICFhcGkuZmxhdHRlbigpLmxlbmd0aCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHR0eXBlID0gdHlwZSArICcuZHQnO1xuXHR9XG5cblx0YXJncy51bnNoaWZ0KGFwaSk7XG5cblx0JChhcGkudGFibGUoKS5ub2RlKCkpLnRyaWdnZXIodHlwZSwgYXJncyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgY29sdW1uIGlzIGEgY2hlY2tib3ggY29sdW1uXG4gKiBAcGFyYW0geyp9IGNvbCBEYXRhVGFibGVzIGNvbHVtbiBvYmplY3RcbiAqIEByZXR1cm5zIFxuICovXG5mdW5jdGlvbiBpc0NoZWNrYm94Q29sdW1uKGNvbCkge1xuXHRyZXR1cm4gY29sLm1SZW5kZXIgJiYgY29sLm1SZW5kZXIuX25hbWUgPT09ICdzZWxlY3RDaGVja2JveCc7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IG9mIHRoZSBEYXRhVGFibGUgc2hvd2luZyBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbiAqIGl0ZW1zIHNlbGVjdGVkLiBUaGlzIGlzIGRvbmUgYnkgYWRkaW5nIHRhZ3MgdG8gdGhlIGV4aXN0aW5nIHRleHRcbiAqXG4gKiBAcGFyYW0ge0RhdGFUYWJsZS5BcGl9IGFwaSBEYXRhVGFibGUgdG8gdXBkYXRlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZvKGFwaSwgbm9kZSkge1xuXHRpZiAoYXBpLnNlbGVjdC5zdHlsZSgpID09PSAnYXBpJyB8fCBhcGkuc2VsZWN0LmluZm8oKSA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgY3R4ID0gYXBpLnNldHRpbmdzKClbMF07XG5cdHZhciByb3dTZXRMZW5ndGggPSBjdHguX3NlbGVjdF9zZXQubGVuZ3RoO1xuXHR2YXIgcm93cyA9IHJvd1NldExlbmd0aCA/IHJvd1NldExlbmd0aCA6IGFwaS5yb3dzKHsgc2VsZWN0ZWQ6IHRydWUgfSkuY291bnQoKTtcblx0dmFyIGNvbHVtbnMgPSBhcGkuY29sdW1ucyh7IHNlbGVjdGVkOiB0cnVlIH0pLmNvdW50KCk7XG5cdHZhciBjZWxscyA9IGFwaS5jZWxscyh7IHNlbGVjdGVkOiB0cnVlIH0pLmNvdW50KCk7XG5cblx0Ly8gSWYgc3VidHJhY3RpdmUgc2VsZWN0aW9uLCB0aGVuIHdlIG5lZWQgdG8gdGFrZSB0aGUgbnVtYmVyIG9mIHJvd3MgYW5kXG5cdC8vIHN1YnRyYWN0IHRob3NlIHRoYXQgaGF2ZSBiZWVuIGRlc2VsZWN0ZWRcblx0aWYgKGN0eC5fc2VsZWN0X21vZGUgPT09ICdzdWJ0cmFjdGl2ZScpIHtcblx0XHRyb3dzID0gYXBpLnBhZ2UuaW5mbygpLnJlY29yZHNEaXNwbGF5IC0gcm93U2V0TGVuZ3RoO1xuXHR9XG5cblx0dmFyIGFkZCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgbnVtKSB7XG5cdFx0ZWwuYXBwZW5kKFxuXHRcdFx0JCgnPHNwYW4gY2xhc3M9XCJzZWxlY3QtaXRlbVwiLz4nKS5hcHBlbmQoXG5cdFx0XHRcdGFwaS5pMThuKFxuXHRcdFx0XHRcdCdzZWxlY3QuJyArIG5hbWUgKyAncycsXG5cdFx0XHRcdFx0eyBfOiAnJWQgJyArIG5hbWUgKyAncyBzZWxlY3RlZCcsIDA6ICcnLCAxOiAnMSAnICsgbmFtZSArICcgc2VsZWN0ZWQnIH0sXG5cdFx0XHRcdFx0bnVtXG5cdFx0XHRcdClcblx0XHRcdClcblx0XHQpO1xuXHR9O1xuXG5cdHZhciBlbCA9ICQobm9kZSk7XG5cdHZhciBvdXRwdXQgPSAkKCc8c3BhbiBjbGFzcz1cInNlbGVjdC1pbmZvXCIvPicpO1xuXG5cdGFkZChvdXRwdXQsICdyb3cnLCByb3dzKTtcblx0YWRkKG91dHB1dCwgJ2NvbHVtbicsIGNvbHVtbnMpO1xuXHRhZGQob3V0cHV0LCAnY2VsbCcsIGNlbGxzKTtcblxuXHR2YXIgZXhpc3RpbmcgPSBlbC5jaGlsZHJlbignc3Bhbi5zZWxlY3QtaW5mbycpO1xuXG5cdGlmIChleGlzdGluZy5sZW5ndGgpIHtcblx0XHRleGlzdGluZy5yZW1vdmUoKTtcblx0fVxuXG5cdGlmIChvdXRwdXQudGV4dCgpICE9PSAnJykge1xuXHRcdGVsLmFwcGVuZChvdXRwdXQpO1xuXHR9XG59XG5cbi8qKlxuICogQWRkIGEgY2hlY2tib3ggdG8gdGhlIGhlYWRlciBmb3IgY2hlY2tib3ggY29sdW1ucywgYWxsb3dpbmcgYWxsIHJvd3MgdG9cbiAqIGJlIHNlbGVjdGVkLCBkZXNlbGVjdGVkIG9yIGp1c3QgdG8gc2hvdyB0aGUgc3RhdGUuXG4gKlxuICogQHBhcmFtIHsqfSBkdCBBUElcbiAqIEBwYXJhbSB7Kn0gaGVhZGVyQ2hlY2tib3ggdGhlIGhlYWRlciBjaGVja2JveCBvcHRpb25cbiAqL1xuZnVuY3Rpb24gaW5pdENoZWNrYm94SGVhZGVyKCBkdCwgaGVhZGVyQ2hlY2tib3ggKSB7XG5cdHZhciBkdFNldHRpbmdzID0gZHQuc2V0dGluZ3MoKVswXTtcblx0dmFyIGR0SW50ZXJuYWxDb2x1bW5zID0gZHRTZXR0aW5ncy5hb0NvbHVtbnM7XG5cblx0Ly8gRmluZCBhbnkgY2hlY2tib3ggY29sdW1uKHMpXG5cdGR0LmNvbHVtbnMoKS5pdGVyYXRvcignY29sdW1uJywgZnVuY3Rpb24gKHMsIGlkeCkge1xuXHRcdHZhciBjb2wgPSBkdEludGVybmFsQ29sdW1uc1tpZHhdO1xuXG5cdFx0Ly8gQ2hlY2tib3ggY29sdW1ucyBoYXZlIGEgcmVuZGVyaW5nIGZ1bmN0aW9uIHdpdGggYSBnaXZlbiBuYW1lXG5cdFx0aWYgKCEgaXNDaGVja2JveENvbHVtbihjb2wpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBoZWFkZXIgPSBkdC5jb2x1bW4oaWR4KS5oZWFkZXIoKTtcblxuXHRcdGlmICghICQoJ2lucHV0JywgaGVhZGVyKS5sZW5ndGgpIHtcblx0XHRcdC8vIElmIG5vIGNoZWNrYm94IHlldCwgaW5zZXJ0IG9uZVxuXHRcdFx0dmFyIGlucHV0ID0gJCgnPGlucHV0PicpXG5cdFx0XHRcdC5hdHRyKHtcblx0XHRcdFx0XHRjbGFzczogY2hlY2tib3hDbGFzcyh0cnVlKSxcblx0XHRcdFx0XHR0eXBlOiAnY2hlY2tib3gnLFxuXHRcdFx0XHRcdCdhcmlhLWxhYmVsJzogZHQuaTE4bignc2VsZWN0LmFyaWEuaGVhZGVyQ2hlY2tib3gnKSB8fCAnU2VsZWN0IGFsbCByb3dzJ1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYXBwZW5kVG8oaGVhZGVyKVxuXHRcdFx0XHQub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5jaGVja2VkKSB7XG5cdFx0XHRcdFx0XHRpZiAoaGVhZGVyQ2hlY2tib3ggPT0gJ3NlbGVjdC1wYWdlJykge1xuXHRcdFx0XHRcdFx0XHRkdC5yb3dzKHtwYWdlOiAnY3VycmVudCd9KS5zZWxlY3QoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkdC5yb3dzKHtzZWFyY2g6ICdhcHBsaWVkJ30pLnNlbGVjdCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChoZWFkZXJDaGVja2JveCA9PSAnc2VsZWN0LXBhZ2UnKSB7XG5cdFx0XHRcdFx0XHRcdGR0LnJvd3Moe3BhZ2U6ICdjdXJyZW50Jywgc2VsZWN0ZWQ6IHRydWV9KS5kZXNlbGVjdCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGR0LnJvd3Moe3NlbGVjdGVkOiB0cnVlfSkuZGVzZWxlY3QoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBVcGRhdGUgdGhlIGhlYWRlciBjaGVja2JveCdzIHN0YXRlIHdoZW4gdGhlIHNlbGVjdGlvbiBpbiB0aGVcblx0XHRcdC8vIHRhYmxlIGNoYW5nZXNcblx0XHRcdGR0Lm9uKCdkcmF3IHNlbGVjdCBkZXNlbGVjdCcsIGZ1bmN0aW9uIChlLCBwYXNzLCB0eXBlKSB7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncm93JyB8fCAhIHR5cGUpIHtcblx0XHRcdFx0XHR2YXIgbnVtcyA9IGhlYWRlckNoZWNrYm94U3RhdGUoZHQsIGhlYWRlckNoZWNrYm94KTtcblxuXHRcdFx0XHRcdGlmIChudW1zLnNlYXJjaCAmJiBudW1zLnNlYXJjaCA8PSBudW1zLmNvdW50ICYmIG51bXMuc2VhcmNoID09PSBudW1zLmF2YWlsYWJsZSkge1xuXHRcdFx0XHRcdFx0aW5wdXRcblx0XHRcdFx0XHRcdFx0LnByb3AoJ2NoZWNrZWQnLCB0cnVlKVxuXHRcdFx0XHRcdFx0XHQucHJvcCgnaW5kZXRlcm1pbmF0ZScsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAobnVtcy5zZWFyY2ggPT09IDAgJiYgbnVtcy5jb3VudCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0aW5wdXRcblx0XHRcdFx0XHRcdFx0LnByb3AoJ2NoZWNrZWQnLCBmYWxzZSlcblx0XHRcdFx0XHRcdFx0LnByb3AoJ2luZGV0ZXJtaW5hdGUnLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0aW5wdXRcblx0XHRcdFx0XHRcdFx0LnByb3AoJ2NoZWNrZWQnLCBmYWxzZSlcblx0XHRcdFx0XHRcdFx0LnByb3AoJ2luZGV0ZXJtaW5hdGUnLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIGtleXNTZXQoZHQpIHtcblx0dmFyIGN0eCA9IGR0LnNldHRpbmdzKClbMF07XG5cdHZhciBmbGFnID0gY3R4Ll9zZWxlY3Qua2V5cztcblx0dmFyIG5hbWVzcGFjZSA9ICdkdHMta2V5cy0nICsgY3R4LnNUYWJsZUlkO1xuXG5cdGlmIChmbGFnKSB7XG5cdFx0Ly8gTmVlZCBhIHRhYmluZGV4IG9mIHRoZSBgdHJgIGVsZW1lbnRzIHRvIG1ha2UgdGhlbSBmb2N1c2FibGUgYnkgdGhlIGJyb3dzZXJcblx0XHQkKGR0LnJvd3Moe3BhZ2U6ICdjdXJyZW50J30pLm5vZGVzKCkpLmF0dHIoJ3RhYmluZGV4JywgMCk7XG5cblx0XHRkdC5vbignZHJhdy4nICsgbmFtZXNwYWNlLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHQkKGR0LnJvd3Moe3BhZ2U6ICdjdXJyZW50J30pLm5vZGVzKCkpLmF0dHIoJ3RhYmluZGV4JywgMCk7XG5cdFx0fSk7XG5cblx0XHQvLyBMaXN0ZW4gb24gZG9jdW1lbnQgZm9yIHRhYiwgdXAgYW5kIGRvd25cblx0XHQkKGRvY3VtZW50KS5vbigna2V5ZG93bi4nICsgbmFtZXNwYWNlLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIGtleSA9IGUua2V5Q29kZTtcblx0XHRcdHZhciBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG5cdFx0XHQvLyBDYW4ndCB1c2UgZS5rZXkgYXMgaXQgd2Fzbid0IHdpZGVseSBzdXBwb3J0ZWQgdW50aWwgMjAxN1xuXHRcdFx0Ly8gOSBUYWJcblx0XHRcdC8vIDEzIFJldHVyblxuXHRcdFx0Ly8gMzIgU3BhY2Vcblx0XHRcdC8vIDM4IEFycm93VXBcblx0XHRcdC8vIDQwIEFycm93RG93blxuXHRcdFx0aWYgKCEgWzksIDEzLCAzMiwgMzgsIDQwXS5pbmNsdWRlcyhrZXkpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG5vZGVzID0gZHQucm93cyh7cGFnZTogJ2N1cnJlbnQnfSkubm9kZXMoKS50b0FycmF5KCk7XG5cdFx0XHR2YXIgaWR4ID0gbm9kZXMuaW5kZXhPZihhY3RpdmUpO1xuXHRcdFx0dmFyIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuXHRcdFx0Ly8gT25seSB0YWtlIGFuIGFjdGlvbiBpZiBhIHJvdyBoYXMgZm9jdXNcblx0XHRcdGlmIChpZHggPT09IC0xKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGtleSA9PT0gOSkge1xuXHRcdFx0XHQvLyBUYWIgZm9jdXMgY2hhbmdlXG5cdFx0XHRcdGlmIChlLnNoaWZ0ID09PSBmYWxzZSAmJiBpZHggPT09IG5vZGVzLmxlbmd0aCAtIDEpIHtcblx0XHRcdFx0XHRrZXlzUGFnZURvd24oZHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKGUuc2hpZnQgPT09IHRydWUgJiYgaWR4ID09PSAwKSB7XG5cdFx0XHRcdFx0a2V5c1BhZ2VVcChkdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQnJvd3NlciB3aWxsIGRvIGl0IGZvciB1c1xuXHRcdFx0XHRcdHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGtleSA9PT0gMTMgfHwga2V5ID09PSAzMikge1xuXHRcdFx0XHQvLyBSb3cgc2VsZWN0aW9uIC8gZGVzZWxlY3Rpb25cblx0XHRcdFx0dmFyIHJvdyA9IGR0LnJvdyhhY3RpdmUpO1xuXG5cdFx0XHRcdGlmIChyb3cuc2VsZWN0ZWQoKSkge1xuXHRcdFx0XHRcdHJvdy5kZXNlbGVjdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJvdy5zZWxlY3QoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoa2V5ID09PSAzOCkge1xuXHRcdFx0XHQvLyBNb3ZlIHVwXG5cdFx0XHRcdGlmIChpZHggPiAwKSB7XG5cdFx0XHRcdFx0bm9kZXNbaWR4LTFdLmZvY3VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0a2V5c1BhZ2VVcChkdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBNb3ZlIGRvd25cblx0XHRcdFx0aWYgKGlkeCA8IG5vZGVzLmxlbmd0aCAtMSkge1xuXHRcdFx0XHRcdG5vZGVzW2lkeCsxXS5mb2N1cygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGtleXNQYWdlRG93bihkdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZXZlbnREZWZhdWx0KSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBTdG9wIHRoZSByb3dzIGZyb20gYmVpbmcgYWJsZSB0byBnYWluIGZvY3VzXG5cdFx0JChkdC5yb3dzKCkubm9kZXMoKSkucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcblxuXHRcdC8vIE51a2UgZXZlbnRzXG5cdFx0ZHQub2ZmKCdkcmF3LicgKyBuYW1lc3BhY2UpO1xuXHRcdCQoZG9jdW1lbnQpLm9mZigna2V5ZG93bi4nICsgbmFtZXNwYWNlKTtcblx0fVxufVxuXG4vKipcbiAqIENoYW5nZSB0byB0aGUgbmV4dCBwYWdlIGFuZCBmb2N1cyBvbiB0aGUgZmlyc3Qgcm93XG4gKlxuICogQHBhcmFtIHtEYXRhVGFibGUuQXBpfSBkdCBEYXRhVGFibGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24ga2V5c1BhZ2VEb3duKGR0KSB7XG5cdC8vIElzIHRoZXJlIGFub3RoZXIgcGFnZSB0byB0dXJuIHRvP1xuXHR2YXIgaW5mbyA9IGR0LnBhZ2UuaW5mbygpO1xuXG5cdGlmIChpbmZvLnBhZ2UgPCBpbmZvLnBhZ2VzIC0gMSkge1xuXHRcdGR0XG5cdFx0XHQub25lKCdkcmF3JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRkdC5yb3coJzpmaXJzdC1jaGlsZCcpLm5vZGUoKS5mb2N1cygpO1xuXHRcdFx0fSlcblx0XHRcdC5wYWdlKCduZXh0Jylcblx0XHRcdC5kcmF3KGZhbHNlKTtcblx0fVxufVxuXG4vKipcbiAqIENoYW5nZSB0byB0aGUgcHJldmlvdXMgcGFnZSBhbmQgZm9jdXMgb24gdGhlIGxhc3Qgcm93XG4gKlxuICogQHBhcmFtIHtEYXRhVGFibGUuQXBpfSBkdCBEYXRhVGFibGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24ga2V5c1BhZ2VVcChkdCkge1xuXHQvLyBJcyB0aGVyZSBhbm90aGVyIHBhZ2UgdG8gdHVybiB0bz9cblx0dmFyIGluZm8gPSBkdC5wYWdlLmluZm8oKTtcblxuXHRpZiAoaW5mby5wYWdlID4gMCkge1xuXHRcdGR0XG5cdFx0XHQub25lKCdkcmF3JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRkdC5yb3coJzpsYXN0LWNoaWxkJykubm9kZSgpLmZvY3VzKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnBhZ2UoJ3ByZXZpb3VzJylcblx0XHRcdC5kcmF3KGZhbHNlKTtcblx0fVxufVxuXG4vKipcbiAqIERldGVybWluZSB0aGUgY291bnRzIHVzZWQgdG8gZGVmaW5lIHRoZSBoZWFkZXIgY2hlY2tib3gncyBzdGF0ZVxuICpcbiAqIEBwYXJhbSB7Kn0gZHQgRFQgQVBJXG4gKiBAcGFyYW0geyp9IGhlYWRlckNoZWNrYm94IENvbmZpZ3VyYXRpb24gZm9yIHdoYXQgdGhlIGhlYWRlciBjaGVja2JveCBkb2VzXG4gKiBAcmV0dXJucyBDb3VudHMgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGhlYWRlckNoZWNrYm94U3RhdGUoZHQsIGhlYWRlckNoZWNrYm94KSB7XG5cdHZhciBjdHggPSBkdC5zZXR0aW5ncygpWzBdO1xuXHR2YXIgc2VsZWN0YWJsZSA9IGN0eC5fc2VsZWN0LnNlbGVjdGFibGU7XG5cdHZhciBhdmFpbGFibGUgPSAwO1xuXHR2YXIgY291bnQgPSBoZWFkZXJDaGVja2JveCA9PSAnc2VsZWN0LXBhZ2UnXG5cdFx0PyBkdC5yb3dzKHtwYWdlOiAnY3VycmVudCcsIHNlbGVjdGVkOiB0cnVlfSkuY291bnQoKVxuXHRcdDogZHQucm93cyh7c2VsZWN0ZWQ6IHRydWV9KS5jb3VudCgpO1xuXHR2YXIgc2VhcmNoID0gaGVhZGVyQ2hlY2tib3ggPT0gJ3NlbGVjdC1wYWdlJ1xuXHRcdD8gZHQucm93cyh7cGFnZTogJ2N1cnJlbnQnLCBzZWxlY3RlZDogdHJ1ZX0pLmNvdW50KClcblx0XHQ6IGR0LnJvd3Moe3NlYXJjaDogJ2FwcGxpZWQnLCBzZWxlY3RlZDogdHJ1ZX0pLmNvdW50KCk7XG5cblx0aWYgKCEgc2VsZWN0YWJsZSkge1xuXHRcdGF2YWlsYWJsZSA9IGhlYWRlckNoZWNrYm94ID09ICdzZWxlY3QtcGFnZSdcblx0XHRcdD8gZHQucm93cyh7cGFnZTogJ2N1cnJlbnQnfSkuY291bnQoKVxuXHRcdFx0OiBkdC5yb3dzKHtzZWFyY2g6ICdhcHBsaWVkJ30pLmNvdW50KCk7XHRcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBOZWVkIHRvIGNvdW50IGhvdyBtYW55IHJvd3MgYXJlIGFjdHVhbGx5IHNlbGVjdGFibGUgdG8ga25vdyBpZiBhbGwgc2VsZWN0YWJsZVxuXHRcdC8vIHJvd3MgYXJlIHNlbGVjdGVkIG9yIG5vdFxuXHRcdHZhciBpbmRleGVzID0gaGVhZGVyQ2hlY2tib3ggPT0gJ3NlbGVjdC1wYWdlJ1xuXHRcdFx0PyBkdC5yb3dzKHtwYWdlOiAnY3VycmVudCd9KS5pbmRleGVzKClcblx0XHRcdDogZHQucm93cyh7c2VhcmNoOiAnYXBwbGllZCd9KS5pbmRleGVzKCk7XG5cblx0XHRmb3IgKHZhciBpPTAgOyBpPGluZGV4ZXMubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHQvLyBGb3Igc3BlZWQgSSB1c2UgdGhlIGludGVybmFsIERhdGFUYWJsZXMgb2JqZWN0LlxuXHRcdFx0dmFyIHJvd0ludGVybmFsID0gY3R4LmFvRGF0YVtpbmRleGVzW2ldXTtcblx0XHRcdHZhciByZXN1bHQgPSBzZWxlY3RhYmxlKHJvd0ludGVybmFsLl9hRGF0YSwgcm93SW50ZXJuYWwublRyLCBpbmRleGVzW2ldKTtcblxuXHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRhdmFpbGFibGUrKztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGF2YWlsYWJsZTogYXZhaWxhYmxlLFxuXHRcdGNvdW50OiBjb3VudCxcblx0XHRzZWFyY2g6IHNlYXJjaFxuXHR9XG59XG5cbi8qKlxuICogSW5pdGlhbGlzYXRpb24gb2YgYSBuZXcgdGFibGUuIEF0dGFjaCBldmVudCBoYW5kbGVycyBhbmQgY2FsbGJhY2tzIHRvIGFsbG93XG4gKiBTZWxlY3QgdG8gb3BlcmF0ZSBjb3JyZWN0bHkuXG4gKlxuICogVGhpcyB3aWxsIG9jY3VyIF9hZnRlcl8gdGhlIGluaXRpYWwgRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvbiwgYWx0aG91Z2hcbiAqIGJlZm9yZSBBamF4IGRhdGEgaXMgcmVuZGVyZWQsIGlmIHRoZXJlIGlzIGFqYXggZGF0YVxuICpcbiAqIEBwYXJhbSAge0RhdGFUYWJsZS5zZXR0aW5nc30gY3R4IFNldHRpbmdzIG9iamVjdCB0byBvcGVyYXRlIG9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbml0KGN0eCkge1xuXHR2YXIgYXBpID0gbmV3IERhdGFUYWJsZS5BcGkoY3R4KTtcblx0Y3R4Ll9zZWxlY3RfaW5pdCA9IHRydWU7XG5cblx0Ly8gV2hlbiBgYWRkaXRpdmVgIHRoZW4gYF9zZWxlY3Rfc2V0YCBjb250YWlucyBhIGxpc3Qgb2YgdGhlIHJvdyBpZHMgdGhhdFxuXHQvLyBhcmUgc2VsZWN0ZWQuIElmIGBzdWJ0cmFjdGl2ZWAgdGhlbiBhbGwgcm93cyBhcmUgc2VsZWN0ZWQsIGV4Y2VwdCB0aG9zZVxuXHQvLyBpbiBgX3NlbGVjdF9zZXRgLCB3aGljaCBpcyBhIGxpc3Qgb2YgaWRzLlxuXHRjdHguX3NlbGVjdF9tb2RlID0gJ2FkZGl0aXZlJztcblx0Y3R4Ll9zZWxlY3Rfc2V0ID0gW107XG5cblx0Ly8gUm93IGNhbGxiYWNrIHNvIHRoYXQgY2xhc3NlcyBjYW4gYmUgYWRkZWQgdG8gcm93cyBhbmQgY2VsbHMgaWYgdGhlIGl0ZW1cblx0Ly8gd2FzIHNlbGVjdGVkIGJlZm9yZSB0aGUgZWxlbWVudCB3YXMgY3JlYXRlZC4gVGhpcyB3aWxsIGhhcHBlbiB3aXRoIHRoZVxuXHQvLyBgZGVmZXJSZW5kZXJgIG9wdGlvbiBlbmFibGVkLlxuXHQvL1xuXHQvLyBUaGlzIG1ldGhvZCBvZiBhdHRhY2hpbmcgdG8gYGFvUm93Q3JlYXRlZENhbGxiYWNrYCBpcyBhIGhhY2sgdW50aWxcblx0Ly8gRGF0YVRhYmxlcyBoYXMgcHJvcGVyIGV2ZW50cyBmb3Igcm93IG1hbmlwdWxhdGlvbiBJZiB5b3UgYXJlIHJldmlld2luZ1xuXHQvLyB0aGlzIGNvZGUgdG8gY3JlYXRlIHlvdXIgb3duIHBsdWctaW5zLCBwbGVhc2UgZG8gbm90IGRvIHRoaXMhXG5cdGN0eC5hb1Jvd0NyZWF0ZWRDYWxsYmFjay5wdXNoKGZ1bmN0aW9uIChyb3csIGRhdGEsIGluZGV4KSB7XG5cdFx0XHR2YXIgaSwgaWVuO1xuXHRcdFx0dmFyIGQgPSBjdHguYW9EYXRhW2luZGV4XTtcblx0XHRcdHZhciBpZCA9IGFwaS5yb3coaW5kZXgpLmlkKCk7XG5cblx0XHRcdC8vIFJvd1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRkLl9zZWxlY3Rfc2VsZWN0ZWQgfHxcblx0XHRcdFx0KGN0eC5fc2VsZWN0X21vZGUgPT09ICdhZGRpdGl2ZScgJiYgY3R4Ll9zZWxlY3Rfc2V0LmluY2x1ZGVzKGlkKSkgfHxcblx0XHRcdFx0KGN0eC5fc2VsZWN0X21vZGUgPT09ICdzdWJ0cmFjdGl2ZScgJiYgISBjdHguX3NlbGVjdF9zZXQuaW5jbHVkZXMoaWQpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGQuX3NlbGVjdF9zZWxlY3RlZCA9IHRydWU7XG5cblx0XHRcdFx0JChyb3cpXG5cdFx0XHRcdFx0LmFkZENsYXNzKGN0eC5fc2VsZWN0LmNsYXNzTmFtZSlcblx0XHRcdFx0XHQuZmluZCgnaW5wdXQuJyArIGNoZWNrYm94Q2xhc3ModHJ1ZSkpLnByb3AoJ2NoZWNrZWQnLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2VsbHMgYW5kIGNvbHVtbnMgLSBpZiBzZXBhcmF0ZWQgb3V0LCB3ZSB3b3VsZCBuZWVkIHRvIGRvIHR3b1xuXHRcdFx0Ly8gbG9vcHMsIHNvIGl0IG1ha2VzIHNlbnNlIHRvIGNvbWJpbmUgdGhlbSBpbnRvIGEgc2luZ2xlIG9uZVxuXHRcdFx0Zm9yIChpID0gMCwgaWVuID0gY3R4LmFvQ29sdW1ucy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0Y3R4LmFvQ29sdW1uc1tpXS5fc2VsZWN0X3NlbGVjdGVkIHx8XG5cdFx0XHRcdFx0KGQuX3NlbGVjdGVkX2NlbGxzICYmIGQuX3NlbGVjdGVkX2NlbGxzW2ldKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQkKGQuYW5DZWxsc1tpXSkuYWRkQ2xhc3MoY3R4Ll9zZWxlY3QuY2xhc3NOYW1lKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xuXG5cdF9jdW11bGF0aXZlRXZlbnRzKGFwaSk7XG5cblx0Ly8gVXBkYXRlIHRoZSB0YWJsZSBpbmZvcm1hdGlvbiBlbGVtZW50IHdpdGggc2VsZWN0ZWQgaXRlbSBzdW1tYXJ5XG5cdGFwaS5vbignaW5mby5kdCcsIGZ1bmN0aW9uIChlLCBjdHgsIG5vZGUpIHtcblx0XHQvLyBTdG9yZSB0aGUgaW5mbyBub2RlIGZvciB1cGRhdGluZyBvbiBzZWxlY3QgLyBkZXNlbGVjdFxuXHRcdGlmICghY3R4Ll9zZWxlY3QuaW5mb0Vscy5pbmNsdWRlcyhub2RlKSkge1xuXHRcdFx0Y3R4Ll9zZWxlY3QuaW5mb0Vscy5wdXNoKG5vZGUpO1xuXHRcdH1cblxuXHRcdGluZm8oYXBpLCBub2RlKTtcblx0fSk7XG5cblx0YXBpLm9uKCdzZWxlY3QuZHRTZWxlY3QuZHQgZGVzZWxlY3QuZHRTZWxlY3QuZHQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0Y3R4Ll9zZWxlY3QuaW5mb0Vscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0aW5mbyhhcGksIGVsKTtcblx0XHR9KTtcblxuXHRcdGFwaS5zdGF0ZS5zYXZlKCk7XG5cdH0pO1xuXG5cdC8vIENsZWFuIHVwIGFuZCByZWxlYXNlXG5cdGFwaS5vbignZGVzdHJveS5kdFNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcblx0XHQvLyBSZW1vdmUgY2xhc3MgZGlyZWN0bHkgcmF0aGVyIHRoYW4gY2FsbGluZyBkZXNlbGVjdCAtIHdoaWNoIHdvdWxkIHRyaWdnZXIgZXZlbnRzXG5cdFx0JChhcGkucm93cyh7IHNlbGVjdGVkOiB0cnVlIH0pLm5vZGVzKCkpLnJlbW92ZUNsYXNzKGFwaS5zZXR0aW5ncygpWzBdLl9zZWxlY3QuY2xhc3NOYW1lKTtcblxuXHRcdCQoJ2lucHV0LicgKyBjaGVja2JveENsYXNzKHRydWUpLCBhcGkudGFibGUoKS5oZWFkZXIoKSkucmVtb3ZlKCk7XG5cblx0XHRkaXNhYmxlTW91c2VTZWxlY3Rpb24oYXBpKTtcblx0XHRhcGkub2ZmKCcuZHRTZWxlY3QnKTtcblx0XHQkKCdib2R5Jykub2ZmKCcuZHRTZWxlY3QnICsgX3NhZmVJZChhcGkudGFibGUoKS5ub2RlKCkpKTtcblx0fSk7XG59XG5cbi8qKlxuICogQWRkIG9uZSBvciBtb3JlIGl0ZW1zIChyb3dzIG9yIGNvbHVtbnMpIHRvIHRoZSBzZWxlY3Rpb24gd2hlbiBzaGlmdCBjbGlja2luZ1xuICogaW4gT1Mgc2VsZWN0aW9uIHN0eWxlXG4gKlxuICogQHBhcmFtICB7RGF0YVRhYmxlLkFwaX0gZHQgICBEYXRhVGFibGVcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgIHR5cGUgUm93IG9yIGNvbHVtbiByYW5nZSBzZWxlY3RvclxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgaWR4ICBJdGVtIGluZGV4IHRvIHNlbGVjdCB0b1xuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgbGFzdCBJdGVtIGluZGV4IHRvIHNlbGVjdCBmcm9tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByb3dDb2x1bW5SYW5nZShkdCwgdHlwZSwgaWR4LCBsYXN0KSB7XG5cdC8vIEFkZCBhIHJhbmdlIG9mIHJvd3MgZnJvbSB0aGUgbGFzdCBzZWxlY3RlZCByb3cgdG8gdGhpcyBvbmVcblx0dmFyIGluZGV4ZXMgPSBkdFt0eXBlICsgJ3MnXSh7IHNlYXJjaDogJ2FwcGxpZWQnIH0pLmluZGV4ZXMoKTtcblx0dmFyIGlkeDEgPSBpbmRleGVzLmluZGV4T2YobGFzdCk7XG5cdHZhciBpZHgyID0gaW5kZXhlcy5pbmRleE9mKGlkeCk7XG5cblx0aWYgKCFkdFt0eXBlICsgJ3MnXSh7IHNlbGVjdGVkOiB0cnVlIH0pLmFueSgpICYmIGlkeDEgPT09IC0xKSB7XG5cdFx0Ly8gc2VsZWN0IGZyb20gdG9wIHRvIGhlcmUgLSBzbGlnaHRseSBvZGQsIGJ1dCBib3RoIFdpbmRvd3MgYW5kIE1hYyBPU1xuXHRcdC8vIGRvIHRoaXNcblx0XHRpbmRleGVzLnNwbGljZShpbmRleGVzLmluZGV4T2YoaWR4KSArIDEsIGluZGV4ZXMubGVuZ3RoKTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyByZXZlcnNlIHNvIHdlIGNhbiBzaGlmdCBjbGljayAndXAnIGFzIHdlbGwgYXMgZG93blxuXHRcdGlmIChpZHgxID4gaWR4Mikge1xuXHRcdFx0dmFyIHRtcCA9IGlkeDI7XG5cdFx0XHRpZHgyID0gaWR4MTtcblx0XHRcdGlkeDEgPSB0bXA7XG5cdFx0fVxuXG5cdFx0aW5kZXhlcy5zcGxpY2UoaWR4MiArIDEsIGluZGV4ZXMubGVuZ3RoKTtcblx0XHRpbmRleGVzLnNwbGljZSgwLCBpZHgxKTtcblx0fVxuXG5cdGlmICghZHRbdHlwZV0oaWR4LCB7IHNlbGVjdGVkOiB0cnVlIH0pLmFueSgpKSB7XG5cdFx0Ly8gU2VsZWN0IHJhbmdlXG5cdFx0ZHRbdHlwZSArICdzJ10oaW5kZXhlcykuc2VsZWN0KCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gRGVzZWxlY3QgcmFuZ2UgLSBuZWVkIHRvIGtlZXAgdGhlIGNsaWNrZWQgb24gcm93IHNlbGVjdGVkXG5cdFx0aW5kZXhlcy5zcGxpY2UoaW5kZXhlcy5pbmRleE9mKGlkeCksIDEpO1xuXHRcdGR0W3R5cGUgKyAncyddKGluZGV4ZXMpLmRlc2VsZWN0KCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDbGVhciBhbGwgc2VsZWN0ZWQgaXRlbXNcbiAqXG4gKiBAcGFyYW0gIHtEYXRhVGFibGUuc2V0dGluZ3N9IGN0eCBTZXR0aW5ncyBvYmplY3Qgb2YgdGhlIGhvc3QgRGF0YVRhYmxlXG4gKiBAcGFyYW0gIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIEZvcmNlIHRoZSBkZS1zZWxlY3Rpb24gdG8gaGFwcGVuLCByZWdhcmRsZXNzXG4gKiAgICAgb2Ygc2VsZWN0aW9uIHN0eWxlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhcihjdHgsIGZvcmNlKSB7XG5cdGlmIChmb3JjZSB8fCBjdHguX3NlbGVjdC5zdHlsZSA9PT0gJ3NpbmdsZScpIHtcblx0XHR2YXIgYXBpID0gbmV3IERhdGFUYWJsZS5BcGkoY3R4KTtcblxuXHRcdGFwaS5yb3dzKHsgc2VsZWN0ZWQ6IHRydWUgfSkuZGVzZWxlY3QoKTtcblx0XHRhcGkuY29sdW1ucyh7IHNlbGVjdGVkOiB0cnVlIH0pLmRlc2VsZWN0KCk7XG5cdFx0YXBpLmNlbGxzKHsgc2VsZWN0ZWQ6IHRydWUgfSkuZGVzZWxlY3QoKTtcblx0fVxufVxuXG4vKipcbiAqIFNlbGVjdCBpdGVtcyBiYXNlZCBvbiB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIGZvciBzdHlsZSBhbmQgaXRlbXMuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICBlICAgIE1vdXNlIGV2ZW50IG9iamVjdFxuICogQHBhcmFtICB7RGF0YVRhYmxlcy5BcGl9ICAgICBkdCAgIERhdGFUYWJsZVxuICogQHBhcmFtICB7RGF0YVRhYmxlLnNldHRpbmdzfSBjdHggIFNldHRpbmdzIG9iamVjdCBvZiB0aGUgaG9zdCBEYXRhVGFibGVcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgdHlwZSBJdGVtcyB0byBzZWxlY3RcbiAqIEBwYXJhbSAge2ludHxvYmplY3R9ICAgICAgICAgaWR4ICBJbmRleCBvZiB0aGUgaXRlbSB0byBzZWxlY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHR5cGVTZWxlY3QoZSwgZHQsIGN0eCwgdHlwZSwgaWR4KSB7XG5cdHZhciBzdHlsZSA9IGR0LnNlbGVjdC5zdHlsZSgpO1xuXHR2YXIgdG9nZ2xlYWJsZSA9IGR0LnNlbGVjdC50b2dnbGVhYmxlKCk7XG5cdHZhciBpc1NlbGVjdGVkID0gZHRbdHlwZV0oaWR4LCB7IHNlbGVjdGVkOiB0cnVlIH0pLmFueSgpO1xuXG5cdGlmIChpc1NlbGVjdGVkICYmICF0b2dnbGVhYmxlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKHN0eWxlID09PSAnb3MnKSB7XG5cdFx0aWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHtcblx0XHRcdC8vIEFkZCBvciByZW1vdmUgZnJvbSB0aGUgc2VsZWN0aW9uXG5cdFx0XHRkdFt0eXBlXShpZHgpLnNlbGVjdCghaXNTZWxlY3RlZCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGUuc2hpZnRLZXkpIHtcblx0XHRcdGlmICh0eXBlID09PSAnY2VsbCcpIHtcblx0XHRcdFx0Y2VsbFJhbmdlKGR0LCBpZHgsIGN0eC5fc2VsZWN0X2xhc3RDZWxsIHx8IG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJvd0NvbHVtblJhbmdlKFxuXHRcdFx0XHRcdGR0LFxuXHRcdFx0XHRcdHR5cGUsXG5cdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdGN0eC5fc2VsZWN0X2xhc3RDZWxsID8gY3R4Ll9zZWxlY3RfbGFzdENlbGxbdHlwZV0gOiBudWxsXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gTm8gY21kIG9yIHNoaWZ0IGNsaWNrIC0gZGVzZWxlY3QgaWYgc2VsZWN0ZWQsIG9yIHNlbGVjdFxuXHRcdFx0Ly8gdGhpcyByb3cgb25seVxuXHRcdFx0dmFyIHNlbGVjdGVkID0gZHRbdHlwZSArICdzJ10oeyBzZWxlY3RlZDogdHJ1ZSB9KTtcblxuXHRcdFx0aWYgKGlzU2VsZWN0ZWQgJiYgc2VsZWN0ZWQuZmxhdHRlbigpLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRkdFt0eXBlXShpZHgpLmRlc2VsZWN0KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2VsZWN0ZWQuZGVzZWxlY3QoKTtcblx0XHRcdFx0ZHRbdHlwZV0oaWR4KS5zZWxlY3QoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoc3R5bGUgPT0gJ211bHRpK3NoaWZ0Jykge1xuXHRcdGlmIChlLnNoaWZ0S2V5KSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ2NlbGwnKSB7XG5cdFx0XHRcdGNlbGxSYW5nZShkdCwgaWR4LCBjdHguX3NlbGVjdF9sYXN0Q2VsbCB8fCBudWxsKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyb3dDb2x1bW5SYW5nZShcblx0XHRcdFx0XHRkdCxcblx0XHRcdFx0XHR0eXBlLFxuXHRcdFx0XHRcdGlkeCxcblx0XHRcdFx0XHRjdHguX3NlbGVjdF9sYXN0Q2VsbCA/IGN0eC5fc2VsZWN0X2xhc3RDZWxsW3R5cGVdIDogbnVsbFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGR0W3R5cGVdKGlkeCkuc2VsZWN0KCFpc1NlbGVjdGVkKTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0ZHRbdHlwZV0oaWR4KS5zZWxlY3QoIWlzU2VsZWN0ZWQpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9zYWZlSWQobm9kZSkge1xuXHRyZXR1cm4gbm9kZS5pZC5yZXBsYWNlKC9bXmEtekEtWjAtOVxcLVxcX10vZywgJy0nKTtcbn1cblxuLyoqXG4gKiBTZXQgdXAgZXZlbnQgaGFuZGxlcnMgZm9yIGN1bXVsYXRpdmUgc2VsZWN0aW9uXG4gKlxuICogQHBhcmFtIHsqfSBhcGkgRFQgQVBJIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIF9jdW11bGF0aXZlRXZlbnRzKGFwaSkge1xuXHQvLyBBZGQgZXZlbnQgbGlzdGVuZXJzIHRvIGFkZCAvIHJlbW92ZSBmcm9tIHRoZSBfc2VsZWN0X3NldFxuXHRhcGkub24oJ3NlbGVjdCcsIGZ1bmN0aW9uIChlLCBkdCwgdHlwZSwgaW5kZXhlcykge1xuXHRcdC8vIE9ubHkgc3VwcG9ydCBmb3Igcm93cyBhdCB0aGUgbW9tZW50XG5cdFx0aWYgKHR5cGUgIT09ICdyb3cnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGN0eCA9IGFwaS5zZXR0aW5ncygpWzBdO1xuXG5cdFx0aWYgKGN0eC5fc2VsZWN0X21vZGUgPT09ICdhZGRpdGl2ZScpIHtcblx0XHRcdC8vIEFkZCByb3cgdG8gdGhlIHNlbGVjdGlvbiBsaXN0IGlmIGl0IGlzbid0IGFscmVhZHkgdGhlcmVcblx0XHRcdF9hZGQoYXBpLCBjdHguX3NlbGVjdF9zZXQsIGluZGV4ZXMpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFN1YnRyYWN0aXZlIC0gaWYgYSByb3cgaXMgc2VsZWN0ZWQgaXQgc2hvdWxkIG5vdCBpbiB0aGUgbGlzdFxuXHRcdFx0Ly8gYXMgaW4gc3VidHJhY3RpdmUgbW9kZSB0aGUgbGlzdCBnaXZlcyB0aGUgcm93cyB3aGljaCBhcmUgbm90XG5cdFx0XHQvLyBzZWxlY3RlZFxuXHRcdFx0X3JlbW92ZShhcGksIGN0eC5fc2VsZWN0X3NldCwgaW5kZXhlcyk7XG5cdFx0fVxuXHR9KTtcblxuXHRhcGkub24oJ2Rlc2VsZWN0JywgZnVuY3Rpb24gKGUsIGR0LCB0eXBlLCBpbmRleGVzKSB7XG5cdFx0Ly8gT25seSBzdXBwb3J0IGZvciByb3dzIGF0IHRoZSBtb21lbnRcblx0XHRpZiAodHlwZSAhPT0gJ3JvdycpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgY3R4ID0gYXBpLnNldHRpbmdzKClbMF07XG5cblx0XHRpZiAoY3R4Ll9zZWxlY3RfbW9kZSA9PT0gJ2FkZGl0aXZlJykge1xuXHRcdFx0Ly8gTGlzdCBpcyBvZiB0aG9zZSByb3dzIHNlbGVjdGVkLCBzbyByZW1vdmUgaXRcblx0XHRcdF9yZW1vdmUoYXBpLCBjdHguX3NlbGVjdF9zZXQsIGluZGV4ZXMpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIExpc3QgaXMgb2Ygcm93cyB3aGljaCBhcmUgZGVzZWxlY3RlZCwgc28gYWRkIGl0IVxuXHRcdFx0X2FkZChhcGksIGN0eC5fc2VsZWN0X3NldCwgaW5kZXhlcyk7XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gX2FkZChhcGksIGFyciwgaW5kZXhlcykge1xuXHRmb3IgKHZhciBpPTAgOyBpPGluZGV4ZXMubGVuZ3RoIDsgaSsrKSB7XG5cdFx0dmFyIGlkID0gYXBpLnJvdyhpbmRleGVzW2ldKS5pZCgpO1xuXG5cdFx0aWYgKGlkICYmIGlkICE9PSAndW5kZWZpbmVkJyAmJiAhIGFyci5pbmNsdWRlcyhpZCkpIHtcblx0XHRcdGFyci5wdXNoKGlkKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gX3JlbW92ZShhcGksIGFyciwgaW5kZXhlcykge1xuXHRmb3IgKHZhciBpPTAgOyBpPGluZGV4ZXMubGVuZ3RoIDsgaSsrKSB7XG5cdFx0dmFyIGlkID0gYXBpLnJvdyhpbmRleGVzW2ldKS5pZCgpO1xuXHRcdHZhciBpZHggPSBhcnIuaW5kZXhPZihpZCk7XG5cblx0XHRpZiAoaWR4ICE9PSAtMSkge1xuXHRcdFx0YXJyLnNwbGljZShpZHgsIDEpO1xuXHRcdH1cblx0fVxufVxuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogRGF0YVRhYmxlcyBzZWxlY3RvcnNcbiAqL1xuXG4vLyByb3cgYW5kIGNvbHVtbiBhcmUgYmFzaWNhbGx5IGlkZW50aWNhbCBqdXN0IGFzc2lnbmVkIHRvIGRpZmZlcmVudCBwcm9wZXJ0aWVzXG4vLyBhbmQgY2hlY2tpbmcgYSBkaWZmZXJlbnQgYXJyYXksIHNvIHdlIGNhbiBkeW5hbWljYWxseSBjcmVhdGUgdGhlIGZ1bmN0aW9ucyB0b1xuLy8gcmVkdWNlIHRoZSBjb2RlIHNpemVcbiQuZWFjaChcblx0W1xuXHRcdHsgdHlwZTogJ3JvdycsIHByb3A6ICdhb0RhdGEnIH0sXG5cdFx0eyB0eXBlOiAnY29sdW1uJywgcHJvcDogJ2FvQ29sdW1ucycgfVxuXHRdLFxuXHRmdW5jdGlvbiAoaSwgbykge1xuXHRcdERhdGFUYWJsZS5leHQuc2VsZWN0b3Jbby50eXBlXS5wdXNoKGZ1bmN0aW9uIChzZXR0aW5ncywgb3B0cywgaW5kZXhlcykge1xuXHRcdFx0dmFyIHNlbGVjdGVkID0gb3B0cy5zZWxlY3RlZDtcblx0XHRcdHZhciBkYXRhO1xuXHRcdFx0dmFyIG91dCA9IFtdO1xuXG5cdFx0XHRpZiAoc2VsZWN0ZWQgIT09IHRydWUgJiYgc2VsZWN0ZWQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybiBpbmRleGVzO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaWVuID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuXHRcdFx0XHRkYXRhID0gc2V0dGluZ3Nbby5wcm9wXVtpbmRleGVzW2ldXTtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZGF0YSAmJiAoXG5cdFx0XHRcdFx0XHQoc2VsZWN0ZWQgPT09IHRydWUgJiYgZGF0YS5fc2VsZWN0X3NlbGVjdGVkID09PSB0cnVlKSB8fFxuXHRcdFx0XHRcdFx0KHNlbGVjdGVkID09PSBmYWxzZSAmJiAhZGF0YS5fc2VsZWN0X3NlbGVjdGVkKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0b3V0LnB1c2goaW5kZXhlc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dDtcblx0XHR9KTtcblx0fVxuKTtcblxuRGF0YVRhYmxlLmV4dC5zZWxlY3Rvci5jZWxsLnB1c2goZnVuY3Rpb24gKHNldHRpbmdzLCBvcHRzLCBjZWxscykge1xuXHR2YXIgc2VsZWN0ZWQgPSBvcHRzLnNlbGVjdGVkO1xuXHR2YXIgcm93RGF0YTtcblx0dmFyIG91dCA9IFtdO1xuXG5cdGlmIChzZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNlbGxzO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDAsIGllbiA9IGNlbGxzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG5cdFx0cm93RGF0YSA9IHNldHRpbmdzLmFvRGF0YVtjZWxsc1tpXS5yb3ddO1xuXG5cdFx0aWYgKFxuXHRcdFx0cm93RGF0YSAmJiAoXG5cdFx0XHRcdChzZWxlY3RlZCA9PT0gdHJ1ZSAmJlxuXHRcdFx0XHRcdHJvd0RhdGEuX3NlbGVjdGVkX2NlbGxzICYmXG5cdFx0XHRcdFx0cm93RGF0YS5fc2VsZWN0ZWRfY2VsbHNbY2VsbHNbaV0uY29sdW1uXSA9PT0gdHJ1ZSkgfHxcblx0XHRcdFx0KHNlbGVjdGVkID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdCghcm93RGF0YS5fc2VsZWN0ZWRfY2VsbHMgfHwgIXJvd0RhdGEuX3NlbGVjdGVkX2NlbGxzW2NlbGxzW2ldLmNvbHVtbl0pKVxuXHRcdFx0KVxuXHRcdCkge1xuXHRcdFx0b3V0LnB1c2goY2VsbHNbaV0pO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59KTtcblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIERhdGFUYWJsZXMgQVBJXG4gKlxuICogRm9yIGNvbXBsZXRlIGRvY3VtZW50YXRpb24sIHBsZWFzZSByZWZlciB0byB0aGUgZG9jcy9hcGkgZGlyZWN0b3J5IG9yIHRoZVxuICogRGF0YVRhYmxlcyBzaXRlXG4gKi9cblxuLy8gTG9jYWwgdmFyaWFibGVzIHRvIGltcHJvdmUgY29tcHJlc3Npb25cbnZhciBhcGlSZWdpc3RlciA9IERhdGFUYWJsZS5BcGkucmVnaXN0ZXI7XG52YXIgYXBpUmVnaXN0ZXJQbHVyYWwgPSBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsO1xuXG5hcGlSZWdpc3Rlcignc2VsZWN0KCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcblx0XHREYXRhVGFibGUuc2VsZWN0LmluaXQobmV3IERhdGFUYWJsZS5BcGkoY3R4KSk7XG5cdH0pO1xufSk7XG5cbmFwaVJlZ2lzdGVyKCdzZWxlY3QuYmx1cmFibGUoKScsIGZ1bmN0aW9uIChmbGFnKSB7XG5cdGlmIChmbGFnID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3QuYmx1cmFibGU7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XG5cdFx0Y3R4Ll9zZWxlY3QuYmx1cmFibGUgPSBmbGFnO1xuXHR9KTtcbn0pO1xuXG5hcGlSZWdpc3Rlcignc2VsZWN0LnRvZ2dsZWFibGUoKScsIGZ1bmN0aW9uIChmbGFnKSB7XG5cdGlmIChmbGFnID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3QudG9nZ2xlYWJsZTtcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcblx0XHRjdHguX3NlbGVjdC50b2dnbGVhYmxlID0gZmxhZztcblx0fSk7XG59KTtcblxuYXBpUmVnaXN0ZXIoJ3NlbGVjdC5pbmZvKCknLCBmdW5jdGlvbiAoZmxhZykge1xuXHRpZiAoZmxhZyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFswXS5fc2VsZWN0LmluZm87XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XG5cdFx0Y3R4Ll9zZWxlY3QuaW5mbyA9IGZsYWc7XG5cdH0pO1xufSk7XG5cbmFwaVJlZ2lzdGVyKCdzZWxlY3QuaXRlbXMoKScsIGZ1bmN0aW9uIChpdGVtcykge1xuXHRpZiAoaXRlbXMgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHRbMF0uX3NlbGVjdC5pdGVtcztcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcblx0XHRjdHguX3NlbGVjdC5pdGVtcyA9IGl0ZW1zO1xuXG5cdFx0ZXZlbnRUcmlnZ2VyKG5ldyBEYXRhVGFibGUuQXBpKGN0eCksICdzZWxlY3RJdGVtcycsIFtpdGVtc10pO1xuXHR9KTtcbn0pO1xuXG5hcGlSZWdpc3Rlcignc2VsZWN0LmtleXMoKScsIGZ1bmN0aW9uIChmbGFnKSB7XG5cdGlmIChmbGFnID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3Qua2V5cztcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcblx0XHRpZiAoIWN0eC5fc2VsZWN0KSB7XG5cdFx0XHREYXRhVGFibGUuc2VsZWN0LmluaXQobmV3IERhdGFUYWJsZS5BcGkoY3R4KSk7XG5cdFx0fVxuXG5cdFx0Y3R4Ll9zZWxlY3Qua2V5cyA9IGZsYWc7XG5cblx0XHRrZXlzU2V0KG5ldyBEYXRhVGFibGUuQXBpKGN0eCkpO1xuXHR9KTtcbn0pO1xuXG4vLyBUYWtlcyBlZmZlY3QgZnJvbSB0aGUgX25leHRfIHNlbGVjdGlvbi4gTm9uZSBkaXNhYmxlcyBmdXR1cmUgc2VsZWN0aW9uLCBidXRcbi8vIGRvZXMgbm90IGNsZWFyIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gVXNlIHRoZSBgZGVzZWxlY3RgIG1ldGhvZHMgZm9yIHRoYXRcbmFwaVJlZ2lzdGVyKCdzZWxlY3Quc3R5bGUoKScsIGZ1bmN0aW9uIChzdHlsZSkge1xuXHRpZiAoc3R5bGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHRbMF0uX3NlbGVjdC5zdHlsZTtcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcblx0XHRpZiAoIWN0eC5fc2VsZWN0KSB7XG5cdFx0XHREYXRhVGFibGUuc2VsZWN0LmluaXQobmV3IERhdGFUYWJsZS5BcGkoY3R4KSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFjdHguX3NlbGVjdF9pbml0KSB7XG5cdFx0XHRpbml0KGN0eCk7XG5cdFx0fVxuXG5cdFx0Y3R4Ll9zZWxlY3Quc3R5bGUgPSBzdHlsZTtcblxuXHRcdC8vIEFkZCAvIHJlbW92ZSBtb3VzZSBldmVudCBoYW5kbGVycy4gVGhleSBhcmVuJ3QgcmVxdWlyZWQgd2hlbiBvbmx5XG5cdFx0Ly8gQVBJIHNlbGVjdGlvbiBpcyBhdmFpbGFibGVcblx0XHR2YXIgZHQgPSBuZXcgRGF0YVRhYmxlLkFwaShjdHgpO1xuXG5cdFx0aWYgKHN0eWxlICE9PSAnYXBpJykge1xuXHRcdFx0ZHQucmVhZHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRkaXNhYmxlTW91c2VTZWxlY3Rpb24oZHQpO1xuXHRcdFx0XHRlbmFibGVNb3VzZVNlbGVjdGlvbihkdCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRkaXNhYmxlTW91c2VTZWxlY3Rpb24oZHQpO1xuXHRcdH1cblxuXHRcdGV2ZW50VHJpZ2dlcihuZXcgRGF0YVRhYmxlLkFwaShjdHgpLCAnc2VsZWN0U3R5bGUnLCBbc3R5bGVdKTtcblx0fSk7XG59KTtcblxuYXBpUmVnaXN0ZXIoJ3NlbGVjdC5zZWxlY3RvcigpJywgZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdGlmIChzZWxlY3RvciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFswXS5fc2VsZWN0LnNlbGVjdG9yO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xuXHRcdHZhciBkdCA9IG5ldyBEYXRhVGFibGUuQXBpKGN0eCk7XG5cdFx0dmFyIHN0eWxlID0gY3R4Ll9zZWxlY3Quc3R5bGU7XG5cblx0XHRkaXNhYmxlTW91c2VTZWxlY3Rpb24oZHQpO1xuXG5cdFx0Y3R4Ll9zZWxlY3Quc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdGlmIChzdHlsZSAmJiBzdHlsZSAhPT0gJ2FwaScpIHtcblx0XHRcdGR0LnJlYWR5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0ZGlzYWJsZU1vdXNlU2VsZWN0aW9uKGR0KTtcblx0XHRcdFx0ZW5hYmxlTW91c2VTZWxlY3Rpb24oZHQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0ZGlzYWJsZU1vdXNlU2VsZWN0aW9uKGR0KTtcblx0XHR9XG5cdH0pO1xufSk7XG5cbmFwaVJlZ2lzdGVyKCdzZWxlY3Quc2VsZWN0YWJsZSgpJywgZnVuY3Rpb24gKHNldCkge1xuXHRsZXQgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXG5cdGlmIChzZXQpIHtcblx0XHRjdHguX3NlbGVjdC5zZWxlY3RhYmxlID0gc2V0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cmV0dXJuIGN0eC5fc2VsZWN0LnNlbGVjdGFibGU7XG59KTtcblxuYXBpUmVnaXN0ZXIoJ3NlbGVjdC5sYXN0KCknLCBmdW5jdGlvbiAoc2V0KSB7XG5cdGxldCBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cblx0aWYgKHNldCkge1xuXHRcdGN0eC5fc2VsZWN0X2xhc3RDZWxsID0gc2V0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0cmV0dXJuIGN0eC5fc2VsZWN0X2xhc3RDZWxsO1xufSk7XG5cbmFwaVJlZ2lzdGVyKCdzZWxlY3QuY3VtdWxhdGl2ZSgpJywgZnVuY3Rpb24gKG1vZGUpIHtcblx0aWYgKG1vZGUpIHtcblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XG5cdFx0XHRpZiAoY3R4Ll9zZWxlY3RfbW9kZSA9PT0gbW9kZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkdCA9IG5ldyBEYXRhVGFibGUuQXBpKGN0eCk7XG5cblx0XHRcdC8vIENvbnZlcnQgZnJvbSB0aGUgY3VycmVudCBtb2RlLCB0byB0aGUgbmV3XG5cdFx0XHRpZiAobW9kZSA9PT0gJ3N1YnRyYWN0aXZlJykge1xuXHRcdFx0XHQvLyBGb3Igc3VidHJhY3RpdmUgbW9kZSB3ZSB0cmFjayB0aGUgcm93IGlkcyB3aGljaCBhcmUgbm90IHNlbGVjdGVkXG5cdFx0XHRcdHZhciB1bnNlbGVjdGVkID0gZHQucm93cyh7c2VsZWN0ZWQ6IGZhbHNlfSkuaWRzKCkudG9BcnJheSgpO1xuXG5cdFx0XHRcdGN0eC5fc2VsZWN0X21vZGUgPSBtb2RlO1xuXHRcdFx0XHRjdHguX3NlbGVjdF9zZXQubGVuZ3RoID0gMDtcblx0XHRcdFx0Y3R4Ll9zZWxlY3Rfc2V0LnB1c2guYXBwbHkoY3R4Ll9zZWxlY3Rfc2V0LCB1bnNlbGVjdGVkKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBTd2l0Y2hpbmcgdG8gYWRkaXRpdmUsIHNvIHNlbGVjdGVkIHJvd3MgYXJlIHRvIGJlIHVzZWRcblx0XHRcdFx0dmFyIHNlbGVjdGVkID0gZHQucm93cyh7c2VsZWN0ZWQ6IHRydWV9KS5pZHMoKS50b0FycmF5KCk7XG5cblx0XHRcdFx0Y3R4Ll9zZWxlY3RfbW9kZSA9IG1vZGU7XG5cdFx0XHRcdGN0eC5fc2VsZWN0X3NldC5sZW5ndGggPSAwO1xuXHRcdFx0XHRjdHguX3NlbGVjdF9zZXQucHVzaC5hcHBseShjdHguX3NlbGVjdF9zZXQsIHNlbGVjdGVkKTtcblx0XHRcdH1cblx0XHR9KS5kcmF3KGZhbHNlKTtcblx0fVxuXG5cdGxldCBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cblx0aWYgKGN0eCAmJiBjdHguX3NlbGVjdF9zZXQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bW9kZTogY3R4Ll9zZWxlY3RfbW9kZSxcblx0XHRcdHJvd3M6IGN0eC5fc2VsZWN0X3NldFxuXHRcdH07XG5cdH1cblxuXHRyZXR1cm4gbnVsbDtcbn0pO1xuXG5hcGlSZWdpc3RlclBsdXJhbCgncm93cygpLnNlbGVjdCgpJywgJ3JvdygpLnNlbGVjdCgpJywgZnVuY3Rpb24gKHNlbGVjdCkge1xuXHR2YXIgYXBpID0gdGhpcztcblx0dmFyIHNlbGVjdGVkSW5kZXhlcyA9IFtdO1xuXG5cdGlmIChzZWxlY3QgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGVzZWxlY3QoKTtcblx0fVxuXG5cdHRoaXMuaXRlcmF0b3IoJ3JvdycsIGZ1bmN0aW9uIChjdHgsIGlkeCkge1xuXHRcdGNsZWFyKGN0eCk7XG5cblx0XHQvLyBUaGVyZSBpcyBhIGdvb2QgYW1vdW50IG9mIGtub3dsZWRnZSBvZiBEYXRhVGFibGVzIGludGVybmFscyBpblxuXHRcdC8vIHRoaXMgZnVuY3Rpb24uIEl0IF9jb3VsZF8gYmUgZG9uZSB3aXRob3V0IHRoYXQsIGJ1dCBpdCB3b3VsZCBodXJ0XG5cdFx0Ly8gcGVyZm9ybWFuY2UgKG9yIERUIHdvdWxkIG5lZWQgbmV3IEFQSXMgZm9yIHRoaXMgd29yaylcblx0XHR2YXIgZHREYXRhID0gY3R4LmFvRGF0YVtpZHhdO1xuXHRcdHZhciBkdENvbHVtbnMgPSBjdHguYW9Db2x1bW5zO1xuXG5cdFx0aWYgKGN0eC5fc2VsZWN0LnNlbGVjdGFibGUpIHtcblx0XHRcdHZhciByZXN1bHQgPSBjdHguX3NlbGVjdC5zZWxlY3RhYmxlKGR0RGF0YS5fYURhdGEsIGR0RGF0YS5uVHIsIGlkeCk7XG5cblx0XHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdC8vIE5vdCBzZWxlY3RhYmxlIC0gZG8gbm90aGluZ1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0JChkdERhdGEublRyKS5hZGRDbGFzcyhjdHguX3NlbGVjdC5jbGFzc05hbWUpO1xuXHRcdGR0RGF0YS5fc2VsZWN0X3NlbGVjdGVkID0gdHJ1ZTtcblxuXHRcdHNlbGVjdGVkSW5kZXhlcy5wdXNoKGlkeCk7XG5cblx0XHRmb3IgKHZhciBpPTAgOyBpPGR0Q29sdW1ucy5sZW5ndGggOyBpKyspIHtcblx0XHRcdHZhciBjb2wgPSBkdENvbHVtbnNbaV07XG5cblx0XHRcdC8vIFJlZ2VuZXJhdGUgdGhlIGNvbHVtbiB0eXBlIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRpZiAoY29sLnNUeXBlID09PSBudWxsKSB7XG5cdFx0XHRcdGFwaS5jb2x1bW5zKCkudHlwZXMoKVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoaXNDaGVja2JveENvbHVtbihjb2wpKSB7XG5cdFx0XHRcdHZhciBjZWxscyA9IGR0RGF0YS5hbkNlbGxzO1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGUgY2hlY2tib3ggc2hvd3MgdGhlIHJpZ2h0IHN0YXRlXG5cdFx0XHRcdGlmIChjZWxscyAmJiBjZWxsc1tpXSkge1xuXHRcdFx0XHRcdCQoJ2lucHV0LicgKyBjaGVja2JveENsYXNzKHRydWUpLCBjZWxsc1tpXSkucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSW52YWxpZGF0ZSB0aGUgc29ydCBkYXRhIGZvciB0aGlzIGNvbHVtbiwgaWYgbm90IGFscmVhZHkgZG9uZVxuXHRcdFx0XHRpZiAoZHREYXRhLl9hU29ydERhdGEgIT09IG51bGwpIHtcblx0XHRcdFx0XHRkdERhdGEuX2FTb3J0RGF0YVtpXSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0KSB7XG5cdFx0ZXZlbnRUcmlnZ2VyKGFwaSwgJ3NlbGVjdCcsIFsncm93Jywgc2VsZWN0ZWRJbmRleGVzXSwgdHJ1ZSk7XG5cdH0pO1xuXG5cdHJldHVybiB0aGlzO1xufSk7XG5cbmFwaVJlZ2lzdGVyKCdyb3coKS5zZWxlY3RlZCgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXG5cdGlmIChjdHggJiYgdGhpcy5sZW5ndGggJiYgY3R4LmFvRGF0YVt0aGlzWzBdXSAmJiBjdHguYW9EYXRhW3RoaXNbMF1dLl9zZWxlY3Rfc2VsZWN0ZWQpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn0pO1xuXG5hcGlSZWdpc3Rlcigncm93KCkuZm9jdXMoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcblxuXHRpZiAoY3R4ICYmIHRoaXMubGVuZ3RoICYmIGN0eC5hb0RhdGFbdGhpc1swXV0gJiYgY3R4LmFvRGF0YVt0aGlzWzBdXS5uVHIpIHtcblx0XHRjdHguYW9EYXRhW3RoaXNbMF1dLm5Uci5mb2N1cygpO1xuXHR9XG59KTtcblxuYXBpUmVnaXN0ZXIoJ3JvdygpLmJsdXIoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcblxuXHRpZiAoY3R4ICYmIHRoaXMubGVuZ3RoICYmIGN0eC5hb0RhdGFbdGhpc1swXV0gJiYgY3R4LmFvRGF0YVt0aGlzWzBdXS5uVHIpIHtcblx0XHRjdHguYW9EYXRhW3RoaXNbMF1dLm5Uci5ibHVyKCk7XG5cdH1cbn0pO1xuXG5hcGlSZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLnNlbGVjdCgpJywgJ2NvbHVtbigpLnNlbGVjdCgpJywgZnVuY3Rpb24gKHNlbGVjdCkge1xuXHR2YXIgYXBpID0gdGhpcztcblxuXHRpZiAoc2VsZWN0ID09PSBmYWxzZSkge1xuXHRcdHJldHVybiB0aGlzLmRlc2VsZWN0KCk7XG5cdH1cblxuXHR0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoY3R4LCBpZHgpIHtcblx0XHRjbGVhcihjdHgpO1xuXG5cdFx0Y3R4LmFvQ29sdW1uc1tpZHhdLl9zZWxlY3Rfc2VsZWN0ZWQgPSB0cnVlO1xuXG5cdFx0dmFyIGNvbHVtbiA9IG5ldyBEYXRhVGFibGUuQXBpKGN0eCkuY29sdW1uKGlkeCk7XG5cblx0XHQkKGNvbHVtbi5oZWFkZXIoKSkuYWRkQ2xhc3MoY3R4Ll9zZWxlY3QuY2xhc3NOYW1lKTtcblx0XHQkKGNvbHVtbi5mb290ZXIoKSkuYWRkQ2xhc3MoY3R4Ll9zZWxlY3QuY2xhc3NOYW1lKTtcblxuXHRcdGNvbHVtbi5ub2RlcygpLnRvJCgpLmFkZENsYXNzKGN0eC5fc2VsZWN0LmNsYXNzTmFtZSk7XG5cdH0pO1xuXG5cdHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCwgaSkge1xuXHRcdGV2ZW50VHJpZ2dlcihhcGksICdzZWxlY3QnLCBbJ2NvbHVtbicsIGFwaVtpXV0sIHRydWUpO1xuXHR9KTtcblxuXHRyZXR1cm4gdGhpcztcbn0pO1xuXG5hcGlSZWdpc3RlcignY29sdW1uKCkuc2VsZWN0ZWQoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcblxuXHRpZiAoY3R4ICYmIHRoaXMubGVuZ3RoICYmIGN0eC5hb0NvbHVtbnNbdGhpc1swXV0gJiYgY3R4LmFvQ29sdW1uc1t0aGlzWzBdXS5fc2VsZWN0X3NlbGVjdGVkKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59KTtcblxuYXBpUmVnaXN0ZXJQbHVyYWwoJ2NlbGxzKCkuc2VsZWN0KCknLCAnY2VsbCgpLnNlbGVjdCgpJywgZnVuY3Rpb24gKHNlbGVjdCkge1xuXHR2YXIgYXBpID0gdGhpcztcblxuXHRpZiAoc2VsZWN0ID09PSBmYWxzZSkge1xuXHRcdHJldHVybiB0aGlzLmRlc2VsZWN0KCk7XG5cdH1cblxuXHR0aGlzLml0ZXJhdG9yKCdjZWxsJywgZnVuY3Rpb24gKGN0eCwgcm93SWR4LCBjb2xJZHgpIHtcblx0XHRjbGVhcihjdHgpO1xuXG5cdFx0dmFyIGRhdGEgPSBjdHguYW9EYXRhW3Jvd0lkeF07XG5cblx0XHRpZiAoZGF0YS5fc2VsZWN0ZWRfY2VsbHMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZGF0YS5fc2VsZWN0ZWRfY2VsbHMgPSBbXTtcblx0XHR9XG5cblx0XHRkYXRhLl9zZWxlY3RlZF9jZWxsc1tjb2xJZHhdID0gdHJ1ZTtcblxuXHRcdGlmIChkYXRhLmFuQ2VsbHMpIHtcblx0XHRcdCQoZGF0YS5hbkNlbGxzW2NvbElkeF0pLmFkZENsYXNzKGN0eC5fc2VsZWN0LmNsYXNzTmFtZSk7XG5cdFx0fVxuXHR9KTtcblxuXHR0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgsIGkpIHtcblx0XHRldmVudFRyaWdnZXIoYXBpLCAnc2VsZWN0JywgWydjZWxsJywgYXBpLmNlbGxzKGFwaVtpXSkuaW5kZXhlcygpLnRvQXJyYXkoKV0sIHRydWUpO1xuXHR9KTtcblxuXHRyZXR1cm4gdGhpcztcbn0pO1xuXG5hcGlSZWdpc3RlcignY2VsbCgpLnNlbGVjdGVkKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cblx0aWYgKGN0eCAmJiB0aGlzLmxlbmd0aCkge1xuXHRcdHZhciByb3cgPSBjdHguYW9EYXRhW3RoaXNbMF1bMF0ucm93XTtcblxuXHRcdGlmIChyb3cgJiYgcm93Ll9zZWxlY3RlZF9jZWxscyAmJiByb3cuX3NlbGVjdGVkX2NlbGxzW3RoaXNbMF1bMF0uY29sdW1uXSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufSk7XG5cbmFwaVJlZ2lzdGVyUGx1cmFsKCdyb3dzKCkuZGVzZWxlY3QoKScsICdyb3coKS5kZXNlbGVjdCgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgYXBpID0gdGhpcztcblxuXHR0aGlzLml0ZXJhdG9yKCdyb3cnLCBmdW5jdGlvbiAoY3R4LCBpZHgpIHtcblx0XHQvLyBMaWtlIHRoZSBzZWxlY3QgYWN0aW9uLCB0aGlzIGhhcyBhIGxvdCBvZiBrbm93bGVkZ2UgYWJvdXQgRFQgaW50ZXJuYWxseVxuXHRcdHZhciBkdERhdGEgPSBjdHguYW9EYXRhW2lkeF07XG5cdFx0dmFyIGR0Q29sdW1ucyA9IGN0eC5hb0NvbHVtbnM7XG5cblx0XHQkKGR0RGF0YS5uVHIpLnJlbW92ZUNsYXNzKGN0eC5fc2VsZWN0LmNsYXNzTmFtZSk7XG5cdFx0ZHREYXRhLl9zZWxlY3Rfc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRjdHguX3NlbGVjdF9sYXN0Q2VsbCA9IG51bGw7XG5cblx0XHRmb3IgKHZhciBpPTAgOyBpPGR0Q29sdW1ucy5sZW5ndGggOyBpKyspIHtcblx0XHRcdHZhciBjb2wgPSBkdENvbHVtbnNbaV07XG5cblx0XHRcdC8vIFJlZ2VuZXJhdGUgdGhlIGNvbHVtbiB0eXBlIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRpZiAoY29sLnNUeXBlID09PSBudWxsKSB7XG5cdFx0XHRcdGFwaS5jb2x1bW5zKCkudHlwZXMoKVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoaXNDaGVja2JveENvbHVtbihjb2wpKSB7XG5cdFx0XHRcdHZhciBjZWxscyA9IGR0RGF0YS5hbkNlbGxzO1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGUgY2hlY2tib3ggc2hvd3MgdGhlIHJpZ2h0IHN0YXRlXG5cdFx0XHRcdGlmIChjZWxscyAmJiBjZWxsc1tpXSkge1xuXHRcdFx0XHRcdCQoJ2lucHV0LicgKyBjaGVja2JveENsYXNzKHRydWUpLCBkdERhdGEuYW5DZWxsc1tpXSkucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEludmFsaWRhdGUgdGhlIHNvcnQgZGF0YSBmb3IgdGhpcyBjb2x1bW4sIGlmIG5vdCBhbHJlYWR5IGRvbmVcblx0XHRcdFx0aWYgKGR0RGF0YS5fYVNvcnREYXRhICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0ZHREYXRhLl9hU29ydERhdGFbaV0gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHR0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgsIGkpIHtcblx0XHRldmVudFRyaWdnZXIoYXBpLCAnZGVzZWxlY3QnLCBbJ3JvdycsIGFwaVtpXV0sIHRydWUpO1xuXHR9KTtcblxuXHRyZXR1cm4gdGhpcztcbn0pO1xuXG5hcGlSZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLmRlc2VsZWN0KCknLCAnY29sdW1uKCkuZGVzZWxlY3QoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGFwaSA9IHRoaXM7XG5cblx0dGhpcy5pdGVyYXRvcignY29sdW1uJywgZnVuY3Rpb24gKGN0eCwgaWR4KSB7XG5cdFx0Y3R4LmFvQ29sdW1uc1tpZHhdLl9zZWxlY3Rfc2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRcdHZhciBhcGkgPSBuZXcgRGF0YVRhYmxlLkFwaShjdHgpO1xuXHRcdHZhciBjb2x1bW4gPSBhcGkuY29sdW1uKGlkeCk7XG5cblx0XHQkKGNvbHVtbi5oZWFkZXIoKSkucmVtb3ZlQ2xhc3MoY3R4Ll9zZWxlY3QuY2xhc3NOYW1lKTtcblx0XHQkKGNvbHVtbi5mb290ZXIoKSkucmVtb3ZlQ2xhc3MoY3R4Ll9zZWxlY3QuY2xhc3NOYW1lKTtcblxuXHRcdC8vIE5lZWQgdG8gbG9vcCBvdmVyIGVhY2ggY2VsbCwgcmF0aGVyIHRoYW4ganVzdCB1c2luZ1xuXHRcdC8vIGBjb2x1bW4oKS5ub2RlcygpYCBhcyBjZWxscyB3aGljaCBhcmUgaW5kaXZpZHVhbGx5IHNlbGVjdGVkIHNob3VsZFxuXHRcdC8vIG5vdCBoYXZlIHRoZSBgc2VsZWN0ZWRgIGNsYXNzIHJlbW92ZWQgZnJvbSB0aGVtXG5cdFx0YXBpLmNlbGxzKG51bGwsIGlkeClcblx0XHRcdC5pbmRleGVzKClcblx0XHRcdC5lYWNoKGZ1bmN0aW9uIChjZWxsSWR4KSB7XG5cdFx0XHRcdHZhciBkYXRhID0gY3R4LmFvRGF0YVtjZWxsSWR4LnJvd107XG5cdFx0XHRcdHZhciBjZWxsU2VsZWN0ZWQgPSBkYXRhLl9zZWxlY3RlZF9jZWxscztcblxuXHRcdFx0XHRpZiAoZGF0YS5hbkNlbGxzICYmICghY2VsbFNlbGVjdGVkIHx8ICFjZWxsU2VsZWN0ZWRbY2VsbElkeC5jb2x1bW5dKSkge1xuXHRcdFx0XHRcdCQoZGF0YS5hbkNlbGxzW2NlbGxJZHguY29sdW1uXSkucmVtb3ZlQ2xhc3MoY3R4Ll9zZWxlY3QuY2xhc3NOYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH0pO1xuXG5cdHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCwgaSkge1xuXHRcdGV2ZW50VHJpZ2dlcihhcGksICdkZXNlbGVjdCcsIFsnY29sdW1uJywgYXBpW2ldXSwgdHJ1ZSk7XG5cdH0pO1xuXG5cdHJldHVybiB0aGlzO1xufSk7XG5cbmFwaVJlZ2lzdGVyUGx1cmFsKCdjZWxscygpLmRlc2VsZWN0KCknLCAnY2VsbCgpLmRlc2VsZWN0KCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBhcGkgPSB0aGlzO1xuXG5cdHRoaXMuaXRlcmF0b3IoJ2NlbGwnLCBmdW5jdGlvbiAoY3R4LCByb3dJZHgsIGNvbElkeCkge1xuXHRcdHZhciBkYXRhID0gY3R4LmFvRGF0YVtyb3dJZHhdO1xuXG5cdFx0aWYgKGRhdGEuX3NlbGVjdGVkX2NlbGxzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGRhdGEuX3NlbGVjdGVkX2NlbGxzW2NvbElkeF0gPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgY2xhc3Mgb25seSBpZiB0aGUgY2VsbHMgZXhpc3QsIGFuZCB0aGUgY2VsbCBpcyBub3QgY29sdW1uXG5cdFx0Ly8gc2VsZWN0ZWQsIGluIHdoaWNoIGNhc2UgdGhlIGNsYXNzIHNob3VsZCByZW1haW4gKHNpbmNlIGl0IGlzIHNlbGVjdGVkXG5cdFx0Ly8gaW4gdGhlIGNvbHVtbilcblx0XHRpZiAoZGF0YS5hbkNlbGxzICYmICFjdHguYW9Db2x1bW5zW2NvbElkeF0uX3NlbGVjdF9zZWxlY3RlZCkge1xuXHRcdFx0JChkYXRhLmFuQ2VsbHNbY29sSWR4XSkucmVtb3ZlQ2xhc3MoY3R4Ll9zZWxlY3QuY2xhc3NOYW1lKTtcblx0XHR9XG5cdH0pO1xuXG5cdHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCwgaSkge1xuXHRcdGV2ZW50VHJpZ2dlcihhcGksICdkZXNlbGVjdCcsIFsnY2VsbCcsIGFwaVtpXV0sIHRydWUpO1xuXHR9KTtcblxuXHRyZXR1cm4gdGhpcztcbn0pO1xuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogQnV0dG9uc1xuICovXG5mdW5jdGlvbiBpMThuKGxhYmVsLCBkZWYpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChkdCkge1xuXHRcdHJldHVybiBkdC5pMThuKCdidXR0b25zLicgKyBsYWJlbCwgZGVmKTtcblx0fTtcbn1cblxuLy8gQ29tbW9uIGV2ZW50cyB3aXRoIHN1aXRhYmxlIG5hbWVzcGFjZXNcbmZ1bmN0aW9uIG5hbWVzcGFjZWRFdmVudHMoY29uZmlnKSB7XG5cdHZhciB1bmlxdWUgPSBjb25maWcuX2V2ZW50TmFtZXNwYWNlO1xuXG5cdHJldHVybiAnZHJhdy5kdC5EVCcgKyB1bmlxdWUgKyAnIHNlbGVjdC5kdC5EVCcgKyB1bmlxdWUgKyAnIGRlc2VsZWN0LmR0LkRUJyArIHVuaXF1ZTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlZChkdCwgY29uZmlnKSB7XG5cdGlmIChjb25maWcubGltaXRUby5pbmRleE9mKCdyb3dzJykgIT09IC0xICYmIGR0LnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5hbnkoKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKGNvbmZpZy5saW1pdFRvLmluZGV4T2YoJ2NvbHVtbnMnKSAhPT0gLTEgJiYgZHQuY29sdW1ucyh7IHNlbGVjdGVkOiB0cnVlIH0pLmFueSgpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoY29uZmlnLmxpbWl0VG8uaW5kZXhPZignY2VsbHMnKSAhPT0gLTEgJiYgZHQuY2VsbHMoeyBzZWxlY3RlZDogdHJ1ZSB9KS5hbnkoKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2J1dHRvbk5hbWVzcGFjZSA9IDA7XG5cbiQuZXh0ZW5kKERhdGFUYWJsZS5leHQuYnV0dG9ucywge1xuXHRzZWxlY3RlZDoge1xuXHRcdHRleHQ6IGkxOG4oJ3NlbGVjdGVkJywgJ1NlbGVjdGVkJyksXG5cdFx0Y2xhc3NOYW1lOiAnYnV0dG9ucy1zZWxlY3RlZCcsXG5cdFx0bGltaXRUbzogWydyb3dzJywgJ2NvbHVtbnMnLCAnY2VsbHMnXSxcblx0XHRpbml0OiBmdW5jdGlvbiAoZHQsIG5vZGUsIGNvbmZpZykge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0Y29uZmlnLl9ldmVudE5hbWVzcGFjZSA9ICcuc2VsZWN0JyArIF9idXR0b25OYW1lc3BhY2UrKztcblxuXHRcdFx0Ly8gLkRUIG5hbWVzcGFjZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgYnkgRGF0YVRhYmxlcyBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBvbiB0YWJsZSBkZXN0cm95XG5cdFx0XHRkdC5vbihuYW1lc3BhY2VkRXZlbnRzKGNvbmZpZyksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhhdC5lbmFibGUoZW5hYmxlZChkdCwgY29uZmlnKSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoZHQsIG5vZGUsIGNvbmZpZykge1xuXHRcdFx0ZHQub2ZmKGNvbmZpZy5fZXZlbnROYW1lc3BhY2UpO1xuXHRcdH1cblx0fSxcblx0c2VsZWN0ZWRTaW5nbGU6IHtcblx0XHR0ZXh0OiBpMThuKCdzZWxlY3RlZFNpbmdsZScsICdTZWxlY3RlZCBzaW5nbGUnKSxcblx0XHRjbGFzc05hbWU6ICdidXR0b25zLXNlbGVjdGVkLXNpbmdsZScsXG5cdFx0aW5pdDogZnVuY3Rpb24gKGR0LCBub2RlLCBjb25maWcpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdGNvbmZpZy5fZXZlbnROYW1lc3BhY2UgPSAnLnNlbGVjdCcgKyBfYnV0dG9uTmFtZXNwYWNlKys7XG5cblx0XHRcdGR0Lm9uKG5hbWVzcGFjZWRFdmVudHMoY29uZmlnKSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgY291bnQgPVxuXHRcdFx0XHRcdGR0LnJvd3MoeyBzZWxlY3RlZDogdHJ1ZSB9KS5mbGF0dGVuKCkubGVuZ3RoICtcblx0XHRcdFx0XHRkdC5jb2x1bW5zKHsgc2VsZWN0ZWQ6IHRydWUgfSkuZmxhdHRlbigpLmxlbmd0aCArXG5cdFx0XHRcdFx0ZHQuY2VsbHMoeyBzZWxlY3RlZDogdHJ1ZSB9KS5mbGF0dGVuKCkubGVuZ3RoO1xuXG5cdFx0XHRcdHRoYXQuZW5hYmxlKGNvdW50ID09PSAxKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLmRpc2FibGUoKTtcblx0XHR9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIChkdCwgbm9kZSwgY29uZmlnKSB7XG5cdFx0XHRkdC5vZmYoY29uZmlnLl9ldmVudE5hbWVzcGFjZSk7XG5cdFx0fVxuXHR9LFxuXHRzZWxlY3RBbGw6IHtcblx0XHR0ZXh0OiBpMThuKCdzZWxlY3RBbGwnLCAnU2VsZWN0IGFsbCcpLFxuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtc2VsZWN0LWFsbCcsXG5cdFx0YWN0aW9uOiBmdW5jdGlvbiAoZSwgZHQsIG5vZGUsIGNvbmZpZykge1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5zZWxlY3QuaXRlbXMoKTtcblx0XHRcdHZhciBtb2QgPSBjb25maWcuc2VsZWN0b3JNb2RpZmllcjtcblx0XHRcdFxuXHRcdFx0aWYgKG1vZCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIG1vZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdG1vZCA9IG1vZC5jYWxsKGR0LCBlLCBkdCwgbm9kZSwgY29uZmlnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXNbaXRlbXMgKyAncyddKG1vZCkuc2VsZWN0KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpc1tpdGVtcyArICdzJ10oKS5zZWxlY3QoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gc2VsZWN0b3JNb2RpZmllciBjYW4gYmUgc3BlY2lmaWVkXG5cdH0sXG5cdHNlbGVjdE5vbmU6IHtcblx0XHR0ZXh0OiBpMThuKCdzZWxlY3ROb25lJywgJ0Rlc2VsZWN0IGFsbCcpLFxuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtc2VsZWN0LW5vbmUnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y2xlYXIodGhpcy5zZXR0aW5ncygpWzBdLCB0cnVlKTtcblx0XHR9LFxuXHRcdGluaXQ6IGZ1bmN0aW9uIChkdCwgbm9kZSwgY29uZmlnKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRjb25maWcuX2V2ZW50TmFtZXNwYWNlID0gJy5zZWxlY3QnICsgX2J1dHRvbk5hbWVzcGFjZSsrO1xuXG5cdFx0XHRkdC5vbihuYW1lc3BhY2VkRXZlbnRzKGNvbmZpZyksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGNvdW50ID1cblx0XHRcdFx0XHRkdC5yb3dzKHsgc2VsZWN0ZWQ6IHRydWUgfSkuZmxhdHRlbigpLmxlbmd0aCArXG5cdFx0XHRcdFx0ZHQuY29sdW1ucyh7IHNlbGVjdGVkOiB0cnVlIH0pLmZsYXR0ZW4oKS5sZW5ndGggK1xuXHRcdFx0XHRcdGR0LmNlbGxzKHsgc2VsZWN0ZWQ6IHRydWUgfSkuZmxhdHRlbigpLmxlbmd0aDtcblxuXHRcdFx0XHR0aGF0LmVuYWJsZShjb3VudCA+IDApO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdH0sXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKGR0LCBub2RlLCBjb25maWcpIHtcblx0XHRcdGR0Lm9mZihjb25maWcuX2V2ZW50TmFtZXNwYWNlKTtcblx0XHR9XG5cdH0sXG5cdHNob3dTZWxlY3RlZDoge1xuXHRcdHRleHQ6IGkxOG4oJ3Nob3dTZWxlY3RlZCcsICdTaG93IG9ubHkgc2VsZWN0ZWQnKSxcblx0XHRjbGFzc05hbWU6ICdidXR0b25zLXNob3ctc2VsZWN0ZWQnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKGUsIGR0KSB7XG5cdFx0XHRpZiAoZHQuc2VhcmNoLmZpeGVkKCdkdC1zZWxlY3QnKSkge1xuXHRcdFx0XHQvLyBSZW1vdmUgZXhpc3RpbmcgZnVuY3Rpb25cblx0XHRcdFx0ZHQuc2VhcmNoLmZpeGVkKCdkdC1zZWxlY3QnLCBudWxsKTtcblxuXHRcdFx0XHR0aGlzLmFjdGl2ZShmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gVXNlIGEgZml4ZWQgZmlsdGVyaW5nIGZ1bmN0aW9uIHRvIG1hdGNoIG9uIHNlbGVjdGVkIHJvd3Ncblx0XHRcdFx0Ly8gVGhpcyBuZWVkcyB0byByZWZlcmVuY2UgdGhlIGludGVybmFsIGFvRGF0YSBzaW5jZSB0aGF0IGlzXG5cdFx0XHRcdC8vIHdoZXJlIFNlbGVjdCBzdG9yZXMgaXRzIHJlZmVyZW5jZSBmb3IgdGhlIHNlbGVjdGVkIHN0YXRlXG5cdFx0XHRcdHZhciBkYXRhU3JjID0gZHQuc2V0dGluZ3MoKVswXS5hb0RhdGE7XG5cblx0XHRcdFx0ZHQuc2VhcmNoLmZpeGVkKCdkdC1zZWxlY3QnLCBmdW5jdGlvbiAodGV4dCwgZGF0YSwgaWR4KSB7XG5cdFx0XHRcdFx0Ly8gX3NlbGVjdF9zZWxlY3RlZCBpcyBzZXQgYnkgU2VsZWN0IG9uIHRoZSBkYXRhIG9iamVjdCBmb3IgdGhlIHJvd1xuXHRcdFx0XHRcdHJldHVybiBkYXRhU3JjW2lkeF0uX3NlbGVjdF9zZWxlY3RlZDtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dGhpcy5hY3RpdmUodHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGR0LmRyYXcoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4kLmVhY2goWydSb3cnLCAnQ29sdW1uJywgJ0NlbGwnXSwgZnVuY3Rpb24gKGksIGl0ZW0pIHtcblx0dmFyIGxjID0gaXRlbS50b0xvd2VyQ2FzZSgpO1xuXG5cdERhdGFUYWJsZS5leHQuYnV0dG9uc1snc2VsZWN0JyArIGl0ZW0gKyAncyddID0ge1xuXHRcdHRleHQ6IGkxOG4oJ3NlbGVjdCcgKyBpdGVtICsgJ3MnLCAnU2VsZWN0ICcgKyBsYyArICdzJyksXG5cdFx0Y2xhc3NOYW1lOiAnYnV0dG9ucy1zZWxlY3QtJyArIGxjICsgJ3MnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5zZWxlY3QuaXRlbXMobGMpO1xuXHRcdH0sXG5cdFx0aW5pdDogZnVuY3Rpb24gKGR0KSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0XHRcdHRoaXMuYWN0aXZlKGR0LnNlbGVjdC5pdGVtcygpID09PSBsYyk7XG5cblx0XHRcdGR0Lm9uKCdzZWxlY3RJdGVtcy5kdC5EVCcsIGZ1bmN0aW9uIChlLCBjdHgsIGl0ZW1zKSB7XG5cdFx0XHRcdHRoYXQuYWN0aXZlKGl0ZW1zID09PSBsYyk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG59KTtcblxuLy8gTm90ZSB0aGF0IERhdGFUYWJsZXMgMi4xIGhhcyBtb3JlIHJvYnVzdCB0eXBlIGRldGVjdGlvbiwgYnV0IHdlIHJldGFpblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAyLjAgZm9yIHRoZSBtb21lbnQuXG5EYXRhVGFibGUudHlwZSgnc2VsZWN0LWNoZWNrYm94Jywge1xuXHRjbGFzc05hbWU6ICdkdC1zZWxlY3QnLFxuXHRkZXRlY3Q6IERhdGFUYWJsZS52ZXJzaW9uQ2hlY2soJzIuMScpXG5cdFx0PyB7XG5cdFx0XHRvbmVPZjogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIG5vIG9wXG5cdFx0XHR9LFxuXHRcdFx0YWxsT2Y6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBubyBvcFxuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uIChzZXR0aW5ncywgY29sLCBpZHgpIHtcblx0XHRcdFx0cmV0dXJuIGlzQ2hlY2tib3hDb2x1bW4oY29sKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdFx0Ly8gUmVuZGVyaW5nIGZ1bmN0aW9uIHdpbGwgdGVsbCB1cyBpZiBpdCBpcyBhIGNoZWNrYm94IHR5cGVcblx0XHRcdHJldHVybiBkYXRhID09PSAnc2VsZWN0LWNoZWNrYm94JyA/IGRhdGEgOiBmYWxzZTtcblx0XHR9LFxuXHRvcmRlcjoge1xuXHRcdHByZTogZnVuY3Rpb24gKGQpIHtcblx0XHRcdHJldHVybiBkID09PSAnWCcgPyAtMSA6IDA7XG5cdFx0fVxuXHR9XG59KTtcblxuJC5leHRlbmQodHJ1ZSwgRGF0YVRhYmxlLmRlZmF1bHRzLm9MYW5ndWFnZSwge1xuXHRzZWxlY3Q6IHtcblx0XHRhcmlhOiB7XG5cdFx0XHRyb3dDaGVja2JveDogJ1NlbGVjdCByb3cnXG5cdFx0fVxuXHR9XG59KTtcblxuRGF0YVRhYmxlLnJlbmRlci5zZWxlY3QgPSBmdW5jdGlvbiAodmFsdWVQcm9wLCBuYW1lUHJvcCkge1xuXHR2YXIgdmFsdWVGbiA9IHZhbHVlUHJvcCA/IERhdGFUYWJsZS51dGlsLmdldCh2YWx1ZVByb3ApIDogbnVsbDtcblx0dmFyIG5hbWVGbiA9IG5hbWVQcm9wID8gRGF0YVRhYmxlLnV0aWwuZ2V0KG5hbWVQcm9wKSA6IG51bGw7XG5cblx0dmFyIGZuID0gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdywgbWV0YSkge1xuXHRcdHZhciBkdFJvdyA9IG1ldGEuc2V0dGluZ3MuYW9EYXRhW21ldGEucm93XTtcblx0XHR2YXIgc2VsZWN0ZWQgPSBkdFJvdy5fc2VsZWN0X3NlbGVjdGVkO1xuXHRcdHZhciBhcmlhTGFiZWwgPSBtZXRhLnNldHRpbmdzLm9MYW5ndWFnZS5zZWxlY3QuYXJpYS5yb3dDaGVja2JveDtcblx0XHR2YXIgc2VsZWN0YWJsZSA9IG1ldGEuc2V0dGluZ3MuX3NlbGVjdC5zZWxlY3RhYmxlO1xuXG5cdFx0aWYgKHR5cGUgPT09ICdkaXNwbGF5Jykge1xuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIHJvdyBpcyBzZWxlY3RhYmxlIGJlZm9yZSBzaG93aW5nIHRoZSBjaGVja2JveFxuXHRcdFx0aWYgKHNlbGVjdGFibGUpIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHNlbGVjdGFibGUocm93LCBkdFJvdy5uVHIsIG1ldGEucm93KTtcblx0XG5cdFx0XHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAkKCc8aW5wdXQ+Jylcblx0XHRcdFx0LmF0dHIoe1xuXHRcdFx0XHRcdCdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLFxuXHRcdFx0XHRcdGNsYXNzOiBjaGVja2JveENsYXNzKCksXG5cdFx0XHRcdFx0bmFtZTogbmFtZUZuID8gbmFtZUZuKHJvdykgOiBudWxsLFxuXHRcdFx0XHRcdHR5cGU6ICdjaGVja2JveCcsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlRm4gPyB2YWx1ZUZuKHJvdykgOiBudWxsLFxuXHRcdFx0XHRcdGNoZWNrZWQ6IHNlbGVjdGVkXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5vbignaW5wdXQnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdC8vIExldCBTZWxlY3QgMTAwJSBjb250cm9sIHRoZSBzdGF0ZSBvZiB0aGUgY2hlY2tib3hcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0XHQvLyBBbmQgbWFrZSBzdXJlIHRoaXMgY2hlY2tib3ggbWF0Y2hlcyBpdCdzIHJvdyBhcyBpdCBpcyBwb3NzaWJsZVxuXHRcdFx0XHRcdC8vIHRvIGNoZWNrIG91dCBvZiBzeW5jIGlmIHRoaXMgd2FzIGNsaWNrZWQgb24gdG8gZGVzZWxlY3QgYSByYW5nZVxuXHRcdFx0XHRcdC8vIGJ1dCByZW1haW5zIHNlbGVjdGVkIGl0c2VsZlxuXHRcdFx0XHRcdHRoaXMuY2hlY2tlZCA9ICQodGhpcykuY2xvc2VzdCgndHInKS5oYXNDbGFzcygnc2VsZWN0ZWQnKTtcblx0XHRcdFx0fSlbMF07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09ICd0eXBlJykge1xuXHRcdFx0cmV0dXJuICdzZWxlY3QtY2hlY2tib3gnO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlID09PSAnZmlsdGVyJykge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWxlY3RlZCA/ICdYJyA6ICcnO1xuXHR9XG5cblx0Ly8gV29ya2Fyb3VuZCBzbyB1Z2xpZnkgZG9lc24ndCBzdHJpcCB0aGUgZnVuY3Rpb24gbmFtZS4gSXQgaXMgdXNlZFxuXHQvLyBmb3IgdGhlIGNvbHVtbiB0eXBlIGRldGVjdGlvbi5cblx0Zm4uX25hbWUgPSAnc2VsZWN0Q2hlY2tib3gnO1xuXG5cdHJldHVybiBmbjtcbn1cblxuLy8gTGVnYWN5IGNoZWNrYm94IG9yZGVyaW5nXG5EYXRhVGFibGUuZXh0Lm9yZGVyWydzZWxlY3QtY2hlY2tib3gnXSA9IGZ1bmN0aW9uIChzZXR0aW5ncywgY29sKSB7XG5cdHJldHVybiB0aGlzLmFwaSgpXG5cdFx0LmNvbHVtbihjb2wsIHsgb3JkZXI6ICdpbmRleCcgfSlcblx0XHQubm9kZXMoKVxuXHRcdC5tYXAoZnVuY3Rpb24gKHRkKSB7XG5cdFx0XHRpZiAoc2V0dGluZ3MuX3NlbGVjdC5pdGVtcyA9PT0gJ3JvdycpIHtcblx0XHRcdFx0cmV0dXJuICQodGQpLnBhcmVudCgpLmhhc0NsYXNzKHNldHRpbmdzLl9zZWxlY3QuY2xhc3NOYW1lKS50b1N0cmluZygpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoc2V0dGluZ3MuX3NlbGVjdC5pdGVtcyA9PT0gJ2NlbGwnKSB7XG5cdFx0XHRcdHJldHVybiAkKHRkKS5oYXNDbGFzcyhzZXR0aW5ncy5fc2VsZWN0LmNsYXNzTmFtZSkudG9TdHJpbmcoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9KTtcbn07XG5cbiQuZm4uRGF0YVRhYmxlLnNlbGVjdCA9IERhdGFUYWJsZS5zZWxlY3Q7XG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBJbml0aWFsaXNhdGlvblxuICovXG5cbi8vIERhdGFUYWJsZXMgY3JlYXRpb24gLSB3ZSBuZWVkIHRoaXMgdG8gcnVuIF9iZWZvcmVfIGRhdGEgaXMgcmVhZCBpbiwgYnV0XG4vLyBmb3IgYmFja3dhcmRzIGNvbXBhdC4gd2UgYWxzbyBydW4gYWdhaW4gb24gcHJlSW5pdC4gSWYgaXQgaGFwcGVucyB0d2ljZVxuLy8gaXQgd2lsbCBzaW1wbHkgZG8gbm90aGluZyB0aGUgc2Vjb25kIHRpbWUgYXJvdW5kLlxuJChkb2N1bWVudCkub24oJ2kxOG4uZHQuZHRTZWxlY3QgcHJlSW5pdC5kdC5kdFNlbGVjdCcsIGZ1bmN0aW9uIChlLCBjdHgpIHtcblx0aWYgKGUubmFtZXNwYWNlICE9PSAnZHQnKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0RGF0YVRhYmxlLnNlbGVjdC5pbml0KG5ldyBEYXRhVGFibGUuQXBpKGN0eCkpO1xufSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/datatables.net-select/js/dataTables.select.mjs\n");

/***/ })

};
;